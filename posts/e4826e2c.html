<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 入门基础的内容，包括继承、派生类的访问控制、继承中的构造函数和析构函数等。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 入门基础之七"><meta property="og:url" content="https://www.techgrow.cn/posts/e4826e2c.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 入门基础的内容，包括继承、派生类的访问控制、继承中的构造函数和析构函数等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/04/vs-studio-extend-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-5.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-6.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-7.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-8.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-10.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-11.png"><meta property="article:published_time" content="2021-11-14T13:55:33.000Z"><meta property="article:modified_time" content="2024-04-08T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-extends-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/e4826e2c.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/e4826e2c.html","path":"posts/e4826e2c.html","title":"C++ 入门基础之七"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 入门基础之七 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/app/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%A6%82%E5%BF%B5"><span class="nav-text">继承概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">类之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%BE%E4%BE%8B"><span class="nav-text">继承关系举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">继承相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">派生类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="nav-text">继承重要说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">继承使用案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">派生类的访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">单个类的访问控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">继承成员的访问控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9A%84-%E2%80%9C%E4%B8%89%E7%9C%8B%E2%80%9D-%E5%8E%9F%E5%88%99"><span class="nav-text">继承成员访问控制的 “三看” 原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8E%9F%E5%88%99"><span class="nav-text">派生类成员访问级别的控制原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%BF%A1%E6%81%AF"><span class="nav-text">使用工具查看类的内存布局信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83"><span class="nav-text">Windows 系统环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83"><span class="nav-text">Linux 系统环境</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="nav-text">继承中的构造和析构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E5%8E%9F%E5%88%99"><span class="nav-text">类型兼容原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-text">继承中的对象模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E7%9A%84%E8%B0%83%E7%94%A8%E5%8E%9F%E5%88%99"><span class="nav-text">继承中的构造与析构的调用原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88%E6%B7%B7%E6%90%AD%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-text">继承与组合混搭情况下的构造与析构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">继承中的同名成员的处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84-static-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8"><span class="nav-text">派生类中的 static 关键字使用</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">532</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">50</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/e4826e2c.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 入门基础之七 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 入门基础的内容，包括继承、派生类的访问控制、继承中的构造函数和析构函数等。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 入门基础之七</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-14 21:55:33" itemprop="dateCreated datePublished" datetime="2021-11-14T21:55:33+08:00">2021-11-14</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-04-08 21:55:33" itemprop="dateModified" datetime="2024-04-08T21:55:33+08:00">2024-04-08</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/e4826e2c.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/e4826e2c.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>3.1k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>3 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8bbc3f09.html">C++ 入门基础之一</a>、<a href="/posts/b03c11a0.html">C++ 入门基础之二</a>、<a href="/posts/f26087ad.html">C++ 入门基础之三</a></li><li><a href="/posts/beb2ebb3.html">C++ 入门基础之四</a>、<a href="/posts/a35089f6.html">C++ 入门基础之五</a>、<a href="/posts/a54941f5.html">C++ 入门基础之六</a></li><li><a href="/posts/e4826e2c.html">C++ 入门基础之七</a>、<a href="/posts/4c2ae4c0.html">C++ 入门基础之八</a>、<a href="/posts/f1a16291.html">C++ 入门基础之九</a></li></ul><h2 id="继承概念"><a href="#继承概念" class="headerlink" title="继承概念"></a>继承概念</h2><p>面向对象程序设计有 4 个主要特点：抽象、封装、继承和多态。面向对象程序设计的两个重要特征一数据抽象与封装，两者已经能够设计出基于对象的程序，这是面向对象程序设计的基础。要较好地进行面向对象程序设计，还必须了解面向对象程序设计另外两个重要特征 —— 继承和多态。继承是面向对象程序设计最重要的特征，可以说，如果没有掌握继承，就等于没有掌握类和对象的精华，就是没有掌握面向对象程序设计的真谛。</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>类之间一般有三种关系：</p><ul><li><code>has-A</code>：包含关系，用以描述一个类由多个 “部件类” 构成。实现 <code>has-A</code> 关系可以用类成员表示，即一个类中的数据成员是另一种已经定义的类。</li><li><code>uses-A</code>：一个类部分地使用另一个类。类之间成员函数的联系，可以通过定义友元或者对象参数传递来实现。</li><li><code>is-A</code>：机制称为 “继承” 。关系具有传递性，不具有对称性。</li></ul><span id="more"></span><h3 id="继承关系举例"><a href="#继承关系举例" class="headerlink" title="继承关系举例"></a>继承关系举例</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-1.png"></p><h3 id="继承相关概念"><a href="#继承相关概念" class="headerlink" title="继承相关概念"></a>继承相关概念</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-2.png"></p><h3 id="派生类的定义"><a href="#派生类的定义" class="headerlink" title="派生类的定义"></a>派生类的定义</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-3.png"></p><blockquote><p>值得一提的是，C++ 中的继承方式（public、private、protected）会影响子类的对外访问属性。</p></blockquote><h3 id="继承重要说明"><a href="#继承重要说明" class="headerlink" title="继承重要说明"></a>继承重要说明</h3><ul><li>(a) 子类拥有父类的所有成员变量和成员函数</li><li> (b) 子类可以拥有父类没有的方法和属性</li><li> (c) 子类就是一种特殊的父类</li><li> (d) 子类对象可以当作父类对象使用</li></ul><h3 id="继承使用案例"><a href="#继承使用案例" class="headerlink" title="继承使用案例"></a>继承使用案例</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基类（父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Parent</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义派生类（子类），继承方式是 public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Child</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) {</span><br><span class="line">		<span class="comment">// 直接访问基类（父类）的 public 成员变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">		<span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; <span class="string">", c="</span> &lt;&lt; <span class="keyword">this</span>-&gt;c &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Child <span class="title">child</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	child.<span class="built_in">print</span>();	<span class="comment">// 直接调用基类（父类）的 public 成员函数</span></span><br><span class="line">	child.<span class="built_in">echo</span>();	<span class="comment">// 直接调用派生类（子类）的 public 成员函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1, b=2</span><br><span class="line">a=1, b=2, c=3</span><br></pre></td></tr></tbody></table></figure><h2 id="派生类的访问控制"><a href="#派生类的访问控制" class="headerlink" title="派生类的访问控制"></a>派生类的访问控制</h2><p>派生类（子类）继承了基类（父类）的全部成员变量和成员函数（除了所有构造函数和析构函数之外的成员函数），但是这些成员的访问属性，在派生过程中是可以调整的。</p><h3 id="单个类的访问控制"><a href="#单个类的访问控制" class="headerlink" title="单个类的访问控制"></a>单个类的访问控制</h3><p>在 C++ 中，类成员变量和类成员函数的访问级别分为：<code>public</code>、<code>private</code>、<code>protected</code></p><ul><li><code>private</code>：修饰的成员变量和成员函数，只能在类的内部被访问</li><li><code>public</code>：修饰的成员变量和成员函数，可以在类的内部和类的外部被访问</li><li><code>protected</code>：修饰的成员变量和成员函数，可以在派生类（子类）的内部访问，不能在派生类（子类）的外部被访问</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在类中没有声明访问控制级别的成员变量和成员函数，默认都是 <code>private</code> 访问级别的。</p></div><h3 id="继承成员的访问控制"><a href="#继承成员的访问控制" class="headerlink" title="继承成员的访问控制"></a>继承成员的访问控制</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-4.png"></p><p>在 C++ 中，不同的继承方式（<code>public</code>、<code>private</code>、<code>protected</code>）会改变继承成员的访问属性：</p><ul><li><code>public 继承</code>：父类成员在子类中保持原有的访问级别</li><li><code>private 继承</code>：父类成员在子类中都变为 <code>private</code> 成员</li><li><code>protected 继承</code>：父类中 <code>public</code> 成员会变成 <code>protected</code>，父类中 <code>private</code> 成员仍然为 <code>private</code>，父类中 <code>protected</code> 成员仍然为 <code>protected</code></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>父类的 <code>private</code> 成员在子类中依然存在，但是无法访问到的，即无论使用哪种方式继承父类，子类都不能直接使用父类的 <code>private</code> 成员。</p></div><h3 id="继承成员访问控制的-“三看”-原则"><a href="#继承成员访问控制的-“三看”-原则" class="headerlink" title="继承成员访问控制的 “三看” 原则"></a>继承成员访问控制的 “三看” 原则</h3><p>在 C++ 中，不同的继承方式（<code>public</code>、<code>private</code>、<code>protected</code>）会改变继承成员的访问属性，最终可总结为以下三个原则（通过某一个原则，判断是否可以被访问）：</p><ul><li>(a) 看调用语句是写在子类的内部还是外部</li><li> (b) 看子类如何从父类继承（<code>public</code>、<code>private</code>、<code>protected</code>）</li><li>(c) 看父类中的访问级别（<code>public</code>、<code>private</code>、<code>protected</code>）</li></ul><h3 id="派生类成员访问级别的控制原则"><a href="#派生类成员访问级别的控制原则" class="headerlink" title="派生类成员访问级别的控制原则"></a>派生类成员访问级别的控制原则</h3><p>对于派生类自身的成员，访问级别的控制原则如下：</p><ul><li>(a) 需要被外界访问的成员直接设置为 <code>public</code></li><li>(b) 只能在当前类中访问的成员设置为 <code>private</code></li><li>(c) 只能在当前类和子类中访问的成员设置为 <code>protected</code></li></ul><h3 id="使用工具查看类的内存布局信息"><a href="#使用工具查看类的内存布局信息" class="headerlink" title="使用工具查看类的内存布局信息"></a>使用工具查看类的内存布局信息</h3><h4 id="Windows-系统环境"><a href="#Windows-系统环境" class="headerlink" title="Windows 系统环境"></a>Windows 系统环境</h4><p>在 Visual Studio 开发人员命令提示窗口内，可以使用以下命令查看类的内存布局信息。</p><ul><li>C++ 代码中的继承关系</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_index;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>使用命令查看类的内存布局信息，其中 <code>YYY</code> 是类的名称，<code>xxx</code> 是 C++ 源文件的名称</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayoutYYY xxx.cpp</span><br></pre></td></tr></tbody></table></figure><ul><li>命令输出的结果</li></ul><p><img data-src="../../../asset/2024/04/vs-studio-extend-1.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p>更多关于 Visual Studio 命令的详细使用教程，请阅读 <a target="_blank" rel="external nofollow" href="https://blog.csdn.net/weixin_44380570/article/details/120562497">《使用 VS 查看对象模型以及结构体内存对齐》</a>。</p></div><h4 id="Linux-系统环境"><a href="#Linux-系统环境" class="headerlink" title="Linux 系统环境"></a>Linux 系统环境</h4><p>在 Linux 系统中，可以使用 GNU Compiler Collection（GCC）提供的一些工具来查看类的内存布局。其中一个最常用的工具是 <code>g++</code>，它是 GCC 的 C++ 编译器。可以使用 <code>g++</code> 编译器的 <code>-fdump-class-hierarchy</code> 选项来生成类的内存布局信息，如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fdump-<span class="class"><span class="keyword">class</span>-<span class="title">hierarchy</span> <span class="title">xxx</span>.<span class="title">cpp</span></span></span><br></pre></td></tr></tbody></table></figure><p>这将生成一个名为 <code>xxx.cpp.class</code> 的文件，其中包含了类的内存布局信息，可以打开这个文件查看生成的信息。另外，还可以使用 <code>objdump</code> 命令来反汇编一个已编译的程序，然后查看类的内存布局。这种方法更加复杂，但在某些情况下也很有用。</p><h2 id="继承中的构造和析构"><a href="#继承中的构造和析构" class="headerlink" title="继承中的构造和析构"></a>继承中的构造和析构</h2><h3 id="类型兼容原则"><a href="#类型兼容原则" class="headerlink" title="类型兼容原则"></a>类型兼容原则</h3><p>类型兼容规则是指在需要基类（父类）对象的任何地方，都可以使用公有派生类<strong>（公有继承）</strong>的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。值得一提的是，在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承得到的成员，类型兼容规则是多态的重要基础之一。类型兼容规则中所指的替代包括以下情况：</p><ul><li>子类对象可以当作父类对象使用</li><li>子类对象可以直接赋值给父类对象</li><li>子类对象可以直接初始化父类对象</li><li>父类指针可以直接指向子类对象</li><li>父类引用可以直接引用子类对象</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printParent</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"I'm parent"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类（公有继承）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printChild</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"I'm child"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">howToPrint</span><span class="params">(Parent* p)</span> </span>{</span><br><span class="line">	p-&gt;<span class="built_in">printParent</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">howToPrint</span><span class="params">(Parent&amp; p)</span> </span>{</span><br><span class="line">	p.<span class="built_in">printParent</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	Parent p1;</span><br><span class="line">	p1.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line">	Child c1;</span><br><span class="line">	c1.<span class="built_in">printChild</span>();</span><br><span class="line">	c1.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1-1 父类指针可以直接指向子类对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"1-1"</span> &lt;&lt; endl;</span><br><span class="line">	Parent* p2 = <span class="literal">NULL</span>;</span><br><span class="line">	p2 = &amp;c1;</span><br><span class="line">	p2-&gt;<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1-2 父类指针可以直接指向子类对象，指针做函数参数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"1-2"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">howToPrint</span>(&amp;p1);</span><br><span class="line">	<span class="built_in">howToPrint</span>(&amp;c1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2-1 父类引用可以直接引用子类对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"2-1"</span> &lt;&lt; endl;</span><br><span class="line">	Parent&amp; p3 = c1;</span><br><span class="line">	p3.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2-2 父类引用可以直接引用子类对象，引用做函数参数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"2-2"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">howToPrint</span>(p1);</span><br><span class="line">	<span class="built_in">howToPrint</span>(c1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3-1 子类对象可以直接初始化父类对象，会自动调用父类的拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"3-1"</span> &lt;&lt; endl;</span><br><span class="line">	Parent p4 = c1;</span><br><span class="line">	p4.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4-1 子类对象可以直接赋值给父类对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"4-1"</span> &lt;&lt; endl;</span><br><span class="line">	Parent p5;</span><br><span class="line">	p5 = c1;</span><br><span class="line">	p5.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">I'm parent</span><br><span class="line">I'm child</span><br><span class="line">I'm parent</span><br><span class="line">1-1</span><br><span class="line">I'm parent</span><br><span class="line">1-2</span><br><span class="line">I'm parent</span><br><span class="line">I'm parent</span><br><span class="line">2-1</span><br><span class="line">I'm parent</span><br><span class="line">2-2</span><br><span class="line">I'm parent</span><br><span class="line">I'm parent</span><br><span class="line">3-1</span><br><span class="line">I'm parent</span><br><span class="line">4-1</span><br><span class="line">I'm parent</span><br></pre></td></tr></tbody></table></figure><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p>类在 C++ 编译器的内部可以理解为结构体，子类是由父类成员叠加子类新成员得到的。</p><p><img data-src="../../../asset/2021/11/cplusplus-extends-5.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-6.png"></p><p>父类与子类的构造函数、析构函数的关系如下：</p><ul><li>在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初始化</li><li>在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清理</li></ul><h3 id="继承中的构造与析构的调用原则"><a href="#继承中的构造与析构的调用原则" class="headerlink" title="继承中的构造与析构的调用原则"></a>继承中的构造与析构的调用原则</h3><ul><li>(a) 子类对象在创建时，会首先调用父类的构造函数</li><li> (b) 父类构造函数执行结束后，再执行子类的构造函数</li><li> (c) <strong>当父类只存在有参构造函数时，必须在子类的初始化列表中显示调用父类的构造函数</strong></li><li> (d) 析构函数调用的先后顺序与构造函数相反，即先调用子类的析构函数，再调用父类的析构函数</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Parent</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">		cout &lt;&lt; <span class="string">"父类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Parent</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"父类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printParent</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当父类只存在有参构造函数时，必须在子类的初始化列表中显示调用</span></span><br><span class="line">	<span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : <span class="built_in">Parent</span>(a, b) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">		cout &lt;&lt; <span class="string">"子类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Child</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"子类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printChild</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;c &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Child <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	c1.<span class="built_in">printParent</span>();</span><br><span class="line">	c1.<span class="built_in">printChild</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类的构造函数被调用</span><br><span class="line">子类的构造函数被调用</span><br><span class="line">I'm parent, a = 1, b = 2</span><br><span class="line">I'm child, c = 3</span><br><span class="line">子类的析构函数被调用</span><br><span class="line">父类的析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h3 id="继承与组合混搭情况下的构造与析构"><a href="#继承与组合混搭情况下的构造与析构" class="headerlink" title="继承与组合混搭情况下的构造与析构"></a>继承与组合混搭情况下的构造与析构</h3><p>继承与组合对象混搭使用的情况下，构造函数与析构函数的调用原则如下：</p><ul><li><code>构造函数的调用顺序</code>：先构造父类，再构造成员变量，最后构造自身</li><li><code>析构函数的调用顺序</code>：先析构自身，再析构成员变量，最后析构父类</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Object</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">		cout &lt;&lt; <span class="string">"Object类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Object</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"Object类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printObject</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"I'm object, a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> :</span> <span class="keyword">public</span> Object {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过初始化列表，调用父类的构造函数</span></span><br><span class="line">	<span class="built_in">Parent</span>(<span class="keyword">char</span>* p) : <span class="built_in">Object</span>(<span class="number">1</span>, <span class="number">2</span>) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">		cout &lt;&lt; <span class="string">"Parent类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Parent</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"Parent类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printParent</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"I'm parent, p = "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">char</span>* p;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过初始化列表，调用组合对象与父类的构造函数</span></span><br><span class="line">	<span class="built_in">Child</span>(<span class="keyword">char</span>* c) : <span class="built_in">obj1</span>(<span class="number">3</span>, <span class="number">4</span>), <span class="built_in">obj2</span>(<span class="number">5</span>, <span class="number">6</span>), <span class="built_in">Parent</span>(c) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">		cout &lt;&lt; <span class="string">"Child类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Child</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"Child类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printChild</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"I'm child, p = "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">char</span>* c;</span><br><span class="line">	<span class="comment">// 组合对象</span></span><br><span class="line">	Object obj1;</span><br><span class="line">	Object obj2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">char</span>* str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">'J'</span>;</span><br><span class="line">	str[<span class="number">1</span>] = <span class="string">'i'</span>;</span><br><span class="line">	str[<span class="number">2</span>] = <span class="string">'m'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Child <span class="title">c1</span><span class="params">(str)</span></span>;</span><br><span class="line">	c1.<span class="built_in">printChild</span>();</span><br><span class="line">	c1.<span class="built_in">printParent</span>();</span><br><span class="line">	c1.<span class="built_in">printObject</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object类的构造函数被调用</span><br><span class="line">Parent类的构造函数被调用</span><br><span class="line">Object类的构造函数被调用</span><br><span class="line">Object类的构造函数被调用</span><br><span class="line">Child类的构造函数被调用</span><br><span class="line">I'm child, p = Jim</span><br><span class="line">I'm parent, p = Jim</span><br><span class="line">I'm object, a = 1, b = 2</span><br><span class="line">Child类的析构函数被调用</span><br><span class="line">Object类的析构函数被调用</span><br><span class="line">Object类的析构函数被调用</span><br><span class="line">Parent类的析构函数被调用</span><br><span class="line">Object类的析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h3 id="继承中的同名成员的处理方式"><a href="#继承中的同名成员的处理方式" class="headerlink" title="继承中的同名成员的处理方式"></a>继承中的同名成员的处理方式</h3><ul><li>当子类成员与父类成员同名时，子类不会覆盖父类的同名成员，子类依旧可以从父类继承同名成员。</li><li>在子类中通过作用域限定运算符 <code>::</code> 进行同名成员的区分（即在子类中使用父类的同名成员时，需要显式地使用类名限定符），其作用类似 Java 中的 <code>super</code> 关键字。</li><li>如果子类和父类的成员函数同名，子类会把父类的所有的同名成员函数都隐藏掉，子类必须通过作用域限定运算符 <code>::</code> 显式调用父类的同名成员函数。</li><li>特别注意，同名成员存储在内存中的不同位置。</li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-7.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-8.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Parent</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : <span class="built_in">Parent</span>(a, b) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a + <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b + <span class="number">5</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"I'm child, a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Child <span class="title">child</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类访问自身的同名成员函数</span></span><br><span class="line">	child.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类访问自身的同名成员变量</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"child's a = "</span> &lt;&lt; child.a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"child's b = "</span> &lt;&lt; child.b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类访问父类的同名成员函数</span></span><br><span class="line">	child.Parent::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类访问父类的同名成员变量</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"parent's a = "</span> &lt;&lt; child.Parent::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"parent's b = "</span> &lt;&lt; child.Parent::b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I'm child, a = 6, b = 7</span><br><span class="line">child's a = 6</span><br><span class="line">child's b = 7</span><br><span class="line">I'm parent, a = 1, b = 2</span><br><span class="line">parent's a = 1</span><br><span class="line">parent's b = 2</span><br></pre></td></tr></tbody></table></figure><h3 id="派生类中的-static-关键字使用"><a href="#派生类中的-static-关键字使用" class="headerlink" title="派生类中的 static 关键字使用"></a>派生类中的 static 关键字使用</h3><p>在 C++ 的普通类中，<code>static</code> 关键字的使用可以看 <a href="/posts/a35089f6.html#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">这里</a>，而派生类中 <code>static</code> 关键字的使用说明如下：</p><ul><li>基类定义的静态成员，将被所有派生类共享</li><li>根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质（遵守派生类成员访问级别控制的原则）</li><li>在派生类中访问基类的静态成员，需要显式说明，对应的语法是：<code>类名 :: 成员</code> 或者通过对象访问：<code>对象名 . 成员</code></li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-10.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-11.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 声明公有的静态成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 声明公有的静态成员变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 声明私有的静态成员变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义私有的静态成员变量</span></span><br><span class="line"><span class="keyword">int</span> Parent::b = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义公有的静态成员变量，这里不是简单的变量赋值，更重要的是告诉C++编译器，给静态成员变量分配内存, 否则在派生类中用到该变量就会报错</span></span><br><span class="line"><span class="keyword">int</span> Parent::a = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">// 访问从基类继承得到的静态成员变量</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getA2</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">// 访问基类的静态成员变量</span></span><br><span class="line">		<span class="keyword">return</span> Parent::a;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">// return b;  错误写法，基类中静态成员自身的访问特性遵守派生类的访问级别控制原则，因此这里不能访问基类中私有的静态成员变量b</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用从基类继承得到的静态成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用基类的静态成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>{</span><br><span class="line">		Parent::<span class="built_in">print</span>();</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在类外访问基类的静态成员变量和静态成员函数</span></span><br><span class="line">	Parent::a++;</span><br><span class="line">	Parent::<span class="built_in">print</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在类外访问派生类的静态成员变量和静态成员函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; Child::a &lt;&lt; endl;</span><br><span class="line">	Child::<span class="built_in">print</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Child c1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.<span class="built_in">getA2</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.Parent::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	c1.<span class="built_in">print1</span>();</span><br><span class="line">	c1.<span class="built_in">print2</span>();</span><br><span class="line">	c1.Parent::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = 31, b = 50</span><br><span class="line"></span><br><span class="line">a = 31</span><br><span class="line">a = 31, b = 50</span><br><span class="line"></span><br><span class="line">a = 31</span><br><span class="line">a = 31</span><br><span class="line">a = 31</span><br><span class="line"></span><br><span class="line">a = 31, b = 50</span><br><span class="line">a = 31, b = 50</span><br><span class="line">a = 31, b = 50</span><br></pre></td></tr></tbody></table></figure><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/e4826e2c.html" title="C++ 入门基础之七">https://www.techgrow.cn/posts/e4826e2c.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/881a3bba.html" rel="prev" title="CMake 入门教程之二常用命令"><i class="fa fa-angle-left"></i> CMake 入门教程之二常用命令</a></div><div class="post-nav-item"> <a href="/posts/d786f74a.html" rel="next" title="Vue 开发随笔">Vue 开发随笔<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.2m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">18:01</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤 ICP 备 19024664 号</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035 号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/app/api/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/app/api/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/e4826e2c.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>