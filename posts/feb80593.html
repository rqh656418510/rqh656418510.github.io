<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要记录 C++ 的高频面试题。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 高频面试题之二"><meta property="og:url" content="https://www.techgrow.cn/posts/feb80593.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要记录 C++ 的高频面试题。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-07-25T14:32:18.000Z"><meta property="article:modified_time" content="2020-07-25T14:32:18.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.techgrow.cn/posts/feb80593.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/feb80593.html","path":"posts/feb80593.html","title":"C++ 高频面试题之二"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 高频面试题之二 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">基础面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-text">C++ 中构造函数和析构函数可不可以是虚函数，为什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-text">C++ 中构造函数和析构函数可不可以抛出异常，为什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-text">C++ 中局部变量存储在哪里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%A0%E5%BC%95%E7%94%A8%E4%B8%8D%E4%BC%A0%E5%80%BC"><span class="nav-text">C++ 中拷贝构造函数为什么传引用不传值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="nav-text">C++ 中内联函数的普通函数的区别（反汇编的角度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB"><span class="nav-text">C++ 中如何实现一个不可以被继承的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">C++ 中什么是纯虚函数，为什么要有纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-text">C++ 中虚函数表存放在哪里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-const-%E5%92%8C-static-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中 const 和 static 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">C++ 中四种强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-deque-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">C++ 中 deque 的底层原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-text">C++ 中虚函数和多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">C++ 中异常处理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E6%80%A7%E8%83%BD%E8%A6%81%E6%B1%82%E9%AB%98%E7%9A%84%E5%9C%B0%E6%96%B9%E4%B8%8D%E8%83%BD%E6%BB%A5%E7%94%A8%E5%BC%82%E5%B8%B8"><span class="nav-text">C++ 中为什么在性能要求高的地方不能滥用异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E6%97%A9%E7%BB%91%E5%AE%9A%E5%92%8C%E6%99%9A%E7%BB%91%E5%AE%9A"><span class="nav-text">C++ 中的早绑定和晚绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="nav-text">C++ 中指针和引用的区别（反汇编的角度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">C++ 中如何解决智能指针循环引用的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中重载函数和虚函数底层实现的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-map-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8CAVL-%E5%92%8C-RBTree-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中 map 的底层实现，AVL 和 RBTree 有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%81%87%E5%A6%82-map-%E7%9A%84%E9%94%AE%E6%98%AF%E7%B1%BB%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%82%A3%E4%B9%88-map-%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%9A%84"><span class="nav-text">C++ 中假如 map 的键是类类型，那么 map 底层是如何比较的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%85%B7%E4%BD%93%E8%AE%B2%E4%B8%80%E4%B8%8B"><span class="nav-text">C++ 中设计模式知道哪些，具体讲一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-stack-%E5%92%8C-queue-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-text">C++ 中 stack 和 queue 的底层实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E6%8A%9B%E5%87%BA%E4%BA%86%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-text">C++ 中如果构造函数里面抛出了异常，会发生什么，如何解决</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">707</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/feb80593.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 高频面试题之二 | Clay 的技术空间"><meta itemprop="description" content="本文主要记录 C++ 的高频面试题。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 高频面试题之二</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-07-25 22:32:18" itemprop="dateCreated datePublished" datetime="2020-07-25T22:32:18+08:00">2020-07-25</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/feb80593.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/feb80593.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>8.9k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>8 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/2f38a56e.html">C++ 高频面试题之一</a></li><li><a href="/posts/feb80593.html">C++ 高频面试题之二</a></li></ul><h2 id="基础面试题"><a href="#基础面试题" class="headerlink" title="基础面试题"></a>基础面试题</h2><h3 id="C-中构造函数和析构函数可不可以是虚函数，为什么"><a href="#C-中构造函数和析构函数可不可以是虚函数，为什么" class="headerlink" title="C++ 中构造函数和析构函数可不可以是虚函数，为什么"></a>C++ 中构造函数和析构函数可不可以是虚函数，为什么</h3><ul><li><p>构造函数不可以是虚函数，</p><ul><li>因为在调用构造函数时，编译器尚未将对象的虚函数表（<code>vtable</code>）建立完整，也就是尚未将对象的虚函数表指针（<code>vptr</code>）设为派生类的版本，无法实现多态。</li></ul></li><li><p>析构函数可以是虚函数</p><ul><li>在有继承时应该将析构函数设为虚函数（即虚析构函数），因为这样才能确保通过基类指针删除派生类对象时，能够正确调用派生类的析构函数，防止资源泄漏。</li></ul></li></ul><h3 id="C-中构造函数和析构函数可不可以抛出异常，为什么"><a href="#C-中构造函数和析构函数可不可以抛出异常，为什么" class="headerlink" title="C++ 中构造函数和析构函数可不可以抛出异常，为什么"></a>C++ 中构造函数和析构函数可不可以抛出异常，为什么</h3><ul><li><p>构造函数可以抛出异常，但不建议这样做</p><ul><li>因为当构造函数抛出异常时，对象构造会中止，进入未完全构造的状态。此时，编译器会自动调用已成功构造的成员对象或基类的析构函数，而未构造完成的成员对象则不会调用其析构函数。</li><li>特别注意：如果在构造函数中手动分配了资源（如使用裸指针、<code>new</code> 分配内存等），而在抛出异常时未手动释放这些资源，就会发生内存泄漏。因此，推荐使用 RAII（如智能指针、STL 容器）来管理资源，或者使用 <code>try-catch</code> 在异常抛出后完成资源释放。</li></ul></li><li><p>析构函数可以抛出异常，但强烈不建议这样做</p><ul><li>因为如果析构函数在对象销毁过程中抛出异常，而此时程序正在处理另一个未捕获的异常，会导致双重异常。此时，C++ 运行时系统将调用 <code>std::terminate()</code>，直接终止程序，导致崩溃。</li><li>因此，析构函数内部应捕获所有可能发生的异常，避免异常向外传播，可以使用 <code>try-catch</code> 包裹资源清理逻辑，并在 <code>catch</code> 块中记录日志或执行降级处理。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><ul><li>构造函数可以抛异常，用于表示构造失败，但需确保资源安全，避免内存泄漏。</li><li>析构函数不应该抛异常，防止异常传播冲突（双重异常错误）导致程序崩溃，建议使用 <code>try-catch</code> 处理内部异常。</li></ul></div><h3 id="C-中局部变量存储在哪里"><a href="#C-中局部变量存储在哪里" class="headerlink" title="C++ 中局部变量存储在哪里"></a>C++ 中局部变量存储在哪里</h3><p>普通局部变量在栈上，<code>static</code> 局部变量在静态区，局部动态分配（<code>new</code>）的变量在堆上。</p><table><thead><tr><th>类型</th><th>存储区域</th><th>备注</th></tr></thead><tbody><tr><td>普通局部变量</td><td>栈（Stack）</td><td>函数调用时分配，函数返回时自动回收</td></tr><tr><td><code>const</code> 修饰的局部变量</td><td>栈（Stack）</td><td>只是不可修改，本质还是普通局部变量</td></tr><tr><td><code>static</code> 修饰的局部变量</td><td>静态区（Data Segment）</td><td>程序整个运行期间都存在，生命周期和程序一样长</td></tr><tr><td>局部动态分配的变量（如 <code>new</code> 出来的）</td><td>堆（Heap）</td><td>手动分配内存，手动释放内存，不跟函数栈生命周期同步</td></tr></tbody></table><h3 id="C-中拷贝构造函数为什么传引用不传值"><a href="#C-中拷贝构造函数为什么传引用不传值" class="headerlink" title="C++ 中拷贝构造函数为什么传引用不传值"></a>C++ 中拷贝构造函数为什么传引用不传值</h3><p>在 C++ 中，拷贝构造函数必须传引用（通常是 <code>const</code> 引用），而不能传值，否则会导致无限递归调用拷贝构造函数，最终造成编译不通过或者程序崩溃。</p><ul><li>传引用的话，不需要拷贝，只是引用原对象，不触发拷贝构造。</li><li>加 <code>const</code> 是为了支持传入 <code>const</code> 对象，并防止在函数内部意外修改原对象。</li></ul><h3 id="C-中内联函数的普通函数的区别（反汇编的角度）"><a href="#C-中内联函数的普通函数的区别（反汇编的角度）" class="headerlink" title="C++ 中内联函数的普通函数的区别（反汇编的角度）"></a>C++ 中内联函数的普通函数的区别（反汇编的角度）</h3><p>在 C++ 中，内联函数和普通函数的主要区别体现在函数调用开销上。从反汇编层面来看，两者区别很明显：</p><ul><li><p>普通函数：</p><ul><li>编译器会生成真实的函数调用指令，比如在 x86 平台上通常是 <code>CALL</code> 指令。</li><li>调用普通函数时，程序会：<ul><li>将参数压入栈中（或者通过寄存器传递）。</li><li>保存当前执行位置（调用点地址）。</li><li>跳转到函数地址执行。</li><li>函数执行完后，通过 <code>RET</code> 指令返回调用点继续执行。</li></ul></li><li>在反汇编中，可以看到明显的 <code>CALL</code> 和 <code>RET</code> 指令。</li></ul></li><li><p>内联函数：</p><ul><li>编译器在调用内联函数的地方直接展开函数体代码，不会生成 <code>CALL</code> 指令。</li><li>也就是说，没有函数调用开销，代码像普通语句一样直接排列在调用点。</li><li>在反汇编中，内联函数对应的机器码是直接展开的，看不到 <code>CALL</code> 指令，而是看到函数体相关的操作指令（比如加法、赋值、比较等）。</li></ul></li></ul><blockquote><p>内联函数的普通函数的区别总结</p></blockquote><table><thead><tr><th>特性</th><th>普通函数</th><th>内联函数</th></tr></thead><tbody><tr><td>调用方式</td><td>生成 CALL 指令跳转</td><td>直接展开函数体</td></tr><tr><td>性能</td><td>有函数调用开销（压栈、跳转、返回等）</td><td>无函数调用开销（更快）</td></tr><tr><td>二进制体积</td><td>较小（代码复用）</td><td>可能变大（每次调用都复制函数体）</td></tr><tr><td>反汇编特征</td><td>明显看到 CALL 和 RET 汇编指令</td><td>没有 CALL 汇编指令，代码直接嵌入</td></tr></tbody></table><h3 id="C-中如何实现一个不可以被继承的类"><a href="#C-中如何实现一个不可以被继承的类" class="headerlink" title="C++ 中如何实现一个不可以被继承的类"></a>C++ 中如何实现一个不可以被继承的类</h3><p>在 C++ 中，要实现一个不能被继承的类（Final Class），有以下两种常见的方法：</p><ul><li><p>(1) 使用 C++ 11 引入的 <code>final</code> 关键字</p><ul><li>在类声明后加上 <code>final</code>，表示该类禁止被继承。</li><li>符合现代 C++ 规范，如果尝试继承，会在编译期直接报错。</li></ul></li><li><p>(2) 声明构造函数或析构函数为 <code>private</code> 或 <code>protected</code>，并且不给友元访问</p><ul><li>将类的构造函数或析构函数声明为 <code>private</code> 或 <code>protected</code>，并且不开放友元访问。</li><li>如果尝试继承，因为子类构造或析构时无法访问基类的构造函数或析构函数。</li><li>这种方式会让实例化对象也变复杂（比如只能通过静态方法创建对象），适合一些单例模式或者控制构造的场景。</li></ul></li></ul><h3 id="C-中什么是纯虚函数，为什么要有纯虚函数"><a href="#C-中什么是纯虚函数，为什么要有纯虚函数" class="headerlink" title="C++ 中什么是纯虚函数，为什么要有纯虚函数"></a>C++ 中什么是纯虚函数，为什么要有纯虚函数</h3><blockquote><p>什么是纯虚函数？</p></blockquote><p>在 C++ 中，纯虚函数（Pure Virtual Function）是指在基类中声明，但不提供具体实现，强制派生类必须重写（Override）这个函数。</p><ul><li>定义形式是使用 <code>virtual</code> 关键字，并在函数声明后面加上 <code>= 0</code>，比如 <code>virtual void func() = 0;</code>。</li><li>有至少一个纯虚函数的类叫做抽象类（Abstract Class），抽象类不能直接实例化对象（只能作为基类使用）。</li></ul><blockquote><p>为什么要有纯虚函数？</p></blockquote><p>纯虚函数是 C++ 中实现 “接口抽象” 和 “强制子类重写” 的关键机制，是支撑多态性的基石。</p><ul><li>强制子类去实现某些接口 / 行为，保证程序的设计一致性。</li><li>为多态（运行期多态）提供基础支持。</li><li>描述一种 “规范” 或者 “接口”，而不是具体实现。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>一个类即使只有一个纯虚函数，也是抽象类，不能被实例化。</li><li>子类如果不实现所有继承的纯虚函数，那么子类也是抽象类。</li><li>抽象类可以有成员变量和成员函数。</li></ul></div><h3 id="C-中虚函数表存放在哪里"><a href="#C-中虚函数表存放在哪里" class="headerlink" title="C++ 中虚函数表存放在哪里"></a>C++ 中虚函数表存放在哪里</h3><p>虚函数表（<code>vtable</code>）存放在程序的静态存储区，由编译器维护。拥有虚函数的类，其每个对象的内部都持有一个指向它的虚函数表指针（<code>vptr</code>），用于实现运行时多态。</p><blockquote><p>虚函数表详细介绍</p></blockquote><p>当一个类中有虚函数时，编译器通常会为这个类生成一张虚函数表（<code>vtable</code>）。<code>vtable</code> 本质上是存放在程序的静态存储区（<code>.rodata</code> 只读数据段或全局数据段）的一张表，而对象本身只保存一份指向 <code>vtable</code> 的指针，通常称为虚函数表指针（<code>vptr</code>）。</p><ul><li><p>虚函数表（<code>vtable</code>）</p><ul><li>每个拥有虚函数的类都对应一张 <code>vtable</code>，通常是只读的，防止程序运行时被篡改。</li><li><code>vtable</code> 是一张静态分配的表（通常存放在 <code>.rodata</code> 只读数据段或全局数据段）。</li><li><code>vtable</code> 里面存放的是各个虚函数的实际函数地址（指针）。</li></ul></li><li><p>虚函数表指针（<code>vptr</code>）</p><ul><li>拥有虚函数的类，其每个对象的内部都隐藏了一个 <code>vptr</code> 指针成员（占 4 个字节），指向所属类的 <code>vtable</code>。</li><li><code>vptr</code> 通常在构造函数中由编译器自动初始化。</li></ul></li><li><p>为什么要这么设计</p><ul><li>快速实现多态：调用虚函数时，通过 <code>vptr</code> 可以快速找到函数地址，效率很高（只多一次指针间接访问）。</li><li>支持动态绑定：编译器在运行时根据实际对象类型，动态找到正确的函数实现。</li></ul></li></ul><h3 id="C-中-const-和-static-的区别"><a href="#C-中-const-和-static-的区别" class="headerlink" title="C++ 中 const 和 static 的区别"></a>C++ 中 const 和 static 的区别</h3><p><code>const</code> 保证变量或函数行为不可修改，<code>static</code> 控制变量或函数的存储周期和作用域，两者关注点完全不同，但可以组合使用。</p><table><thead><tr><th>特性</th><th><code>const</code></th><th><code>static</code></th></tr></thead><tbody><tr><td>关键字含义</td><td>表示常量，值不可修改</td><td>表示静态存储周期，生命周期贯穿整个程序运行</td></tr><tr><td>修饰的对象</td><td>变量、指针、函数参数，函数返回值、成员函数等</td><td>变量、成员变量、成员函数</td></tr><tr><td>生命周期</td><td>作用域结束时销毁（正常对象）</td><td>程序开始时分配，结束时销毁</td></tr><tr><td>主要作用</td><td>保证只读、不被意外修改</td><td>保持数据共享、持久化</td></tr><tr><td>常用场景</td><td>保护只读数据、接口规范</td><td>跨函数 / 跨对象共享数据、缓存数据</td></tr></tbody></table><h3 id="C-中四种强制类型转换"><a href="#C-中四种强制类型转换" class="headerlink" title="C++ 中四种强制类型转换"></a>C++ 中四种强制类型转换</h3><table><thead><tr><th>类型转换</th><th>主要用途</th><th>安全性</th><th>是否运行时检查</th><th>典型应用场景</th></tr></thead><tbody><tr><td><code>const_cast</code></td><td>用于增加或去除 <code>const</code> / <code>volatile</code> 属性</td><td>安全（只改修饰，不会改变对象本质）</td><td>否</td><td>修改函数参数的常量性（如 API 不一致场景）</td></tr><tr><td><code>static_cast</code></td><td>用于基本类型转换、类层次间的安全转换</td><td>较安全（编译期类型安全的转换）</td><td>否</td><td><code>int</code> 转 <code>float</code>、父类和子类之间的指针 / 引用转换（向上转换无风险）</td></tr><tr><td><code>dynamic_cast</code></td><td>多态类型之间安全向下转换</td><td>很安全（失败时返回 <code>nullptr</code> 或抛异常）</td><td>是</td><td>运行时会判断实际类型，实现多态安全转换</td></tr><tr><td><code>reinterpret_cast</code></td><td>最暴力，用于无关类型之间的转换</td><td>不安全（可能导致未定义行为）</td><td>否</td><td>指针和整数之间转换、 不同类型指针之间转换</td></tr></tbody></table><h3 id="C-中-deque-的底层原理"><a href="#C-中-deque-的底层原理" class="headerlink" title="C++ 中 deque 的底层原理"></a>C++ 中 deque 的底层原理</h3><ul><li><code>deque</code> 叫做双端队列，它是通过多段小连续块（<code>buffer</code>）组织起来的，配合中央控制器（<code>map</code>）来管理，实现了头部和尾部快速插入和删除，并支持随机访问。</li><li><code>deque</code> 的底层结构是由分块连续数组和一个中央控制器（<code>map</code>）组成<ul><li>元素不是存在一整块内存里，而是存在若干小块内存（称为 <code>buffer</code>）。</li><li>每个 <code>buffer</code> 是一个固定大小的数组（比如 512 bytes 或 4096 bytes 之类的，根据元素大小决定）。</li><li>有一个叫 <code>map</code> 的数组，存了所有 <code>buffer</code> 的指针。</li><li><code>map</code> 自己是连续的小数组，支持随机访问和动态扩展。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>deque</code> 一种双向开口的连续线性空间（双端队列容器），底层的数据结构是支持动态开辟内存空间的二维数组。</li><li><code>deque</code> 本质上是由一段一段的定量连续空间（分段连续内存空间）构造而成，一旦有必要在 <code>deque</code> 的头端或尾端增加新空间，便会配置一段新的定量连续空间，然后串接在整个 <code>deque</code> 的头端或尾端。</li></ul></div><h3 id="C-中虚函数和多态"><a href="#C-中虚函数和多态" class="headerlink" title="C++ 中虚函数和多态"></a>C++ 中虚函数和多态</h3><ul><li>虚函数是指在基类中使用 <code>virtual</code> 关键字声明的成员函数，目的是为了允许派生类重写（重新定义）它，从而实现运行时的多态性。</li><li>多态指的是，当通过基类指针或引用调用虚函数时，程序能够在运行时根据实际派生类对象的类型，动态决定调用哪一个派生类中重写的函数。</li><li>虚函数使得同一接口在不同对象上展现出不同的行为，C++ 通过虚函数表（<code>vtable</code>）和虚函数表指针（<code>vptr</code>）机制来支持这种动态绑定。</li></ul><h3 id="C-中异常处理机制"><a href="#C-中异常处理机制" class="headerlink" title="C++ 中异常处理机制"></a>C++ 中异常处理机制</h3><ul><li><p>异常处理机制</p><ul><li>C++ 中的异常机制主要通过 <code>try-catch-throw</code> 关键字组合来实现，用于处理程序运行时出现的错误。</li><li>当程序执行中遇到异常时，通过 <code>throw</code> 抛出一个异常对象，异常对象可以是内置类型、类对象或指针等。</li><li>异常抛出后，程序会沿调用栈向上寻找匹配的 <code>catch</code> 语句块进行处理。</li><li>如果找到了合适的 <code>catch</code>，就进入处理代码块；如果没有找到匹配的处理器，程序会调用 <code>std::terminate()</code> 终止运行。</li></ul></li><li><p>异常注意事项</p><ul><li>C++ 异常是按类型匹配，可以按异常对象的类型分发到不同的 <code>catch</code> 语句块。</li><li>异常发生时，局部对象会自动析构（保证资源释放），这叫栈展开（Stack Unwinding）。</li><li>可以自定义异常类，通常继承自 <code>std::exception</code>。</li><li>不建议抛出裸指针或基本类型，应抛出类对象，利于扩展。</li></ul></li></ul><h3 id="C-中为什么在性能要求高的地方不能滥用异常"><a href="#C-中为什么在性能要求高的地方不能滥用异常" class="headerlink" title="C++ 中为什么在性能要求高的地方不能滥用异常"></a>C++ 中为什么在性能要求高的地方不能滥用异常</h3><p>在性能敏感的场景下，不建议滥用 C++ 异常机制。因为即使不抛出异常，异常机制本身也增加了代码量和隐藏开销；而一旦抛出异常，栈展开、资源清理的代价非常高，会严重影响程序性能。</p><ul><li><p>(1) 异常会增加隐藏的运行开销</p><ul><li>即使程序正常执行、没有抛异常，编译器也要为了异常处理生成额外的隐藏代码（比如保存上下文信息、支持栈展开）。</li><li>这导致了指令更多、代码膨胀、缓存命中率降低，从而影响执行性能。</li></ul></li><li><p>(2) 抛出异常本身是非常昂贵的操作</p><ul><li>抛出异常（<code>throw</code>）时，会：<ul><li>搜索调用栈上所有活跃的 <code>catch</code> 语句块。</li><li>执行栈展开（调用析构函数释放资源）。</li></ul></li><li>这些操作比普通的返回、跳转要慢几个数量级；在一些测试中，<code>throw</code> 一次比普通函数调用慢几十倍甚至上百倍。</li></ul></li><li><p>(3) 异常破坏了分支预测和局部性</p><ul><li>高性能系统（比如游戏引擎、交易系统）特别依赖 CPU 的分支预测和缓存局部性。</li><li>异常的流程是非线性跳转，让 CPU 很难预测，大大降低执行效率。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>正常流程不应该依赖异常（异常是处理真正意外情况的，不是常规控制逻辑）。</li><li>如果追求极致性能，常用错误码返回（比如 <code>return false;</code> 或 <code>status code</code>），而不是抛出异常。</li><li>C++ 11 及以后（现代 C++）提倡在可以预测的错误路径上使用 <code>noexcept</code> 保证无异常，提高优化空间。</li></ul></div><h3 id="C-中的早绑定和晚绑定"><a href="#C-中的早绑定和晚绑定" class="headerlink" title="C++ 中的早绑定和晚绑定"></a>C++ 中的早绑定和晚绑定</h3><p>在 C++ 中，早绑定是编译期确定函数调用，比如普通成员函数、重载函数；而晚绑定是运行期根据对象的实际类型确定调用，依赖虚函数和虚函数表。一般非虚函数使用早绑定，虚函数使用晚绑定。</p><ul><li><p>早绑定</p><ul><li>又叫 “静态绑定”</li><li> 在编译时就确定了调用哪个函数。</li><li>早绑定适用于：<ul><li>普通成员函数（非虚函数）</li><li>重载函数（函数名相同，参数不同）</li><li>静态成员函数</li></ul></li><li>早绑定的特点是效率高，因为编译器可以直接生成调用代码，没有运行时开销。</li></ul></li><li><p>晚绑定</p><ul><li>又叫 “动态绑定”</li><li> 在运行时根据对象的实际类型确定调用哪个函数。</li><li>晚绑定适用于：<ul><li>虚函数（<code>virtual</code> 修饰的函数）</li></ul></li><li>晚绑定依靠虚函数表（<code>vtable</code>）和虚函数表指针（<code>vptr</code>）来实现。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">什么是绑定</p><p>绑定指的是：在程序中，把函数调用与实际的函数实现对应起来的过程。</p></div><h3 id="C-中指针和引用的区别（反汇编的角度）"><a href="#C-中指针和引用的区别（反汇编的角度）" class="headerlink" title="C++ 中指针和引用的区别（反汇编的角度）"></a>C++ 中指针和引用的区别（反汇编的角度）</h3><p>在语法层面，指针和引用有较大区别，但从底层反汇编来看，引用通常也是通过隐藏的指针实现的，二者机器指令上差异非常小；不同点在于编译器对引用自动处理了解引用操作，使得引用使用起来更接近对象本身，更安全直观。</p><blockquote><p>指针和引用的深入对比</p></blockquote><ul><li>语义上的区别</li></ul><table><thead><tr><th></th><th>指针（Pointer）</th><th>引用（Reference）</th></tr></thead><tbody><tr><td>绑定关系</td><td>可以随时指向不同对象</td><td>初始化后必须绑定一个对象，不能再改</td></tr><tr><td>是否可以为空</td><td>可以是 <code>nullptr</code></td><td>理论上不能为空（但野引用有风险）</td></tr><tr><td>语法操作</td><td><code>*p</code> 解引用，<code>p-&gt;</code> 访问成员</td><td>直接用引用名访问，像别名一样</td></tr><tr><td>内存开销</td><td>占一个指针大小</td><td>底层的实现通常也是一个指针</td></tr><tr><td>多级概念</td><td>有多级指针</td><td>没有多级引用</td></tr></tbody></table><ul><li>反汇编上的区别<ul><li>反汇编层面，指针和引用几乎没有本质差别。</li><li>主要区别是：<ul><li>指针：需要程序员显式操作（<code>*</code>、<code>-&gt;</code>），比如需要解引用（<code>*</code>）才能访问实际对象。</li><li>引用：在大部分编译器实现里，底层也是一个隐藏的指针，但是编译器帮程序员自动完成了解引用动作，所以语法上看起来像直接操作对象。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>在优化后的汇编代码中，如果编译器确定引用不会为 <code>nullptr</code>，可以进一步做优化（比如省略空指针检查），而指针一般需要显式检查。</li><li>有些平台（比如嵌入式）可能为了节省开销，对指针和引用处理得更细致些，但在常规 PC 编译器（如 GCC、Clang、MSVC）中，两者的性能开销接近。</li></ul></div><h3 id="C-中如何解决智能指针循环引用的问题"><a href="#C-中如何解决智能指针循环引用的问题" class="headerlink" title="C++ 中如何解决智能指针循环引用的问题"></a>C++ 中如何解决智能指针循环引用的问题</h3><ul><li>循环引用问题发生在两个对象相互持有对方的 <code>shared_ptr</code> 智能指针时，导致对象无法被销毁。</li><li>解决方法是：在定义对象的时候，使用强引用智能指针（<code>shared_ptr</code>）；而在引用对象的时候，使用弱引用智能指针（<code>weak_ptr</code>）。</li><li><code>weak_ptr</code> 是一种不增加引用计数的智能指针，不会干扰 <code>shared_ptr</code> 的生命周期控制，从而避免了循环引用问题。</li><li>使用 <code>weak_ptr</code> 后，可以在需要时通过 <code>lock()</code> 将其转换为 <code>shared_ptr</code>，然后再安全地访问对象。</li></ul><h3 id="C-中重载函数和虚函数底层实现的区别"><a href="#C-中重载函数和虚函数底层实现的区别" class="headerlink" title="C++ 中重载函数和虚函数底层实现的区别"></a>C++ 中重载函数和虚函数底层实现的区别</h3><p>重载函数在编译时通过函数签名（函数名称、参数的数量和类型）来选择具体函数版本，不需要额外的运行时开销。而虚函数依赖于虚函数表（<code>vtable</code>）和虚函数表指针（<code>vptr</code>）来实现动态绑定，增加了运行时的开销，特别是在多态场景中需要查找虚函数表来决定调用哪个版本的函数。</p><blockquote><p>重载函数和虚函数底层实现的区别</p></blockquote><ul><li><p>函数解析方式：</p><ul><li>重载函数：在编译时，编译器根据函数调用的参数类型来选择具体的函数。这个过程完全是静态的，基于编译时的类型信息。</li><li>虚函数：在运行时，根据对象的动态类型来决定调用哪个函数。这个过程是动态的，依赖于虚函数表（<code>vtable</code>）和虚函数表指针（<code>vptr</code>）。</li></ul></li><li><p>符号表管理：</p><ul><li>重载函数：编译器通过名称改编（Name Mangling）来区分不同的重载函数。每个重载版本都有一个唯一的符号名，且所有的解析发生在编译期。</li><li>虚函数：编译器为每个包含虚函数的类生成虚函数表（<code>vtable</code>），对象实例包含一个指向该表的虚函数表指针（<code>vptr</code>）。函数解析是在运行时进行的，通过查找 <code>vtable</code> 来决定调用的虚函数。</li></ul></li><li><p>性能开销：</p><ul><li>重载函数：没有运行时开销，函数调用在编译时期确定。</li><li>虚函数：由于依赖虚函数表（<code>vtable</code>）和虚函数表指针（<code>vptr</code>），每次调用虚函数时都会有一定的运行时开销。具体来说，每次虚函数调用需要通过对象的 <code>vptr</code> 查找 <code>vtable</code>，然后找到正确的函数指针，再进行调用。</li></ul></li><li><p>内存结构：</p><ul><li>重载函数：每个函数都有一个固定的符号，编译器通过符号表来处理不同版本的重载函数。</li><li>虚函数：每个包含虚函数的类有一个虚函数表（<code>vtable</code>），每个对象有一个指向该表的虚函数表指针（<code>vptr</code>），通过该指针实现运行时多态。</li></ul></li></ul><blockquote><p>重载函数和虚函数底层实现的总结</p></blockquote><table><thead><tr><th></th><th>重载函数</th><th>虚函数</th></tr></thead><tbody><tr><td>解析方式</td><td>编译时静态解析</td><td>运行时动态解析</td></tr><tr><td>符号管理</td><td>名称改编（Name Mangling）</td><td>虚函数表（<code>vtable</code>）</td></tr><tr><td>性能开销</td><td>无运行时开销</td><td>每次调用虚函数时有额外开销（查找 <code>vtable</code>）</td></tr><tr><td>内存结构</td><td>不需要 <code>vtable</code>，直接通过符号表</td><td>需要 <code>vtable</code> 和 <code>vptr</code>，增加内存开销</td></tr></tbody></table><h3 id="C-中-map-的底层实现，AVL-和-RBTree-有什么区别"><a href="#C-中-map-的底层实现，AVL-和-RBTree-有什么区别" class="headerlink" title="C++ 中 map 的底层实现，AVL 和 RBTree 有什么区别"></a>C++ 中 map 的底层实现，AVL 和 RBTree 有什么区别</h3><ul><li><p><code>map</code> 的底层实现</p><ul><li><code>map</code> 是一种有序关联容器，底层是基于红黑树（RBTree）实现的。</li><li>红黑树是一种自平衡的二叉查找树，它保证了树的高度在 <code>O(log n)</code> 的范围内，从而保证了查找、插入和删除操作的时间复杂度为 <code>O(log n)</code>。</li><li>在 <code>map</code> 中，键（Key）是唯一的，而且数据会根据键值的大小进行排序。每个节点包含一个键值对，查找、插入和删除操作都利用红黑树的性质进行。</li></ul></li><li><p>AVL 树和 RBTree 树的区别</p><ul><li>AVL 树和红黑树都是自平衡二叉查找树，主要用于保证查找操作的时间复杂度为 <code>O (log n)</code>。</li><li>AVL 树的平衡更严格，查询性能更好，但在插入和删除时需要更多的旋转。</li><li>红黑树的平衡度较为宽松，插入和删除的旋转操作较少，但查询性能可能稍差于 AVL 树。</li></ul></li></ul><blockquote><p>AVL 树和 RBTree 树的深入对比</p></blockquote><ul><li><p><strong>平衡条件</strong></p><ul><li>AVL 树：<ul><li>AVL 树是一种严格平衡的二叉查找树。它要求树中每个节点的左右子树的高度差不超过 1，即 平衡因子（左右子树的高度差）只能是 <code>-1</code>、<code>0</code> 或 <code>1</code>。</li><li>由于这种严格平衡的要求，AVL 树的插入和删除操作可能需要较多的旋转来恢复平衡。</li></ul></li><li>红黑树：<ul><li>红黑树对平衡的要求较为宽松。它通过给每个节点着色（红色或黑色）来实现平衡，满足以下规则：<ul><li>每个节点是红色或黑色。</li><li>根节点是黑色。</li><li>红色节点不能有红色的子节点（即没有两个连续的红色节点）。</li><li>从任一节点到其所有叶节点的路径上，黑色节点的个数相同。</li></ul></li><li>红黑树的平衡度不如 AVL 树严格，但它的插入和删除操作通常较为高效，尤其是在频繁修改数据的情况下。</li></ul></li></ul></li><li><p><strong>插入和删除</strong></p><ul><li>AVL 树：<ul><li>插入和删除操作较为复杂，因为每次操作后都要保持严格的平衡条件。通常需要通过 “单旋转” 或 “双旋转” 来调整树结构。</li><li>由于要求严格平衡，AVL 树在插入和删除操作中可能会有较多的旋转。</li></ul></li><li>红黑树：<ul><li>红黑树的插入和删除操作相对简单一些。插入时，通过颜色的改变和较少的旋转来恢复平衡。删除时，也有特定的调整策略来保持树的平衡。</li></ul></li></ul></li><li><p><strong>查询效率</strong></p><ul><li>AVL 树：<ul><li>由于 AVL 树的平衡条件更严格，通常能保证更小的树高度，查找操作相对更快。查询操作的时间复杂度为 <code>O(log n)</code>，但由于需要更多的旋转，性能在插入和删除时可能受到影响。</li></ul></li><li>红黑树：<ul><li>红黑树的平衡度相对较宽松，因此查找操作的效率略低于 AVL 树，但由于插入和删除操作需要的旋转较少，整体性能在一些情况下更为稳定。</li></ul></li></ul></li><li><p><strong>性能对比</strong></p><ul><li>AVL 树：<ul><li>在查找操作频繁的情况下，AVL 树通常会表现得更好，因为它的高度比红黑树更小。</li><li>但是在插入和删除操作频繁的场景中，AVL 树的旋转操作会导致性能下降。</li></ul></li><li>红黑树：<ul><li>在插入和删除操作频繁的场景中，红黑树通常表现得更好，因为它需要较少的旋转，调整较为简单。</li><li>但是在查询操作上，红黑树的性能可能会稍微逊色于 AVL 树。</li></ul></li></ul></li></ul><h3 id="C-中假如-map-的键是类类型，那么-map-底层是如何比较的"><a href="#C-中假如-map-的键是类类型，那么-map-底层是如何比较的" class="headerlink" title="C++ 中假如 map 的键是类类型，那么 map 底层是如何比较的"></a>C++ 中假如 map 的键是类类型，那么 map 底层是如何比较的</h3><ul><li>在 C++ 中，当 <code>map</code> 的键（Key）是类类型时，底层红黑树需要对键进行大小比较。默认是使用键类型的 <code>&lt;</code> 运算符重载函数。</li><li>如果类类型没有提供 <code>&lt;</code> 运算符重载函数，则可以自定义一个比较器，并在 <code>map</code> 模板参数中指定。比较器需要符合严格弱序性，以保证红黑树能正常维护平衡和有序性。</li></ul><h3 id="C-中设计模式知道哪些，具体讲一下"><a href="#C-中设计模式知道哪些，具体讲一下" class="headerlink" title="C++ 中设计模式知道哪些，具体讲一下"></a>C++ 中设计模式知道哪些，具体讲一下</h3><ul><li>C++ 中设计模式分为创建型、结构型、行为型三大类，我比较熟悉的包括单例模式、工厂模式、观察者模式、策略模式、代理模式、适配器模式、装饰器模式等。</li><li>以单例模式为例，它通过私有化构造函数和提供全局访问点，保证系统中只有一个实例，常用于日志记录、配置管理等场景。</li></ul><h3 id="C-中-stack-和-queue-的底层实现"><a href="#C-中-stack-和-queue-的底层实现" class="headerlink" title="C++ 中 stack 和 queue 的底层实现"></a>C++ 中 stack 和 queue 的底层实现</h3><ul><li><code>stack</code> 和 <code>queue</code> 都是容器适配器，默认是基于 <code>deque</code> 容器实现。</li><li><code>stack</code> 主要通过 <code>push_back()</code>、<code>pop_back()</code> 来实现后进先出（LIFO），<code>queue</code> 主要通过 <code>push_back()</code>、<code>pop_front()</code> 来实现先进先出（FIFO）。</li><li>底层之所以选用 <code>deque</code>，是因为 <code>deque</code> 在头部和尾部都能提供常数时间（<code>O(1)</code>）的插入和删除操作，性能符合 <code>stack</code> 和 <code>queue</code> 的特点。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>在 C++ 中，<code>stack</code> 和 <code>queue</code> 都允许自定义底层容器，比如可以用 <code>vector</code> 来作为底层容器（只要它支持需要的接口），即 <code>stack&lt;int, std::vector&lt;int&gt;&gt; s;</code>。</li></ul></div><h3 id="C-中如果构造函数里面抛出了异常，会发生什么，如何解决"><a href="#C-中如果构造函数里面抛出了异常，会发生什么，如何解决" class="headerlink" title="C++ 中如果构造函数里面抛出了异常，会发生什么，如何解决"></a>C++ 中如果构造函数里面抛出了异常，会发生什么，如何解决</h3><ul><li>如果 C++ 构造函数抛出异常，当前对象不会构造成功，编译器会自动析构已经成功构造的成员对象和基类对象，防止资源泄漏。</li><li>为了避免内存泄漏，通常遵循 RAII 原则，比如使用智能指针等自动资源管理工具来避免手动释放资源。</li><li>在 C++ 11 之后，可以使用 <code>noexcept</code> 明确声明构造函数不会抛出异常，这对性能优化、标准容器（如 <code>vector</code>）的内部移动操作有重要意义。</li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/feb80593.html" title="C++ 高频面试题之二">https://www.techgrow.cn/posts/feb80593.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/2f38a56e.html" rel="prev" title="C++ 高频面试题之一"><i class="fa fa-angle-left"></i> C++ 高频面试题之一</a></div><div class="post-nav-item"> <a href="/posts/68d93948.html" rel="next" title="Meson 入门指南之一">Meson 入门指南之一<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.9m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">28:08</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/feb80593.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>