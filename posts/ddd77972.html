<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Java 虚拟机中的垃圾收集，包括 GC 算法、垃圾收集器等。"><meta property="og:type" content="article"><meta property="og:title" content="Java 虚拟机入门教程之二 JVM 垃圾收集"><meta property="og:url" content="https://www.techgrow.cn/posts/ddd77972.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 Java 虚拟机中的垃圾收集，包括 GC 算法、垃圾收集器等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-reachability-analysis.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-biaoji-qingchu.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-copy.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-biaoji-zhengli.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-minor-gc.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-collector-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-collector-choose.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-gc-collector.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-collector-serial.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-collector-parnew.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-collector-passe.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-collector-serial-old.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-collector-parallel-old.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-collector-cms.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-cms-process.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/jvm-collector-g1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-collector-g1-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-collector-g1-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-collector-choose.png"><meta property="article:published_time" content="2019-05-14T12:13:43.000Z"><meta property="article:modified_time" content="2023-03-27T12:13:43.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM 虚拟机"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2020/06/jvm-reachability-analysis.png"><link rel="canonical" href="https://www.techgrow.cn/posts/ddd77972.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/ddd77972.html","path":"posts/ddd77972.html","title":"Java 虚拟机入门教程之二 JVM 垃圾收集"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java 虚拟机入门教程之二 JVM 垃圾收集 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/app/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="nav-text">JVM 的垃圾收集机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="nav-text">确定对象是否可以回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-text">可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-text">GC 算法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-text">标记 - 清除算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-text">标记 - 整理算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6"><span class="nav-text">GC 算法进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text">分代收集算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="nav-text">GC 算法对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-text">内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-Eden-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D"><span class="nav-text">对象优先在 Eden 空间分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-text">长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="nav-text">动态对象年龄判定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-text">空间分配担保</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-text">GC 的触发条件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-text">Minor GC 的触发条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Full-GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-text">Full GC 的触发条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">JVM 的垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="nav-text">概念理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stop-The-World-%E7%8E%B0%E8%B1%A1"><span class="nav-text">Stop-The-World 现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC-%E5%92%8C-Full-GC"><span class="nav-text">Minor GC 和 Full GC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GC-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">GC 不同类型的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Minor-GC-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">Minor GC 的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Full-GC-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">Full GC 的概念</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">Minor GC 的执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Server-%E5%92%8C-Client-%E6%A8%A1%E5%BC%8F"><span class="nav-text">Server 和 Client 模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">收集器的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">常见的收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%85%B4%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">新兴的收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E7%A7%8D%E9%BB%98%E8%AE%A4%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">七种默认的收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="nav-text">收集器的使用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">新生代的收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">Serial 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">ParNew 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">Parallel Scavenge 收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">老年代的收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">Parallel Old 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">CMS 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">G1 收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">如何选择垃圾收集器</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">655</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/ddd77972.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java 虚拟机入门教程之二 JVM 垃圾收集 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 Java 虚拟机中的垃圾收集，包括 GC 算法、垃圾收集器等。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Java 虚拟机入门教程之二 JVM 垃圾收集</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-05-14 20:13:43" itemprop="dateCreated datePublished" datetime="2019-05-14T20:13:43+08:00">2019-05-14</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-03-27 20:13:43" itemprop="dateModified" datetime="2023-03-27T20:13:43+08:00">2023-03-27</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/ddd77972.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/ddd77972.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>25k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>23 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/f9740ba6.html">Java 虚拟机入门教程之一 JVM 内存结构</a></li><li><a href="/posts/ddd77972.html">Java 虚拟机入门教程之二 JVM 垃圾收集</a></li><li><a href="/posts/3056813b.html">Java 虚拟机入门教程之三 JVM 参数调优</a></li><li><a href="/posts/f524f467.html">Java 虚拟机入门教程之四 JVM 四种引用</a></li><li><a href="/posts/62936140.html">Java 虚拟机入门教程之五 JVM 性能优化</a></li><li><a href="/posts/d5b19bd1.html">Java 虚拟机入门教程之六 JVM 类加载机制</a></li></ul><h2 id="JVM-的垃圾收集机制"><a href="#JVM-的垃圾收集机制" class="headerlink" title="JVM 的垃圾收集机制"></a>JVM 的垃圾收集机制</h2><h3 id="确定对象是否可以回收"><a href="#确定对象是否可以回收" class="headerlink" title="确定对象是否可以回收"></a>确定对象是否可以回收</h3><p>在 Java 中，如何确定一个对象是否可以回收呢？常用的算法有两种：引用计数算法、可达性分析算法。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法（Reference Counting）是通过判断对象的引用数量来决定对象是否可以被回收。它的思路是给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。大部分场景下，这个算法都是不错，效率也比较高；但是 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题；而且对对象赋值时均要维护引用计数器，同时计数器本身也有一定的消耗。</p><span id="more"></span><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用计数算法的缺陷</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 占点内存，以便GC日志观看</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        testGC();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>{</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里发生GC， objA 和 objB能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码最后面两句将 objA 和 objB 赋值为 null，也就是说 objA 和 objB 指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法（Reachability Analysis）用于判断对象的引用链是否可达。它的思路是：通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如图所示：</p><p><img data-src="../../../asset/2020/06/jvm-reachability-analysis.png" alt="jvm-reachability-analysis"></p><p>在 Java 中，可作为 GC Root 的对象包括以下几种：</p><ul><li>在 Java 虚拟机栈（栈帧中的局部变量表）中引用的对象，例如各个线程被调用的方法栈中使用到的参数、局部变量等。</li><li>在方法区中类静态属性引用的对象，例如 Java 类的引用类型静态变量。</li><li>在方法区中常量引用的对象，例如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象。</li><li>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized 关键字）持有的对象。</li><li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><blockquote><p>除了上述这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不 同，还可以有其他对象 “临时性” 地加入，共同构成完整 GC Roots 集合。</p></blockquote><h3 id="GC-算法基础"><a href="#GC-算法基础" class="headerlink" title="GC 算法基础"></a>GC 算法基础</h3><p>垃圾收集算法主要有：复制算法（Copying）、标记 - 清除算法（Mark-Sweep）、标记 - 整理算法（Mark-Compact）、分代收集算法（Generational Collection）。</p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记 - 清除算法</h4><p>“标记 - 清除” 算法是最基础的算法，它分为 “标记” 和” 清除” 两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它有两个不足：一个是效率问题，标记和清除两个过程的效率都不高（两次扫描，耗时严重）；另一个是空间问题，标记清除之后会产生大量的不连续的内存碎片，内存碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存从而不得不提前触发另一次垃圾收集动作。</p><p><img data-src="../../../asset/2020/06/jvm-biaoji-qingchu.png" alt="jvm-biaoji-qingchu"></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率和内存碎片问题，一种称为 “复制”（Copying）的垃圾收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p><p><img data-src="../../../asset/2020/06/jvm-copy.png" alt="jvm-copy"></p><p>将现有的内存空间分为两块，每次只使用其中一块，在垃圾收集时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾收集。如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾收集的时刻，复制算法的效率是很高的。又由于对象在垃圾收集过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。<strong>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的</strong>。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。该算法的缺点是将系统内存折半。</p><p>JVM 的新生代串行垃圾收集器中使用了复制算法的思想。新生代分为 Eden 空间、From Survivor 空间、To Survivor 空间。其中 From Survivor 空间和 To Survivor 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。From Survivor 和 To Survivor 空间也称为 Survivor 空间，即幸存者空间，用于存放未被回收的对象。在垃圾收集时，Eden 空间中的存活对象会被复制到未使用的 Survivor 空间中（假设是 To Survivor），正在使用的 Survivor 空间（假设是 From Survivor）中的年轻对象也会被复制到 To Survivor 空间中（大对象或者老年对象会直接进入老年代，如果 To Survivor 空间已满，则对象也会直接进入老年代）。此时，Eden 空间和 From Survivor 空间中的剩余对象就是垃圾对象，可以直接清空，To Survivor 空间则存放此次回收后的存活对象。这种改进的复制算法既保证了内存空间的连续性，又避免了大量的内存空间浪费。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记 - 整理算法</h4><p>“复制算法” 在对象存活率较高时就要进行较多的复制操作，效率将会变低。如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以老年代不能直接选用这种算法。标记 - 整理算法中，标记过程仍然与 “标记 - 清除” 算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。这样就可以保证不会产生内存碎片，但是移动内存区域块（整理内存）的过程比较耗时。值得一提的是，” 标记 - 整理” 算法又叫 “标记 - 压缩” 算法。</p><p><img data-src="../../../asset/2020/06/jvm-biaoji-zhengli.png" alt="jvm-biaoji-zhengli"></p><h3 id="GC-算法进阶"><a href="#GC-算法进阶" class="headerlink" title="GC 算法进阶"></a>GC 算法进阶</h3><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：不同的对象的生命周期（存活情况）是不一样的，而不同生命周期的对象位于堆内存中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。“分代收集”（Generational Collection）算法，根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样既可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或者 “标记 - 整理” 算法来进行回收。</p><h4 id="GC-算法对比"><a href="#GC-算法对比" class="headerlink" title="GC 算法对比"></a>GC 算法对比</h4><p><strong>复制算法：</strong></p><ul><li>复制算法执行的速度较快，典型的空间换时间</li><li>当对象的存活率很高的时候，不断的复制操作会显得耗时</li><li>复制算法很明显的缺点就是浪费内存空间，因为将内存分为两块，一次只能使用一块，这也意味着分的块越大，浪费的内存越多</li></ul><p><strong>标记 - 清除算法：</strong></p><ul><li>首先是速度慢，因为” 标记 - 清除算法” 在标记阶段需要使用递归的方式从根结点出发，不断寻找可达的对象；而在清除阶段又需要遍历堆内存中的所有对象，查看其是否被标记，然后再清除；并且在程序进行 GC 的时候，JVM 中所有的 Java 程序都要进行暂停，俗称 Stop-The-World，后面会提到。</li><li>其次是其最大的缺点，使用这种算法进行清理而得的堆内存的空闲空间一般是不连续的，由于对象实例在堆内存中是随机存储的，所以在清理之后，会产生许多的内存碎片，如果这个时候来了一个很大的对象实例，尽管显示内存还足够，但是已经存不下这个大对象了，内存碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。再者，这种零散的碎片对于数组的分配也不是很方便。</li></ul><p><strong>标记 - 整理算法：</strong></p><ul><li>首先这种算法克服了” 标记 - 清除算法” 中会产生内存碎片的缺点，也解决了复制算法中内存减半使用的不足</li><li>而其缺点则是速度也不是很快，不仅要遍历标记所有可达结点，还要一个个整理可达存活对象的地址，所以导致其效率不是很高</li></ul><div class="admonition note"><p class="admonition-title">不同 GC 算法的适用场景</p><p>GC (Generational Collection) 是分代收集，分别有 Minor GC 和 Full GC 两种类型，主要发生在 JVM 的堆内存中，其使用的 GC 算法如下：</p><ul><li><code>Minor GC</code>：次数上频繁收集新生代，一般采用 "复制" 算法来进行垃圾收集</li><li><code>Full GC</code>：次数上频繁收集老年代，一般采用 "标记 - 清除" 或者 "标记 - 压缩" 算法来进行垃圾收集</li></ul></div><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p>Java 的自动内存管理，最终可以归结为自动化地解决了两个问题：给对象分配内存、回收分配给对象的内存。对象的内存分配通常是在堆上分配（除此以外还有可能经过 JIT 编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的 Eden 空间上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是固定的，实际取决于垃圾收集器的具体组合以及虚拟机中与内存相关的参数的设置。下面以使用 Serial/Serial Old 收集器，介绍内存分配的策略。</p><h4 id="对象优先在-Eden-空间分配"><a href="#对象优先在-Eden-空间分配" class="headerlink" title="对象优先在 Eden 空间分配"></a>对象优先在 Eden 空间分配</h4><p>大多数情况下，对象在新生代的 Eden 空间中分配，当 Eden 空间没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓的大对象是指需要大量连续内存空间的 Java 对象，最典型的大对象就是很长的字符串以及数组。大对象对虚拟机的内存分配来说是一个坏消息（尤其是遇到朝生夕灭的 “短命大对象”，写程序时应避免），经常出现大对象容易导致内存还有不少空间时，就提前触发 GC 以获取足够的连续内存空间来安置它们。虚拟机提供了一个 <code>-XX:PretenureSizeThreshold</code> 参数，令大小超过这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 空间及两个 Survivor 空间之间发生大量的内存复制（新生代采用复制算法来回收内存）。</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 空间出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 空间容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 空间中每 “熬过” 一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 设置。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续内存空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 的设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续内存空间是否大于历次晋升到老年代对象的平均大小；如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于或者 HandlePromotionFailure 的设置不允许冒险，那这时也要改为进行一次 Full GC。新生代使用复制算法，但为了内存利用率，只使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC 来让老年代腾出更多空间。使用平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了 HandlePromotionFailure 失败，那就只好在失败后重新发起一次 Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将 HandlePromotionFailure 开关打开，避免 Full GC 过于频繁。</p><h3 id="GC-的触发条件"><a href="#GC-的触发条件" class="headerlink" title="GC 的触发条件"></a>GC 的触发条件</h3><h4 id="Minor-GC-的触发条件"><a href="#Minor-GC-的触发条件" class="headerlink" title="Minor GC 的触发条件"></a>Minor GC 的触发条件</h4><p>对于 Minor GC，其触发条件非常简单，当新生代的 Eden 空间满时，就将触发一次 Minor GC。</p><h4 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h4><ul><li><p><strong>System.gc () 被调用</strong>：这里 <code>System.gc()</code> 方法的作用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过 <code>-XX:+ DisableExplicitGC</code> 来禁止 RMI 调用 <code>System.gc()</code>。</p></li><li><p><strong>老年代空间不足</strong>：老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出如下错误： <code>Java.lang.OutOfMemoryError: Java heap space</code>，为避免以上两种状况引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p></li><li><p><strong>空间分配担保失败</strong>：在新生代使用复制算法的 Minor GC，需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。</p></li><li><p><strong>Concurrent Mode Failure</strong>：- 出现 Concurrent Mode Failure 错误。在 CMS 收集器执行垃圾回收的过程中，同时会有对象要放入老年代，而此时如果老年代空间不足（有时候空间不足是由于 CMS 执行垃圾回收时，当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p></li><li><p><strong>永久代空间不足</strong>：在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些类信息、静态变量、常量、常量池等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出错误信息 <code>java.lang.OutOfMemoryError: PermGen space</code>，为避免 Permanet Generation 占满造成 Full GC 现象，可采用的方法为增大 Permanet Generation 空间或转为使用 CMS GC。在 JDK 1.8 中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种 Full GC 触发的可能性。</p></li></ul><h2 id="JVM-的垃圾收集器"><a href="#JVM-的垃圾收集器" class="headerlink" title="JVM 的垃圾收集器"></a>JVM 的垃圾收集器</h2><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是垃圾收集算法的具体实现。GC 的部分参数说明如下，可用于分析 <code>-XX:+PrintGCDetails</code> 打印出的 GC 详细信息：</p><ul><li><code>DefNew</code>：Default New Generation</li><li><code>Tenured</code>：Old</li><li><code>ParNew</code>：Parallel New Generation</li><li><code>PSYoungGen</code>：Parallel Scavenge</li><li><code>ParOldGen</code>：Parallel Old Generation</li></ul><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul><li>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即：吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）</li><li>虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%</li><li> 高吞吐量意味着可以高效率地利用 CPU 的时间，尽快完成程序的运算任务，适合用于后台运算而不需要太多交互的任务</li></ul><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><ul><li>这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们的解释如下</li><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户线程在继续运行，而垃圾收集程序运行于另一个 CPU 核上</li></ul><h4 id="Stop-The-World-现象"><a href="#Stop-The-World-现象" class="headerlink" title="Stop-The-World 现象"></a>Stop-The-World 现象</h4><p>在垃圾收集器执行时，比如 Serial、Parallel 垃圾收集器，所有正在执行中的 Java 程序都会被挂起（被暂停），只有 Native 方法可以执行，但是也不能和 JVM 进行交互，这样一来似乎整个 Java 世界都停止了，这也就是为什么叫做 “Stop-The-World (STW)”。等到 GC 程序执行完毕后，Java 程序才会重新恢复执行。这个其实很好理解，因为 GC 程序是一个线程，Java 程序也是一个线程，它们操作的堆内存是一片共享的区域。假设一种情况，Java 程序 A 新建了一个对象，<code>new Object()</code> 被存放在堆内存，但是很不巧的是，堆内存刚刚执行过复制算法，前一步存活的对象已经被转移到另一块空间了，而 <code>new Object()</code> 就留在了原来的空间，无辜地被清除了。这显然是不可接受的，因为线程不安全。</p><div class="admonition note"><p class="admonition-title">提示</p><p>Java 虚拟机提供的 7 种默认垃圾收集器都存在 STW 问题，只是不同垃圾收集器之间，对应用程序暂停运行时间的控制（优化）不一样，比如 CMS 与 G1 收集器极大减少了暂停应用程序运行的时间。</p></div><h4 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h4><p>在 Java 的垃圾回收机制中，Minor GC 和 Full GC 是两种不同的垃圾回收类型，它们的区别主要在于作用范围和触发条件。</p><h5 id="GC-不同类型的区别"><a href="#GC-不同类型的区别" class="headerlink" title="GC 不同类型的区别"></a>GC 不同类型的区别</h5><p>在 JVM 中，以下是一些常见的 GC 类型：</p><ul><li><p>Minor GC 或者 Yong GC（新生代垃圾回收）：</p><ul><li><strong>触发条件</strong>：Minor GC 主要在新生代（Young Generation）满了的时候触发。</li><li><strong>作用范围</strong>：它只清理新生代中的对象，特别是伊甸园区（Eden）和幸存者区（Survivor）。</li><li><strong>执行频率</strong>：由于新生代的对象生命周期较短，Minor GC 会频繁发生。</li><li><strong>执行速度</strong>：Minor GC 通常非常快，但它会导致 Stop-The-World（STW），即暂停所有应用程序线程。</li></ul></li><li><p>Major GC 或者 Old GC（老年代垃圾回收）：</p><ul><li><strong>触发条件</strong>：当老年代（Old Generation）快满或已满时会触发 Major GC。</li><li><strong>作用范围</strong>：主要清理老年代中的对象，老年代通常存放生命周期较长的对象。</li><li><strong>执行频率</strong>：由于老年代中的对象比较稳定，Major GC 发生频率较低，但每次发生时耗时较长。</li><li><strong>执行速度</strong>：Major GC 会导致更长时间的 Stop-The-World（STW）。</li></ul></li><li><p>Full GC（完全垃圾回收）：</p><ul><li><strong>触发条件</strong>：Full GC 会在整个堆空间（包括新生代和老年代）都接近满时触发。</li><li><strong>作用范围</strong>：Full GC 会清理新生代和老年代中的所有对象，同时也会对永久代（Metaspace/PermGen）进行清理。</li><li><strong>执行频率</strong>：Full GC 发生的频率应该尽可能低，因为它通常是所有 GC 操作中最耗时的。</li><li><strong>执行速度</strong>：Full GC 会导致最长时间的 Stop-The-World（STW）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><ul><li>Minor GC（Young GC）：清理新生代，频繁发生，STW 时间较短。</li><li>Major GC（Old GC）：清理老年代，较少发生，STW 时间较长。</li><li>Full GC：清理整个堆空间，包含新生代、老年代，甚至包括永久代，STW 时间最长。</li></ul></div><h5 id="Minor-GC-的概念"><a href="#Minor-GC-的概念" class="headerlink" title="Minor GC 的概念"></a>Minor GC 的概念</h5><p>Minor GC 又称为新生代 GC，是针对新生代的垃圾回收。</p><ul><li><strong>Minor GC 的工作范围</strong>：<ul><li>Minor GC 专门用于新生代的垃圾回收。</li><li>新生代主要用于存放新创建的对象，通常分为三个区域：Eden、From Survivor 和 To Survivor。<ul><li>Eden 区：大部分新创建的对象最初被分配在 Eden 区。</li><li>Survivor 区：存活下来的对象会从 Eden 区转移到 From Survivor 或 To Survivor。</li></ul></li></ul></li><li><strong>Minor GC 的触发条件</strong>：<ul><li>当 Eden 区满了时，会触发 Minor GC。</li><li>Minor GC 会扫描新生代的所有区域，回收不再使用的对象，将存活的对象复制到 Survivor 区（如果对象已经存活多次，可能会晋升到老年代）。</li></ul></li><li><strong>Minor GC 的特点</strong>：<ul><li>速度较快，因为新生代的对象生命周期较短，大部分对象在一次 Minor GC 中即可被回收。</li><li>垃圾收集算法采用的是复制算法，执行频率较高，因为对象创建频繁。</li></ul></li></ul><h5 id="Full-GC-的概念"><a href="#Full-GC-的概念" class="headerlink" title="Full GC 的概念"></a>Full GC 的概念</h5><p>Full GC 又称为 Major GC 或者老年代 GC，是针对整个 Java 堆（包括新生代和老年代）的垃圾回收，以及方法区（在 JDK 7 及之前又称为永久代，在 JDK 8 及之后又称为元空间）。Full GC 的速度一般会比 Minor GC 慢 10 倍以上。</p><ul><li><strong>Full GC 的工作范围</strong>：<ul><li>针对整个 Java 堆（包括新生代和老年代）以及方法区的垃圾回收。</li></ul></li><li><strong>Full GC 的触发条件</strong>：<ul><li>老年代（Tenured Generation）满了，需要进行回收。</li><li>永久代（PermGen）或元空间（MetaSpace）满了，需要进行回收。</li><li>显式调用 <code>System.gc()</code> 方法请求垃圾回收（虽然这只是一个建议，JVM 不一定会立即执行）。</li><li>某些情况下，为了防止老年代内存溢出，JVM 会主动触发 Full GC。</li></ul></li><li><strong>Full GC 的特点</strong>：<ul><li>速度较慢，因为它需要扫描整个堆并回收所有代中的对象。</li><li>执行频率较低，但每次执行都会导致较长的停顿（Stop The World），影响应用的性能。</li></ul></li></ul><h4 id="Minor-GC-的执行过程"><a href="#Minor-GC-的执行过程" class="headerlink" title="Minor GC 的执行过程"></a>Minor GC 的执行过程</h4><p>JVM 的堆内存从 GC 的角度可以细分为：新生代（包括 Eden 区、From Survivor 区和 To Survivor 区）和老年代，其中新生代占 1/3 堆空间，老年代占 2/3 堆空间，如下图所示：</p><p><img data-src="../../../asset/2024/03/jvm-minor-gc.png"></p><blockquote><p>第一步：Eden、From Survivor 复制到 To Survivor，且将对象的年龄加一</p></blockquote><p>首先，当 Eden 区满的时候会触发第一次 GC ，将还活着的对象拷贝到 From Survivor 区。当 Eden 区再次触发 GC 的时候，会扫描 Eden 区和 From Survivor 区，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接拷贝到 To Survivor 区域（如果有对象的年龄已经达到了老年的标准，则拷贝到老年代区），同时将这些对象的年龄加一。</p><blockquote><p>第二步：清空 Eden、From Survivor</p></blockquote><p>然后，清空 Eden 和 From Survivor 中的对象，而且在拷贝操作执行完成之后 From Survivor 区和 To Survivor 区会交换角色，谁空谁就是 To Survivor 区。</p><blockquote><p>第三步：From Survivor 和 To Survivor 交换</p></blockquote><p>最后，From Survivor 区和 To Survivor 区交换角色，原 To Survivor 成为下一次 GC 时的 From Survivor 区。部分对象会在 From Survivor 区和 To Survivor 区中复制来复制去，如此交换 15 次（由 JVM 参数 <code>-XX:MaxTenuringThreshold</code> 决定，这个参数值默认是 15）后，最终如果还是存活，就晋升到老年代区中。</p><h4 id="Server-和-Client-模式"><a href="#Server-和-Client-模式" class="headerlink" title="Server 和 Client 模式"></a>Server 和 Client 模式</h4><p>在 Java 虚拟机（JVM）中，”Server” 和 “Client” 模式通常指的是两种不同的 JIT（Just-In-Time）编译器模式，这些模式会影响 Java 应用程序的性能和启动时间。</p><ul><li><p><strong>Client 模式</strong>：在 Client 模式下，JIT 编译器更加注重启动速度和内存占用。它会尽快编译代码以提供快速的启动，并且通常会选择更快的编译方法，但生成的代码可能不够优化。这种模式适用于客户端应用程序，例如桌面应用程序或移动应用程序，因为这些应用程序通常更关注启动时间和响应速度。</p></li><li><p><strong>Server 模式</strong>：在 Server 模式下，JIT 编译器更加注重长期运行时的性能优化。它会花费更多时间来分析和优化代码，以提供更高的执行性能。尽管在启动时会有一些性能损失，但是随着应用程序的长期运行，Server 模式下的性能通常会比 Client 模式更好。这种模式适用于服务器端应用程序，例如 Web 服务器或大型企业应用程序，因为这些应用程序更关注长时间的稳定性和性能表现。</p></li></ul><p>要在 Java 虚拟机中启用特定的模式，可以使用 <code>-client</code> 或 <code>-server</code> 参数。例如：</p><ul><li><code>java -client MyApp</code>：启用客户端模式运行名为 MyApp 的 Java 应用程序</li><li><code>java -server MyApp</code>：启用服务器模式运行名为 MyApp 的 Java 应用程序</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>从 JDK 9 开始，JIT 编译器已经改为使用 Graal 编译器，而不再有明确的 "Client" 和 "Server" 模式。不过，仍然可以通过 <code>-XX:+UseJVMCICompiler</code> 和 <code>-XX:-UseJVMCICompiler</code> JVM 参数来选择使用 Graal 编译器，以及通过其他参数来调整编译器的行为和性能特性。</p></div><div class="admonition note"><p class="admonition-title">Server 和 Client 模式的使用范围</p><ul><li>一般使用 Server 模式，Client 模式基本不会使用。</li><li>64 位的操作系统，只能使用 Server 模式，<a href="../../../asset/2024/03/jvm-server-client-mode.jpeg">点击</a>查看截图。</li><li>32 位的 Window 操作系统，不论硬件如何都默认使用 Client 的 JVM 模式。</li><li>32 位的其它操作系统（如 Linux），2G 内存同时有 2 个 cpu 以上使用 Server 模式，低于该配置还是使用 Client 模式。</li></ul></div><h3 id="收集器的分类"><a href="#收集器的分类" class="headerlink" title="收集器的分类"></a>收集器的分类</h3><p>Java 虚拟机有 7 种不同类型的垃圾收集器，每种垃圾收集器都有自身的特性和适用场景。值得一提的是，各式各样垃圾收集器的出现说明一个事实：GC 没有 “银弹”，换句话说，所有 GC 都不能兼具低停顿时间和低运行时开销的特性。</p><h4 id="常见的收集器"><a href="#常见的收集器" class="headerlink" title="常见的收集器"></a>常见的收集器</h4><p><img data-src="../../../asset/2024/03/jvm-gc-collector-2.png"></p><ul><li><code>Serial</code><ul><li>串行垃圾收集器，它为单线程环境设计，只使用一个线程进行垃圾收集，会暂停所有的用户线程（通常称为 “Stop The World”）。只有当垃圾回收完成时，才会重新唤醒主线程继续执行，所以不适合服务器环境。该垃圾收集器占用内存空间比较小，因此这是嵌入式应用程序的首选垃圾收集器类型，适用于能够承受短暂停顿的应用程序。</li></ul></li><li><code>Parallel</code><ul><li>并行垃圾收集器，多个垃圾收集线程并行工作，此时用户线程也是阻塞的（通常称为 “Stop The World”），适用于科学计算 / 大数据处理等弱交互场景。也就是说 Serial 和 Parallel 其实是类似的，不过是多了几个线程进行垃圾收集，但是主线程都会被暂停，但是并行垃圾收集器花费的处理时间，肯定比串行的垃圾收集器要更短。</li></ul></li><li><code>CMS</code><ul><li>并发垃圾收集器（Concurrent Mark Sweep - 并发标记清除，简称 CMS），用户线程和垃圾收集线程可以同时执行（不一定是并行，有可能是交替执行），减少了用户线程暂停的时间。并发是可以有交互的，也就是说可以一边进行垃圾收集，一边执行应用程序的代码。</li><li>在 CMS 收集器运行的过程中，应用程序将暂停两次。首次暂停发生在标记可直接访问的存活对象时，这个暂停被称为 “初始标记”。第二次暂停发生在 CMS 收集器结束时期，用于修正在并发标记过程中，应用程序线程在 CMS 垃圾回收完成后更新对象时被遗漏的对象，这就是所谓的 “重新标记”。</li><li>CMS 收集器在 Java 8 中已被标记为过时，并在 Java 14 中被移除。CMS 收集器在以前被互联网公司使用得比较多，适用于对应用程序的响应时间有要求的场景。</li></ul></li><li><code>G1</code><ul><li>G1 收集器旨在替代 CMS 收集器，它的特点是支持并行、并发以及增量压缩，且暂停时间较短。与 CMS 收集器使用的内存布局不同，G1 收集器将堆内存划分为大小相同的区域，然后并发地进行垃圾回收。G1 收集器会使用多个线程，触发全局标记阶段。标记阶段完成后，G1 就知道哪个区域可能大部分是空的，并首选该区域作为清除 / 删除阶段。</li><li>在 G1 收集器之前的其他收集器进行收集的范围都是单独针对新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的，它们都是一部分 Region（不需要连续）的集合。每个 Region 从 1M 到 32M 不等，且有可能属于 Eden、Survivor 或者 Tenured (Old) 内存区域的其中一种。。</li><li>G1 收集器是从 2012 年才开始在 JDK 1.7 中可用，Oracle 官方计划在 JDK 9 中将 G1 收集器变成默认的垃圾收集器，逐步替换 JDK 1.8 以前的 CMS 收集器。</li></ul></li></ul><h4 id="新兴的收集器"><a href="#新兴的收集器" class="headerlink" title="新兴的收集器"></a>新兴的收集器</h4><ul><li><code>Epsilon</code><ul><li>Epsilon 收集器是在 Java 11 中引入的，是一个无操作的收集器，不做任何实际的内存回收，只负责管理内存分配。</li><li>Epsilon 收集器一般只在当用户知道应用程序的确切内存占用情况，并且不需要垃圾回收时才使用。</li></ul></li><li><code>Shenandoah</code><ul><li>Shenandoah 收集器是 OpenJDK 项目的一部分，是一种 CPU 密集型的分代垃圾收集器。它使用了一种 “全局并发标记 - 压缩算法”，会进行内存压缩，立即删除无用对象并释放系统的内存空间，所有的这一切都是与应用程序线程并行发生。</li><li>Shenandoah 收集器类似于 G1，也是基于 Region 的堆设计，可以简单地认为是 G1 的升级版。Shenandoah 的 STW 时间不会随堆内存的增大而线性增长，所以回收 200GB 堆内存和 2GB 堆内存的 STW 时间相差无几，而且垃圾回收的大部分阶段都是并发进行的。</li><li>Shenandoah 收集器从 JDK 12 开始引入，在 JDK 15 中，被移出了实验阶段。在 JDK 21 中，被官方宣布将弃用和移除。</li></ul></li><li><code>ZGC</code><ul><li>ZGC 收集器是 OpenJDK 项目的一部分，是一种低延迟垃圾收集器，其设计目标与 Shenandoah 收集器的目标非常相似：控制 STW 时间，目标是 10ms 以内，且 STW 时间不会随堆内存的增大而线性增长。</li><li>ZGC 收集器是基于 Region 的堆设计，适用于要求低延迟、大量堆空间使用的场景。ZGC 允许在执行垃圾回收时，同时让 Java 应用程序继续运行。</li><li>ZGC 收集器从 JDK 11 开始引入，在 JDK 12 中改进。在 JDK 15 中，被移出了实验阶段，是未来下一代的垃圾收集器。</li></ul></li></ul><h3 id="七种默认的收集器"><a href="#七种默认的收集器" class="headerlink" title="七种默认的收集器"></a>七种默认的收集器</h3><p>Java 虚拟机默认提供了 7 种垃圾收集器，分别是：</p><ul><li>UseSerialGC：串行垃圾收集器</li><li> UseParallelGC：并行垃圾收集器</li><li> UseConcMarkSweepGC：并发垃圾收集器，也叫并发标记清除垃圾收集器（CMS）</li><li>UseG1GC：G1 垃圾收集器</li><li> UseParNewGC：新生代的并行垃圾收集器</li><li> UseParallelOldGC：老年代的并行垃圾收集器</li><li> UseSerialOldGC：老年代的串行垃圾收集器（已经被官方移除）</li></ul><blockquote><p>不同垃圾收集器的组合搭配如下：</p></blockquote><p><img data-src="../../../asset/2024/03/jvm-gc-collector-choose.png"></p><h3 id="收集器的使用范围"><a href="#收集器的使用范围" class="headerlink" title="收集器的使用范围"></a>收集器的使用范围</h3><p>Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的垃圾收集器。下面的左图展示了 HotSpot 中 7 种作用于不同分代的垃圾收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。垃圾收集器所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p><p><img data-src="../../../asset/2020/06/jvm-gc-collector.png" alt="jvm-gc-collector"></p><ul><li><p>新生代使用的收集器</p><ul><li>Serial (Serial Copying)：串行垃圾收集器 (UseSerialGC)</li><li>Parallel Scavenge：并行垃圾收集器 (UseParallelGC)</li><li>ParNew：新生代的并行垃圾收集器 (UseParNewGC)</li></ul></li><li><p> 老年代使用的收集器</p><ul><li>Serial Old：老年代的串行垃圾收集器 (UseSerialOldGC)</li><li>Parallel Old (Parallel Compacting)：老年代的并行垃圾收集器 (UseParallelOldGC)</li><li>CMS：并发垃圾收集器 (UseConcMarkSweepGC)</li></ul></li><li><p> 新生代和老年代都能使用的收集器</p><ul><li>G1：G1 垃圾收集器 (UseG1GC)</li></ul></li></ul><p>值得一提的是，在 JDK 8 中，默认使用的垃圾收集器组合是 Parallel Scavenge (新生代用) + Parallel Old (老年代用)。在 JDK 9 及以后，默认使用的垃圾收集器是 G1。</p><h3 id="新生代的收集器"><a href="#新生代的收集器" class="headerlink" title="新生代的收集器"></a>新生代的收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p><img data-src="../../../asset/2020/06/jvm-collector-serial.png" alt="jvm-collector-serial"></p><p>Serial 收集器是最基本、发展历史最悠久的收集器，曾经（在 JDK 1.3.1 之前）是虚拟机新生代垃圾收集的唯一选择。</p><p><strong>特性：</strong></p><p>这个收集器是一个单线程的收集器，但它的 “单线程” 的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，即会造成 “Stop The World” 现象。虽然在收集垃圾的过程中，需要暂停所有其它的工作线程，但是它简单高效的。<strong>对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率。</strong></p><p><strong>优势：</strong></p><p>简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p><strong>应用场景：</strong></p><p>Serial 收集器是虚拟机运行在 Client 模式下的默认新生代收集器。</p><p><strong>对应的 JVM 参数：</strong></p><ul><li>JVM 参数配置：<code>-XX:UseSerialGC</code>，启用 Serial 收集器</li><li> JVM 参数开启后：会使用 Serial (新生代用) + Serial Old (老年代用) 的收集器组合，也就是说，新生代和老年代都会使用串行垃圾收集器，而且新生代使用的是 “复制算法”，老年代使用的是 “标记 - 整理算法”</li></ul><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p><img data-src="../../../asset/2020/06/jvm-collector-parnew.png" alt="jvm-collector-parNew"></p><p><strong>特性：</strong></p><p>ParNew 收集器其实就是 Serial 收集器新生代的并行多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。</p><p><strong>应用场景：</strong></p><p>ParNew 收集器是许多运行在 Server 模式下的虚拟机中首选的新生代收集器。很重要的原因是：除了 Serial 收集器外，目前只有它能与老年代的 CMS 收集器配合工作。在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器 - CMS 收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p><p><strong>对应的 JVM 参数：</strong></p><ul><li>JVM 参数配置：<code>-XX:+UseParNewGC</code>，启用 ParNew 收集器</li><li> JVM 参数开启后：会使用 ParNew (新生代用) + Serial Old (老年代用) 的收集器组合，新生代使用的是 “复制算法”，老年代使用的是 “标记 - 整理算法”</li></ul><p><strong>ParNew 收集器 Vs Serial 收集器：</strong></p><p>ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。然而，随着可以使用的 CPU 的数量的增加，ParNew 收集器对于 GC 时系统资源的有效利用还是很有好处的。ParNew 收集器默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多的情况下，可使用 <code>-XX:ParallerGCThreads</code> JVM 参数指定执行 GC 的线程数。</p><p><strong>已过时的收集器搭配组合，不推荐使用：</strong></p><ul><li>从 JDK 8 开始，ParNew + Serial Old 和 Serial + CMS 这样的收集器搭配组合，已经不推荐使用（如下图所示），且在使用时会出现警告信息</li><li>从 JDK 9 开始，ParNew 收集器被标记为已过时，并且在后续 JDK 版本中逐步被移除，在使用时会出现 <code>Unrecognized VM option 'UseParNewGC'</code> 的错误信息</li></ul><p><img data-src="../../../asset/2024/03/jvm-gc-collector-passe.png"></p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p><strong>特性：</strong></p><p>Parallel Scavenge 收集器类似 ParNew 也是一个新生代收集器，使用复制算法，也是一个并行的多线程的收集器，俗称 “吞吐量优先收集器”。简而言之，目的是实现串行收集器在新生代的并行化。</p><p><strong>应用场景：</strong></p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 的时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p><strong>对应的 JVM 参数：</strong></p><ul><li>JVM 参数配置：<code>-XX:+UseParallelGC</code> 或者 <code>-XX:+UseParallelOldGC</code>（可以互相激活），启用 Parallel Scanvenge 收集器</li><li> JVM 参数开启后：会使用 Parallel Scavenge (新生代用) + Parallel Old (老年代用) 的收集器组合，新生代使用的是 “复制算法”，老年代使用的是 “标记 - 整理算法”</li></ul><p><strong>Parallel Scavenge 收集器 与 CMS 收集器：</strong></p><p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量（Throughput）。由于与吞吐量关系密切，这也是 Parallel Scavenge 收集器经常被称为 “吞吐量优先收集器” 的原因。值得注意的一点是，Parallel Scavenge 收集器无法与 CMS 收集器配合使用，所以在 JDK 1.6 推出 Parallel Old 收集器之前，如果新生代选择 Parallel Scavenge 收集器，那么老年代只有 Serial Old 收集器能与之配合使用。</p><p><strong>Parallel Scavenge 收集器 Vs ParNew 收集器：</strong></p><p>Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别是，前者具有 GC 自适应调节策略特性。Parallel Scavenge 收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个 JVM 参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后就不需要手工指定新生代的大小（<code>-Xmn</code>）、Eden 区和 Survivor 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代的对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（<code>-XX:MaxGCPauseMills</code>）或者最大的吞吐量，这种方式称为 GC 自适应调节策略（GC Ergonomics）。</p><div class="admonition note"><p class="admonition-title">GC 线程数控制</p><p>Parallel Scavenge 收集器也可以使用 <code>-XX:ParallerGCThreads</code> JVM 参数指定执行 GC 的线程数，默认的 GC 线程数设定规则如下：</p><ul><li>当 CPU 数量 &gt; 8，GC 线程数等于 5/8</li><li> 当 CPU 数量 &lt; 8，GC 线程数等于 CPU 数量</li></ul></div><h3 id="老年代的收集器"><a href="#老年代的收集器" class="headerlink" title="老年代的收集器"></a>老年代的收集器</h3><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p><img data-src="../../../asset/2020/06/jvm-collector-serial-old.png" alt="jvm-collector-serial-old"></p><p><strong>特性：</strong></p><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用的是 “标记 - 整理算法”。</p><p><strong>应用场景：</strong></p><ul><li>Client 模式下，Serial Old 收集器的主要意义也是在于给 Client 模式下的虚拟机使用。</li><li>Server 模式下，主要有两大用途：一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用；另一种用途就是作为 CMS 收集器的担保机制，即在并发收集发生 “Concurrent Mode Failure” 错误时使用。</li></ul><p><strong>对应的 JVM 参数：</strong></p><ul><li>JVM 参数配置：<code>-XX:+UseSerialOldlGC</code>，启用 Serial Old 收集器</li></ul><div class="admonition note"><p class="admonition-title">Serial Old 收集器已过时</p><p>从 JDK 9 开始，Serial Old 收集器被标记为已过时，并且在后续 JDK 版本中逐步被移除。这是因为出现了并发标记清除（CMS）和并行（Parallel）垃圾收集器等更先进的替代方案，Serial Old 收集器在性能和并发性方面逐渐被认为不再适用。</p></div><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p><img data-src="../../../asset/2020/06/jvm-collector-parallel-old.png" alt="jvm-collector-parallel-old"></p><p><strong>特性：</strong></p><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记 - 整理算法”，目的是在老年代同样提供吞吐量优先的垃圾收集器。</p><p><strong>应用场景：</strong></p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><p><strong>对应的 JVM 参数：</strong></p><ul><li>JVM 参数配置：<code>-XX:+UseParallelOldGC</code> 或者 <code>-XX:+UseParallelGC</code>（可以互相激活），启用 Parallel Old 收集器</li><li> JVM 参数开启后：会使用 Parallel Scavenge (新生代用) + Parallel Old (老年代用) 的收集器组合</li></ul><p><strong>不同版本 JDK 的收集器组合：</strong></p><ul><li>在 JDK 1.6 之前，新生代使用 Parallel Scavenge 收集器时，只能搭配老年代的 Serial Old 收集器一起使用，这只能保证新生代的吞吐量优先，无法保证整体的吞吐量</li><li>如果系统对吞吐量的要求比较高，在 JDK 1.8 后可以考虑 Parallel Scavenge （新生代收集器）和 Parallel Old （老年代收集器）的搭配组合</li></ul><p><strong>Parallel Old 收集器与 Parallel Scavenge 收集器：</strong></p><p>Parallel Old 收集器是在 JDK 1.6 中才开始提供的，在此之前新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。因为如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合使用）。由于老年代 Serial Old 收集器在服务端应用性能上的 “拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集器（Serial Old）无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种收集器组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合 “给力”。直到 Parallel Old 收集器出现后，” 吞吐量优先” 收集器终于有了比较名副其实的应用组合，那就是 Parallel Scavenge + Parallel Old。</p><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p><img data-src="../../../asset/2020/06/jvm-collector-cms.png" alt="jvm-collector-cms"></p><p><strong>特性：</strong></p><p>CMS（Concurrent Mark Sweep - 并发标记清除）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS 非常适合堆内存大、CPU 核数多的服务器端应用，也是 G1 收集器出现之前大型应用的首选收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验，CMS 收集器就非常符合这类应用的需求。</p><p><strong>工作流程：</strong></p><p>CMS 收集器是基于 “标记 - 清除算法” 实现的，它的工作过程相对于前面几种收集器来说更复杂一些，整个过程分为以下 4 个步骤。由于在耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户线程一起并发执行，所以从总体上来看，可以认为 CMS 收集器的内存回收线程和用户线程是一起并发执行的。</p><p><img data-src="../../../asset/2024/03/jvm-gc-cms-process.png"></p><ul><li>初始标记（CMS initial mark）：初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，仍需要暂停所有用户线程（STW）。</li><li>并发标记（CMS concurrent mark）：执行 GC Roots 跟踪的过程，这阶段耗时较长，但可以和用户线程一起执行，不需要暂停用户线程。</li><li>重新标记（CMS remark）：重新标记阶段是为了修正并发标记期间因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有用户线程（STW），这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的执行时间短。</li><li>并发清除（CMS concurrent sweep）：清除 GC Roots 不可达对象，和用户线程一起执行，不需要暂停用户线程。基于标记结果，直接清理垃圾对象。在清理的过程中，应用程序又会不断地产生新的垃圾（叫浮动垃圾），这些垃圾就要留到下一次 GC 时再清理掉。</li></ul><p><strong>优点：</strong></p><ul><li>CMS 是一款优秀的收集器，它的主要优点是并发收集、停顿时间短，因此 CMS 收集器也被称为 “并发低停顿收集器”（Concurrent Low Pause Collector）。</li></ul><p><strong>缺点：</strong></p><ul><li><p>CMS 收集器对 CPU 资源非常敏感，其实面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是（CPU 数量 + 3）/ 4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程占用不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（例如 2 个）时，CMS 对用户线程的影响就可能变得很大。</p></li><li><p>CMS 收集器无法处理浮动垃圾，可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉，这一部分垃圾就称为 “浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供给并发收集时的程序运作使用。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动担保机制：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集（Full GC），这样停顿时间就很长了，因为 Serial Old 是串行收集器，会导致 Stop-The-World 现象。</p></li><li><p>CMS 收集器会产生大量内存碎片。CMS 是一款基于 “标记 - 清除算法” 实现的收集器，而 “标记 - 清除算法” 无法整理内存碎片，这意味着垃圾收集结束时会有大量内存碎片产生。内存碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续内存空间来分配当前对象，导致不得不提前触发一次 Full GC。也就是说，老年代的空间会随着应用的长时间运行被逐步耗尽，最后将不得不通过担保机制对堆内存进行整理（压缩）。CMS 也提供了参数 <code>-XX:CMSFullGCSBeForeCompaction</code>（默认 0，即每次都进行内存整理）来指定多少次 CMS 收集之后，进行一次压缩的 Full GC。</p></li></ul><p><strong>对应的 JVM 参数：</strong></p><ul><li>JVM 参数配置：<code>-XX:+UseConcMarkSweepGC</code>，启用 CMS 收集器</li><li> JVM 参数开启后：会自动启用 <code>-XX:+UseParNewGC</code> 参数，使用 ParNew (新生代用) + CMS (老年代用) + Serial Old (老年代用) 的收集器组合，Serial Old 收集器将作为 CMS 出错后的备用收集器</li></ul><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p><img data-src="../../../asset/2020/06/jvm-collector-g1.png" alt="jvm-collector-g1"></p><p>G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。G1 是一款面向服务端应用的收集器，应用在多 CPU 和大内存服务器环境中，在实现高吞吐量的同时，尽可能缩短 Stop-The-World 停顿的时间。</p><blockquote><p>以前收集器的共同特点</p></blockquote><ul><li>新生代和老年代是各自独立且连续的内存块</li><li>新生代收集使用单 Eden + S0 + S1 执行复制算法</li><li>老年代收集必须扫描整个老年代区域</li><li>都是以尽可能少而快速地执行 GC 为设计原则</li></ul><blockquote><p>G1 收集器的特点</p></blockquote><ul><li>像 CMS 收集器一样，能与应用程序并发执行</li><li>整理空闲空间更快</li><li>需要更多的时间来预测 GC 停顿时间</li><li>不希望牺牲大量的吞吐量性能</li><li>不需要更大的 Java Heap</li></ul><blockquote><p>G1 与 CMS 收集器对比</p></blockquote><p>G1 收集器设计目标是取代 CMS 收集器，它跟 CMS 相比，在以下方面表现的更出色：</p><ul><li>G1 是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。</li><li>G1 的 Stop The World（STW）更可控，G1 在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</li></ul><blockquote><p>G1 收集器的发展历史和改变</p></blockquote><p>G1 是从 2012 年才开始在 JDK 1.7 中可用，Oracle 官方计划在 JDK 9 中将 G1 变成默认的垃圾收集器，逐步替换 JDK 1.8 以前的 CMS 收集器。G1 的主要改变是：Eden、Survivor 和 Tenured (Old) 等内存区域不再是连续的，而是变成一个个大小一样的 Region，每个 Region 从 1M 到 32M 不等。一个 Region 有可能属于 Eden、Survivor 或者 Tenured (Old) 内存区域的其中一种。</p><hr><p><strong>特性：</strong></p><ul><li><p>并行与并发：G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿的时间，部分其他收集器需要停顿 Java 线程来执行的 GC 动作，而 G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</p></li><li><p>分代收集：与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。</p></li><li><p>空间整合：与 CMS 的 “标记 - 清除算法” 不同，G1 从整体来看是基于 “标记 - 整理算法” 实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的，但无论如何，这两种算法都意味着 G1 在运作期间不会产生内存碎片，垃圾收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 Full GC。</p></li><li><p>可预测的停顿：这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p></li></ul><p><strong>横跨整个堆内存：</strong></p><p>在 G1 之前的其他收集器进行收集的范围都是单独针对新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。</p><p><strong>可预测时间模型：</strong></p><p>G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p><p><strong>避免全堆扫描：</strong></p><p>G1 把 Java 堆分为多个 Region，就是 “化整为零”。但是 Region 不可能是孤立的，一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个 Java 堆才能保证准确性，这显然是对 GC 效率的极大伤害。为了避免全堆扫描的发生，虚拟机为 G1 中每个 Region 维护了一个与之对应的 Remembered Set。虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是就通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</p><p><strong>区域化垃圾收集：</strong></p><p><img data-src="../../../asset/2024/03/jvm-gc-collector-g1-1.png"></p><ul><li><p>G1 将新生代、老年代的物理空间划分取消了，如上图所示。G1 将堆划分为若干个区域（Reign），它仍然属于分代收集器，这些 Region 的一部分包含新生代，而且新生代的垃圾收集依然采用暂停所有用户线程的方式（STW），将存活对象拷贝到 Survivor 空间或者老年代。另一部分的 Region 包含老年代，G1 通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1 完成了堆的压缩（至少是部分堆的压缩），这样也就不会有 CMS 的内存碎片问题存在了。</p></li><li><p>在 G1 中，还有一种特殊的区域，叫做 Humongous（巨大的）区域，如果一个对象占用了空间超过了分区容量 50% 以上，G1 收集器就认为这是一个巨型对象，这些巨型对象默认直接分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放巨型对象。如果一个 Humongous 区装不下一个巨型对象，那么 G1 会寻找连续的 Humongous 区来存储，为了能找到连续的 H 区，有时候不得不启动 Full GC。</p></li></ul><p><strong>底层原理：</strong></p><ul><li><p>G1 是 Region 区域化垃圾收集器，化整为零，打破了原来新生代和老年代的壁垒，避免了全内存扫描，只需要按照区域来进行扫描即可。区域化内存划片 Region，这样是为了一些不连续的内存区域，避免了全内存区的 GC 操作。核心思想是将整个堆内存区域分成大小相同的子区域（Region），在 JVM 启动时会自动设置子区域大小。</p></li><li><p>在堆的使用上，G1 并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可，每个分区（堆区）也不会固定地为某个年代服务，可以按需在新生代和老年代之间切换。应用程序在启动时可以通过 JVM 参数 <code>-XX:G1HeapRegionSize</code> 可指定每个堆区的大小（范围是 1MB ~ 32MB，并且值必须是 2 的幂），默认将整堆划分为 2048 个分区。也就是说，分区大小范围在 1MB ~ 32MB，最多能设置 2048 个分区，即能够支持的最大内存为：32MB * 2048 = 64G 内存。通常来说，调整 <code>-XX:G1HeapRegionSize</code> 这个 JVM 参数可以优化 G1 的性能和吞吐量。例如，增大 G1HeapRegionSize 可以减少堆区的数量，提高回收效率，但可能会增加回收时的停顿时间；而减小 G1HeapRegionSize 可以增加堆区的数量，降低单个回收的停顿时间，但可能会增加回收的总体开销。</p></li></ul><p><strong>回收步骤：</strong></p><p><img data-src="../../../asset/2024/03/jvm-gc-collector-g1-2.png"></p><p>Eden 区耗尽后会被触发垃圾收集，主要是小区域垃圾收集 + 形成连续的内存块，避免内碎片的产生。垃圾回收的步骤如下：</p><ul><li>将 Eden 区的数据移动到 Survivor 区，如果 Survivor 区的空间不够，Eden 区的对象会晋升到 Old 区</li><li> Survivor 区的对象移动到新的 Survivor 区，部分对象晋升到 Old 区</li><li>等 Eden 区收拾干净了，GC 执行结束，用户的线程会继续执行</li></ul><p>最后在 GC 完成后，就会形成连续的内存空间，这样就解决了内存碎片的问题</p><p><strong>工作流程：</strong></p><ul><li>初始标记（Initial Marking）：初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并修改 TAMS（Next Top At Mark Start）的值，让下一阶段用户线程并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿用户线程（STW），但耗时很短。</li><li>并发标记（Concurrent Marking）：并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可以与用户线程并发执行。</li><li>最终标记（Final Marking）：最终标记阶段是为了修正在并发标记期间因用户线程继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿用户线程（STW）。</li><li>筛选回收（Live Data Counting and Evacuation）：筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，这个阶段虽然也可以做到与用户线程一起并发执行，但是会导致只回收一部分 Region，停顿时间是用户可控制的，而且停顿用户线程可以大幅提高垃圾收集效率。与 CMS 收集器不同的是，G1 收集器采用 “复制算法” 来回收垃圾，也就是直接将整个 Region 中存活的对象拷贝到另一个 Region，而且 G1 收集器会优先选择垃圾较多的 Region 进行回收，而不是所有 Region 都进行回收。</li></ul><p><strong>常用配置参数：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-XX:+UseG1GC</code></td><td>启用 G1 收集器</td></tr><tr><td><code>-XX:G1HeapRegionSize</code></td><td>设置每个堆区的大小，范围是 1MB ~ 32MB，且值必须是 2 的幂。目的是根据最小的堆大小，划分出 2048 个分区。</td></tr><tr><td><code>-XX:MaxGCPauseMillis</code></td><td>设置最大 GC 停顿时间，这是一个软目标，JVM 会尽可能（但不保证）停顿小于这个时间。</td></tr><tr><td><code>-XX:InitiatingHeapOccupancyPercent</code></td><td>设置堆空间的占用率达到多少时，G1 会启动混合收集（mixed collections），默认值是 45%。特别注意，这个堆空间占用率表示的是：老年代已使用空间 / 整个堆空间。</td></tr><tr><td><code>-XX:G1NewSizePercent</code></td><td>新生代大小占整个堆大小的最小百分比，默认值是 5%。</td></tr><tr><td><code>-XX:G1MaxNewSizePercent</code></td><td>新生代大小占整个堆大小的最大百分比，默认值是 60%。</td></tr><tr><td><code>-XX:ConcGCThreads</code></td><td>并发 GC 使用的线程数。</td></tr><tr><td><code>-XX:G1ReservePercent</code></td><td>设置作为空闲空间的预留内存百分比，用于降低目标空间溢出的风险，默认值是 10%。</td></tr></tbody></table><blockquote><p>对于 G1 收集器，开发人员日常使用最频繁的三个 JVM 参数： -XX:+UseG1GC、-Xmx32G、-XX:MaxGCPauseMillis=100</p></blockquote><div class="admonition note"><p class="admonition-title">什么是混合收集（mixed collections）</p><p>G1 在老年代占用达到一定比例后，会开始执行混合收集。混合收集是指同时收集部分新生代和老年代的垃圾，以确保系统在垃圾收集时的停顿时间更短。通过调整 <code>-XX:InitiatingHeapOccupancyPercent</code> 参数，可以影响 G1 垃圾收集器在什么时候开始执行混合收集，从而影响垃圾收集的性能表现。例如，将 <code>-XX:InitiatingHeapOccupancyPercent</code> 设置为 45%，则表示当堆的占用率达到 45% 时，G1 垃圾收集器将会启动混合收集。</p></div><h3 id="如何选择垃圾收集器"><a href="#如何选择垃圾收集器" class="headerlink" title="如何选择垃圾收集器"></a>如何选择垃圾收集器</h3><div class="admonition note"><p class="admonition-title">为什么新生代采用 复制算法，而老年代采用 标记 - 整理算法 呢？</p><ul><li><code>新生代使用复制算法</code>：因为新生代对象的生存时间比较短，80% 都是要回收的对象，采用 "复制算法" 可以更灵活高效，且便于整理内存空间；采用 "标记 - 清除算法"，则会造成内存碎片化比较严重的问题；采用 "标记 - 整理算法"，则会造成执行效率较低的问题。</li><li><code>老年代采用标记 - 整理算法</code>：一是为了解决 "标记 - 清除算法" 的内存碎片问题；二是为了解决 "复制算法" 的内存空间折半问题，由于老年代的空间比较大，而且存活的对象相对较多，因此不可能采用 "复制算法"，否则特别占用内存空间，且会大大提高复制成本。</li></ul></div><blockquote><p>垃圾收集器组合使用的选择标准</p></blockquote><ul><li><p>单 CPU、小内存，如单机程序</p><ul><li><code>-XX:+UseSerialGC</code></li><li>上述 JVM 参数启用后，新生代会使用 Serial 垃圾收集器，老年代会使用 Serial Old 垃圾收集器</li></ul></li><li><p>多 CPU、追求高吞吐量，如科学计算、大数据处理等弱交互场景</p><ul><li><code>-XX:+UseParallelGC</code>：新生代垃圾收集器</li><li><code>-XX:+UseParallelOldGC</code>：老年代垃圾收集器</li><li>上述两个 JVM 参数会互相激活</li></ul></li><li><p>多 CPU、追求低停顿时间、要求快速响应，如大型互联网应用</p><ul><li><code>-XX:+ParNewGC</code>：新生代垃圾收集器</li><li><code>-XX:+UseConcMarkSweepGC</code>：老年代垃圾收集器</li></ul></li><li><p>多 CPU、大内存、追求高吞吐量、要求可控停顿时间，如大型服务端应用程序</p><ul><li><code>-XX:+UseG1GC</code>：新生代和老年代的垃圾收集器</li></ul></li></ul><blockquote><p>不同垃圾收集器的组合搭配如下：</p></blockquote><p><img data-src="../../../asset/2024/03/jvm-gc-collector-choose.png"></p><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/ddd77972.html" title="Java 虚拟机入门教程之二 JVM 垃圾收集">https://www.techgrow.cn/posts/ddd77972.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag"><i class="fa fa-tag"></i> JVM 虚拟机</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/55e5dfd.html" rel="prev" title="Spring 之 AOP 的基础使用"><i class="fa fa-angle-left"></i> Spring 之 AOP 的基础使用</a></div><div class="post-nav-item"> <a href="/posts/9e227cab.html" rel="next" title="SkyWalking 安装与运行教程">SkyWalking 安装与运行教程<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.6m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">24:38</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤 ICP 备 19024664 号</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035 号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/app/api/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/app/api/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/ddd77972.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>