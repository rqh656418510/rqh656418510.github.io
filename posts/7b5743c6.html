<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 HashMap 的底层源码和底层原理剖析。"><meta property="og:type" content="article"><meta property="og:title" content="HashMap 底层原理浅析"><meta property="og:url" content="https://www.techgrow.cn/posts/7b5743c6.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 HashMap 的底层源码和底层原理剖析。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/01/jdk-hashmap-put-function.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/05/hashmap-arch-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/05/hashmap-arch-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/05/hashmap-arch-3.png"><meta property="article:published_time" content="2019-05-26T15:20:42.000Z"><meta property="article:modified_time" content="2019-05-26T15:20:42.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Java"><meta property="article:tag" content="源码剖析"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2021/01/jdk-hashmap-put-function.png"><link rel="canonical" href="https://www.techgrow.cn/posts/7b5743c6.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/7b5743c6.html","path":"posts/7b5743c6.html","title":"HashMap 底层原理浅析"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>HashMap 底层原理浅析 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81"><span class="nav-text">HashMap 底层源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Put-%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-text">Put 方法的具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-text">扩容操作的具体实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">HashMap 底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">HashMap 的底层数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-7-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">JDK 1.7 中的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-8-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">JDK 1.8 中的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-11-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">JDK 11+ 中的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E7%9A%84%E7%89%B9%E7%82%B9%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">HashMap 的特点如何实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">三种常见的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E5%AD%98%E5%82%A8"><span class="nav-text">HashMap 实现快速存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%89%A9%E5%AE%B9"><span class="nav-text">HashMap 什么时候会扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%BA%95%E5%B1%82%E7%9A%84%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="nav-text">HashMap 底层的哈希算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashTable-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">HashTable 底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">HashTable 如何实现线程安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">ConcurrentHashMap 底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ConcurrentHashMap"><span class="nav-text">为什么需要 ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">ConcurrentHashMap 如何实现线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-7-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">JDK 1.7 中的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-8-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">JDK 1.8 中的实现</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">684</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/7b5743c6.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="HashMap 底层原理浅析 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 HashMap 的底层源码和底层原理剖析。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> HashMap 底层原理浅析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-05-26 23:20:42" itemprop="dateCreated datePublished" datetime="2019-05-26T23:20:42+08:00">2019-05-26</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/7b5743c6.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/7b5743c6.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.2k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>4 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="HashMap-底层源码"><a href="#HashMap-底层源码" class="headerlink" title="HashMap 底层源码"></a>HashMap 底层源码</h2><span id="more"></span><h3 id="Put-方法的具体实现"><a href="#Put-方法的具体实现" class="headerlink" title="Put 方法的具体实现"></a>Put 方法的具体实现</h3><p>在 HashMap 中，<code>put</code> 方法的具体实现流程和底层源码如下：</p><p><img data-src="../../../asset/2021/01/jdk-hashmap-put-function.png" alt="jdk-hashmap-put-function"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">	HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">	HashMap.Node&lt;K, V&gt; p;</span><br><span class="line">	<span class="keyword">int</span> n, i;</span><br><span class="line">	<span class="comment">// 1.如果table为空或者长度为0，即没有元素，那么使用resize()方法扩容</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">		n = (tab = resize()).length;</span><br><span class="line">	<span class="comment">// 2.计算插入存储的数组索引i，此处计算方法同 1.7 中的indexFor()方法</span></span><br><span class="line">	<span class="comment">// 如果数组为空，即不存在Hash冲突，则直接插入数组</span></span><br><span class="line">	<span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">		tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">// 3.插入时，如果发生Hash冲突，则依次往下判断</span></span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		HashMap.Node&lt;K, V&gt; e;</span><br><span class="line">		K k;</span><br><span class="line">		<span class="comment">// a.判断table[i]的元素的key是否与需要插入的key一样，若相同则直接用新的value覆盖掉旧的value</span></span><br><span class="line">		<span class="comment">// 判断原则equals() - 所以需要当key的对象重写该方法</span></span><br><span class="line">		<span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">				((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			e = p;</span><br><span class="line">			<span class="comment">// b.继续判断：需要插入的数据结构是红黑树还是链表</span></span><br><span class="line">			<span class="comment">// 如果是红黑树，则直接在树中插入 or 更新键值对</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">			e = ((HashMap.TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">			<span class="comment">// 如果是链表，则在链表中插入 or 更新键值对</span></span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			<span class="comment">// i .遍历table[i]，判断key是否已存在：采用equals对比当前遍历结点的key与需要插入数据的key</span></span><br><span class="line">			<span class="comment">//    如果存在相同的，则直接覆盖</span></span><br><span class="line">			<span class="comment">// ii.遍历完毕后任务发现上述情况，则直接在链表尾部插入数据</span></span><br><span class="line">			<span class="comment">//    插入完成后判断链表长度是否 &gt; 8：若是，则把链表转换成红黑树</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">				<span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">					p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">					<span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">						treeifyBin(tab, hash);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">						((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				p = e;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 对于i 情况的后续操作：发现key已存在，直接用新value覆盖旧value&amp;返回旧value</span></span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">			V oldValue = e.value;</span><br><span class="line">			<span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">				e.value = value;</span><br><span class="line">			afterNodeAccess(e);</span><br><span class="line">			<span class="keyword">return</span> oldValue;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	++modCount;</span><br><span class="line">	<span class="comment">// 插入成功后，判断实际存在的键值对数量size &gt; 最大容量</span></span><br><span class="line">	<span class="comment">// 如果大于则进行扩容</span></span><br><span class="line">	<span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">		resize();</span><br><span class="line">	<span class="comment">// 插入成功时会调用的方法（默认实现为空）</span></span><br><span class="line">	afterNodeInsertion(evict);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="扩容操作的具体实现"><a href="#扩容操作的具体实现" class="headerlink" title="扩容操作的具体实现"></a>扩容操作的具体实现</h3><p>在 HashMap 中，扩容操作的底层源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法有两种使用情况：1.初始化哈希表；2.当前数组容量过小，需要扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt;[] resize() {</span><br><span class="line">	Node&lt;K, V&gt;[] oldTab = table;<span class="comment">// 扩容前的数组（当前数组）</span></span><br><span class="line">	<span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">// 扩容前的数组容量（数组长度）</span></span><br><span class="line">	<span class="keyword">int</span> oldThr = threshold;<span class="comment">// 扩容前数组的阈值</span></span><br><span class="line">	<span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">		<span class="comment">// 针对情况2：若扩容前的数组容量超过最大值，则不再扩容</span></span><br><span class="line">		<span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">			threshold = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">return</span> oldTab;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 针对情况2：若没有超过最大值，就扩容为原来的2倍（左移1位）</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">				oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">			newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 针对情况1：初始化哈希表（采用指定或者使用默认值的方式）</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">		newCap = oldThr;</span><br><span class="line">	<span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">		newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">		newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算新的resize上限</span></span><br><span class="line">	<span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;</span><br><span class="line">		newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">				(<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">	}</span><br><span class="line">	threshold = newThr;</span><br><span class="line">	<span class="meta">@SuppressWarnings({"rawtypes", "unchecked"})</span></span><br><span class="line">	Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap];</span><br><span class="line">	table = newTab;</span><br><span class="line">	<span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="comment">// 把每一个bucket都移动到新的bucket中去</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">			Node&lt;K, V&gt; e;</span><br><span class="line">			<span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {</span><br><span class="line">				oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">					newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">					((TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">				<span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">					Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">					Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">					Node&lt;K, V&gt; next;</span><br><span class="line">					<span class="keyword">do</span> {</span><br><span class="line">						next = e.next;</span><br><span class="line">						<span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">							<span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">								loHead = e;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								loTail.next = e;</span><br><span class="line">							loTail = e;</span><br><span class="line">						} <span class="keyword">else</span> {</span><br><span class="line">							<span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">								hiHead = e;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								hiTail.next = e;</span><br><span class="line">							hiTail = e;</span><br><span class="line">						}</span><br><span class="line">					} <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">					<span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {</span><br><span class="line">						loTail.next = <span class="keyword">null</span>;</span><br><span class="line">						newTab[j] = loHead;</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {</span><br><span class="line">						hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">						newTab[j + oldCap] = hiHead;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="HashMap-底层原理"><a href="#HashMap-底层原理" class="headerlink" title="HashMap 底层原理"></a>HashMap 底层原理</h2><h3 id="HashMap-的底层数据结构"><a href="#HashMap-的底层数据结构" class="headerlink" title="HashMap 的底层数据结构"></a>HashMap 的底层数据结构</h3><h4 id="JDK-1-7-中的实现"><a href="#JDK-1-7-中的实现" class="headerlink" title="JDK 1.7 中的实现"></a>JDK 1.7 中的实现</h4><p>在 JDK 1.7 中，HashMap 采用数组 + 链表作为底层的数据结构，其中使用链表是为了解决哈希冲突。当发生哈希冲突时，即多个键被映射到了同一个哈希桶（数组的位置），HashMap 会将这些键值对存储在同一个哈希桶对应的链表中。具体来说，在 JDK 1.7 中，HashMap 的每个哈希桶（数组的位置）实际上是一个链表，每个链表存储了哈希值相同的键值对。当执行 Put 操作时，HashMap 首先会计算键的哈希值，然后确定该键应该存储在数组的哪个位置。如果该位置已经存在了链表，HashMap 就会遍历该链表，检查是否已经存在相同键的键值对。如果存在相同的键，则 HashMap 会更新相应的值；如果不存在相同的键，则 HashMap 会将新的键值对添加到链表的末尾。链地址法的优点是它能够处理哈希冲突，并且在一定程度上保持了 HashMap 的性能。然而，在负载因子较高的情况下，即链表较长的情况下，查询键值对的效率可能会降低，因为需要遍历链表来找到目标键值对。</p><h4 id="JDK-1-8-中的实现"><a href="#JDK-1-8-中的实现" class="headerlink" title="JDK 1.8 中的实现"></a>JDK 1.8 中的实现</h4><p>在 JDK 1.8 之后，HashMap 采用数组 + 链表 + 红黑树作为底层的数据结构，之所以引入红黑树来替代链表，是为了改善在负载因子较高时的性能，这种结构称为 “链表与红黑树混合实现”。当哈希冲突发生时，如果链表的长度超过一定阈值（默认为 8），HashMap 会将链表转换为红黑树。这样做的目的是为了在链表长度较长时提高查询、修改和删除操作的效率，因为红黑树的时间复杂度更稳定，为 O (log n)。而当链表长度较短时，仍然保持使用链表结构，因为在较短的链表中，链表的遍历效率更高。值得一提的是，当红黑树中元素个数小于一定数量时，会转换回原来的链表结构，JDK 设置这个默认数量为 6 个。</p><h4 id="JDK-11-中的实现"><a href="#JDK-11-中的实现" class="headerlink" title="JDK 11+ 中的实现"></a>JDK 11+ 中的实现</h4><p>在 JDK 11、JDK 17 等高版本的 JDK 中，HashMap 的实现仍然基于数组 + 链表 + 红黑树混合实现（如下图所示）。因此，处理哈希冲突的方式与 JDK 1.8 中相似，只是可能会对一些细节进行了优化或改进，比如会引入树化优化、移位优化等。比如树化优化指的是在进行树化操作时，会先判断当前链表长度是否大于等于 8，如果不是，则不会进行树化操作，以节省资源。这个优化主要是为了解决在一些场景下，链表长度虽然超过了阈值，但树化操作并不能带来性能提升的问题。</p><p><img data-src="../../../asset/2024/05/hashmap-arch-1.png"></p><div class="admonition note"><p class="admonition-title">　提示</p><p>无论在哪个版本的 JDK 里面，HashMap 使用的链表都是单向链表。</p></div><h3 id="HashMap-的特点如何实现"><a href="#HashMap-的特点如何实现" class="headerlink" title="HashMap 的特点如何实现"></a>HashMap 的特点如何实现</h3><p>HashMap 是一种可以快速存储和快速存储的键值对容器，那么 JDK 是如何实现 HashMap 的快速存储和快速查找呢？</p><h4 id="三种常见的数据结构"><a href="#三种常见的数据结构" class="headerlink" title="三种常见的数据结构"></a>三种常见的数据结构</h4><p>这里首先从数组、链表、二叉查找树这三种常见的数据结构说起。</p><blockquote><p>数组</p></blockquote><p>数组是连续的内存空间，利用二分查找法，数组的时间复杂度最低可以低到 O (1)，可见数组的查询效率是非常高的。但是由于数组的内存必须是连续的，空间复杂度很高，所以数组的插入、删除效率都非常低。</p><blockquote><p>链表</p></blockquote><p>链表的内存空间比较分散，空间复杂度较低，执行插入和删除操作的效率较高。但是由于链表的内存空间过于分散，导致查询效率大大降低。</p><blockquote><p>二叉查找树</p></blockquote><p>二叉查找树的别名是二叉搜索树，或者叫二叉排序树，在查询效率上和排序后数组的二分查找法效率完全相同，从根节点开始到下面的分支节点，左边的节点永远比父节点的要小，右边的节点永远比父节点大，如下图所示：</p><p><img data-src="../../../asset/2024/05/hashmap-arch-2.png"></p><p>上图中一共 12 个元素，如果按顺序查找，可能最多需要查找 12 次才能查到目标元素；但是通过使用二叉查找树后，查找 43 这个元素，只需要判断 4 次就可以。由此可以看出二叉查找树在查询效率上和排序后的数组二分查找法效率是一样的。但是由于二叉树的元素过于分散，导致空间复杂度过大，执行插入和删除操作时会非常低效。为了解决这个问题，JDK 使用了红黑树这种数据结构，而红黑树在时间复杂度上可以做到 O (log n) 的高效率。</p><h4 id="HashMap-实现快速存储"><a href="#HashMap-实现快速存储" class="headerlink" title="HashMap 实现快速存储"></a>HashMap 实现快速存储</h4><p>快速存储是链表和红黑树的优势。HashMap 中数组的索引是通过哈希值（hashCode）与其右移 16 位后的结果进行异或运算，然后按位与运算（取模）来获得的，底层源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 调用 key.hashCode() 生成初步哈希值，然后对哈希值进行扰动处理</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用按位与运算替代取模运算（这样更高效），n 是 HashMap 底层数组的长度（总是 2 的幂），hash 是经过扰动处理后的哈希值</span></span><br><span class="line"><span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></tbody></table></figure><p>通过这样的计算可以保证数组索引的分散。但是分散并不代表不会出现相同的索引，也就是索引冲突（哈希冲突）。在遇到哈希冲突的时候，HashMap 会在该索引的位置生成一个单向链表，将元素放置到尾部。虽然链表这种数据结构的插入效率比较高，但是在查询上效率却非常低，所以 HashMap 在链表元素数量大于 8 的时候，会自动将链表转成红黑树，以达到查询高效，插入也高效的目的。当然，在红黑树中元素个数小于一定数量时，会转换回原来的链表结构，JDK 设置这个默认数量为 6 个。这样不管是在外围 “数组” 上，还是在 “链表” 上，以及转换成 “红黑树” 这种数据结构，HashMap 都能做到快速存储。</p><div class="admonition note"><p class="admonition-title">总结</p><p>HashMap 底层的数组在查找效率上绝对有保证。当发生哈希冲突时，会使用链表存储冲突的元素，元素数量仅仅只有 8 个的链表，查询效率不需要考虑。大于 8 个元素后，链表会转换成红黑树，而红黑树的查询效率与数组相当，这点也不需要质疑。综合考虑，当发生哈希冲突时，HashMap 在查询方面也做到了快速查找的特性。</p></div><h3 id="HashMap-什么时候会扩容"><a href="#HashMap-什么时候会扩容" class="headerlink" title="HashMap 什么时候会扩容"></a>HashMap 什么时候会扩容</h3><p>HashMap 在内部会维护一个负载因子（Load Factor），默认的负载因子是 <code>0.75</code>，也就是当 HashMap 中的元素数量达到容量的 75% 时，会触发扩容操作。扩容操作会创建一个新的更大的数组，通常是 <strong>当前容量的两倍</strong>，然后将原有的元素重新散列到新的数组中。这个过程需要重新计算每个元素的哈希值，并将其放置到新的数组中。由于这个过程涉及到重新哈希，可能会导致元素的重新排列，因此在扩容过程中，HashMap 的性能可能会受到影响。</p><div class="admonition note"><p class="admonition-title">提示</p><p>HashMap 的默认初始容量是 16，最大容量为 2^30，每次扩容后的容量都是之前容量的两倍。</p></div><h3 id="HashMap-底层的哈希算法"><a href="#HashMap-底层的哈希算法" class="headerlink" title="HashMap 底层的哈希算法"></a>HashMap 底层的哈希算法</h3><p>在 HashMap 中，哈希算法的核心是调用对象（键对象）的 <code>hashCode()</code> 方法生成一个初步的哈希值，然后通过一系列处理（扰动处理）使这个哈希值分布得更加均匀，以减少哈希冲突。下面是 Java 8 中 HashMap 底层源码中用于计算哈希值的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 调用 key.hashCode() 生成初步哈希值，然后进行扰动处理</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>key.hashCode()</code>：调用键对象的 <code>hashCode()</code> 方法，生成初步的哈希值 <code>h</code>。</li><li><code>h &gt;&gt;&gt; 16</code>：将初步哈希值 <code>h</code> 向右无符号移动 16 位，目的是为了引入哈希值的高位信息。</li><li><code>h ^ (h &gt;&gt;&gt; 16)</code>：将初步哈希值 <code>h</code> 和其右移 16 位后的结果进行异或操作。这样做是为了混合哈希值的高位和低位，以生成一个更加随机和均匀分布的哈希值。</li></ul><p>上述步骤生成的哈希值，将用于确定键在 HashMap 中存储的位置，即哈希桶的位置（数组的位置）。具体位置的计算方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用按位与运算替代取模运算，这样更高效</span></span><br><span class="line"><span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></tbody></table></figure><p>其中，<code>n</code> 是 HashMap 底层数组的长度（总是 2 的幂），<code>hash</code> 是经过扰动处理后的哈希值。<code>(n - 1) &amp; hash</code> 通过按位与运算将哈希值限制在数组的索引范围内。</p><div class="admonition note"><p class="admonition-title">总结</p><p>HashMap 底层的哈希算法通过键对象的 <code>hashCode()</code> 方法生成初步哈希值，并通过扰动处理（即将哈希值与其右移 16 位后的结果进行异或运算）使哈希值分布更加均匀，从而有效减少哈希冲突，提升整体性能。这是 HashMap 在 Java 中实现高效键值对存储和检索的关键机制。</p></div><h2 id="HashTable-底层原理"><a href="#HashTable-底层原理" class="headerlink" title="HashTable 底层原理"></a>HashTable 底层原理</h2><h3 id="HashTable-如何实现线程安全"><a href="#HashTable-如何实现线程安全" class="headerlink" title="HashTable 如何实现线程安全"></a>HashTable 如何实现线程安全</h3><p>HashTable 使用同步方法来保证线程安全，也就是所有关键操作方法（如 <code>get()</code>、<code>put()</code>、<code>remove()</code> 等）都使用了 <code>synchronized</code> 关键字进行同步，确保同一时刻只有一个线程可以执行这些方法，这也就保证了线程安全。</p><h2 id="ConcurrentHashMap-底层原理"><a href="#ConcurrentHashMap-底层原理" class="headerlink" title="ConcurrentHashMap 底层原理"></a>ConcurrentHashMap 底层原理</h2><h3 id="为什么需要-ConcurrentHashMap"><a href="#为什么需要-ConcurrentHashMap" class="headerlink" title="为什么需要 ConcurrentHashMap"></a>为什么需要 ConcurrentHashMap</h3><div class="admonition note"><p class="admonition-title">思考</p><p>为什么已经有 HashTable 了，JDK 还会提供 ConcurrentHashMap 这个线程安全的类呢？</p></div><p>首先 HashTable 本身是个容器，这也就说明了 HashTable 本身可以不断的变大，试想一下，HashTable 如果本身存储 1000 个元素，那么在调用 <code>get()</code> 方法时，就会将这 1000 个元素完全锁住，期间其他任何线程都得等待。这样就会造成容器越大，对容器数据操作的效率就越低。为了解决这个问题，JDK 提供了 ConcurrentHashMap 类，其实 ConcurrentHashMap 的底层也是通过 <code>synchronized</code> 关键字来实现线程安全的，不同于 HashTable 的是 ConcurrentHashMap 在线程同步上更加细分化，它不会像 HashTable 那样一次性将所有数据都锁住，而是采用 “分段锁” 思想。</p><h3 id="ConcurrentHashMap-如何实现线程安全"><a href="#ConcurrentHashMap-如何实现线程安全" class="headerlink" title="ConcurrentHashMap 如何实现线程安全"></a>ConcurrentHashMap 如何实现线程安全</h3><div class="admonition note"><p class="admonition-title">思考</p><p>这里需要知道，ConcurrentHashMap 底层数据结构的实现其实和 HashMap 没有多大区别，都是数组 + 链表 + 红黑树。那怎么将 HashMap 的数据结构使用分段锁的思想使其在线程同步上更加细分化呢？</p></div><h4 id="JDK-1-7-中的实现-1"><a href="#JDK-1-7-中的实现-1" class="headerlink" title="JDK 1.7 中的实现"></a>JDK 1.7 中的实现</h4><p>在 JDK 1.7 及以前，是这样实现的。比如容器 HashMap 中存在 1000 个元素，各个元素都放置到 HashMap 数组的链表或者红黑树中，最后得到的数组大小可能只有 128。ConcurrentHashMap 会根据这 128 个数组元素对其分段，比如以 16 个数组元素为一段，可以分为 8 段。在实际获取和添加元素时，首先会根据哈希算法计算得到元素的索引，然后找到该元素所处的段位，然后只将该段位锁住，并不影响其他段位的数据操作。这样，如果按照 HashTable 的效率为基本单位来计算，ConcurrentHashMap 在 JDK 1.7 及以前的效率会提高 8 倍，当然数据量越大，提高的效率将越多。</p><p><img data-src="../../../asset/2024/05/hashmap-arch-3.png"></p><h4 id="JDK-1-8-中的实现-1"><a href="#JDK-1-8-中的实现-1" class="headerlink" title="JDK 1.8 中的实现"></a>JDK 1.8 中的实现</h4><p>在 JDK 1.8 及以后，ConcurrentHashMap 依旧使用分段锁的思想来实现线程安全，但不同于 JDK 1.7 及以前的实现，JDK 1.8 将锁的粒度更加细分化，以每个数组索引为锁来进行实现。比如 HashMap 中数组的长度为 128，那么就会存在 128 个锁将每个数组元素锁住，这样在并发效率上有了很大的提升。</p><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/7b5743c6.html" title="HashMap 底层原理浅析">https://www.techgrow.cn/posts/7b5743c6.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> 源码剖析</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/77bb067c.html" rel="prev" title="MyBatis 入门教程之六"><i class="fa fa-angle-left"></i> MyBatis 入门教程之六</a></div><div class="post-nav-item"> <a href="/posts/9e38efb3.html" rel="next" title="Java 大数据知识图谱 (最新)">Java 大数据知识图谱 (最新)<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.7m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">26:16</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/7b5743c6.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>