<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 从基础到进阶的内容。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 杂记之三从基础到进阶"><meta property="og:url" content="https://www.techgrow.cn/posts/9ce17bf9.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 从基础到进阶的内容。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2022/07/cplusplus-vector-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/12/cplusplus-iterator-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/12/cplusplus-iterator-2.png"><meta property="article:published_time" content="2023-08-20T13:55:33.000Z"><meta property="article:modified_time" content="2023-08-20T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2022/07/cplusplus-vector-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/9ce17bf9.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/9ce17bf9.html","path":"posts/9ce17bf9.html","title":"C++ 杂记之三从基础到进阶"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 杂记之三从基础到进阶 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script>
  (function () {

  // 防止 Pjax 重复绑定事件
  if (window.__moonMenuCodeExpandBound) {
    return;
  }
  window.__moonMenuCodeExpandBound = true;

  const STORAGE_KEY = 'moon_menu_code_fold';

  /* ===============================
   * 1. 设置 moon-menu 按钮的 title
   * =============================== */
  (function bindMoonMenuTitles() {
    const items = [
      { selector: '#moon-menu-item-code',        title: '展开 / 折叠代码块' },
      { selector: '#moon-menu-item-back2top',    title: '回到页面顶部' },
      { selector: '#moon-menu-item-back2bottom', title: '回到页面底部' }
    ];

    let allReady = true;

    items.forEach(item => {
      const el = document.querySelector(item.selector);
      if (!el) {
        allReady = false;
        return;
      }
      el.setAttribute('title', item.title);
    });

    if (!allReady) {
      setTimeout(bindMoonMenuTitles, 100);
    }
  })();

  /* =================================
   * 2. 页面首次加载：代码块恢复展开或折叠状态
   * ================================= */
  function applyStoredCodeState() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    const state = localStorage.getItem(STORAGE_KEY);
    if (!state) {
      return;
    }

    containers.forEach(container => {
      if (state === 'expanded') {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else if (state === 'folded') {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });
  }

  // 等代码块出现后，再恢复展开或折叠状态
  function waitAndApplyState() {
    const containers = document.querySelectorAll('.code-container');

    if (!containers.length) {
      setTimeout(waitAndApplyState, 100);
      return;
    }

    applyStoredCodeState();
  }

  // 页面首次加载时恢复状态
  waitAndApplyState();
  
  // Pjax 切换页面后，必须重新恢复状态
  document.addEventListener('pjax:complete', function () {
    waitAndApplyState();
  });

  /* ===============================
   * 3. 点击按钮：切换状态并保存
   * =============================== */
  document.addEventListener('click', function (e) {
    const codeMenu = e.target.closest('#moon-menu-item-code');
    if (!codeMenu) {
      return;
    }

    toggleAllCodeBlocks();
  });

  // 展开或折叠代码块
  function toggleAllCodeBlocks() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    // 只要存在折叠的代码块，就认为当前是折叠状态
    const hasFolded = Array.from(containers).some(c => {
      return c.classList.contains('highlight-fold');
    });

    containers.forEach(container => {
      if (hasFolded) {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });

    // 记录展开或折叠状态
    localStorage.setItem(
      STORAGE_KEY,
      hasFolded ? 'expanded' : 'folded'
    );
  }

})();
</script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string-%E5%AE%B9%E5%99%A8"><span class="nav-text">string 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#string-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">string 的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">string 的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-text">string 的初始化方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E-string-%E5%8F%96%E5%BE%97-char"><span class="nav-text">从 string 取得 char*</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86-string-%E6%8B%B7%E8%B4%9D%E5%88%B0-char"><span class="nav-text">将 string 拷贝到 char*</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E-string-%E4%B8%8E%E8%8C%83%E5%9B%B4-for-%E4%BD%BF%E7%94%A8"><span class="nav-text">从 string 与范围 for 使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector-%E5%AE%B9%E5%99%A8"><span class="nav-text">vector 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vector-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">vector 的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">vector 的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-text">vector 的初始化方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector-%E4%B8%8E%E8%8C%83%E5%9B%B4-for-%E4%BD%BF%E7%94%A8"><span class="nav-text">vector 与范围 for 使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector-%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">vector 与迭代器的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-text">迭代器的概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">迭代器的类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">迭代器的操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%A4%B1%E6%95%88"><span class="nav-text">迭代器的失效</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">798</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">56</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/9ce17bf9.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 杂记之三从基础到进阶 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 从基础到进阶的内容。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 杂记之三从基础到进阶</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-08-20 21:55:33" itemprop="dateCreated datePublished" datetime="2023-08-20T21:55:33+08:00">2023-08-20</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/9ce17bf9.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/9ce17bf9.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>5 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/332ad818.html">C++ 杂记之一从基础到进阶</a>、<a href="/posts/68a580cf.html">C++ 杂记之二从基础到进阶</a>、<a href="/posts/9ce17bf9.html">C++ 杂记之三从基础到进阶</a></li><li><a href="/posts/d198d85d.html">C++ 杂记之四从基础到进阶</a></li></ul><span id="more"></span><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="string-容器"><a href="#string-容器" class="headerlink" title="string 容器"></a>string 容器</h3><h4 id="string-的概念"><a href="#string-的概念" class="headerlink" title="string 的概念"></a>string 的概念</h4><p><code>string</code> 是 STL 的字符串类型，通常用来表示字符串。而在使用 <code>string</code> 之前，字符串通常是用 <code>char*</code> 表示的。<code>string</code> 与 <code>char*</code> 都可以用来表示字符串，两者的区别如下：</p><ul><li><code>string</code> 是一个类，<code>char*</code> 是一个指向字符的指针</li><li><code>string</code> 封装了 <code>char*</code> 来管理字符串，本质是一个 <code>char*</code> 类型的容器</li><li><code>string</code> 不用考虑内存释放和越界的问题</li><li><code>string</code> 负责管理 <code>char*</code> 所分配的内存。每一次 <code>string</code> 的复制，取值都由 <code>string</code> 类负责维护，不用担心复制越界和取值越界等问题</li><li><code>string</code> 提供了一系列的字符串操作函数，例如：查找（find）、拷贝（copy）、删除（erase）、替换（replace）、插入（insert）</li></ul><h4 id="string-的构造函数"><a href="#string-的构造函数" class="headerlink" title="string 的构造函数"></a>string 的构造函数</h4><ul><li>默认构造函数：<code>string();</code></li><li>带参数的构造函数：<ul><li><code>string(const char *s);</code>，用字符串 s 初始化</li><li><code>string(int n, char c);</code>，用 <code>n</code> 个字符 c 初始化</li></ul></li><li>拷贝构造函数：<code>string(const string &amp;str);</code></li></ul><div class="admonition warning"><p class="admonition-title">字符串头文件说明</p><ul><li>在标准 C++ 中，使用 <code>string</code> 必须显式包含 <code>&lt;string&gt;</code> 头文件。任何在未包含 <code>&lt;string&gt;</code> 的情况下仍然能够使用 <code>string</code> 的代码，都依赖于标准库实现的间接包含行为，属于非标准、不可移植的用法。</li><li>一些标准库实现（例如 libstdc++）在 <code>&lt;iostream&gt;</code> 等头文件的内部实现中，可能间接包含了 <code>&lt;string&gt;</code>，从而使代码在特定编译器和版本下 "看起来可以正常工作"。然而，这种行为是实现细节，不受 C++ 标准保证，随着编译器、标准库版本或编译选项（如不同的 <code>-std=</code> 标准级别）变化，代码都有可能无法通过编译。</li></ul></div><h4 id="string-的初始化方式"><a href="#string-的初始化方式" class="headerlink" title="string 的初始化方式"></a>string 的初始化方式</h4><ul><li>C 语言中，字符串的初始化方式</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字符串字面量初始化：末尾自动追加 '\0'，其余元素补 0</span></span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>] = <span class="string">"C++"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于上面 s1 的写法效果，显式写出 '\0'，其余元素补 0</span></span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">100</span>] = {<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不指定字符串长度，让编译器自动推导，实际大小是 4（包括末尾的 '\0'）</span></span><br><span class="line"><span class="keyword">char</span> str3[] = <span class="string">"C++"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字符列表初始化（末尾必须要有 '\0'，否则不是字符串）</span></span><br><span class="line"><span class="keyword">char</span> str4[] = {<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分初始化：其余元素补 0（非字符串语义，但结果满足 '\0' 结尾）</span></span><br><span class="line"><span class="keyword">char</span> str5[<span class="number">100</span>] = {<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>};</span><br></pre></td></tr></tbody></table></figure><ul><li>C++ 中，字符串的初始化方式</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化，s1 是空字符串，表示里面没有字符</span></span><br><span class="line">string s1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的字符串内容拷贝到 s2 所代表的一段内存中，拷贝时不包括字符串末尾的 '\0'</span></span><br><span class="line">string s2 = <span class="string">"I Love C++"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟上面字符串 s2 的写法效果一样</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">"I Love C++"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表初始化</span></span><br><span class="line">string s4{<span class="string">"I Love C++"</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串 s2 的内容拷贝到 s4 所代表的一段内存中</span></span><br><span class="line">string s5 = s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 s5 初始化为连续 5 个字符 'a' 组成的字符串（aaaaa），可能会在系统内部创建临时对象</span></span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(<span class="number">5</span>, <span class="string">'a'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 s2 的下标 2（第 3 个字符）开始，连续拷贝到字符串末尾，构造新的字符串</span></span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(s2, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 s2 的下标 2（第 3 个字符）开始，连续拷贝 4 个字符，构造新的字符串</span></span><br><span class="line"><span class="function">string <span class="title">s8</span><span class="params">(s2, <span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字符数组（必须有一个元素是 '\0'，否则会出现未定义行为）初始化字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[] = {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>};</span><br><span class="line"><span class="function">string <span class="title">s9</span><span class="params">(buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 const char* 初始化 string</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p1 = <span class="string">"Modern C++"</span>;</span><br><span class="line">string s1 = p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟上面字符串 s1 的写法效果一样</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 char 数组（必须有一个元素是 '\0'，否则会出现未定义行为）初始化字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[] = {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>};</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 char*（必须有一个元素是 '\0'，否则会出现未定义行为）初始化 string</span></span><br><span class="line"><span class="keyword">char</span> buf2[] = {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>};</span><br><span class="line"><span class="keyword">char</span>* p2 = buf2;</span><br><span class="line">string s4 = p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定长度进行构造（不依赖 '\0'）</span></span><br><span class="line"><span class="keyword">char</span> buf3[] = {<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>};</span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(buf3, <span class="number">3</span>)</span></span>;  <span class="comment">// 只拷贝前 3 个字符："ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝 char 数组的一部分（不依赖 '\0'）</span></span><br><span class="line"><span class="keyword">char</span> buf4[] = <span class="string">"Hello C++ World"</span>;</span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(buf4 + <span class="number">6</span>, <span class="number">3</span>)</span></span>;  <span class="comment">// 从第 7 个字符开始，拷贝 3 个字符："C++"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝 char 数组的一部分（依赖 '\0'，否则会出现未定义行为）</span></span><br><span class="line"><span class="keyword">char</span> buf5[] = {<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'\0'</span>};</span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(buf5 + <span class="number">3</span>)</span></span>;  <span class="comment">// 从第 4 个字符开始，一直拷贝，直到遇到 '\0'，最终拷贝 4 个字符：DEFG</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>通过 <code>char[]</code> 或者 <code>char *</code> 初始化 <code>string</code> 的写法</th><th>传入的真实类型</th><th>是否依赖 <code>'\0'</code></th><th>说明</th></tr></thead><tbody><tr><td><code>string(p)</code></td><td><code>const char*</code></td><td>依赖</td><td> C 风格字符串，必须包含 <code>'\0'</code>，遇 <code>'\0'</code> 结束拷贝</td></tr><tr><td><code>string(p, n)</code></td><td><code>const char* + size_t</code></td><td>不依赖</td><td>精确拷贝 n 个字节，p 可以没有 <code>'\0'</code></td></tr><tr><td><code>string(arr)</code></td><td><code>const char*</code>（arr 衰变）</td><td>依赖</td><td> arr 必须包含 <code>'\0'</code>，遇 <code>'\0'</code> 结束拷贝</td></tr><tr><td><code>string(arr, n)</code></td><td><code>const char* + size_t</code></td><td>不依赖</td><td>精确拷贝 n 个字节，arr 可以没有 <code>'\0'</code></td></tr></tbody></table><div class="admonition note"><p class="admonition-title">char 与 string 之间的转换</p><ul><li>在 C++ 中，<code>char[]</code> 与 <code>char*</code> 可以隐式转换为 <code>string</code>，而 <code>string</code> 不能自动转换为 <code>char[]</code> 或者 <code>char*</code>，只能通过 <code>string::c_str()</code> 显式获取 <code>const char *</code>。</li><li><code>string</code> 的构造函数并不区分 <code>char*</code> 和 <code>char[]</code>，因为字符数组在参数传递时会退化为字符指针；是否依赖 <code>'\0'</code>，只取决于开发者调用的是 <code>string(const char*)</code> 还是 <code>string(const char*, size_t)</code>。</li></ul></div><h4 id="从-string-取得-char"><a href="#从-string-取得-char" class="headerlink" title="从 string 取得 char*"></a>从 string 取得 char*</h4><p>从 <code>string</code> 取得 <code>char*</code>，可以使用：</p><ul><li><code>const char *c_str() const;</code>，返回一个以 <code>\0</code> 结尾的字符串的首地址</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>在 C++ 中，<code>char[]</code> 与 <code>char *</code> 可以隐式转换为 <code>string</code> 类型，反过来则不可以，例如右边这种写法是合法的： <code>char *p = "abc"; string str = p;</code></li></ul></div><h4 id="将-string-拷贝到-char"><a href="#将-string-拷贝到-char" class="headerlink" title="将 string 拷贝到 char*"></a>将 <code>string</code> 拷贝到 <code>char*</code></h4><p>将 <code>string</code> 拷贝到 <code>char*</code> 指向的内存空间，可以使用：</p><ul><li><code>int copy(char *s, int n, int pos=0) const;</code></li></ul><p>将当前串中以 <code>pos</code> 位置开始的 <code>n</code> 个字符拷贝到以 <code>s</code> 为起始位置的字符数组中，返回实际拷贝的字符数量。特别注意，要保证指针 <code>s</code> 所指向的内存空间足以容纳当前的字符串，不然可能会发生越界。</p><h4 id="从-string-与范围-for-使用"><a href="#从-string-与范围-for-使用" class="headerlink" title="从 string 与范围 for 使用"></a>从 string 与范围 for 使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string s10 = <span class="string">"hello c++"</span>;</span><br><span class="line"><span class="comment">// 通过范围 for 遍历字符串所有元素，使用常量引用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>&amp; c : s10) {</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过范围 for 和引用遍历字符串所有元素，并更改其元素的值，使用普通引用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : s10) {</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello c++</span><br><span class="line">HELLO C++</span><br></pre></td></tr></tbody></table></figure><h3 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器"></a>vector 容器</h3><h4 id="vector-的概念"><a href="#vector-的概念" class="headerlink" title="vector 的概念"></a>vector 的概念</h4><p>vector 的数据存储以及操作方式，与 Array 非常相似，两者的唯一差别在于空间运用的灵活性。Array 是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎的细节得由自己来实现；首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。Vector 是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此 vector 的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就初始化一个大的 Array 了。Vector 的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦 vector 旧空间满了，如果客户每新增一个元素 vector 内部只是扩充一个元素的空间，实为不智，因为所谓的扩充空间（不论多大），一如刚才所说，是 “配置新空间 - 数据移动 - 释放旧空间” 的大工程，时间成本很高，应该加入某种未雨绸缪的考虑。</p><div class="admonition note"><p class="admonition-title">总结</p><ul><li>vector 是将元素置于一个动态数组中加以管理的容器。</li><li>vector 可以随机存取元素（支持使用索引值直接存取， 用 <code>[]</code> 操作符或 <code>at()</code> 函数。</li><li>vector 尾部添加或移除元素非常快速，但是在头部或中部插入元素或移除元素比较耗时。</li></ul></div><h4 id="vector-的结构"><a href="#vector-的结构" class="headerlink" title="vector 的结构"></a>vector 的结构</h4><p><img data-src="../../../asset/2022/07/cplusplus-vector-1.png"></p><p>vector 底层所采用的数据结构是线性连续空间（单向开口的连续内存空间），可以理解为支持动态开辟内存空间的数组（单向开口）；它以两个迭代器（<code>_Myfirst</code> 和 <code>_Mylast</code>）分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器 <code>_Myend</code> 指向整块连续内存空间的尾端。<strong>vector 往尾部添加或移除元素的效率非常高，但是往头部或者中部插入元素或移除元素则比较耗时。</strong>为了降低空间配置时的速度成本，vector 实际配置的大小可能比客户端需求大一些，以应付将来可能的扩充，这里是容量的概念。换句话说，一个 vector 的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再需要新增元素时，整个 vector 容器就得另觅居所（即扩容）。值得一提的是，所谓动态增加大小，并不是在原空间之后续接新空间（因为无法保证原空间之后尚有可配置的连续空间），而是申请一块更大的内存空间，然后将原数据拷贝到新空间，并释放原空间。因此，对 vector 的任何操作，一旦引起空间的重新配置，指向原 vector 的所有迭代器就都失效了，这是程序最容易出错的地方，务必小心。<strong>特别注意，vector 一旦需要执行扩容操作，那么每次都会以原来空间大小的 2 倍进行扩容。</strong></p><h4 id="vector-的初始化方式"><a href="#vector-的初始化方式" class="headerlink" title="vector 的初始化方式"></a>vector 的初始化方式</h4><ul><li>默认初始化</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空 vector 对象</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br></pre></td></tr></tbody></table></figure><ul><li>指定大小（元素值默认初始化）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指定大小的 vector 对象</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// size = 5，int 全部为 0，结果是：[0, 0, 0, 0, 0]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>指定大小 + 指定初始值</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指定大小的 vector 对象，并指定元素的初始值</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// size = 5，int 全部为 10，结果是：[10, 10, 10, 10, 10]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>列表初始化</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列表初始化，指定 vector 中的元素值</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟上面 v1 的写法效果一样</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空 vector 对象</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v{};</span><br></pre></td></tr></tbody></table></figure><ul><li>拷贝初始化</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// v2 是 v1 的深拷贝</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟上面 v2 的写法效果一样</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3 = v1;</span><br></pre></td></tr></tbody></table></figure><ul><li>移动初始化</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动初始化</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(move(v1))</span></span>;  <span class="comment">// v1 被置为有效但未指定状态，v2 接管内存（高效）</span></span><br></pre></td></tr></tbody></table></figure><ul><li>迭代器范围初始化</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lst = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(lst.begin(), lst.end())</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>从 C 风格数组初始化</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(begin(arr), end(arr))</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>C++ 17 / 20 的编译器自动推导类型</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> v = vector{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">vector 容易混淆的初始化写法</p><ul><li>vector 初始化时，使用括号与花括号，语义完全不同，比如：</li><li><code>vector&lt;int&gt; v(3, 2);</code> 使用圆括号 <code>()</code> 初始化，调用的是 <code>vector(size_type count, const T&amp; value)</code> 构造函数，表示创建一个包含 3 个元素 的 <code>vector</code>，并将每个元素都初始化为 2，因此最终结果为 <code>[2, 2, 2]</code>。</li><li><code>vector&lt;int&gt; v{3, 2};</code> 使用花括号 <code>{}</code> 初始化，优先匹配 <code>vector(initializer_list&lt;T&gt;)</code> 构造函数，表示直接使用初始化列表中的元素进行构造，初始化列表中包含两个元素 3 和 2，因此最终结果为 <code>[3, 2]</code>。</li></ul></div><h4 id="vector-与范围-for-使用"><a href="#vector-与范围-for-使用" class="headerlink" title="vector 与范围 for 使用"></a>vector 与范围 for 使用</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v1 = {<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过范围 for 和引用遍历 vector 所有元素，使用常量引用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> string&amp; item : v1) {</span><br><span class="line">    cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过范围 for 和引用遍历 vector 所有元素，并更改其元素的值，使用普通引用</span></span><br><span class="line"><span class="keyword">for</span> (string&amp; item : v1) {</span><br><span class="line">    item = item + <span class="string">"1"</span>;</span><br><span class="line">    cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a b c </span><br><span class="line">a1 b1 c1</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>在 C++ 中使用范围 <code>for</code> 遍历 vector 时，不应在遍历过程中对容器执行插入或删除元素的操作，否则会导致未定义行为，可能表现为程序崩溃、数据异常或难以复现的内存错误。</li><li>这是因为范围 <code>for</code> 遍历 vector 本质上依赖迭代器，而 vector 在插入或删除元素时可能发生内存重分配（比如扩容）或元素整体移动，导致迭代器失效；遍历过程中继续使用失效的迭代器会产生未定义行为，从而引发崩溃或各种不可预期的内存问题。</li><li>不只是范围 <code>for</code>，任何使用迭代器遍历 vector 的场景，在对 vector 进行结构性修改（插入 / 删除）时都需要格外小心。</li></ul></div><h4 id="vector-与迭代器的使用"><a href="#vector-与迭代器的使用" class="headerlink" title="vector 与迭代器的使用"></a>vector 与迭代器的使用</h4><h5 id="迭代器的概述"><a href="#迭代器的概述" class="headerlink" title="迭代器的概述"></a>迭代器的概述</h5><p><code>vector</code> 提供了多种迭代器类型，用于以不同方式遍历和访问容器元素。其迭代器属于随机访问迭代器（Random Access Iterator），支持 <code>++</code>、<code>--</code>、<code>+n</code>、<code>-n</code>、<code>[]</code> 下标访问等操作，效率与指针相当。</p><div class="admonition warning"><p class="admonition-title">迭代器的使用注意事项</p><ul><li><code>vector</code> 的迭代器，本质上类似指针，内部通常就是原始指针或指针封装。</li><li>往 <code>vector</code> 插入、删除元素（尤其是触发扩容时）会导致迭代器失效。</li><li>范围 <code>for</code>、STL 算法（如 <code>std::find()</code>、<code>std::sort()</code>）底层都依赖迭代器来实现。</li><li>使用范围 <code>for</code> 遍历 <code>vector</code> 时，不应在遍历过程中对容器执行插入或删除元素的操作，否则会导致未定义行为，从而引发崩溃或各种不可预期的内存问题。</li></ul></div><h5 id="迭代器的类型"><a href="#迭代器的类型" class="headerlink" title="迭代器的类型"></a>迭代器的类型</h5><p>vector 容器的迭代器有四种类型：</p><ul><li><code>iterator</code>：普通正向迭代器</li><li><code>const_iterator</code>：只读正向迭代器</li><li><code>reverse_iterator</code>：普通反向迭代器（逆序）</li><li><code>const_reverse_iterator</code>：只读反向迭代器（逆序）</li></ul><hr><ul><li><p><code>vector&lt;string&gt;::iterator</code></p><ul><li>普通正向迭代器</li><li>从第一个元素遍历到最后一个元素</li><li>允许修改元素内容<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v = {<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;string&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    *it = <span class="string">"x"</span>;   <span class="comment">// 可以修改元素值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><code>vector&lt;string&gt;::const_iterator</code></p><ul><li>只读正向迭代器</li><li>不能通过迭代器修改元素的值</li><li>常用于只读遍历，提升代码语义安全性<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v = {<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;string&gt;::const_iterator it = v.<span class="built_in">cbegin</span>(); it != v.<span class="built_in">cend</span>(); ++it) {</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><p><img data-src="../../../asset/2025/12/cplusplus-iterator-1.png"></p><ul><li><p><code>vector&lt;string&gt;::reverse_iterator</code></p><ul><li>普通反向迭代器</li><li>从最后一个元素遍历到第一个元素</li><li>允许修改元素内容</li><li>底层仍基于普通迭代器实现<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v = {<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;string&gt;::reverse_iterator it = v.<span class="built_in">rbegin</span>(); it != v.<span class="built_in">rend</span>(); ++it) {</span><br><span class="line">    *it = <span class="string">"x"</span>;   <span class="comment">// 可以修改元素值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><code>vector&lt;string&gt;::const_reverse_iterator</code></p><ul><li>只读反向迭代器</li><li>不能通过迭代器修改元素的值</li><li>常用于反向只读访问<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v = {<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;string&gt;::const_reverse_iterator it = v.<span class="built_in">crbegin</span>(); it != v.<span class="built_in">crend</span>(); ++it) {</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><p><img data-src="../../../asset/2025/12/cplusplus-iterator-2.png"></p><h5 id="迭代器的操作"><a href="#迭代器的操作" class="headerlink" title="迭代器的操作"></a>迭代器的操作</h5><p>vector 的迭代器属于随机访问迭代器（Random Access Iterator），支持 <code>++</code>、<code>--</code>、<code>+n</code>、<code>-n</code>、<code>[]</code> 下标访问等操作，效率与指针相当。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v1 = {<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>};</span><br><span class="line">vector&lt;string&gt;::iterator it = v1.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器支持 * 操作</span></span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器支持 [] 操作</span></span><br><span class="line">cout &lt;&lt; it[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器支持 ++ 操作</span></span><br><span class="line">++it;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器支持 -- 操作</span></span><br><span class="line">--it;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></tbody></table></figure><h5 id="迭代器的失效"><a href="#迭代器的失效" class="headerlink" title="迭代器的失效"></a>迭代器的失效</h5><p>迭代器失效是指：在使用容器迭代器的过程中，由于对容器进行了结构性修改（如调用容器的 <code>erase()</code>、<code>insert()</code>、<code>push_back()</code>、<code>resize()</code>、<code>clear()</code> 等成员函数），导致原本指向容器元素的迭代器不再指向有效元素或合法位置，此时继续使用该迭代器会产生未定义行为。因此，修改容器后必须确认迭代器是否仍然有效，必要时重新获取或使用返回的新迭代器。</p><ul><li>错误示例一：范围 <code>for</code> 中删除 vector 的元素</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一边遍历 vector，一边删除元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : v) {</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">3</span>) {</span><br><span class="line">        v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());  <span class="comment">// 错误写法：范围 for 内部迭代器失效，会导致未定义行为</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>错误示例二：遍历 vector 时删除元素（迭代器失效）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一边遍历 vector，一边删除元素</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>(); it != v1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">        v1.<span class="built_in">erase</span>(it);   <span class="comment">// 错误写法：erase() 调用后会导致当前位置及其后的迭代器全部失效，后续 ++it 操作的是失效迭代器，属于未定义行为</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>错误示例三：遍历 vector 时插入元素（迭代器失效）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一边遍历 vector，一边插入元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) {</span><br><span class="line">        v.<span class="built_in">insert</span>(it, <span class="number">100</span>);   <span class="comment">// 错误写法：可能触发扩容，导致迭代器 it 失效</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><ul><li>正确示例一：使用 <code>erase()</code> 的返回值继续遍历</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一边遍历 vector，一边删除元素</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>(); it != v1.<span class="built_in">end</span>();) {</span><br><span class="line">    <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">        it = v1.<span class="built_in">erase</span>(it);  <span class="comment">// 正确写法：使用 erase() 返回的新迭代器，erase() 返回指向被删除元素下一个位置的有效迭代器</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ++it;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>正确示例二：使用 <code>erase()</code> + <code>remove_if()</code>，避免遍历时删除</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法：先用算法调整元素，再统一 erase()，避免遍历过程中修改容器</span></span><br><span class="line"><span class="comment">// remove_if() 算法负责把不需要的元素移动到容器末尾，并返回新的逻辑结尾；erase() 再把这段无效区间真正删除，这样可以避免在遍历过程中修改容器</span></span><br><span class="line">v1.<span class="built_in">erase</span>(</span><br><span class="line">    <span class="built_in">remove_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(),</span><br><span class="line">                [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; }),</span><br><span class="line">    v1.<span class="built_in">end</span>()</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><ul><li>正确示例三：使用 <code>insert()</code> 的返回值继续遍历</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一边遍历 vector，一边插入元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v1.<span class="built_in">begin</span>(); it != v1.<span class="built_in">end</span>();) {</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) {</span><br><span class="line">        it = v1.<span class="built_in">insert</span>(it, <span class="number">100</span>);  <span class="comment">// 正确写法：使用 insert() 返回的新迭代器</span></span><br><span class="line">        it += <span class="number">2</span>;                  <span class="comment">// 跳过原元素和新插入的元素</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ++it;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>正确示例四：不在遍历时插入</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : v) {</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) {</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">    result.<span class="built_in">push_back</span>(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">swap</span>(result);</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">总结</p><ul><li>C++ 中迭代器失效是指在容器发生结构性修改后，原有迭代器不再指向有效元素，继续使用失效的迭代器会导致未定义行为，正确做法是使用 <code>erase()</code>、<code>insert()</code> 的返回值或避免在遍历过程中修改（插入 / 删除）容器。</li><li>由于范围 <code>for</code> 遍历 vector 本质上依赖迭代器，因此使用范围 <code>for</code> 遍历 <code>vector</code> 时，不应在遍历过程中对容器执行插入或删除元素的操作，否则会导致未定义行为，从而引发崩溃或各种不可预期的内存问题。</li></ul></div><table><thead><tr><th>容器类型</th><th>内存结构</th><th><code>insert()</code> 导致的迭代器失效</th><th><code>erase()</code> 导致的迭代器失效</th><th>推荐写法</th><th>说明</th></tr></thead><tbody><tr><td> vector</td><td> 连续内存</td><td>⚠️ 发生扩容时：所有迭代器、指针、引用全部失效<br>⚠️ 未扩容时：插入点及其后的迭代器失效</td><td>⚠️ 被删位置及其后的迭代器全部失效</td><td><code>it = v.erase(it)</code><br><code>erase() + remove_if()</code></td><td>连续内存，插入 / 删除需要移动元素，是迭代器最容易失效的容器。</td></tr><tr><td>deque</td><td> 分段连续</td><td>⚠️ 可能导致所有迭代器失效<br>⚠️ C++ 标准未保证稳定性，尤其是中间插入</td><td>⚠️ 可能导致所有迭代器失效</td><td>尽量只在头尾两端操作</td><td>分段连续结构，迭代器稳定性差，不要依赖 deque 的迭代器长期有效。</td></tr><tr><td>list</td><td> 双向链表</td><td>✅ 插入不使任何已有迭代器失效</td><td>✅ 仅被删除元素的迭代器失效</td><td><code>list::insert()</code><br><code>list::remove_if()</code></td><td>节点独立，插入删除只改指针，迭代器最稳定。</td></tr><tr><td>map / set</td><td> 红黑树</td><td>✅ 插入不使任何已有迭代器失效</td><td>✅ 仅被删除元素的迭代器失效</td><td><code>it = m.erase(it)</code></td><td>树结构保持节点稳定，删除时必须接收返回迭代器继续遍历。</td></tr></tbody></table><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/9ce17bf9.html" title="C++ 杂记之三从基础到进阶">https://www.techgrow.cn/posts/9ce17bf9.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/1b2af7f9.html" rel="prev" title="SpringBoot 3 进阶教程之一整合 Prometheus 与 Grafana"><i class="fa fa-angle-left"></i> SpringBoot 3 进阶教程之一整合 Prometheus 与 Grafana</a></div><div class="post-nav-item"> <a href="/posts/d09e2a40.html" rel="next" title="GitHub 开发随笔">GitHub 开发随笔<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2026</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.4m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">35:49</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"/lib/mathjax/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/9ce17bf9.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div><div id="moon-menu-item-code" class="moon-menu-item"><i class="fa-solid fa-code"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>