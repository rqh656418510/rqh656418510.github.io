<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 从基础到进阶的内容。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 杂记之二从基础到进阶"><meta property="og:url" content="https://www.techgrow.cn/posts/68a580cf.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 从基础到进阶的内容。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-08-16T13:55:33.000Z"><meta property="article:modified_time" content="2023-08-16T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.techgrow.cn/posts/68a580cf.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/68a580cf.html","path":"posts/68a580cf.html","title":"C++ 杂记之二从基础到进阶"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 杂记之二从基础到进阶 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script>
  (function () {

  // 防止 Pjax 重复绑定事件
  if (window.__moonMenuCodeExpandBound) {
    return;
  }
  window.__moonMenuCodeExpandBound = true;

  const STORAGE_KEY = 'moon_menu_code_fold';

  /* ===============================
   * 1. 设置 moon-menu 按钮的 title
   * =============================== */
  (function bindMoonMenuTitles() {
    const items = [
      { selector: '#moon-menu-item-code',        title: '展开 / 折叠代码块' },
      { selector: '#moon-menu-item-back2top',    title: '回到页面顶部' },
      { selector: '#moon-menu-item-back2bottom', title: '回到页面底部' }
    ];

    let allReady = true;

    items.forEach(item => {
      const el = document.querySelector(item.selector);
      if (!el) {
        allReady = false;
        return;
      }
      el.setAttribute('title', item.title);
    });

    if (!allReady) {
      setTimeout(bindMoonMenuTitles, 100);
    }
  })();

  /* =================================
   * 2. 页面首次加载：代码块恢复展开或折叠状态
   * ================================= */
  function applyStoredCodeState() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    const state = localStorage.getItem(STORAGE_KEY);
    if (!state) {
      return;
    }

    containers.forEach(container => {
      if (state === 'expanded') {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else if (state === 'folded') {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });
  }

  // 等代码块出现后，再恢复展开或折叠状态
  function waitAndApplyState() {
    const containers = document.querySelectorAll('.code-container');

    if (!containers.length) {
      setTimeout(waitAndApplyState, 100);
      return;
    }

    applyStoredCodeState();
  }

  // 页面首次加载时恢复状态
  waitAndApplyState();
  
  // Pjax 切换页面后，必须重新恢复状态
  document.addEventListener('pjax:complete', function () {
    waitAndApplyState();
  });

  /* ===============================
   * 3. 点击按钮：切换状态并保存
   * =============================== */
  document.addEventListener('click', function (e) {
    const codeMenu = e.target.closest('#moon-menu-item-code');
    if (!codeMenu) {
      return;
    }

    toggleAllCodeBlocks();
  });

  // 展开或折叠代码块
  function toggleAllCodeBlocks() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    // 只要存在折叠的代码块，就认为当前是折叠状态
    const hasFolded = Array.from(containers).some(c => {
      return c.classList.contains('highlight-fold');
    });

    containers.forEach(container => {
      if (hasFolded) {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });

    // 记录展开或折叠状态
    localStorage.setItem(
      STORAGE_KEY,
      hasFolded ? 'expanded' : 'folded'
    );
  }

})();
</script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">结构体的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">C 的结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93-1"><span class="nav-text">C++ 的结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E4%B8%8E-C-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C 与 C++ 结构体的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">结构体的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%80%BC%E5%BD%A2%E5%8F%82"><span class="nav-text">结构体作为值形参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82"><span class="nav-text">结构体作为引用形参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E4%BD%93%E4%BD%9C%E4%B8%BA%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82"><span class="nav-text">结果体作为指针形参</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7"><span class="nav-text">函数特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-text">未命名参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-text">后置返回类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9D%82%E5%90%88%E7%94%A8%E6%B3%95"><span class="nav-text">函数杂合用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E-void-%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">返回 void 的表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95"><span class="nav-text">其他常见的函数用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">类型转换的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-text">类型转换的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">类型转换的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">const 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E9%92%88%E5%AF%B9%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%8D%E5%90%8C%E5%86%99%E6%B3%95"><span class="nav-text">const 针对指针的不同写法</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">788</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/68a580cf.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 杂记之二从基础到进阶 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 从基础到进阶的内容。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 杂记之二从基础到进阶</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-08-16 21:55:33" itemprop="dateCreated datePublished" datetime="2023-08-16T21:55:33+08:00">2023-08-16</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/68a580cf.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/68a580cf.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5.7k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>5 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/332ad818.html">C++ 杂记之一从基础到进阶</a>、<a href="/posts/68a580cf.html">C++ 杂记之二从基础到进阶</a>、<a href="/posts/9ce17bf9.html">C++ 杂记之三从基础到进阶</a></li><li><a href="/posts/d198d85d.html">C++ 杂记之四从基础到进阶</a></li></ul><span id="more"></span><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体的概念"><a href="#结构体的概念" class="headerlink" title="结构体的概念"></a>结构体的概念</h3><h4 id="C-的结构体"><a href="#C-的结构体" class="headerlink" title="C 的结构体"></a>C 的结构体</h4><p>在 C 语言中，结构体主要用于将多个不同类型的数据组合成一个整体，属于纯数据封装，不支持面向对象特性。</p><ul><li>基础语法</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> {<span class="string">"Tom"</span>, <span class="number">18</span>, <span class="number">95</span>};</span><br></pre></td></tr></tbody></table></figure><ul><li>在 C 语言中，关键点是：<ul><li>结构体里只能包含成员变量，不能有函数。</li><li>结构体定义出来后，声明变量时通常需要写 <code>struct</code> 关键字。</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span>;</span> <span class="comment">// 声明变量时必须带 struct 关键字</span></span><br></pre></td></tr></tbody></table></figure><ul><li>除非使用 <code>typedef</code> 关键字进行简化</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">} Student;</span><br><span class="line"></span><br><span class="line">Student s1; <span class="comment">// 可以直接使用</span></span><br></pre></td></tr></tbody></table></figure><h4 id="C-的结构体-1"><a href="#C-的结构体-1" class="headerlink" title="C++ 的结构体"></a>C++ 的结构体</h4><p>在 C++ 中，结构体进行了大幅增强，功能上与类（<code>class</code>）几乎完全等价，只是默认的访问控制权限不同而已。C++ 中的结构体支持面向对象特性，可以包含以下内容：</p><ul><li>成员变量</li><li>成员函数</li><li>构造函数 / 析构函数</li><li>访问控制符（<code>public</code>、<code>protected</code>、<code>private</code>）</li><li>继承、多态、虚函数</li><li>模板</li></ul><hr><ul><li>基础语法</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(string n, <span class="keyword">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; name &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Student <span class="title">s</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>C++ 中结构体与类的区别</li></ul><table><thead><tr><th>特性</th><th> C++ 的 <code>struct</code>（结构体）</th><th>C++ 的 <code>class</code>（类）</th></tr></thead><tbody><tr><td>默认成员访问权限</td><td><code>public</code></td><td><code>private</code></td></tr><tr><td>默认继承方式</td><td>公有继承（<code>public</code>）</td><td>私有继承（<code>private</code>）</td></tr><tr><td>其他特性</td><td>几乎完全相同</td><td>几乎完全相同</td></tr></tbody></table><h4 id="C-与-C-结构体的区别"><a href="#C-与-C-结构体的区别" class="headerlink" title="C 与 C++ 结构体的区别"></a>C 与 C++ 结构体的区别</h4><table><thead><tr><th>对比项</th><th> C 语言的结构体</th><th> C++ 的结构体</th></tr></thead><tbody><tr><td>功能定位</td><td>仅数据集合（面向过程）</td><td>完整对象（面向对象）</td></tr><tr><td>成员</td><td>只能有变量，不能有函数</td><td>可以有变量、函数、构造函数、析构函数、继承、虚函数、模板等</td></tr><tr><td>访问控制符</td><td>不支持</td><td>支持 <code>public</code> / <code>protected</code> / <code>private</code></td></tr><tr><td>继承</td><td>不支持</td><td>支持继承</td></tr><tr><td>多态</td><td>不支持</td><td>支持（虚函数）</td></tr><tr><td>默认访问权限</td><td>全部 <code>public</code></td><td>默认 <code>public</code></td></tr><tr><td><code>typedef</code> 简化</td><td>定义后不可以直接使用，需要 <code>typedef</code> 才能省略 <code>struct</code> 关键字</td><td>定义后可以直接使用，无需 <code>typedef</code> 就可以省略 <code>struct</code> 关键字</td></tr><tr><td>用途</td><td>数据封装</td><td>既能封装数据，也能封装行为</td></tr></tbody></table><h3 id="结构体的使用"><a href="#结构体的使用" class="headerlink" title="结构体的使用"></a>结构体的使用</h3><p>本节将演示 C++ 中如何使用结果体，不再涉及 C 语言的结构体。</p><h4 id="结构体作为值形参"><a href="#结构体作为值形参" class="headerlink" title="结构体作为值形参"></a>结构体作为值形参</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> {</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"id = "</span> &lt;&lt; id &lt;&lt; <span class="string">", name = "</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体作为值形参（效率低，会发生数据拷贝）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(student stu)</span> </span>{</span><br><span class="line">    stu.id = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu.name, <span class="string">"Jim"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    student student1;</span><br><span class="line">    student1.id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(student1.name, <span class="string">"Peter"</span>);</span><br><span class="line">    student1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(student1);</span><br><span class="line">    student1.<span class="built_in">show</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id = 1, name = Peter</span><br><span class="line">id = 1, name = Peter</span><br></pre></td></tr></tbody></table></figure><h4 id="结构体作为引用形参"><a href="#结构体作为引用形参" class="headerlink" title="结构体作为引用形参"></a>结构体作为引用形参</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> {</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"id = "</span> &lt;&lt; id &lt;&lt; <span class="string">", name = "</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体作为引用形参（效率高，不会发生数据拷贝）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(student &amp;stu)</span> </span>{</span><br><span class="line">    stu.id = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu.name, <span class="string">"Jim"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    student student1;</span><br><span class="line">    student1.id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(student1.name, <span class="string">"Peter"</span>);</span><br><span class="line">    student1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(student1);</span><br><span class="line">    student1.<span class="built_in">show</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id = 1, name = Peter</span><br><span class="line">id = 2, name = Jim</span><br></pre></td></tr></tbody></table></figure><h4 id="结果体作为指针形参"><a href="#结果体作为指针形参" class="headerlink" title="结果体作为指针形参"></a>结果体作为指针形参</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> {</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"id = "</span> &lt;&lt; id &lt;&lt; <span class="string">", name = "</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体作为指针形参（效率高，不会发生数据拷贝）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(student *stu)</span> </span>{</span><br><span class="line">    stu-&gt;id = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu-&gt;name, <span class="string">"Jim"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    student student1;</span><br><span class="line">    student1.id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(student1.name, <span class="string">"Peter"</span>);</span><br><span class="line">    student1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(&amp;student1);</span><br><span class="line">    student1.<span class="built_in">show</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id = 1, name = Peter</span><br><span class="line">id = 2, name = Jim</span><br></pre></td></tr></tbody></table></figure><h2 id="函数特性"><a href="#函数特性" class="headerlink" title="函数特性"></a>函数特性</h2><table><thead><tr><th>函数特性</th><th> C++ 标准</th><th>说明</th></tr></thead><tbody><tr><td>内联函数（Inline Function）</td><td>C++ 98</td><td><code>inline</code> 用于提示编译器将函数展开；类内定义的成员函数默认 <code>inline</code>。</td></tr><tr><td>未命名参数（Unnamed Parameter）</td><td>C++ 98</td><td> 参数可以只写类型不写名称，但函数体中无法使用该参数；常用于函数声明或不使用某参数的场景。</td></tr><tr><td>后置返回类型（Trailing Return Type）</td><td>C++ 11</td><td> 使用 <code>auto func(...) -&gt; type</code> 语法，使返回类型可以依赖参数类型，尤其适用于模板和复杂类型。</td></tr><tr><td>返回 void 的表达式形式（return void_expression）</td><td>C++ 17</td><td> 允许 <code>return func();</code>，其中 <code>func()</code> 返回 <code>void</code>；C++ 17 才允许 <code>return</code> 语句中含 <code>void</code> 表达式。</td></tr></tbody></table><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><ul><li><p>内联函数的概述：</p><ul><li>定义：<ul><li>内联函数是提示编译器将函数调用直接展开到调用处的函数，而不是通过函数调用机制（压栈、跳转等）执行。</li></ul></li><li>作用：<ul><li>减少函数调用开销，提高性能（尤其是小函数、频繁调用的函数）。</li><li>便于在头文件中定义函数，实现模板和类成员函数的编译。</li></ul></li><li>注意：<ul><li><strong><code>inline</code> 是只是给编译器建议（不是强制内联），是否采用该建议由编译器决定，编译器可能会忽略建议。</strong></li><li><strong><code>inline</code> 不适合大函数，否则可能会导致代码膨胀。</strong></li><li><strong>在类内定义的成员函数，默认都是内联函数。</strong></li></ul></li></ul></li><li><p>内联函数的语法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> 返回类型 函数名(参数列表) {</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>内联函数的使用示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 调用 add() 函数时，编译器可能会直接将 return a+b; 展开</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>内联函数的适用场景：</p><ul><li>(1) 小型、简单的函数<ul><li>例如 Getter/Setter、数学小函数：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ </span><br><span class="line">    <span class="keyword">return</span> x - x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>(2) 类的成员函数<ul><li>在类内定义的成员函数，默认都是内联函数：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>{ <span class="keyword">return</span> x; } <span class="comment">// 默认 inline</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>{ <span class="keyword">return</span> y; } <span class="comment">// 默认 inline</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>(3) 模板函数<ul><li>模板函数和或静态成员函数通常在头文件中定义，结合 <code>inline</code> 可以避免重复定义的链接错误：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>内联函数的优缺点：</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>减少函数调用开销</td><td>可能导致代码膨胀，增大可执行文件</td></tr><tr><td>适合小函数、频繁调用</td><td>大函数不适合使用 <code>inline</code>，会导致代码膨胀</td></tr><tr><td>便于在头文件中定义函数</td><td>不是强制内联，编译器可能忽略</td></tr></tbody></table></li></ul><div class="admonition note"><p class="admonition-title">C++ 11 的增强</p><p>在 C++ 11 中，增加了 <code>inline</code> 和 <code>constexpr</code>、模板、类静态成员函数的结合用法，核心作用是减少函数调用开销、便于在头文件中定义小函数。值得一提的是，<code>constexpr</code> 可以看成是一种更严格的内联函数。</p></div><h3 id="未命名参数"><a href="#未命名参数" class="headerlink" title="未命名参数"></a>未命名参数</h3><ul><li><p>未命名参数（也称为省略参数名）的概述：</p><ul><li>函数声明时，可以只有形参类型，没有形参名称。</li><li>比如：<code>int func(int a, int);</code>。</li><li>第一个参数 <code>int a</code> 有名称，可以在函数体中使用。</li><li>第二个参数只有类型 <code>int</code>，没有名称，所以在函数体中无法访问这个参数。</li><li>未命名参数不等于默认参数，因此在调用上面的函数时，必须传入两个参数。</li></ul></li><li><p>未命名参数的常见用途：</p><ul><li>回调或接口函数中，暂时不使用某个参数：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a * <span class="number">2</span>; <span class="comment">// 第二个参数暂时不使用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>声明函数而不定义时：通常在头文件里只给类型，名称可省略：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span></span>; <span class="comment">// 只声明，不需要第二个参数名</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>未命名参数的注意事项：</p><ul><li><strong>在函数声明中省略参数名是合法的。</strong></li><li><strong>在函数定义中省略参数名也是合法的，但函数体内无法访问该参数。</strong></li><li><strong>未命名参数不等于默认参数，没有默认值的参数即使未命名，也必须在调用时提供。</strong></li></ul></li></ul><h3 id="后置返回类型"><a href="#后置返回类型" class="headerlink" title="后置返回类型"></a>后置返回类型</h3><ul><li><p>后置返回类型的语法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(参数列表)</span> -&gt; 返回类型</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>后置返回类型的使用示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> -&gt; <span class="keyword">int</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> -&gt; <span class="keyword">int</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>auto</code> 出现在函数名前，表示编译器需要看 <code>-&gt;</code> 后面的类型。</li><li><code>-&gt; int</code> 表示函数返回 <code>int</code> 类型。</li><li>函数调用方式与普通函数一样：<code>func(1, 2)</code>。</li></ul></li><li><p>后置返回类型的用途：</p><ul><li>(1) 适合函数声明和函数定义分离<ul><li>传统写法有时类型太复杂：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">func</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br></pre></td></tr></tbody></table></figure></li><li>用后置返回类型更清晰：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> -&gt; std::map&lt;std::string, std::vector&lt;<span class="keyword">int</span>&gt;&gt;</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>(2) 解决依赖于模板参数或复杂类型的问题<ul><li>在模板或泛型函数中，返回类型可能依赖于参数类型：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T a, U b)</span> -&gt; <span class="title">decltype</span><span class="params">(a + b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><code>decltype(a + b)</code> 会根据输入类型自动推导返回类型。</li><li>如果用传统方式定义函数：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, U b)</span></span>; <span class="comment">// 无法直接这样写，因为返回类型依赖参数类型</span></span><br></pre></td></tr></tbody></table></figure></li><li>编译会报错，因为返回类型在参数类型声明之前无法确定。</li><li>后置返回类型解决了返回类型依赖参数类型的问题。</li></ul></li><li>(3) 与 <code>auto</code> 结合，支持更灵活的类型推导<ul><li>后置返回类型和 <code>auto</code> 可以结合使用，让函数返回类型延迟到函数体或参数类型确定之后。</li><li>这对模板和泛型编程非常有用。</li></ul></li></ul></li><li><p>后置返回类型的注意事项：</p><ul><li>不是必须的，普通函数仍然可以用传统写法。</li><li>不影响函数调用语法，调用时与普通函数一致。</li><li>主要在返回类型依赖参数类型或者模板参数的情况下使用。</li></ul></li></ul><h3 id="函数杂合用法"><a href="#函数杂合用法" class="headerlink" title="函数杂合用法"></a>函数杂合用法</h3><h4 id="返回-void-的表达式"><a href="#返回-void-的表达式" class="headerlink" title="返回 void 的表达式"></a>返回 void 的表达式</h4><ul><li><p>概述和语法：</p><ul><li>C++ 17 引入了允许 <code>return void_expression;</code> 的特性，也称为 <code>void return expression</code> 或 <code>返回 void 的表达式</code>。</li><li>在 C++ 17 之前，<code>return expr;</code> 中的 <code>expr</code> 不能是 <code>void</code>。</li><li>从 C++ 17 开始，可以这样写：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func1</span>(); <span class="comment">// func1() 返回 void，可以直接 return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>作用和意义：</p><ul><li>允许直接返回 <code>void</code> 表达式，写法更一致、简洁。</li><li>等价于：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>语义上没有额外效果，只是语法糖，方便模板编程或统一返回写法。</li></ul></li><li><p>注意事项：</p><ul><li>函数返回类型必须是 <code>void</code>。</li><li>不能用在有非 <code>void</code> 返回值的函数中，比如：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func3</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func1</span>(); <span class="comment">// 错误写法：因为 func1() 是 void</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="其他常见的函数用法"><a href="#其他常见的函数用法" class="headerlink" title="其他常见的函数用法"></a>其他常见的函数用法</h4><ul><li><p>(1) 没有形参的函数，可以使用以下两种等价写法进行声明：</p><ul><li><code>int func();</code></li><li><code>int func(void);</code></li><li>两者在 C++ 中的含义相同，均表示 “无参数函数”。</li></ul></li><li><p>(2) 如果一个函数从未被调用，则它可以只有声明而没有定义，编译和链接都不会报错。但是，如果函数被调用，则必须提供函数定义，否则会产生链接错误。</p></li><li><p>(3) 普通函数可以被声明多次（通常放在 <code>.h</code> 头文件中），但函数定义只能出现一次（通常放在对应的 <code>.cpp</code> 文件中）；多次定义同一个函数将导致链接阶段出现 <code>multiple definition</code> 错误。</p></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="类型转换的分类"><a href="#类型转换的分类" class="headerlink" title="类型转换的分类"></a>类型转换的分类</h3><p>在 C++ 中，类型转换分为隐式类型转换和显式类型转换，其中显式类型转换有以下 4 种类型：</p><ul><li><p><code>static_cast</code>：</p><ul><li>静态类型转换，用于如 <code>int</code> 转换成 <code>char</code>。</li><li><code>static_cast</code> 在编译期进行类型检查，只保证转换合法性，不保证运行时安全性。</li><li><code>static_cast</code> 可以用于类层次结构中基类（父类）和派生类（子类）之间指针或者引用的转换。<ul><li>进行上行转换（将派生类的指针或者引用转换成基类表示）是安全的。</li><li>进行下行转换（将基类的指针或者引用转换成派生类表示），由于没有运行时的动态类型检查，所以是不安全的。</li></ul></li><li><code>static_cast</code> 可以用于基本数据类型之间的转换，比如将 <code>int</code> 转化成 <code>char</code>，或者将 <code>char</code> 转换成 <code>int</code>，这种类型转换的安全性需要开发人员来保证。</li><li><strong><code>static_cast</code> 只能用于存在类型关系的指针转换（比如继承层次或 <code>void *</code>），不能用于无关类型指针之间的转换（比如 <code>int *</code> 转换为 <code>dubbo *</code>，或者 <code>float *</code> 转换为 <code>dubbo *</code>）。</strong></li></ul></li><li><p><code>dynamic_cast</code>：</p><ul><li>动态类型转换，用于如父类和子类之间的多态类型转换。</li><li><code>dynamic_cast</code> 在运行期会基于 RTTI 进行类型检查，但只能用于多态类型（存在虚函数的继承体系中），能保证下行转换的安全性。</li><li><code>dynamic_cast</code> 可以用于类层次结构中的上行转换和下行转换，但是不支持基本数据类型的转换。</li><li>在类层次结构中进行上行转换（将派生类的指针或者引用转换成基类表示）时，<code>dynamic_cast</code> 与 <code>static_cast</code> 的效果一样。</li><li>在类层次结构中进行下行转换（将基类的指针或者引用转换成派生类表示）时，<code>dynamic_cast</code> 具有运行时类型检查的功能，比 <code>static_cast</code> 更安全。</li></ul></li><li><p><code>const_cast</code>：</p><ul><li>常量类型转换，用于赋予或者去除类型的 <code>const</code> 只读属性。</li><li>常量指针被转换成非常量指针后，仍然指向原来的对象，反之亦然。</li><li>常量引用被转换成非常量引用后，仍然指向原来的对象，反之亦然。</li><li><strong>不能直接对非指针和非引用的类型使用 <code>const_cast</code> 操作符去直接赋予或者去除它的 <code>const</code> 只读属性。</strong></li></ul></li><li><p><code>reinterpreter_cast</code>：</p><ul><li>重新解释类型（强制类型转换）</li><li><code>reinterpret_cast</code> 用于不同类型之间进行强制类型转换，这是最不安全的一种类型转换机制，最可能出现问题，极少使用，极其危险。</li><li><code>reinterpret_cast</code> 可以将一种数据类型强制转换成另一种数据类型，比如可以将一个指针转换成整数，也可以将整数转换成指针。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 C++ 的四种显式类型转换中，<code>static_cast</code> 和 <code>const_cast</code> 会在编译期进行类型检查；<code>reinterpret_cast</code> 仅在编译期会做最基本的语法检查，不进行类型安全检查；<code>dynamic_cast</code> 会在运行期基于 RTTI 进行类型检查（仅适用于多态类型）。</p></div><h3 id="类型转换的语法"><a href="#类型转换的语法" class="headerlink" title="类型转换的语法"></a>类型转换的语法</h3><ul><li><p>C 语言风格的强制类型转换（Type Cast）很简单，不管什么类型的转换，语法都是：<code>TYPE b = (TYPE) a</code></p></li><li><p>C++ 风格的显式类型转换，提供了 4 种显式类型转换操作符来应对不同的应用场景</p><ul><li><code>TYPE b = const_cast&lt;TYPE&gt; (a)</code></li><li><code>TYPE b = static_cast&lt;TYPE&gt; (a)</code></li><li><code>TYPE b = dynamic_cast&lt;TYPE&gt; (a)</code></li><li><code>TYPE b = reinterpreter_cast&lt;TYPE&gt; (a)</code></li></ul></li></ul><h3 id="类型转换的使用"><a href="#类型转换的使用" class="headerlink" title="类型转换的使用"></a>类型转换的使用</h3><ul><li>基类和派生类（包含虚函数）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Father</span>(string name, <span class="keyword">int</span> age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">"name = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">", age = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Father {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>(string name, <span class="keyword">int</span> age, string hobby) : <span class="built_in">Father</span>(name, age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_hobby = hobby;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">"name = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">", age = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="string">", hobby = "</span> &lt;&lt; m_hobby &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_hobby;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>隐式类型转换</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">3</span> + <span class="number">35.63</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"m = "</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>显式类型转换 - <code>static_cast</code>（静态类型转换）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">5</span> % <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3.2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"k = "</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line">    <span class="keyword">void</span> *q = p; <span class="comment">// void * 可以指向任何指针类型（也称为万能指针）</span></span><br><span class="line">    <span class="keyword">int</span> *n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(q);</span><br><span class="line"></span><br><span class="line">    <span class="function">Father <span class="title">father</span><span class="params">(<span class="string">"Father"</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    <span class="function">Son <span class="title">son</span><span class="params">(<span class="string">"Son"</span>, <span class="number">25</span>, <span class="string">"Game"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上行转换（将派生类的指针转换成基类表示），是安全的</span></span><br><span class="line">    Son *son1 = <span class="keyword">new</span> <span class="built_in">Son</span>(<span class="string">"Son"</span>, <span class="number">25</span>, <span class="string">"Game"</span>);</span><br><span class="line">    Father *father1 = <span class="keyword">static_cast</span>&lt;Father *&gt;(son1);</span><br><span class="line">    father1-&gt;<span class="built_in">print</span>();   <span class="comment">// 发生多态，调用派生类的 print() 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下行转换（将基类的指针转换成派生类表示），是不安全的（编译通过，但运行可能出错）</span></span><br><span class="line">    Father *father2 = <span class="keyword">new</span> <span class="built_in">Father</span>(<span class="string">"Father"</span>, <span class="number">60</span>);</span><br><span class="line">    Son *son2 = <span class="keyword">static_cast</span>&lt;Son *&gt;(father2);</span><br><span class="line">    son2-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用基类的 print() 函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>显式类型转换 - <code>dynamic_cast</code>（动态类型转换）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Father <span class="title">father</span><span class="params">(<span class="string">"Father"</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    <span class="function">Son <span class="title">son</span><span class="params">(<span class="string">"Son"</span>, <span class="number">25</span>, <span class="string">"Game"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上行转换（将派生类的引用转换成基类表示），是安全的</span></span><br><span class="line">    Father &amp;father1 = <span class="keyword">dynamic_cast</span>&lt;Father &amp;&gt;(son);</span><br><span class="line">    father1.<span class="built_in">print</span>(); <span class="comment">// 发生多态，调用派生类的 print() 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下行转换（将基类的引用转换成派生类表示），是不安全的，无法进行类型转换（编译通过，但运行可能出错）</span></span><br><span class="line">    <span class="comment">// Son &amp;son2 = dynamic_cast&lt;Son &amp;&gt;(father);</span></span><br><span class="line">    <span class="comment">// son2.print();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上行转换（将派生类的指针转换成基类表示），是安全的</span></span><br><span class="line">    Son *son1 = <span class="keyword">new</span> <span class="built_in">Son</span>(<span class="string">"Son"</span>, <span class="number">25</span>, <span class="string">"Game"</span>);</span><br><span class="line">    Father *father2 = <span class="keyword">dynamic_cast</span>&lt;Father *&gt;(son1);</span><br><span class="line">    father2-&gt;<span class="built_in">print</span>(); <span class="comment">// 发生多态，调用派生类的 print() 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下行转换（将基类的指针转换成派生类表示），是不安全的，无法进行类型转换（编译通过，但运行可能出错）</span></span><br><span class="line">    Father *father3 = <span class="keyword">new</span> <span class="built_in">Father</span>(<span class="string">"Father"</span>, <span class="number">60</span>);</span><br><span class="line">    <span class="comment">// Son *son2 = dynamic_cast&lt;Son *&gt;(father2);</span></span><br><span class="line">    <span class="comment">// son2-&gt;print();</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>显式类型转换 - <code>const_cast</code>（常量类型转换）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 常量指针被转换成非常量指针</span></span><br><span class="line">    <span class="keyword">int</span> *newP = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 非常量指针被转换成常量指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *newP2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> *&gt; (p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ageRef = age;</span><br><span class="line">    <span class="comment">// 常量引用被转换成非常量引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ageRef2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(ageRef);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;numRef = num;</span><br><span class="line">    <span class="comment">// 非常量引用被转换成常量引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;numRef2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> &amp;&gt;(numRef);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 不能直接对非指针和非引用的变量使用 const_cast 操作符去直接赋予或者去除它的 const 只读属性</span></span><br><span class="line">    <span class="comment">// int a = const_cast&lt;int&gt;(a);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>显式类型转换 - <code>reinterpret_cast</code>（重新解释类型）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 将整数强制转换成指针（不安全，非常危险）</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> * &gt;(a);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h2><h3 id="const-针对指针的不同写法"><a href="#const-针对指针的不同写法" class="headerlink" title="const 针对指针的不同写法"></a>const 针对指针的不同写法</h3><table><thead><tr><th>写法</th><th>含义（读法）</th><th>什么是常量</th><th>类型分类</th></tr></thead><tbody><tr><td><code>const char * p</code></td><td>指向 <code>const char</code> 的指针</td><td>指针所指向的对象是常量</td><td>常量指针（pointer to const）</td></tr><tr><td><code>char const * p</code></td><td>指向 <code>const char</code> 的指针</td><td>指针所指向的对象是常量</td><td>常量指针（pointer to const）</td></tr><tr><td><code>char * const p</code></td><td>指针 <code>p</code> 本身是 <code>const</code>，但可以改指向的内容</td><td>指针本身是常量</td><td>指针常量（const pointer）</td></tr><tr><td><code>const char * const p</code></td><td>指向 <code>const char</code> 的指针常量</td><td>指针本身、指向的数据都是常量</td><td>指向常量的指针常量（const pointer to const）</td></tr><tr><td><code>char const * const p</code></td><td>指向 <code>const char</code> 的指针常量</td><td>指针本身、指向的数据都是常量</td><td>指向常量的指针常量（const pointer to const）</td></tr></tbody></table><table><thead><tr><th>写法</th><th>口诀判断（左定值，右定向）</th><th>指针是否可变</th><th>指向的数据是否可变</th><th>结果</th></tr></thead><tbody><tr><td><code>const char * p</code></td><td>const 在 <code>*</code> 左边（定值）</td><td>是</td><td>否</td><td>常量指针（指针可变，指向的数据不可改）</td></tr><tr><td><code>char const * p</code></td><td>const 在 <code>*</code> 左边（定值）</td><td>是</td><td>否</td><td>常量指针（指针可变，指向的数据不可改）</td></tr><tr><td><code>char * const p</code></td><td>const 在 <code>*</code> 右边（定向）</td><td>否</td><td>是</td><td>指针常量（指针不可变，指向的数据可改）</td></tr><tr><td><code>const char * const p</code></td><td>左定值 + 右定向 → 两者都受限</td><td>否</td><td>否</td><td>指向常量的指针常量（指针和指向的数据都不可变）</td></tr><tr><td><code>char const * const p</code></td><td>左定值 + 右定向 → 两者都受限</td><td>否</td><td>否</td><td>指向常量的指针常量（指针和指向的数据都不可变）</td></tr></tbody></table><hr><ul><li><p>(1) <code>const char *</code></p><ul><li>含义：<ul><li>指向 <code>const char</code> 的指针（常量指针）</li></ul></li><li>特性：<ul><li>指针：可以改</li><li>指向的数据：不能改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = str;</span><br><span class="line">p = other;   <span class="comment">// 正确写法：指针可变</span></span><br><span class="line">*p = <span class="string">'A'</span>;    <span class="comment">// 错误写法：不能修改指针所指向的内容</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：<ul><li>跟 <code>char const *</code> 表示的意义完全一致<strong>（<code>const</code> 放在类型前或后含义都相同）</strong>，只是写法不同</li></ul></li></ul></li><li><p> (2) <code>char const *</code></p><ul><li>含义：<ul><li>指向 <code>const char</code> 的指针（常量指针）</li></ul></li><li>特性：<ul><li>指针：可以改</li><li>指向的数据：不能改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *p = str;</span><br><span class="line">p = other;   <span class="comment">// 正确写法：指针可变</span></span><br><span class="line">*p = <span class="string">'A'</span>;    <span class="comment">// 错误写法：不能修改指针所指向的内容</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：<ul><li>跟 <code>const char *</code> 表示的意义完全一致<strong>（<code>const</code> 放在类型前或后含义都相同）</strong>，只是写法不同</li></ul></li></ul></li><li><p> (3) <code>char * const</code></p><ul><li>含义：<ul><li><code>const</code> 指针（指针常量）指向 <code>char</code></li></ul></li><li>特性：<ul><li>指针：不能改</li><li>指向的数据：可以改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = str;</span><br><span class="line">p = other;   <span class="comment">// 错误写法：指针本身不能变</span></span><br><span class="line">*p = <span class="string">'A'</span>;    <span class="comment">// 正确写法：可以修改指针所指向的内容</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>(4) <code>const char * const p</code></p><ul><li>含义：<ul><li>指向 <code>const char</code> 的 <code>const</code> 指针（指向常量的指针常量）</li><li>也就是：指针本身不能变，指向的数据也不能变</li></ul></li><li>特性：<ul><li>指针：不能改</li><li>指向的数据：不能改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p = str;</span><br><span class="line">p = other;     <span class="comment">// 错误写法：指针 p 是 const，不可改变</span></span><br><span class="line">*p = <span class="string">'A'</span>;      <span class="comment">// 错误写法：指向的数据是 const，不可修改</span></span><br><span class="line"><span class="keyword">char</span> c = p[<span class="number">0</span>]; <span class="comment">// 正确写法：可以读取数据</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：<ul><li>跟 <code>char const * const p</code> 表示的意义完全一致<strong>（<code>const</code> 放在类型前或后含义都相同）</strong>，只是写法不同</li></ul></li></ul></li><li><p> (5) <code>char const * const p</code></p><ul><li>含义：<ul><li>指向 <code>const char</code> 的 <code>const</code> 指针（指向常量的指针常量）</li><li>也就是：指针本身不能变，指向的数据也不能变</li></ul></li><li>特性：<ul><li>指针：不能改</li><li>指向的数据：不能改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> p = str;</span><br><span class="line">p = other;     <span class="comment">// 错误写法：指针 p 是 const，不可改变</span></span><br><span class="line">*p = <span class="string">'A'</span>;      <span class="comment">// 错误写法：指向的数据是 const，不可修改</span></span><br><span class="line"><span class="keyword">char</span> c = p[<span class="number">1</span>]; <span class="comment">// 正确写法：可以读取数据</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：<ul><li>跟 <code>const char * const p</code> 表示的意义完全一致<strong>（<code>const</code> 放在类型前或后含义都相同）</strong>，只是写法不同</li></ul></li></ul></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/68a580cf.html" title="C++ 杂记之二从基础到进阶">https://www.techgrow.cn/posts/68a580cf.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/cb193915.html" rel="prev" title="Debian 11 生产环境安装 Nginx"><i class="fa fa-angle-left"></i> Debian 11 生产环境安装 Nginx</a></div><div class="post-nav-item"> <a href="/posts/1b2af7f9.html" rel="next" title="SpringBoot 3 进阶教程之一整合 Prometheus 与 Grafana">SpringBoot 3 进阶教程之一整合 Prometheus 与 Grafana<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2026</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.3m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">35:08</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/68a580cf.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div><div id="moon-menu-item-code" class="moon-menu-item"><i class="fa-solid fa-code"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>