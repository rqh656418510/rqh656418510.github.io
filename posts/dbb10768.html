<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍如何基于 C++ 开发一款高性能网络库（Muduo）。"><meta property="og:type" content="article"><meta property="og:title" content="基于 C++ 手写 Muduo 高性能网络库"><meta property="og:url" content="https://www.techgrow.cn/posts/dbb10768.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍如何基于 C++ 开发一款高性能网络库（Muduo）。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-5.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-6.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-7.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-8.png"><meta property="article:published_time" content="2025-11-01T13:55:33.000Z"><meta property="article:modified_time" content="2025-11-01T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Linux系统编程"><meta property="article:tag" content="C++"><meta property="article:tag" content="网络编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/dbb10768.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/dbb10768.html","path":"posts/dbb10768.html","title":"基于 C++ 手写 Muduo 高性能网络库"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>基于 C++ 手写 Muduo 高性能网络库 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E7%9A%84"><span class="nav-text">学习目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87"><span class="nav-text">知识储备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="nav-text">开发工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5"><span class="nav-text">阻塞、非阻塞、同步、异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unix-Linux-%E7%9A%84%E4%BA%94%E7%A7%8D-I-O-%E6%A8%A1%E5%9E%8B"><span class="nav-text">Unix/Linux 的五种 I/O 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%A7%80%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-text">优秀的网络服务器设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor-%E7%BD%91%E7%BB%9C-I-O-%E6%A8%A1%E5%9E%8B"><span class="nav-text">Reactor 网络 I/O 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0"><span class="nav-text">I/O 多路复用技术概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">746</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/dbb10768.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="基于 C++ 手写 Muduo 高性能网络库 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍如何基于 C++ 开发一款高性能网络库（Muduo）。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 基于 C++ 手写 Muduo 高性能网络库</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-11-01 21:55:33" itemprop="dateCreated datePublished" datetime="2025-11-01T21:55:33+08:00">2025-11-01</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/dbb10768.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/dbb10768.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>7.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>7 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写 Muduo 高性能网络库</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将改造 C++ 高性能网络库 <a target="_blank" rel="external nofollow" href="https://github.com/chenshuo/muduo">Muduo</a>，比如去掉 Boost 依赖，并使用 C++ 11 进行代码重构，重点是学习 Muduo 的底层设计思想。</p><span id="more"></span><h3 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h3><ul><li>1、理解阻塞、非阻塞、同步、异步</li><li> 2、理解 Unix/Linux 上的五种 I/O 模型</li><li> 3、epoll 的原理以及优势</li><li> 4、深刻理解 Reactor 模型</li><li> 5、从开源 C++ 网络库 Muduo，学习优秀的代码设计</li><li> 6、掌握基于事件驱动和事件回调的 epoll + 线程池的面向对象编程</li><li> 7、通过深入理解 Muduo 源码，加深对于相关项目的深刻理解</li><li> 8、改造 Muduo，不依赖 Boost，使用 C++ 11 进行代码重构</li></ul><h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p>在开发高性能的网路库之前，要求先掌握以下前置知识：</p><ul><li>1、TCP 协议和 UDP 协议</li><li> 2、Linux 的 TCP 网络编程和 UDP 网络编程</li><li> 3、I/O 多路复用编程，包括 select、poll、epoll 库的使用</li><li> 4、Linux 的多线程编程（<code>pthread</code>）、进程和线程模型</li><li> 5、C++ 20 标准新加入的协程支持</li></ul><div class="admonition note"><p class="admonition-title">推荐阅读的书籍</p><p>《UNIX 环境高级编程》、《Linux 高性能服务器编程》、《 Linux 多线程服务端编程 - 使用 Muduo C++ 网络库》《鸟哥的 Linux 私房菜》</p></div><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>11</code></td><td>C++ 标准的版本</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>9</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="阻塞、非阻塞、同步、异步"><a href="#阻塞、非阻塞、同步、异步" class="headerlink" title="阻塞、非阻塞、同步、异步"></a>阻塞、非阻塞、同步、异步</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li>下面提到的 "I/O 操作" 并不局限于网络 I/O，而是一个广义的 I/O 概念，它既包含网络 I/O（Socket 读写），也包含磁盘 I/O（文件读写）等所有涉及内核态与用户态之间数据交换的操作。</li><li>I/O 模型（如阻塞、非阻塞、同步、异步）更多用于讨论网络 I/O，原因是磁盘 I/O 的异步化由操作系统内核自动管理（页缓存 + 异步调度），应用层很少直接干预。</li></ul></div><ul><li><p>同步与异步的区别</p><ul><li>同步：<ul><li>请求方 A 发起 I/O 调用后，由 A 自身完成数据的读写；</li><li>无论阻塞与否，A 都要亲自执行读写操作。</li></ul></li><li>异步：<ul><li>请求方 A 发起 I/O 调用后，仅仅发出请求，并由操作系统内核来完成数据的读写；</li><li>A 不需要等待操作完成，可以继续做其他事情；当操作系统内核完成读写操作后，会通过回调、事件通知等机制通知 A 结果。</li></ul></li></ul></li><li><p>阻塞与非阻塞的区别</p><ul><li>阻塞：<ul><li>调用未完成前，调用线程会一直等待；</li></ul></li><li>非阻塞：<ul><li>调用立即返回，即使操作未完成，也会返回错误码或状态提示（例如 <code>EAGAIN</code>）。</li></ul></li></ul></li><li><p>典型的一次 I/O 操作可以分为两个阶段</p><ul><li>数据准备（阶段一）：该阶段取决于系统 I/O 操作的就绪状态，即数据是否已经可以被读写<ul><li>阻塞：调用会等待数据准备好后再继续执行。</li><li>非阻塞：调用会立即返回，无论数据是否就绪。</li></ul></li><li>数据读写（阶段二）：该阶段取决于应用程序与操作系统内核之间的交互方式<ul><li>同步：由应用程序主动完成数据的读写，将数据从内核缓冲区拷贝到用户空间（或反之）。</li><li>异步：由操作系统内核完成数据的读写，并在操作完成后通知应用程序。</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">总结</p><ul><li>同步 / 异步区分的是谁来完成 I/O 操作（调用方自己还是操作系统内核来完成数据读写）。</li><li>阻塞 / 非阻塞区分的是调用方等待的方式（是否挂起等待处理结果）。</li></ul></div><blockquote><p><strong>常见的四种 I/O 模型</strong></p></blockquote><table><thead><tr><th>I/O 模型</th><th>数据准备阶段</th><th>数据读写阶段</th><th>调用方行为</th><th>示例说明</th></tr></thead><tbody><tr><td>同步阻塞</td><td>阻塞等待数据准备好</td><td>调用方执行读写</td><td>整个过程会阻塞当前线程</td><td><code>int size = recv(fd, buf, 1024, 0);</code>（若无数据则阻塞等待）</td></tr><tr><td>同步非阻塞</td><td>非阻塞轮询数据准备好</td><td>调用方执行读写</td><td>调用立即返回，但需要反复尝试调用</td><td>设置 <code>O_NONBLOCK</code>，多次调用 <code>recv()</code> 检查是否有数据可读</td></tr><tr><td>异步阻塞</td><td>阻塞等待事件完成</td><td>操作系统内核完成读写</td><td>等待通知，但数据读写由操作系统内核完成</td><td>例如 Windows <code>OVERLAPPED</code> I/O + <code>GetOverlappedResult</code> 阻塞等待</td></tr><tr><td>异步非阻塞</td><td>非阻塞提交请求</td><td>操作系统内核完成读写并通知</td><td>完全不阻塞，结果通过回调 / 事件返回</td><td>例如 Linux <code>aio_read()</code> 或 <code>io_uring</code> 提交请求后立即返回</td></tr></tbody></table><blockquote><p><strong>陈硕大神的原话：在处理 I/O 的时候，阻塞和非阻塞都是同步 I/O，只有使用了特殊的 API 才是异步 I/O（如下图所示）。</strong></p></blockquote><p><img data-src="../../../asset/2025/11/cplusplus-muduo-1.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li><code>select</code> / <code>poll</code> / <code>epoll</code> 本身只是事件就绪通知机制，它们并不直接完成数据读写，调用它们的线程仍然需要自己去 <code>read()</code> 或 <code>write()</code> 数据。</li><li>因此，从严格意义上看，它们属于同步 I/O 实现方式，因为最终的 I/O 读写（即数据读写）（即数据读写）是由调用线程自己完成的。</li><li>但它们提供了非阻塞的事件等待，使得线程可以同时监听多个 <code>fd</code>，而不用一个线程阻塞在一个 <code>fd</code> 上。</li><li>真正的异步 I/O 实现，在 Linux 上需要使用 <code>aio_*</code> 系列系统函数或者使用 <code>io_uring</code>。</li></ul></div><h3 id="Unix-Linux-的五种-I-O-模型"><a href="#Unix-Linux-的五种-I-O-模型" class="headerlink" title="Unix/Linux 的五种 I/O 模型"></a>Unix/Linux 的五种 I/O 模型</h3><p>Unix/Linux 支持以下五种 I/O 模型：</p><table><thead><tr><th>I/O 模型</th><th>阻塞 / 非阻塞</th><th>事件通知方式</th><th>适用场景</th></tr></thead><tbody><tr><td>阻塞 I/O</td><td> 阻塞</td><td>同步返回</td><td>简单程序，低并发</td></tr><tr><td>非阻塞 I/O</td><td> 非阻塞</td><td>轮询</td><td>少量 I/O，CPU 可支撑</td></tr><tr><td> I/O 多路复用</td><td>阻塞或非阻塞</td><td>操作系统内核返回就绪事件列表</td><td>高并发网络服务器</td></tr><tr><td>信号驱动 I/O</td><td> 非阻塞</td><td>信号</td><td>小规模异步通知</td></tr><tr><td>异步 I/O</td><td> 非阻塞</td><td>回调 / 事件</td><td>高并发、对延迟敏感场景</td></tr></tbody></table><blockquote><p><strong>阻塞 I/O（Blocking I/O）</strong></p></blockquote><ul><li>特征：应用程序调用 I/O 函数后，如果数据未就绪，调用线程会被阻塞，直到数据准备完成。</li><li>优点：编程实现简单、逻辑直观。</li><li>缺点：线程无法同时处理多个 I/O，吞吐量受限。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-2.png"></p><blockquote><p><strong>非阻塞 I/O（Non-Blocking I/O）</strong></p></blockquote><ul><li>特征：I/O 调用立即返回，即使数据未就绪也不会阻塞。应用程序需要通过轮询（Polling）或循环检查，目的是不断检测数据是否已经就绪，以便及时进行数据读写操作。</li><li>优点：单线程可以处理多个 I/O。</li><li>缺点：轮询会浪费 CPU 资源，逻辑较复杂。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-3.png"></p><blockquote><p><strong>I/O 多路复用（I/O Multiplexing）</strong></p></blockquote><ul><li>典型机制：<code>select</code>、<code>poll</code>、<code>epoll</code>。</li><li>特征：单个线程可以同时监听多个 <code>fd</code>，通过操作系统内核返回就绪事件列表，再进行读写操作。</li><li>优点：高效管理大量并发连接，避免轮询浪费。</li><li>缺点：处理非常大量 <code>fd</code> 时，某些实现（如 <code>select</code>、<code>poll</code>）效率有限。</li><li>注意：在 I/O 多路复用中，复用的线程而不是 TCP 连接。由于最终的 I/O 读写（即数据读写）是由调用线程自己完成的，因此从严格意义上看，I/O 多路复用属于同步 I/O 实现方式。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-4.png"></p><blockquote><p><strong>信号驱动 I/O（Signal-Driven I/O）</strong></p></blockquote><ul><li>特征：应用程序注册信号处理函数（如 <code>SIGIO</code>），当 <code>fd</code> 可读或可写时，操作系统内核发送信号通知。</li><li>优点：异步通知，无需轮询。</li><li>缺点：信号处理复杂，信号丢失或竞态问题较多，不易大规模使用。</li><li>注意：操作系统内核在第一个阶段（数据准备）是异步，在第二个阶段（数据读写）是同步；与非阻塞 I/O 的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统 API 的调用次数，提高了效率。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-5.png"></p><blockquote><p><strong>异步 I/O（Asynchronous I/O）</strong></p></blockquote><ul><li>特征：应用程序发起 I/O 调用后，立即返回；当数据准备好后，由操作系统内核完成数据读写；当数据读写操作完成后，通过信号、回调函数或事件机制通知应用程序。</li><li>优点：真正的异步，高效利用 CPU，可处理大量并发 I/O。</li><li>缺点：编程复杂，Linux 支持有限（传统 AIO 对网络 I/O 支持不好，<code>io_uring</code> 是新方案）。</li><li>注意：这是真正的异步 I/O 实现，在 Linux 上需要使用 <code>aio_*</code> 系列系统函数或者使用 <code>io_uring</code>，Node.js 采用了该 I/O 模型。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-6.png"></p><h3 id="优秀的网络服务器设计"><a href="#优秀的网络服务器设计" class="headerlink" title="优秀的网络服务器设计"></a>优秀的网络服务器设计</h3><p>在这个 CPU 多核时代，服务端网络编程如何选择线程模型呢？赞同 <code>libev</code> 作者的观点：”one loop perthread is usually a good model”，这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的 Event Loop， 然后每个线程运行一个 Event Loop 就行了（当然，线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。</p><hr><p>Event Loop 是 Non-Blocking 网络编程的核心，可以简单理解为 Non-Blocking + epoll + thread-pool 的结合。在实际应用中，Non-Blocking 几乎总是与 I/O Multiplexing 一起使用，原因有以下两点：</p><ul><li>实际上没有人会采用轮询（Busy-Polling）方式不断检查某个 Non-Blocking I/O 操作是否完成，因为这会严重浪费 CPU 资源。</li><li>I/O Multiplexing 通常无法与 Blocking I/O 一起使用，因为在 Blocking I/O 中，<code>accept()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 等调用都有可能阻塞当前线程，从而导致线程无法继续处理其他 Socket 上的 I/O 事件。</li></ul><p><strong>所以，当日常提到 Non-Blocking I/O 时，实际上指的是 Non-Blocking + I/O Multiplexing 的组合，如何单独使用其中任意一种，都无法很好地实现高效的网络 I/O。</strong></p><div class="admonition note"><p class="admonition-title">epoll + fork 不如 epoll + pthread 吗？</p><p>答案肯定是否定的，强大的 Nginx 服务器采用了 epoll + fork 模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个 fork 网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的服务器惊群现象，功能十分强大。</p></div><h3 id="Reactor-网络-I-O-模型"><a href="#Reactor-网络-I-O-模型" class="headerlink" title="Reactor 网络 I/O 模型"></a>Reactor 网络 I/O 模型</h3><div class="admonition note"><p class="admonition-title">维基百科对 Reactor 的描述</p><p>The reactor design pattern is an event handling pattern for handling service requestsdelivered concurrently to a service handler by one or more inputs. The service handlerthen demultiplexes the incoming requests and dispatches them synchronously to theassociated request handlers. 翻译后：Reactor（反应器）设计模式是一种事件处理模式，用于处理由一个或多个输入并发传递到服务处理器的服务请求。然后，服务处理器对传入的请求进行多路分解，并同步地将它们分派给相应的请求处理器。</p></div><ul><li><p>Reactor 是一种基于事件驱动（Event Driven）的网络 I/O 模型，核心思想是：</p><ul><li>主线程（或 I/O 线程）通过 I/O 多路复用（I/O Multiplexing）机制（如 <code>select</code>、<code>poll</code>、<code>epoll</code>），监听多个连接的 I/O 事件。</li><li>当某个事件就绪后，再分发（Dispatch）给对应的事件处理器（EventHandler）进行处理。</li></ul></li><li><p>Reactor 虽然是网络 I/O 模型，但它通常与线程模型结合使用：</p><ul><li>单线程 Reactor：所有 I/O 事件的监听与处理都在同一个线程中完成。</li><li>多线程 Reactor：I/O 事件的监听与业务处理分离，通常用线程池来处理业务逻辑。</li><li>主从 Reactor：主 Reactor 负责连接建立，从 Reactor 负责 I/O 读写（即数据读写），结合多线程提升并发性能。</li></ul></li><li><p>Reactor 的五大核心组件</p><table><thead><tr><th>核心组件</th><th>作用</th></tr></thead><tbody><tr><td> Event（事件）</td><td>表示 I/O 事件的抽象，如连接建立、可读、可写等，用于描述发生了什么类型的网络事件。</td></tr><tr><td>Demultiplexer（事件分离器）</td><td>负责监听并检测多个 I/O 事件的就绪状态（通常由 <code>select</code>、<code>poll</code>、<code>epoll</code> 等系统调用实现），并将已就绪的事件返回给 Reactor。</td></tr><tr><td>Reactor（反应堆）</td><td>事件分发器，负责从 Demultiplexer 获取就绪事件，并将事件分发给对应的 EventHandler 处理。</td></tr><tr><td>EventHandler（事件处理器）</td><td>负责具体的事件处理逻辑，如读、写、连接、业务处理等，是应用层的回调逻辑。</td></tr><tr><td>Acceptor（连接接收器）</td><td>负责监听服务器端口并接收新的客户端连接，在多 Reactor 模型中通常独立运行，仅负责建立连接并将连接交给子 Reactor 处理。</td></tr></tbody></table></li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-7.png"></p><ul><li>Muduo 库的 Multiple Reactors 模型如下图所示：</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-8.png"></p><h3 id="I-O-多路复用技术概述"><a href="#I-O-多路复用技术概述" class="headerlink" title="I/O 多路复用技术概述"></a>I/O 多路复用技术概述</h3><blockquote><p><strong>跨平台特性的对比</strong></p></blockquote><table><thead><tr><th>技术</th><th>是否支持跨平台</th><th>支持的平台</th><th>特点</th></tr></thead><tbody><tr><td><code>select</code></td><td>✅ 广泛跨平台</td><td> Linux / macOS / BSD / Windows / Unix</td><td> 最老的接口，POSIX 标准定义</td></tr><tr><td><code>poll</code></td><td>⚠️ 类 Unix 跨平台（不支持 Windows）</td><td>Linux /macOS/ BSD / Solaris 等</td><td><code>select</code> 的改进版 ，无 <code>fd</code> 数量限制</td></tr><tr><td><code>epoll</code></td><td>❌ Linux 独有</td><td>仅 Linux（2.6+）</td><td>高性能 I/O 多路复用技术</td></tr><tr><td><code>kqueue</code></td><td>❌ BSD/macOS 独有</td><td> FreeBSD / macOS / NetBSD / OpenBSD</td><td><code>epoll</code> 的 BSD 对应物</td></tr></tbody></table><blockquote><p><strong>select 与 poll 的缺点</strong></p></blockquote><p>I/O 多路复用技术 <code>select</code> 有以下缺点：</p><ul><li><p>(1) 文件描述符数量限制：</p><ul><li>单个进程可监视的文件描述符数量存在上限，通常为 1024（可修改）。但由于 <code>select</code> 采用轮询扫描方式检查文件描述符，随着监视数量的增加，性能会明显下降。</li><li>在 Linux 内核头文件中有如下定义：<code>#define __FD_SETSIZE 1024</code>。</li></ul></li><li><p>(2) 内核与用户空间的数据拷贝开销大：</p><ul><li>每次调用 <code>select</code> 都需要在内核空间与用户空间之间复制大量的文件描述符集合，这会造成显著的性能开销。</li></ul></li><li><p>(3) 结果集遍历效率低：</p><ul><li><code>select</code> 返回的是一个包含所有文件描述符的数组，应用程序需要遍历整个数组才能判断哪些描述符处于就绪状态，效率较低。</li></ul></li><li><p>(4) 水平触发机制（Level Trigger）：</p><ul><li><code>select</code> 采用水平触发方式，如果应用程序没有及时处理已就绪的文件描述符，那么在后续的每次 <code>select</code> 调用中，这些描述符仍会被重复通知。</li></ul></li></ul><p>I/O 多路复用技术 <code>poll</code> 跟 <code>select</code> 相比，使用链表来保存文件描述符，不再受文件描述符数量上限的限制，但仍然存在与 <code>select</code> 相同的其他三个缺点（数据拷贝开销大、结果集遍历效率低、水平触发），这里不再累述。</p><div class="admonition warning"><p class="admonition-title">select 无法支持高并发连接</p><p>以 <code>select</code> 为例，若服务器需支持 100 万并发连接，在 <code>__FD_SETSIZE</code> 为 1024 的情况下，至少需要创建约 1000 个进程才能满足要求。如此不仅会带来大量的进程上下文切换开销，还会因频繁的内核空间 / 用户空间句柄拷贝与数组遍历操作，导致系统性能急剧下降。因此，基于 <code>select</code> 模型的服务器要实现百万级并发几乎是不可能的。</p></div><blockquote><p><strong>epoll 的原理以及优势</strong></p></blockquote><p>设想这样一个场景：有 100 万个客户端同时与一个服务器进程保持 TCP 连接，但在任意时刻，通常只有几百到上千个连接是活跃的（这也是现实中最常见的情况）。如何高效地支撑如此庞大的并发连接呢？在 <code>select</code> / <code>poll</code> 时代，服务器每次调用都需要将这 100 万个连接的文件描述符从用户态复制到内核态，让内核轮询这些套接字上是否有事件发生；轮询完成后，再将结果从内核态复制回用户态，供应用程序继续遍历处理。这种方式带来了巨大的内存拷贝和遍历开销，因此基于 <code>select</code> / <code>poll</code> 通常只能处理几千个并发连接。</p><hr><p><code>epoll</code> 的设计思想与 <code>select</code> 完全不同，因此它们的缺点在 <code>epoll</code> 中已不复存在。<code>epoll</code> 在 Linux 内核中引入了一种专用的事件管理机制，通过红黑树（用于管理所有已注册的文件描述符）和就绪链表（用于管理已触发事件的文件描述符）来组织事件，大幅降低了事件查找和分发的开销，使大规模并发连接的事件管理更加高效。</p><ul><li>(1) <code>epoll_create()</code>：创建一个 <code>epoll</code> 对象（内核在 <code>epoll</code> 文件系统中为该对象分配资源）。</li><li>(2) <code>epoll_ctl()</code>：向 <code>epoll</code> 对象中添加、修改或删除需要监听的套接字（例如 100 万个 TCP 连接）。</li><li>(3) <code>epoll_wait()</code>：等待并收集有事件发生的文件描述符。</li></ul><p>其中 <code>epoll_create()</code> 在内核上创建的 <code>eventpoll</code> 结构如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> {</span></span><br><span class="line">    ....(省略)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 红黑树的根节点，这颗树中存储着所有添加到 epoll 中的需要监控的事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 双链表中则存放着将要通过 epoll_wait() 返回给用户的满足条件的事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line"></span><br><span class="line">    ....(省略)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>得益于这种设计，只需在服务器启动时创建一次 <code>epoll</code> 对象，然后在连接建立或关闭时动态地添加或移除对应的套接字即可。更重要的是，<code>epoll_wait()</code> 的调用效率极高：</p><ul><li>它不需要在每次调用时复制所有文件描述符。</li><li>内核也无需遍历全部连接，而是通过回调机制主动将就绪的文件描述符加入到就绪队列中。</li></ul><p>因此，<code>epoll</code> 能够在单进程中轻松支撑数十万甚至上百万级的并发连接，这正是它区别于 <code>select</code> / <code>poll</code> 的根本优势所在。</p><blockquote><p><strong>epoll 的 LT 模式与 ET 模式</strong></p></blockquote><p><code>epoll</code> 支持 LT（水平触发）与 ET（边缘触发），而 <code>select</code>、<code>poll</code> 在设计上只支持 LT（水平触发），没有 ET（边缘触发）的概念。</p><ul><li><p>LT 模式（Level Triggered，水平触发）</p><ul><li>语义：只要 <code>fd</code> 上有数据未被读取完，就会一直被 <code>epoll</code> 通知。</li><li>特点：更 “宽松”，即使一次没读完，下次还会被提醒。</li><li>行为示例：<ul><li>缓冲区有 100 字节可读；</li><li>应用程序只读了 60 字节；</li><li>下次 <code>epoll_wait()</code> 还会再次返回该 <code>fd</code>。</li></ul></li><li>优点：编程简单、不易漏数据。</li><li>缺点：频繁触发，效率略低。</li></ul></li><li><p>ET 模式（Edge Triggered，边缘触发）</p><ul><li>语义：只有当状态发生变化（从无到有）时才触发一次事件。</li><li>特点：仅在 “边缘” 通知，比如缓冲区从空变为非空。</li><li>行为示例：<ul><li>缓冲区变为可读时触发；</li><li>应用程序必须一次性读完所有数据（直到返回 <code>EAGAIN</code>）；</li><li>如果应用程序没读完，下次不会再收到通知。</li></ul></li><li>优点：减少系统调用次数，效率高。</li><li>缺点：编程复杂，稍有疏忽就可能会 “丢事件”。</li></ul></li><li><p>Muduo 采用的是 LT（水平触发）模式</p><ul><li>不会丢失数据或者消息<ul><li>应用程序没有读取完数据，内核是会不断上报数据的</li></ul></li><li>低延迟处理<ul><li>每次读数据只需要一次系统调用，照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</li></ul></li><li>跨平台处理<ul><li>像 <code>select</code> 一样可以跨平台使用</li></ul></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/717586901">深入分析 Muduo 网络库核心代码</a></li><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/683396341">Muduo 库核心代码及优秀编程细节剖析</a></li><li><a target="_blank" rel="external nofollow" href="https://www.ituring.com.cn/article/504549">从抄书到开源之巅：章亦春的程序人生</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/dbb10768.html" title="基于 C++ 手写 Muduo 高性能网络库">https://www.techgrow.cn/posts/dbb10768.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> Linux系统编程</a><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 网络编程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/ef54a41c.html" rel="prev" title="Java 与 Dubbo 的 SPI 机制介绍"><i class="fa fa-angle-left"></i> Java 与 Dubbo 的 SPI 机制介绍</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.1m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">32:01</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/dbb10768.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>