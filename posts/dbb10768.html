<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍如何基于 C++ 开发一款高性能网络库（类似 Muduo），采用 Multiple Reactors 模型。"><meta property="og:type" content="article"><meta property="og:title" content="基于 C++ 手写 Muduo 高性能网络库"><meta property="og:url" content="https://www.techgrow.cn/posts/dbb10768.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍如何基于 C++ 开发一款高性能网络库（类似 Muduo），采用 Multiple Reactors 模型。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-5.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-6.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-7.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-8.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/11/muduo-arch-process.png"><meta property="article:published_time" content="2025-11-01T13:55:33.000Z"><meta property="article:modified_time" content="2025-11-28T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Linux系统编程"><meta property="article:tag" content="C++"><meta property="article:tag" content="网络编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/11/cplusplus-muduo-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/dbb10768.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/dbb10768.html","path":"posts/dbb10768.html","title":"基于 C++ 手写 Muduo 高性能网络库"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>基于 C++ 手写 Muduo 高性能网络库 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script>
  (function () {

  // 防止 Pjax 重复绑定事件
  if (window.__moonMenuCodeExpandBound) {
    return;
  }
  window.__moonMenuCodeExpandBound = true;

  const STORAGE_KEY = 'moon_menu_code_fold';

  /* ===============================
   * 1. 设置 moon-menu 按钮的 title
   * =============================== */
  (function bindMoonMenuTitles() {
    const items = [
      { selector: '#moon-menu-item-code',        title: '展开 / 折叠代码块' },
      { selector: '#moon-menu-item-back2top',    title: '回到页面顶部' },
      { selector: '#moon-menu-item-back2bottom', title: '回到页面底部' }
    ];

    let allReady = true;

    items.forEach(item => {
      const el = document.querySelector(item.selector);
      if (!el) {
        allReady = false;
        return;
      }
      el.setAttribute('title', item.title);
    });

    if (!allReady) {
      setTimeout(bindMoonMenuTitles, 100);
    }
  })();

  /* =================================
   * 2. 页面首次加载：代码块恢复展开或折叠状态
   * ================================= */
  function applyStoredCodeState() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    const state = localStorage.getItem(STORAGE_KEY);
    if (!state) {
      return;
    }

    containers.forEach(container => {
      if (state === 'expanded') {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else if (state === 'folded') {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });
  }

  // 等代码块出现后，再恢复展开或折叠状态
  function waitAndApplyState() {
    const containers = document.querySelectorAll('.code-container');

    if (!containers.length) {
      setTimeout(waitAndApplyState, 100);
      return;
    }

    applyStoredCodeState();
  }

  // 页面首次加载时恢复状态
  waitAndApplyState();
  
  // Pjax 切换页面后，必须重新恢复状态
  document.addEventListener('pjax:complete', function () {
    waitAndApplyState();
  });

  /* ===============================
   * 3. 点击按钮：切换状态并保存
   * =============================== */
  document.addEventListener('click', function (e) {
    const codeMenu = e.target.closest('#moon-menu-item-code');
    if (!codeMenu) {
      return;
    }

    toggleAllCodeBlocks();
  });

  // 展开或折叠代码块
  function toggleAllCodeBlocks() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    // 只要存在折叠的代码块，就认为当前是折叠状态
    const hasFolded = Array.from(containers).some(c => {
      return c.classList.contains('highlight-fold');
    });

    containers.forEach(container => {
      if (hasFolded) {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });

    // 记录展开或折叠状态
    localStorage.setItem(
      STORAGE_KEY,
      hasFolded ? 'expanded' : 'folded'
    );
  }

})();
</script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="nav-text">学习目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87"><span class="nav-text">知识储备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="nav-text">开发工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5"><span class="nav-text">阻塞、非阻塞、同步、异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unix-Linux-%E7%9A%84%E4%BA%94%E7%A7%8D-I-O-%E6%A8%A1%E5%9E%8B"><span class="nav-text">Unix/Linux 的五种 I/O 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%A7%80%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-text">优秀的网络服务器设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor-%E7%BD%91%E7%BB%9C-I-O-%E6%A8%A1%E5%9E%8B"><span class="nav-text">Reactor 网络 I/O 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0"><span class="nav-text">I/O 多路复用技术概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="nav-text">项目介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="nav-text">项目结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="nav-text">项目技术栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-text">项目整体架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81"><span class="nav-text">项目代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#copyable"><span class="nav-text">copyable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noncopyable"><span class="nav-text">noncopyable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Logger"><span class="nav-text">Logger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timestamp"><span class="nav-text">Timestamp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InetAddress"><span class="nav-text">InetAddress</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SocketsOps"><span class="nav-text">SocketsOps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel"><span class="nav-text">Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Poller"><span class="nav-text">Poller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Epoller"><span class="nav-text">Epoller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoop"><span class="nav-text">EventLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread"><span class="nav-text">Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CurrentThread"><span class="nav-text">CurrentThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoopThread"><span class="nav-text">EventLoopThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoopThreadPool"><span class="nav-text">EventLoopThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket"><span class="nav-text">Socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer"><span class="nav-text">Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TcpConnection"><span class="nav-text">TcpConnection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Acceptor"><span class="nav-text">Acceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TcpServer"><span class="nav-text">TcpServer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Connector"><span class="nav-text">Connector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TcpClient"><span class="nav-text">TcpClient</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95"><span class="nav-text">项目测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">测试代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%AD%A5%E9%AA%A4"><span class="nav-text">测试步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%89%A9%E5%B1%95"><span class="nav-text">项目扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E9%97%AE%E7%AD%94"><span class="nav-text">项目问答</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0-TCP-%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%B4%BE%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-text">新 TCP 连接的派发问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoop-%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98"><span class="nav-text">EventLoop 之间的通信问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">795</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">56</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/dbb10768.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="基于 C++ 手写 Muduo 高性能网络库 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍如何基于 C++ 开发一款高性能网络库（类似 Muduo），采用 Multiple Reactors 模型。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 基于 C++ 手写 Muduo 高性能网络库</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-11-01 21:55:33" itemprop="dateCreated datePublished" datetime="2025-11-01T21:55:33+08:00">2025-11-01</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-11-28 21:55:33" itemprop="dateModified" datetime="2025-11-28T21:55:33+08:00">2025-11-28</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/dbb10768.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/dbb10768.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>13k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>12 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写 Muduo 高性能网络库</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 开发一个类似 <a target="_blank" rel="external nofollow" href="https://github.com/chenshuo/muduo">Muduo</a> 的高性能网络库，项目代码大部分都是从 Muduo 移值过来，同时去掉 Boost 依赖，并使用 C++ 11 进行代码重构，重点是学习 Muduo 的底层设计思想（尤其是 Multiple Reactors 模型）。</p><span id="more"></span><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>1、理解阻塞、非阻塞、同步、异步</li><li> 2、理解 Unix/Linux 上的五种 I/O 模型</li><li> 3、epoll 的原理以及优势</li><li> 4、深刻理解 Reactor 模型（基于 I/O 的事件驱动模型）</li><li>5、从开源 C++ 网络库 Muduo 的源码中，学习优秀的代码设计</li><li> 6、掌握基于事件驱动和事件回调的 epoll + 线程池的面向对象编程</li><li> 7、通过深入理解 Muduo 源码，加深对于网络相关项目的深刻理解</li><li> 8、改造 Muduo，不依赖 Boost，使用 C++ 11 进行代码重构</li></ul><h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p>在使用 C++ 开发高性能的网路库之前，要求先掌握以下前置知识：</p><ul><li>1、TCP 协议和 UDP 协议</li><li> 2、Linux 的 TCP 网络编程和 UDP 网络编程</li><li> 3、I/O 多路复用编程，包括 select、poll、epoll 库的使用</li><li> 4、Linux 的多线程编程（<code>pthread</code>）、进程和线程模型</li><li> 5、C++ 20 标准新加入的协程支持</li></ul><div class="admonition note"><p class="admonition-title">推荐阅读的书籍</p><p>《UNIX 环境高级编程》、《Linux 高性能服务器编程》、《Linux 多线程服务端编程 - 使用 Muduo C++ 网络库》《鸟哥的 Linux 私房菜》</p></div><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>11</code></td><td>C++ 标准的版本</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>9</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="阻塞、非阻塞、同步、异步"><a href="#阻塞、非阻塞、同步、异步" class="headerlink" title="阻塞、非阻塞、同步、异步"></a>阻塞、非阻塞、同步、异步</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li>下面提到的 "I/O 操作" 并不局限于网络 I/O，而是一个广义的 I/O 概念，它既包含网络 I/O（Socket 读写），也包含磁盘 I/O（文件读写）等所有涉及内核态与用户态之间数据交换的操作。</li><li>I/O 模型（如阻塞、非阻塞、同步、异步）更多用于讨论网络 I/O，原因是磁盘 I/O 的异步化由操作系统内核自动管理（页缓存 + 异步调度），应用层很少直接干预。</li></ul></div><ul><li><p>同步与异步的区别</p><ul><li>同步：<ul><li>请求方 A 发起 I/O 调用后，由 A 自身完成数据的读写；</li><li>无论阻塞与否，A 都要亲自执行数据的读写，将数据从内核缓冲区拷贝到用户空间（或反之）。</li></ul></li><li>异步：<ul><li>请求方 A 发起 I/O 调用后，仅仅发出请求，并由操作系统内核来完成数据的读写；</li><li>A 不需要等待操作完成，可以继续做其他事情；当操作系统内核完成读写操作后，会通过回调、事件通知等机制通知 A 结果。</li></ul></li></ul></li><li><p>阻塞与非阻塞的区别</p><ul><li>阻塞：<ul><li>调用未完成前，调用线程会一直等待；</li></ul></li><li>非阻塞：<ul><li>调用立即返回，即使操作未完成，也会返回错误码或状态提示（例如 <code>EAGAIN</code>）。</li></ul></li></ul></li><li><p>典型的一次 I/O 操作可以分为两个阶段</p><ul><li>数据准备（阶段一）：该阶段取决于系统 I/O 操作的就绪状态，即数据是否已经可以被读写<ul><li>阻塞：调用会等待数据准备好后再继续执行。</li><li>非阻塞：调用会立即返回，无论数据是否就绪。</li></ul></li><li>数据读写（阶段二）：该阶段取决于应用程序与操作系统内核之间的交互方式<ul><li>同步：由应用程序主动完成数据的读写，将数据从内核缓冲区拷贝到用户空间（或反之）。</li><li>异步：由操作系统内核完成数据的读写，并在操作完成后通知应用程序。</li></ul></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">总结</p><ul><li>同步 / 异步区分的是谁来完成 I/O 读写（调用方自己还是操作系统内核来完成数据读写）。</li><li>阻塞 / 非阻塞区分的是调用方等待的方式（是否挂起等待处理结果）。</li></ul></div><blockquote><p><strong>常见的四种 I/O 模型</strong></p></blockquote><table><thead><tr><th>I/O 模型</th><th>数据准备阶段</th><th>数据读写阶段</th><th>调用方行为</th><th>示例说明</th></tr></thead><tbody><tr><td>同步阻塞</td><td>阻塞等待数据准备好</td><td>调用方执行读写</td><td>整个过程会阻塞当前线程</td><td><code>int size = recv(fd, buf, 1024, 0);</code>（若无数据则阻塞等待）</td></tr><tr><td>同步非阻塞</td><td>非阻塞轮询数据准备好</td><td>调用方执行读写</td><td>调用立即返回，但需要反复尝试调用</td><td>设置 <code>O_NONBLOCK</code>，多次调用 <code>recv()</code> 检查是否有数据可读</td></tr><tr><td>异步阻塞</td><td>阻塞等待事件完成</td><td>操作系统内核完成读写</td><td>等待通知，但数据读写由操作系统内核完成</td><td>例如 Windows <code>OVERLAPPED</code> I/O + <code>GetOverlappedResult</code> 阻塞等待</td></tr><tr><td>异步非阻塞</td><td>非阻塞提交请求</td><td>操作系统内核完成读写并通知</td><td>完全不阻塞，结果通过回调 / 事件返回</td><td>例如 Linux <code>aio_read()</code> 或 <code>io_uring</code> 提交请求后立即返回</td></tr></tbody></table><blockquote><p><strong>陈硕大神的原话：在处理 I/O 的时候，阻塞和非阻塞都是同步 I/O，只有使用了特殊的 API 才是异步 I/O（如下图所示）。</strong></p></blockquote><p><img data-src="../../../asset/2025/11/cplusplus-muduo-1.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li><code>select</code> / <code>poll</code> / <code>epoll</code> 本身只是事件就绪通知机制，它们并不直接完成数据读写，调用它们的线程仍然需要自己去 <code>read()</code> 或 <code>write()</code> 数据。</li><li>因此，从严格意义上看，它们属于同步 I/O 实现方式，因为最终的 I/O 读写（即数据读写）是由调用线程自己完成的。</li><li>但它们提供了非阻塞的事件等待，使得一个线程可以同时监听多个 <code>fd</code>，而不用一个线程阻塞在一个 <code>fd</code> 上。</li><li>真正的异步 I/O 实现，在 Linux 上需要使用 <code>aio_*</code> 系列系统函数或者使用 <code>io_uring</code>。</li></ul></div><h3 id="Unix-Linux-的五种-I-O-模型"><a href="#Unix-Linux-的五种-I-O-模型" class="headerlink" title="Unix/Linux 的五种 I/O 模型"></a>Unix/Linux 的五种 I/O 模型</h3><p>Unix/Linux 支持以下五种 I/O 模型：</p><table><thead><tr><th>I/O 模型</th><th>阻塞 / 非阻塞</th><th>事件通知方式</th><th>适用场景</th></tr></thead><tbody><tr><td>阻塞 I/O</td><td> 阻塞</td><td>同步返回</td><td>简单程序，低并发</td></tr><tr><td>非阻塞 I/O</td><td> 非阻塞</td><td>轮询</td><td>少量 I/O，CPU 可支撑</td></tr><tr><td> I/O 多路复用</td><td>阻塞或非阻塞</td><td>操作系统内核返回就绪事件列表</td><td>高并发网络服务器</td></tr><tr><td>信号驱动 I/O</td><td> 非阻塞</td><td>信号</td><td>小规模异步通知</td></tr><tr><td>异步 I/O</td><td> 非阻塞</td><td>回调 / 事件</td><td>高并发、对延迟敏感场景</td></tr></tbody></table><blockquote><p><strong>阻塞 I/O（Blocking I/O）</strong></p></blockquote><ul><li>特征：应用程序调用 I/O 函数后，如果数据未就绪，调用线程会被阻塞，直到数据准备完成。</li><li>优点：编程实现简单、逻辑直观。</li><li>缺点：线程无法同时处理多个 I/O，吞吐量受限。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-2.png"></p><blockquote><p><strong>非阻塞 I/O（Non-Blocking I/O）</strong></p></blockquote><ul><li>特征：I/O 调用立即返回，即使数据未就绪也不会阻塞。应用程序需要通过轮询（Polling）或循环检查，目的是不断检测数据是否已经就绪，以便及时进行数据读写操作。</li><li>优点：单线程可以处理多个 I/O。</li><li>缺点：轮询会浪费 CPU 资源，逻辑较复杂。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-3.png"></p><blockquote><p><strong>I/O 多路复用（I/O Multiplexing）</strong></p></blockquote><ul><li>典型机制：<code>select</code>、<code>poll</code>、<code>epoll</code>。</li><li>特征：单个线程可以同时监听多个 <code>fd</code>，通过操作系统内核返回就绪事件列表，再进行读写操作。</li><li>优点：高效管理大量并发连接，避免轮询浪费。</li><li>缺点：处理非常大量 <code>fd</code> 时，某些实现（如 <code>select</code>、<code>poll</code>）效率有限。</li><li>注意：在 I/O 多路复用中，复用的线程而不是 TCP 连接。由于最终的 I/O 读写（即数据读写）是由调用线程自己完成的，因此从严格意义上看，I/O 多路复用属于同步 I/O 实现方式。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-4.png"></p><blockquote><p><strong>信号驱动 I/O（Signal-Driven I/O）</strong></p></blockquote><ul><li>特征：应用程序注册信号处理函数（如 <code>SIGIO</code>），当 <code>fd</code> 可读或可写时，操作系统内核发送信号通知。</li><li>优点：异步通知，无需轮询。</li><li>缺点：信号处理复杂，信号丢失或竞态问题较多，不易大规模使用。</li><li>注意：操作系统内核在第一个阶段（数据准备）是异步，在第二个阶段（数据读写）是同步；与非阻塞 I/O 的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统 API 的调用次数，提高了效率。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-5.png"></p><blockquote><p><strong>异步 I/O（Asynchronous I/O）</strong></p></blockquote><ul><li>特征：应用程序发起 I/O 调用后，立即返回；当数据准备好后，由操作系统内核完成数据读写；当数据读写操作完成后，通过信号、回调函数或事件机制通知应用程序。</li><li>优点：真正的异步，高效利用 CPU，可处理大量并发 I/O。</li><li>缺点：编程复杂，Linux 支持有限（传统 AIO 对网络 I/O 支持不好，<code>io_uring</code> 是新方案）。</li><li>注意：这是真正的异步 I/O 实现，在 Linux 上需要使用 <code>aio_*</code> 系列系统函数或者使用 <code>io_uring</code>，Node.js 采用了该 I/O 模型。</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-6.png"></p><h3 id="优秀的网络服务器设计"><a href="#优秀的网络服务器设计" class="headerlink" title="优秀的网络服务器设计"></a>优秀的网络服务器设计</h3><p>在这个 CPU 多核时代，服务端网络编程如何选择线程模型呢？赞同 <code>libev</code> 作者的观点：”one loop perthread is usually a good model”，这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的 Event Loop， 然后每个线程运行一个 Event Loop 就行了（当然，线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。Event Loop 是 Non-Blocking 网络编程的核心，可以简单理解为 Non-Blocking + epoll + thread-pool 的结合。在实际应用中，Non-Blocking 几乎总是与 I/O Multiplexing 一起使用，原因有以下两点：</p><ul><li>实际上没有人会采用轮询（Busy-Polling）方式不断检查某个 Non-Blocking I/O 操作是否完成，因为这会严重浪费 CPU 资源。</li><li>I/O Multiplexing 通常无法与 Blocking I/O 一起使用，因为在 Blocking I/O 中，<code>accept()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 等调用都有可能阻塞当前线程，从而导致线程无法继续处理其他 Socket 上的 I/O 事件。</li></ul><p><strong>所以，当日常提到 Non-Blocking I/O 时，实际上指的是 Non-Blocking + I/O Multiplexing（如 epoll + thread-pool） 的组合，如何单独使用其中任意一种，都无法很好地实现高效的网络 I/O。</strong></p><hr><p>在网络编程领域中，主流的网络 I/O 模型有以下几种（不限于），Muduo 采用的是第四种（<code>reactors in threads - one loop per thread</code>）。</p><ul><li><p>(1) <code>accept + read/write</code></p><ul><li>不适用于并发服务器</li></ul></li><li><p> (2) <code>accept + fork - process-pre-connection</code></p><ul><li>适合并发连接数不大，计算任务工作量大于 Fork 的开销。</li></ul></li><li><p>(3) <code>accept + thread - thread-pre-connection</code></p><ul><li>比第二种网络 I/O 模型的开销小了一点，但是并发造成的线程堆积过多。</li></ul></li><li><p>(4) <code>reactors in threads - one loop per thread</code></p><ul><li>这是 Muduo 库的网络设计方案，底层实质上是基于 Linux 的 <code>epoll</code> + <code>pthread</code> 线程池实现，且依赖了 Boost 库，适用于并发连接数较大的场景。</li><li>有一个 Main Reactor 负载 Accept 连接，然后将连接分发给某个 SubReactor（采用轮询的方式来选择 SubReactor），该连接的所用操作都在那个 SubReactor 所处的线程中完成。多个连接可能被分派到多个线程中被处理，以充分利用 CPU。</li><li>Main Reactor 中有一个 Base I/O Thread 负责 Accept 新的连接，接收到新的连接以后，使用轮询的方式在 Reactor Pool 中找到合适的 SubReactor 将这个连接挂载上去，这个连接上的所有任务都在这个 SubReactor 所处的线程中完成。</li><li>Reactor Poll 的大小是固定的，根据 CPU 的核心数量来确定。如果有过多的耗费 CPU 资源的计算任务，可以提交到 ThreadPool 线程池中专门处理耗时的计算任务。</li></ul></li><li><p>(5) <code>reactors in process - one loop pre process</code></p><ul><li>这是 Nginx 服务器的网络设计方案，基于进程设计，采用多个 Reactors 充当 I/O 进程和工作进程，通过一个 <code>accept</code> 锁，完美解决多个 Reactors 之间的 “惊群现象”。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">reactors in process + fork 不如 reactors in threads 吗？</p><p>答案肯定是否定的，强大的 Nginx 服务器采用了 <code>reactors in process</code> 模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个 fork 网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的服务器惊群现象，功能十分强大。</p></div><h3 id="Reactor-网络-I-O-模型"><a href="#Reactor-网络-I-O-模型" class="headerlink" title="Reactor 网络 I/O 模型"></a>Reactor 网络 I/O 模型</h3><blockquote><p><strong>Reactor 模型的介绍</strong></p></blockquote><div class="admonition warning"><p class="admonition-title">维基百科对 Reactor 的描述</p><p>The reactor design pattern is an event handling pattern for handling service requestsdelivered concurrently to a service handler by one or more inputs. The service handlerthen demultiplexes the incoming requests and dispatches them synchronously to theassociated request handlers. 翻译后：Reactor（反应器）设计模式是一种事件处理模式，用于处理由一个或多个输入并发传递到服务处理器的服务请求。然后，服务处理器对传入的请求进行多路分解，并同步地将它们分派给相应的请求处理器。</p></div><ul><li><p>Reactor 是一种基于事件驱动（Event Driven）的网络 I/O 模型，核心思想是：</p><ul><li>主线程（或 I/O 线程）通过 I/O 多路复用（I/O Multiplexing）机制（如 <code>select</code>、<code>poll</code>、<code>epoll</code>），监听多个连接的 I/O 事件。</li><li>当某个事件就绪后，再分发（Dispatch）给对应的事件处理器（EventHandler）进行处理。</li></ul></li><li><p>Reactor 虽然是网络 I/O 模型，但它通常与线程模型结合使用：</p><ul><li>单线程 Reactor：所有 I/O 事件的监听与处理都在同一个线程中完成。</li><li>多线程 Reactor：I/O 事件的监听与业务处理分离，通常用线程池来处理业务逻辑。</li><li>主从 Reactor：主 Reactor（即 MainReactor）负责连接建立，从 Reactor（即 SubReactor）负责 I/O 读写（即数据读写），结合多线程提升并发性能。</li></ul></li><li><p>Reactor 的五大核心组件：</p><table><thead><tr><th>核心组件</th><th>作用</th><th> Muduo 网络库中对应的核心类</th></tr></thead><tbody><tr><td> Event（事件）</td><td>表示 I/O 事件的抽象，如连接建立、可读、可写等，用于描述发生了什么类型的网络事件。</td><td><code>Channel</code></td></tr><tr><td>Demultiplexer（事件分离器）</td><td>负责监听并检测多个 I/O 事件的就绪状态（通常由 <code>select</code>、<code>poll</code>、<code>epoll</code> 等系统调用实现），并将已就绪的事件返回给 Reactor。</td><td><code>Poller</code>、<code>EPollPoller</code></td></tr><tr><td>Reactor（反应堆）</td><td>事件分发器，负责从 Demultiplexer 获取就绪事件，并将事件分发给对应的 EventHandler 处理。</td><td><code>EventLoop</code></td></tr><tr><td>EventHandler（事件处理器）</td><td>负责具体的事件处理逻辑，如读、写、连接、业务处理等，是应用层的回调逻辑。</td><td>回调函数 + <code>TcpConnection</code> 的 <code>handleRead()</code> / <code>handleWrite()</code> 等</td></tr><tr><td> Acceptor（连接接收器）</td><td>负责监听服务器端口并接收新的客户端连接，在多 Reactor 模型中通常独立运行，仅负责建立连接并将连接交给子 Reactor 处理。</td><td><code>Acceptor</code></td></tr></tbody></table></li><li><p>Reactor 核心组件的工作流程：</p></li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-7.png"></p><ul><li>Muduo 库的 Multiple Reactors 模型：</li></ul><p><img data-src="../../../asset/2025/11/cplusplus-muduo-8.png"></p><blockquote><p><strong>Reactor 模型与 Proactor 模型的区别</strong></p></blockquote><ul><li>Reactor 模型与 Proactor 模型的主要区别</li></ul><table><thead><tr><th>模型</th><th>内核通知的事件</th><th>谁负责实际 I/O 读写</th><th>用户线程需要做什么</th></tr></thead><tbody><tr><td> Reactor</td><td> 可以读 / 可以写</td><td>用户线程做读写</td><td>用户线程收到可读 / 可写通知后，调用 <code>read</code> / <code>write</code>，并处理数据</td></tr><tr><td> Proactor</td><td> 读完了 / 写完了</td><td>内核做读写 （异步完成读 / 写后，再通知用户线程）</td><td>用户线程收到读 / 写完成通知后，直接处理已读 / 已写的数据</td></tr></tbody></table><ul><li>常见库 / 系统采用模型对比</li></ul><table><thead><tr><th>库 / 系统</th><th>模型</th><th>平台</th></tr></thead><tbody><tr><td> Muduo</td><td>Reactor</td><td>Linux</td></tr><tr><td>Netty（NIO）</td><td>Reactor</td><td>Linux</td></tr><tr><td>libevent / libev</td><td>Reactor</td><td>Linux</td></tr><tr><td>Boost.Asio（Linux）</td><td>Reactor</td><td>Linux</td></tr><tr><td>IOCP</td><td>Proactor</td><td>Windows</td></tr><tr><td>Boost.Asio（Windows）</td><td>Proactor</td><td>Windows</td></tr></tbody></table><ul><li> 为什么 Linux 基本用不到 Proactor？<ul><li>因为 Linux 的 <code>aio</code> 不是真正意义上的内核异步 I/O：<ul><li>文件 I/O 是异步的</li><li>网络 I/O 仍然是阻塞式的（内核不自动读取）</li></ul></li><li>所以 Linux 上的高性能网络库几乎都是：<ul><li>epoll（Reactor）</li><li>epoll + thread pool（高级 Reactor）</li></ul></li></ul></li></ul><h3 id="I-O-多路复用技术概述"><a href="#I-O-多路复用技术概述" class="headerlink" title="I/O 多路复用技术概述"></a>I/O 多路复用技术概述</h3><blockquote><p><strong>跨平台特性的对比</strong></p></blockquote><table><thead><tr><th>技术</th><th>是否支持跨平台</th><th>支持的平台</th><th>特点</th></tr></thead><tbody><tr><td><code>select</code></td><td>✅ 广泛跨平台</td><td> Linux / macOS / BSD / Windows / Unix</td><td> 最老的接口，POSIX 标准定义</td></tr><tr><td><code>poll</code></td><td>⚠️ 支持类 Unix 跨平台（不支持 Windows）</td><td>Linux /macOS/ BSD / Solaris 等</td><td><code>select</code> 的改进版 ，无 <code>fd</code> 数量限制</td></tr><tr><td><code>epoll</code></td><td>❌ Linux 独有</td><td>仅 Linux（2.6+）</td><td>高性能 I/O 多路复用技术</td></tr><tr><td><code>kqueue</code></td><td>❌ BSD /macOS 独有</td><td> FreeBSD / macOS / NetBSD / OpenBSD</td><td><code>epoll</code> 的 BSD 平台对应物</td></tr></tbody></table><blockquote><p><strong>select 与 poll 的缺点</strong></p></blockquote><p>I/O 多路复用技术 <code>select</code> 有以下缺点：</p><ul><li><p>(1) 文件描述符数量限制：</p><ul><li>单个进程可监视的文件描述符数量存在上限，通常为 1024（可修改）。但由于 <code>select</code> 采用轮询扫描方式检查文件描述符，随着监视数量的增加，性能会明显下降。</li><li>在 Linux 内核头文件中有如下定义：<code>#define __FD_SETSIZE 1024</code>。</li></ul></li><li><p>(2) 内核与用户空间的数据拷贝开销大：</p><ul><li>每次调用 <code>select</code> 都需要在内核空间与用户空间之间复制大量的文件描述符集合，这会造成显著的性能开销。</li></ul></li><li><p>(3) 结果集遍历效率低：</p><ul><li><code>select</code> 返回的是一个包含所有文件描述符的数组，应用程序需要遍历整个数组才能判断哪些描述符处于就绪状态，效率较低。</li></ul></li><li><p>(4) 水平触发机制（Level Trigger）：</p><ul><li><code>select</code> 采用水平触发方式，如果应用程序没有及时处理已就绪的文件描述符，那么在后续的每次 <code>select</code> 调用中，这些描述符仍会被重复通知。</li></ul></li></ul><p>I/O 多路复用技术 <code>poll</code> 跟 <code>select</code> 相比，使用链表来保存文件描述符，不再受文件描述符数量上限的限制，但仍然存在与 <code>select</code> 相同的其他三个缺点（数据拷贝开销大、结果集遍历效率低、水平触发），这里不再累述。</p><div class="admonition warning"><p class="admonition-title">select 无法支持高并发连接</p><p>以 <code>select</code> 为例，若服务器需支持 100 万并发连接，在 <code>__FD_SETSIZE</code> 为 1024 的情况下，至少需要创建约 1000 个进程才能满足要求。如此不仅会带来大量的进程上下文切换开销，还会因频繁的内核空间 / 用户空间句柄拷贝与数组遍历操作，导致系统性能急剧下降。因此，基于 <code>select</code> 模型的服务器要实现百万级并发几乎是不可能的。</p></div><blockquote><p><strong>epoll 的原理以及优势</strong></p></blockquote><p>设想这样一个场景：有 100 万个客户端同时与一个服务器进程保持 TCP 连接，但在任意时刻，通常只有几百到上千个连接是活跃的（这也是现实中最常见的情况）。如何高效地支撑如此庞大的并发连接呢？在 <code>select</code> / <code>poll</code> 时代，服务器每次调用都需要将这 100 万个连接的文件描述符从用户态复制到内核态，让内核轮询这些套接字上是否有事件发生；轮询完成后，再将结果从内核态复制回用户态，供应用程序继续遍历处理。这种方式带来了巨大的内存拷贝和遍历开销，因此基于 <code>select</code> / <code>poll</code> 通常只能处理几千个并发连接。</p><hr><p><code>epoll</code> 的设计思想与 <code>select</code> 完全不同，因此它们的缺点在 <code>epoll</code> 中已不复存在。<code>epoll</code> 在 Linux 内核中引入了一种专用的事件管理机制，通过红黑树（用于管理所有已注册的文件描述符）和就绪链表（用于管理已触发事件的文件描述符）来组织事件，大幅降低了事件查找和分发的开销，使大规模并发连接的事件管理更加高效。</p><ul><li>(1) <code>epoll_create()</code>：创建一个 <code>epoll</code> 对象（内核在 <code>epoll</code> 文件系统中为该对象分配资源）。</li><li>(2) <code>epoll_ctl()</code>：向 <code>epoll</code> 对象中添加、修改或删除需要监听的套接字（例如 100 万个 TCP 连接）。</li><li>(3) <code>epoll_wait()</code>：等待并收集有事件发生的文件描述符。</li></ul><p>其中 <code>epoll_create()</code> 在内核上创建的 <code>eventpoll</code> 结构如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> {</span></span><br><span class="line">    ....(省略)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 红黑树的根节点，这颗树中存储着所有添加到 epoll 中的需要监控的事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 双链表中则存放着将要通过 epoll_wait() 返回给用户的满足条件的事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line"></span><br><span class="line">    ....(省略)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>得益于这种设计，只需在服务器启动时创建一次 <code>epoll</code> 对象，然后在连接建立或关闭时动态地添加或移除对应的套接字即可。更重要的是，<code>epoll_wait()</code> 的调用效率极高：</p><ul><li>它不需要在每次调用时复制所有文件描述符。</li><li>内核也无需遍历全部连接，而是通过回调机制主动将就绪的文件描述符加入到就绪队列中。</li></ul><p>因此，<code>epoll</code> 能够在单进程中轻松支撑数十万甚至上百万级的并发连接，这正是它区别于 <code>select</code> / <code>poll</code> 的根本优势所在。</p><blockquote><p><strong>epoll 的 LT 模式与 ET 模式</strong></p></blockquote><p><code>epoll</code> 支持 LT（水平触发）与 ET（边缘触发），而 <code>select</code>、<code>poll</code> 在设计上只支持 LT（水平触发），没有 ET（边缘触发）的概念。</p><ul><li><p>LT 模式（Level Triggered，水平触发）</p><ul><li>语义：只要 <code>fd</code> 上有数据未被读取完，就会一直被 <code>epoll</code> 通知。</li><li>特点：更 “宽松”，即使一次没读完，下次还会被提醒。</li><li>行为示例：<ul><li>缓冲区有 100 字节可读；</li><li>应用程序只读了 60 字节；</li><li>下次 <code>epoll_wait()</code> 还会再次返回该 <code>fd</code>。</li></ul></li><li>优点：编程简单、不易漏数据。</li><li>缺点：频繁触发，效率略低。</li></ul></li><li><p>ET 模式（Edge Triggered，边缘触发）</p><ul><li>语义：只有当状态发生变化（从无到有）时才触发一次事件。</li><li>特点：仅在 “边缘” 通知，比如缓冲区从空变为非空。</li><li>行为示例：<ul><li>缓冲区变为可读时触发；</li><li>应用程序必须一次性读完所有数据（直到返回 <code>EAGAIN</code>）；</li><li>如果应用程序没读完，下次不会再收到通知。</li></ul></li><li>优点：减少系统调用次数，效率高。</li><li>缺点：编程复杂，稍有疏忽就可能会 “丢事件”。</li></ul></li><li><p>Muduo 采用的是 LT（水平触发）模式</p><ul><li>不会丢失数据或者消息<ul><li>应用程序没有读取完数据，内核是会不断上报数据的</li></ul></li><li>低延迟处理<ul><li>每次读数据只需要一次系统调用，照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</li></ul></li><li>跨平台处理<ul><li>像 <code>select</code> 一样可以跨平台使用</li></ul></li></ul></li></ul><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">c++-project-mymuduo</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── example</span><br><span class="line">│&nbsp;&nbsp; ├── CMakeLists.txt</span><br><span class="line">│&nbsp;&nbsp; ├── epoll</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── CMakeLists.txt</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── main.cc</span><br><span class="line">│&nbsp;&nbsp; └── mymuduo</span><br><span class="line">│&nbsp;&nbsp;     ├── ChatClient.cc</span><br><span class="line">│&nbsp;&nbsp;     ├── ChatClient.h</span><br><span class="line">│&nbsp;&nbsp;     ├── ChatServer.cc</span><br><span class="line">│&nbsp;&nbsp;     ├── ChatServer.h</span><br><span class="line">│&nbsp;&nbsp;     ├── CMakeLists.txt</span><br><span class="line">│&nbsp;&nbsp;     └── main.cc</span><br><span class="line">├── lib</span><br><span class="line">├── README.md</span><br><span class="line">├── src</span><br><span class="line">│&nbsp;&nbsp; ├── include</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Acceptor.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Buffer.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Callbacks.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Channel.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Connector.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── copyable.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── CurrentThread.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── EPollPoller.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── EventLoop.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── EventLoopThread.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── EventLoopThreadPool.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── InetAddress.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Logger.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── noncopyable.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Poller.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Socket.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── SocketsOps.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── TcpClient.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── TcpConnection.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── TcpServer.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Thread.h</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── Timestamp.h</span><br><span class="line">│&nbsp;&nbsp; ├── Acceptor.cc</span><br><span class="line">│&nbsp;&nbsp; ├── Buffer.cc</span><br><span class="line">│&nbsp;&nbsp; ├── Channel.cc</span><br><span class="line">│&nbsp;&nbsp; ├── CMakeLists.txt</span><br><span class="line">│&nbsp;&nbsp; ├── Connector.cc</span><br><span class="line">│&nbsp;&nbsp; ├── CurrentThread.cc</span><br><span class="line">│&nbsp;&nbsp; ├── DefaultPoller.cc</span><br><span class="line">│&nbsp;&nbsp; ├── EPollPoller.cc</span><br><span class="line">│&nbsp;&nbsp; ├── EventLoop.cc</span><br><span class="line">│&nbsp;&nbsp; ├── EventLoopThread.cc</span><br><span class="line">│&nbsp;&nbsp; ├── EventLoopThreadPool.cc</span><br><span class="line">│&nbsp;&nbsp; ├── InetAddress.cc</span><br><span class="line">│&nbsp;&nbsp; ├── Logger.cc</span><br><span class="line">│&nbsp;&nbsp; ├── Poller.cc</span><br><span class="line">│&nbsp;&nbsp; ├── Socket.cc</span><br><span class="line">│&nbsp;&nbsp; ├── SocketsOps.cc</span><br><span class="line">│&nbsp;&nbsp; ├── TcpClient.cc</span><br><span class="line">│&nbsp;&nbsp; ├── TcpConnection.cc</span><br><span class="line">│&nbsp;&nbsp; ├── TcpServer.cc</span><br><span class="line">│&nbsp;&nbsp; ├── Thread.cc</span><br><span class="line">│&nbsp;&nbsp; └── Timestamp.cc</span><br><span class="line">└── test</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cc</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>目录名称</th><th>目录说明</th></tr></thead><tbody><tr><td><code>build</code></td><td>CMake 编译构建项目的目录（项目首次编译后才会有）</td></tr><tr><td><code>bin</code></td><td>存放项目编译生成的可执行文件的目录（项目首次编译后才会有）</td></tr><tr><td><code>lib</code></td><td>存放项目编译生成的 MyMuduo 动态链接库的目录（项目首次编译后才会有）</td></tr><tr><td><code>src</code></td><td>MyMuduo 网络库的源码</td></tr><tr><td><code>src/include</code></td><td>MyMuduo 网络库的头文件</td></tr><tr><td><code>test</code></td><td>MyMuduo 网络库的的测试代码</td></tr><tr><td><code>example</code></td><td>各种案例代码</td></tr><tr><td><code>example/epoll</code></td><td>epoll 的使用案例代码</td></tr><tr><td><code>example/mymuduo</code></td><td>MyMuduo 网络库的使用案例代码</td></tr><tr><td><code>autobuild.sh</code></td><td>项目一键编译构建的脚本文件</td></tr></tbody></table><h3 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h3><p>基于 C++ 开发网络库时，使用到以下技术：</p><ul><li>单例设计模式</li><li> epoll 等 I/O 多路复用技术</li><li> Linux 网络编程基础（<code>socket()</code>、<code>bind()</code>、<code>listen()</code>、<code>accept()</code>、<code>readv()</code>、<code>write()</code> 等）</li><li>C++ 11 多线程编程（<code>std::thread</code>、<code>std::unique_lock</code>、<code>std::mutex</code>、<code>std::condition_variable</code> 等）</li><li>使用 CMake 构建与集成项目的编译环境</li></ul><h3 id="项目整体架构"><a href="#项目整体架构" class="headerlink" title="项目整体架构"></a>项目整体架构</h3><p><img data-src="../../../asset/2025/11/muduo-arch-process.png"></p><div class="admonition note"><p class="admonition-title">架构图说明</p><p>在上述的架构图中，mainLoop 运行在主线程，负责监听新 TCP 连接并分发给 subLoop；而 subLoop（也称 ioLoop）运行在子线程，负责处理 TCP 连接的具体 I/O 事件（比如，读和写等）。mainLoop 与 subLoop 通过 <code>pendingFunctors</code> 异步任务队列进行线程间通信，禁止直接跨线程操作，这是为了保证某个 TCP 连接的所有 I/O 事件和连接状态操作都在同一个线程中执行，从而保证线程安全。在 Muduo 库的 <a href="../../../asset/2025/11/cplusplus-muduo-8.png">Multiple Reactors</a> 模型中，mainLoop 对应的就是 <code>mainReactor</code>（主 Reactor），而 subLoop 对应的就是 <code>subReactor</code>（子 Reactor）。</p></div><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><div class="admonition note"><p class="admonition-title">代码下载</p><p>本文开发的 MyMuduo 网络库只实现了 Muduo 的核心功能，并不支持 Muduo 的定时事件机制（<code>TimerQueue</code>）、IPV6 / DNS / HTTP / RPC 协议等，完整的项目代码可以在 <a target="_blank" rel="external nofollow" href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-mymuduo">这里</a> 下载得到。</p></div><h3 id="copyable"><a href="#copyable" class="headerlink" title="copyable"></a>copyable</h3><ul><li><code>copyable.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copyable 类被继承以后，派生类对象可以正常地执行构造和析构操作，同时派生类对象还可以进行拷贝构造和赋值操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">copyable</span> {</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">copyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">copyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="noncopyable"><a href="#noncopyable" class="headerlink" title="noncopyable"></a>noncopyable</h3><ul><li><code>noncopyable.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * noncopyable 类被继承以后，派生类对象可以正常地执行构造和析构操作，但是派生类对象不能进行拷贝构造和赋值操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>(<span class="keyword">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><ul><li><code>Logger.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CurrentThread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(logmsgformat, ...)                        \</span></span><br><span class="line"><span class="meta">    do {                                                    \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();                \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.getLogLevel() &lt;= DEBUG) {                \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                             \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            int tid = CurrentThread::tid();                 \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {DEBUG, c, tid};               \</span></span><br><span class="line"><span class="meta">            logger.log(msg);                                \</span></span><br><span class="line"><span class="meta">        }                                                   \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(logmsgformat, ...)                         \</span></span><br><span class="line"><span class="meta">    do {                                                    \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();                \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.getLogLevel() &lt;= INFO) {                 \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                             \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            int tid = CurrentThread::tid();                 \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {INFO, c, tid};                \</span></span><br><span class="line"><span class="meta">            logger.log(msg);                                \</span></span><br><span class="line"><span class="meta">        }                                                   \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARN(logmsgformat, ...)                         \</span></span><br><span class="line"><span class="meta">    do {                                                    \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();                \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.getLogLevel() &lt;= WARN) {                 \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                             \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            int tid = CurrentThread::tid();                 \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {WARN, c, tid};                \</span></span><br><span class="line"><span class="meta">            logger.log(msg);                                \</span></span><br><span class="line"><span class="meta">        }                                                   \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERROR(logmsgformat, ...)                        \</span></span><br><span class="line"><span class="meta">    do {                                                    \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();                \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.getLogLevel() &lt;= ERROR) {                \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                             \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            int tid = CurrentThread::tid();                 \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {ERROR, c, tid};               \</span></span><br><span class="line"><span class="meta">            logger.log(msg);                                \</span></span><br><span class="line"><span class="meta">        }                                                   \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_FATAL(logmsgformat, ...)                              \</span></span><br><span class="line"><span class="meta">    do {                                                          \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();                      \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.getLogLevel() &lt;= FATAL) {                      \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                   \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);       \</span></span><br><span class="line"><span class="meta">            int tid = CurrentThread::tid();                       \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {FATAL, c, tid};                     \</span></span><br><span class="line"><span class="meta">            logger.log(msg);                                      \</span></span><br><span class="line"><span class="meta">            std::this_thread::sleep_for(std::chrono::seconds(1)); \</span></span><br><span class="line"><span class="meta">            exit(-1);                                             \</span></span><br><span class="line"><span class="meta">        }                                                         \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别（DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL）</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LogLevel</span> {</span></span><br><span class="line">    DEBUG,  <span class="comment">// 调试日志信息</span></span><br><span class="line">    INFO,   <span class="comment">// 普通日志信息</span></span><br><span class="line">    WARN,   <span class="comment">// 警告日志信息</span></span><br><span class="line">    ERROR,  <span class="comment">// 错误日志信息</span></span><br><span class="line">    FATAL   <span class="comment">// 致命错误信息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LogMessage</span> {</span></span><br><span class="line">    LogLevel logLevel_;       <span class="comment">// 日志级别</span></span><br><span class="line">    std::string logContent_;  <span class="comment">// 日志内容</span></span><br><span class="line">    <span class="keyword">int</span> threadId_;            <span class="comment">// 打印日志的线程的 ID</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志类（单例模式）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Logger&amp; <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出日志信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别</span></span><br><span class="line">    <span class="function">LogLevel <span class="title">getLogLevel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLogLevel</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别的名称</span></span><br><span class="line">    <span class="function">std::string <span class="title">logLevelToString</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line"></span><br><span class="line">    LogLevel logLevel_;  <span class="comment">// 记录日志级别</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Logger.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Timestamp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏（设置 Debug 模式）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMUDUO_DEBUG</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> kIsDebugMode = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> kIsDebugMode = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏（跨平台获取当前调用的函数名称）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__GNUC__) || defined(__clang__)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FUNC_NAME __PRETTY_FUNCTION__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FUNC_NAME __FUNCSIG__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FUNC_NAME __func__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Logger::<span class="built_in">Logger</span>() {</span><br><span class="line">    <span class="comment">// 设置默认的日志级别</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;logLevel_ = !kIsDebugMode ? INFO : DEBUG;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Logger::~<span class="built_in">Logger</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::instance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出日志信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span> </span>{</span><br><span class="line">    <span class="comment">// 首先在外面构建好完整的字符串（避免多次 &lt;&lt; 竞争）</span></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; Timestamp::<span class="built_in">now</span>().<span class="built_in">toString</span>() &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; message.threadId_ &lt;&lt; <span class="string">" ["</span> &lt;&lt; <span class="built_in">logLevelToString</span>(message.logLevel_)</span><br><span class="line">        &lt;&lt; <span class="string">"] "</span> &lt;&lt; message.logContent_ &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    std::string s = oss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后一次性写入，不使用 std::endl（避免隐式 flush）</span></span><br><span class="line">    std::<span class="built_in">fwrite</span>(s.<span class="built_in">data</span>(), <span class="number">1</span>, s.<span class="built_in">size</span>(), stdout);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::setLogLevel</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;logLevel_ = level;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别</span></span><br><span class="line"><span class="function">LogLevel <span class="title">Logger::getLogLevel</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;logLevel_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别的名称</span></span><br><span class="line"><span class="function">std::string <span class="title">Logger::logLevelToString</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (level) {</span><br><span class="line">        <span class="keyword">case</span> DEBUG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DEBUG"</span>;</span><br><span class="line">        <span class="keyword">case</span> INFO:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"INFO"</span>;</span><br><span class="line">        <span class="keyword">case</span> WARN:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"WARN"</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">        <span class="keyword">case</span> FATAL:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"FATAL"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"UNKNOWN"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h3><ul><li><code>Timestamp.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"copyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timestamp</span> :</span> <span class="keyword">public</span> copyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数，初始化为 0 微秒</span></span><br><span class="line">    <span class="built_in">Timestamp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用微秒数进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timestamp</span><span class="params">(<span class="keyword">int64_t</span> microSecondsSinceEpochArg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间戳转换为字符串表示（比如 2025-11-16 17:45:30）</span></span><br><span class="line">    <span class="function">std::string <span class="title">toString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Timestamp <span class="title">now</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int64_t</span> microSecondsSinceEpoch_;  <span class="comment">// 自纪元（1970年1月1日）以来的微秒数</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Timestamp.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Timestamp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数，初始化为 0 微秒</span></span><br><span class="line">Timestamp::<span class="built_in">Timestamp</span>()</span><br><span class="line">    : <span class="built_in">microSecondsSinceEpoch_</span>(<span class="number">0</span>){</span><br><span class="line"></span><br><span class="line">      };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，使用微秒数进行初始化</span></span><br><span class="line">Timestamp::<span class="built_in">Timestamp</span>(<span class="keyword">int64_t</span> microSecondsSinceEpochArg)</span><br><span class="line">    : <span class="built_in">microSecondsSinceEpoch_</span>(microSecondsSinceEpochArg){</span><br><span class="line"></span><br><span class="line">      };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间戳转换为字符串表示（比如 2025-11-16 17:45:30）</span></span><br><span class="line"><span class="function">std::string <span class="title">Timestamp::toString</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = {<span class="number">0</span>};</span><br><span class="line">    tm *tm_time = <span class="built_in">localtime</span>(&amp;microSecondsSinceEpoch_);</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="number">128</span>, <span class="string">"%4d-%02d-%02d %02d:%02d:%02d"</span>, tm_time-&gt;tm_year + <span class="number">1900</span>, tm_time-&gt;tm_mon + <span class="number">1</span>, tm_time-&gt;tm_mday,</span><br><span class="line">             tm_time-&gt;tm_hour, tm_time-&gt;tm_min, tm_time-&gt;tm_sec);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间戳</span></span><br><span class="line"><span class="function">Timestamp <span class="title">Timestamp::now</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Timestamp</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><ul><li><code>InetAddress.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"copyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络地址类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InetAddress</span> :</span> <span class="keyword">public</span> copyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InetAddress</span><span class="params">(<span class="keyword">uint16_t</span> port = <span class="number">0</span>, std::string ip = <span class="string">"127.0.0.1"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InetAddress</span><span class="params">(<span class="keyword">const</span> sockaddr_in&amp; addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 IP 地址字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">toIp</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 IP 地址和端口号字符串（比如 127.0.0.1:8080）</span></span><br><span class="line">    <span class="function">std::string <span class="title">toIpPort</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取端口号</span></span><br><span class="line">    <span class="function"><span class="keyword">uint16_t</span> <span class="title">toPort</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取底层的 sockaddr_in 结构体指针</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> sockaddr_in* <span class="title">getSockAddr</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置底层的 sockaddr_in 结构体</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSockAddr</span><span class="params">(<span class="keyword">const</span> sockaddr_in&amp; addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sockaddr_in addr_;  <span class="comment">// 底层的 sockaddr_in 结构体</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>InetAddress.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InetAddress.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">InetAddress::<span class="built_in">InetAddress</span>(<span class="keyword">uint16_t</span> port, std::string ip) {</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr_, <span class="keyword">sizeof</span> addr_);</span><br><span class="line">    addr_.sin_family = AF_INET;</span><br><span class="line">    addr_.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    addr_.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">InetAddress::<span class="built_in">InetAddress</span>(<span class="keyword">const</span> sockaddr_in&amp; addr) {</span><br><span class="line">    <span class="keyword">this</span>-&gt;addr_ = addr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 IP 地址字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">InetAddress::toIp</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">    ::<span class="built_in">inet_ntop</span>(AF_INET, &amp;addr_.sin_addr, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 IP 地址和端口号字符串（比如 127.0.0.1:8080）</span></span><br><span class="line"><span class="function">std::string <span class="title">InetAddress::toIpPort</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">    ::<span class="built_in">inet_ntop</span>(AF_INET, &amp;addr_.sin_addr, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">size_t</span> end = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">uint16_t</span> port = <span class="built_in">ntohs</span>(addr_.sin_port);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf + end, <span class="string">":%u"</span>, port);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取端口号</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">InetAddress::toPort</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ntohs</span>(addr_.sin_port);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取底层的 sockaddr_in 结构体指针</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> sockaddr_in* <span class="title">InetAddress::getSockAddr</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> &amp;addr_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置底层的 sockaddr_in 结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InetAddress::setSockAddr</span><span class="params">(<span class="keyword">const</span> sockaddr_in&amp; addr)</span> </span>{</span><br><span class="line">    addr_ = addr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="SocketsOps"><a href="#SocketsOps" class="headerlink" title="SocketsOps"></a>SocketsOps</h3><ul><li><code>SocketsOps.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建非阻塞的 Socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createNonblockingSocket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Socket 错误码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSocketError</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为自连接</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSelfConnect</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本端地址</span></span><br><span class="line"><span class="function">sockaddr_in <span class="title">getLocalAddr</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对端地址</span></span><br><span class="line"><span class="function">sockaddr_in <span class="title">getPeerAddr</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>SocketsOps.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SocketsOps.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建非阻塞的 Socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createNonblockingSocket</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sockfd = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; create nonblock sockfd failed, errno:%d"</span>, __PRETTY_FUNCTION__, errno);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Socket 错误码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSocketError</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> optval;</span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="keyword">sizeof</span> optval;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockopt</span>(sockfd, SOL_SOCKET, SO_ERROR, &amp;optval, &amp;optlen) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> optval;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本端地址</span></span><br><span class="line"><span class="function">sockaddr_in <span class="title">getLocalAddr</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>{</span><br><span class="line">    sockaddr_in localaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;localaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(localaddr));</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(localaddr);</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)(&amp;localaddr), &amp;addrlen) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; get socket name failed, errno:%d"</span>, __PRETTY_FUNCTION__, errno);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> localaddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对端地址</span></span><br><span class="line"><span class="function">sockaddr_in <span class="title">getPeerAddr</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>{</span><br><span class="line">    sockaddr_in peeraddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;peeraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(peeraddr));</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(peeraddr);</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getpeername</span>(sockfd, (sockaddr*)(&amp;peeraddr), &amp;addrlen) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; get peer name failed, errno:%d"</span>, __PRETTY_FUNCTION__, errno);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> peeraddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为自连接</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSelfConnect</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>{</span><br><span class="line">    sockaddr_in localaddr;</span><br><span class="line">    sockaddr_in peeraddr;</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(sockaddr_in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本端地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;localaddr, &amp;addrlen) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对端地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getpeername</span>(sockfd, (sockaddr*)&amp;peeraddr, &amp;addrlen) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须都是 IPv4</span></span><br><span class="line">    <span class="keyword">if</span> (localaddr.sin_family != AF_INET || peeraddr.sin_family != AF_INET) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 IP + 端口是否完全相同</span></span><br><span class="line">    <span class="keyword">return</span> (localaddr.sin_port == peeraddr.sin_port) &amp;&amp; (localaddr.sin_addr.s_addr == peeraddr.sin_addr.s_addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul><li><code>Channel.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Timestamp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Channel 可以理解为通道，封装了 socket fd 和其感兴趣的 event（事件），比如 EPOLLIN、EPOLLOUT 事件，还绑定了 Poller，返回的具体事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 事件回调函数类型定义</span></span><br><span class="line">    <span class="keyword">using</span> EventCallback = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读事件的回调函数类型定义</span></span><br><span class="line">    <span class="keyword">using</span> ReadEventCallback = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(Timestamp)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Channel</span>(EventLoop* loop, <span class="keyword">int</span> fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd 得到 poller 通知以后，处理事件的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 设置事件的回调操作 **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReadCallback</span><span class="params">(ReadEventCallback cb)</span> </span>{</span><br><span class="line">        readCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteCallback</span><span class="params">(EventCallback cb)</span> </span>{</span><br><span class="line">        writeCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCloseCallback</span><span class="params">(EventCallback cb)</span> </span>{</span><br><span class="line">        closeCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setErrorCallback</span><span class="params">(EventCallback cb)</span> </span>{</span><br><span class="line">        errorCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 获取和设置 fd 和 events **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 socket 的 fd</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> fd_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 fd 感兴趣的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">events</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> events_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 fd 上发生的具体事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_revents</span><span class="params">(<span class="keyword">int</span> revent)</span> </span>{</span><br><span class="line">        revents_ = revent;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 设置 fd 相应的事件状态 **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启监听 fd 上的读事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>{</span><br><span class="line">        events_ |= kReadEvent;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听 fd 上的读事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>{</span><br><span class="line">        events_ &amp;= ~kReadEvent;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启监听 fd 上的写事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>{</span><br><span class="line">        events_ |= kWriteEvent;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听 fd 上的写事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>{</span><br><span class="line">        events_ &amp;= ~kWriteEvent;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止监听 fd 上的所有事件（读 + 写）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>{</span><br><span class="line">        events_ = kNoneEvent;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 获取 fd 当前的事件状态 **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前是否没有监听任何事件（既不读也不写）</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNoneEvent</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> events_ == kNoneEvent;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前是否正在监听写事件</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isWriting</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> events_ &amp; kWriteEvent;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前是否正在监听读事件</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isReading</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> events_ &amp; kReadEvent;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前 Channel 在 Poller 中的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> index_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前 Channel 在 Poller 中的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_index</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        index_ = index;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止当 Channel 被手动 remove 掉后，Channel 还在执行事件的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tie</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;<span class="keyword">void</span>&gt;&amp; obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Poller 中删除当前 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 更新 Channel 状态到 Poller 中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理事件，有了 guard 之后，Channel 就不会在被手动 remove 掉后还继续执行事件的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 Channel 支持的事件类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNoneEvent;   <span class="comment">// 无事件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kReadEvent;   <span class="comment">// 读事件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kWriteEvent;  <span class="comment">// 写事件</span></span><br><span class="line"></span><br><span class="line">    EventLoop* loop_;  <span class="comment">// Channel 所属的事件循环</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> fd_;     <span class="comment">// fd，是 Poller 监听的对象</span></span><br><span class="line">    <span class="keyword">int</span> events_;       <span class="comment">// 注册 fd 上感兴趣的事件</span></span><br><span class="line">    <span class="keyword">int</span> revents_;      <span class="comment">// poller 返回的 fd 上具体发生的事件</span></span><br><span class="line">    <span class="keyword">int</span> index_;        <span class="comment">// 标记 Channel 在 Poller 中的状态</span></span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;<span class="keyword">void</span>&gt; tie_;  <span class="comment">// 用于防止 Channel 被手动 remove 掉后，Channel 还在执行事件的回调操作</span></span><br><span class="line">    <span class="keyword">bool</span> tied_;                <span class="comment">// 标记是否已绑定 tie_</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Channel 里面能够获知 fd 上最终发生的具体事件（revents_），所以由它负责调用具体事件的回调操作（即事件分发）</span></span><br><span class="line">    ReadEventCallback readCallback_;  <span class="comment">// 读事件的回调函数</span></span><br><span class="line">    EventCallback writeCallback_;     <span class="comment">// 写事件的回调函数</span></span><br><span class="line">    EventCallback closeCallback_;     <span class="comment">// 关闭事件的回调函数</span></span><br><span class="line">    EventCallback errorCallback_;     <span class="comment">// 错误事件的回调函数</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Channel.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Channel.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Channel 支持的事件类型（与 Epoll 兼容）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Channel::kNoneEvent = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Channel::kReadEvent = EPOLLIN | EPOLLPRI;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Channel::kWriteEvent = EPOLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Channel::<span class="built_in">Channel</span>(EventLoop* loop, <span class="keyword">int</span> fd) : <span class="built_in">loop_</span>(loop), <span class="built_in">fd_</span>(fd), <span class="built_in">events_</span>(<span class="number">0</span>), <span class="built_in">revents_</span>(<span class="number">0</span>), <span class="built_in">index_</span>(<span class="number">-1</span>), <span class="built_in">tied_</span>(<span class="literal">false</span>) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Channel::~<span class="built_in">Channel</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止当 Channel 被手动 remove 掉后，Channel 还在执行事件的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;<span class="keyword">void</span>&gt;&amp; obj)</span> </span>{</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Poller 中删除当前 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::remove</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 通过 Channel 所属的 EventLoop，将当前的 Channel 删除掉</span></span><br><span class="line">    loop_-&gt;<span class="built_in">removeChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 Channel 状态到 Poller 中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::update</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 通过 Channel 所属的 EventLoop，调用 Poller 相应的方法，注册 fd 的感兴趣的事件（events_）</span></span><br><span class="line">    loop_-&gt;<span class="built_in">updateChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd 得到 poller 通知以后，处理事件的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tied_) {</span><br><span class="line">        std::shared_ptr&lt;<span class="keyword">void</span>&gt; guad = tie_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (guad) {</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理事件，有了 guard 之后，Channel 就不会在被手动 remove 掉后还继续执行事件的回调操作了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * EPOLLIN：可读，文件描述符有数据可读且读取不会阻塞（如 socket 或 pipe 有数据）。</span></span><br><span class="line"><span class="comment"> * EPOLLOUT：可写，文件描述符可以写入且不会阻塞（如 socket 可发送数据、pipe 可写入）。</span></span><br><span class="line"><span class="comment"> * EPOLLERR：错误，文件描述符发生错误，无法正常读写（如 TCP reset、I/O 错误）。</span></span><br><span class="line"><span class="comment"> * EPOLLHUP：挂断，文件描述符被挂断（如对端关闭连接）。注意：通常与 EPOLLIN 一起出现。</span></span><br><span class="line"><span class="comment"> * EPOLLPRI：紧急数据，文件描述符有优先数据（TCP OOB 或特殊设备的紧急数据）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span> </span>{</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"channel handle event, revents: %d"</span>, revents_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生挂断事件且没有读事件发生</span></span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; EPOLLHUP) &amp;&amp; !(revents_ &amp; EPOLLIN)) {</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_) {</span><br><span class="line">            <span class="built_in">closeCallback_</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生错误事件</span></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; EPOLLERR) {</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_) {</span><br><span class="line">            <span class="built_in">errorCallback_</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生读事件</span></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (EPOLLIN | EPOLLPRI | EPOLLHUP)) {</span><br><span class="line">        <span class="keyword">if</span> (readCallback_) {</span><br><span class="line">            <span class="built_in">readCallback_</span>(receiveTime);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生写事件</span></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; EPOLLOUT) {</span><br><span class="line">        <span class="keyword">if</span> (writeCallback_) {</span><br><span class="line">            <span class="built_in">writeCallback_</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h3><ul><li><code>Poller.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Timestamp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * I/O 多路复用器抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poller</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Channel 列表类型定义</span></span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Poller</span>(EventLoop* loop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Poller</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 统一定义所有 I/O 多路复用器的接口 **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听就绪事件，返回活跃的 Channel 列表</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="keyword">int</span> timeoutMs, ChannelList* activeChannels)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel* channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel* channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 Poller 中是否存在某个 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasChannel</span><span class="params">(Channel* channel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 创建 I/O 多路复用器实例 **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Poller* <span class="title">newDefaultPoller</span><span class="params">(EventLoop* loop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Channel 集合的类型定义，key 是 fd，而 value 是 fd 所属的 Channel</span></span><br><span class="line">    <span class="keyword">using</span> ChannelMap = std::unordered_map&lt;<span class="keyword">int</span>, Channel*&gt;;</span><br><span class="line"></span><br><span class="line">    ChannelMap channels_;  <span class="comment">// 保存所有的 Channel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop* owerLoop_;  <span class="comment">// Poller 所属的事件循环</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Poller.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Poller.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Channel.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Poller::<span class="built_in">Poller</span>(EventLoop* loop) : <span class="built_in">owerLoop_</span>(loop) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚析构函数</span></span><br><span class="line">Poller::~<span class="built_in">Poller</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 Poller 中是否存在某个 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Poller::hasChannel</span><span class="params">(Channel* channel)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> iterator = channels_.<span class="built_in">find</span>(channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    <span class="keyword">return</span> iterator != channels_.<span class="built_in">end</span>() &amp;&amp; iterator-&gt;second == channel;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>DefaultPoller.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EPollPoller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Poller.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建默认的 I/O 多路复用器</span></span><br><span class="line"><span class="function">Poller* <span class="title">Poller::newDefaultPoller</span><span class="params">(EventLoop* loop)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getenv</span>(<span class="string">"MYMUDUO_USE_POLL"</span>)) {</span><br><span class="line">        <span class="comment">// 创建 Poll 的实例</span></span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"not support poll, only support epoll"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 创建 Epoll 的实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EPollPoller</span>(loop);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Epoller"><a href="#Epoller" class="headerlink" title="Epoller"></a>Epoller</h3><ul><li><code>EPollPoller.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Poller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Timestamp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 Epoll 的 I/O 多路复用器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollPoller</span> :</span> <span class="keyword">public</span> Poller {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">EPollPoller</span>(EventLoop* loop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">EPollPoller</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听就绪事件，返回活跃的 Channel 列表</span></span><br><span class="line">    <span class="function">Timestamp <span class="title">poll</span><span class="params">(<span class="keyword">int</span> timeoutMs, ChannelList* activeChannels)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel* channel)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel* channel)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Epoll 事件列表的初始大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kInitEventListSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充活跃的 Channel 列表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fillActiveChannels</span><span class="params">(<span class="keyword">int</span> numEvents, ChannelList* activeChannels)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 Channel，其中 operation 参数的值有以下几种</span></span><br><span class="line"><span class="comment">     * EPOLL_CTL_ADD   添加 fd 到 Epoll 实例</span></span><br><span class="line"><span class="comment">     * EPOLL_CTL_DEL   从 Epoll 实例中删除 fd</span></span><br><span class="line"><span class="comment">     * EPOLL_CTL_MOD   修改 fd 的监听事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> operation, Channel* channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Epoll 事件列表类型定义</span></span><br><span class="line">    <span class="keyword">using</span> EventList = std::vector&lt;::epoll_event&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epollfd_;       <span class="comment">// Epoll 文件描述符（Epoll 监听的对象）</span></span><br><span class="line">    EventList events_;  <span class="comment">// Epoll 事件列表</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>EPollPoller.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EPollPoller.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Channel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"error.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Epoll 事件列表的初始大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> EPollPoller::kInitEventListSize = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Channel 在 Epoll 中的状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNew = <span class="number">-1</span>;     <span class="comment">// 新创建的 Channel</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kAdded = <span class="number">1</span>;    <span class="comment">// 已经添加到 Epoll 中的 Channel</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDeleted = <span class="number">2</span>;  <span class="comment">// 已经从 Epoll 中移除的 Channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">EPollPoller::<span class="built_in">EPollPoller</span>(EventLoop* loop)</span><br><span class="line">    : <span class="built_in">Poller</span>(loop), <span class="built_in">epollfd_</span>(::<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC)), <span class="built_in">events_</span>(kInitEventListSize) {</span><br><span class="line">    <span class="comment">// 如果创建 Epoll 文件描述符失败，则记录日志并终止程序</span></span><br><span class="line">    <span class="keyword">if</span> (epollfd_ &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; epoll_create1() error:%d"</span>, __PRETTY_FUNCTION__, errno);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">EPollPoller::~<span class="built_in">EPollPoller</span>() {</span><br><span class="line">    <span class="comment">// 关闭 Epoll 文件描述符</span></span><br><span class="line">    ::<span class="built_in">close</span>(epollfd_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听就绪事件，返回活跃的 Channel 列表</span></span><br><span class="line"><span class="function">Timestamp <span class="title">EPollPoller::poll</span><span class="params">(<span class="keyword">int</span> timeoutMs, ChannelList* activeChannels)</span> </span>{</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; fd total count:%lu"</span>, __PRETTY_FUNCTION__, channels_.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听就绪事件，会阻塞当前线程，超时等待返回 0（表示本次等待期间没有任何就绪事件发生）</span></span><br><span class="line">    <span class="keyword">int</span> numEvents = ::<span class="built_in">epoll_wait</span>(epollfd_, &amp;*events_.<span class="built_in">begin</span>(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存错误码</span></span><br><span class="line">    <span class="keyword">int</span> savedErrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有就绪事件发生</span></span><br><span class="line">    <span class="keyword">if</span> (numEvents &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; epoll happend %d events"</span>, __PRETTY_FUNCTION__, numEvents);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充活跃的 Channel 列表</span></span><br><span class="line">        <span class="built_in">fillActiveChannels</span>(numEvents, activeChannels);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果本次监听返回的就绪事件数量等于当前 Epoll 事件列表的大小，则将 Epoll 事件列表的容量扩大一倍</span></span><br><span class="line">        <span class="keyword">if</span> (numEvents == events_.<span class="built_in">size</span>()) {</span><br><span class="line">            events_.<span class="built_in">resize</span>(events_.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果监听超时没有任何就绪事件发生</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (numEvents == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; epoll wait timeout, nothing happened"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果监听出错</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 只有在错误码不是 EINTR（系统调用被中断）时，才记录错误日志</span></span><br><span class="line">        <span class="keyword">if</span> (savedErrno != EINTR) {</span><br><span class="line">            <span class="comment">// 恢复错误码</span></span><br><span class="line">            errno = savedErrno;</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; epoll wait error"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充活跃的 Channel 列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPollPoller::fillActiveChannels</span><span class="params">(<span class="keyword">int</span> numEvents, ChannelList* activeChannels)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历所有就绪的事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numEvents; ++i) {</span><br><span class="line">        <span class="comment">// 获取就绪的 Channel</span></span><br><span class="line">        Channel* channel = <span class="keyword">static_cast</span>&lt;Channel*&gt;(events_[i].data.ptr);</span><br><span class="line">        <span class="comment">// 设置 Channel 上发生的具体事件</span></span><br><span class="line">        channel-&gt;<span class="built_in">set_revents</span>(events_[i].events);</span><br><span class="line">        <span class="comment">// 将就绪的 Channel 添加到活跃的 Channel 列表中</span></span><br><span class="line">        activeChannels-&gt;<span class="built_in">push_back</span>(channel);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPollPoller::updateChannel</span><span class="params">(Channel* channel)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 Channel 在 Epoll 中的状态</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; fd=%d events=%d index=%d"</span>, __PRETTY_FUNCTION__, channel-&gt;<span class="built_in">fd</span>(), channel-&gt;<span class="built_in">events</span>(), index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == kNew || index == kDeleted) {</span><br><span class="line">        <span class="keyword">if</span> (index == kNew) {</span><br><span class="line">            <span class="comment">// 获取 socket 的 fd</span></span><br><span class="line">            <span class="keyword">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">            <span class="comment">// 将 Channel 添加到 Channel 集合中</span></span><br><span class="line">            channels_[fd] = channel;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 更新 Channel 在 Epoll 中的状态</span></span><br><span class="line">        channel-&gt;<span class="built_in">set_index</span>(kAdded);</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_ADD, channel);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 获取 socket 的 fd</span></span><br><span class="line">        <span class="keyword">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">        <span class="comment">// 如果当前没有任何事件感兴趣，则将 Channel 从 Epoll 中删除</span></span><br><span class="line">        <span class="keyword">if</span> (channel-&gt;<span class="built_in">isNoneEvent</span>()) {</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">            channel-&gt;<span class="built_in">set_index</span>(kDeleted);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则，更新 Channel 的状态</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_MOD, channel);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPollPoller::update</span><span class="params">(<span class="keyword">int</span> operation, Channel* channel)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 socket 的 fd</span></span><br><span class="line">    <span class="keyword">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Epoll 事件</span></span><br><span class="line">    ::epoll_event event;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;event, <span class="keyword">sizeof</span> event);</span><br><span class="line">    event.data.ptr = channel;</span><br><span class="line">    event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 fd 相应的 Epoll 事件（使用 Channel 中记录的 interests）</span></span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">epoll_ctl</span>(epollfd_, operation, fd, &amp;event) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (operation == EPOLL_CTL_DEL) {</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"epoll_ctl delete error:%d"</span>, errno);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">LOG_FATAL</span>(<span class="string">"epoll_ctl add or mod error:%d"</span>, errno);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPollPoller::removeChannel</span><span class="params">(Channel* channel)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 socket 的 fd</span></span><br><span class="line">    <span class="keyword">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Channel 集合中将 fd 对应的 Channel 移除掉</span></span><br><span class="line">    channels_.<span class="built_in">erase</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; fd=%d"</span>, __PRETTY_FUNCTION__, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Channel 在 Epoll 中的状态</span></span><br><span class="line">    <span class="keyword">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">    <span class="keyword">if</span> (index == kAdded) {</span><br><span class="line">        <span class="comment">// 更新 Channel</span></span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 Channel 在 Epoll 中的状态</span></span><br><span class="line">    channel-&gt;<span class="built_in">set_index</span>(kNew);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><ul><li><code>EventLoop.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Timestamp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poller</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 回调函数类型定义</span></span><br><span class="line">    <span class="keyword">using</span> Functor = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启事件循环</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出事件循环</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Poller 返回发生事件的时间点</span></span><br><span class="line">    <span class="function">Timestamp <span class="title">pollReturnTime</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前 EventLoop 所在的线程执行回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将回调操作添加到队列中，唤醒 EventLoop 所在的线程执行回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queueInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒 EventLoop 所在的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 EventLoop 中是否存在某个 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前线程是否是 EventLoop 所在的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInLoopThread</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程不是 EventLoop 所在的线程，则触发断言失败</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertInLoopThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程不是 EventLoop 所在的线程，则中止程序运行</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">abortNotInLoopThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 处理 Wakeup Channel 的读事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行当前 EventLoop 需要执行的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPendingFunctors</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Channel 列表的类型定义</span></span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line"></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> looping_;  <span class="comment">// 事件循环状态</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> quit_;     <span class="comment">// 标识退出 EventLoop 循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">pid_t</span> threadId_;            <span class="comment">// 记录当前 EventLoop 所在的线程的 ID</span></span><br><span class="line">    Timestamp pollReturnTime_;        <span class="comment">// 记录 Poller 返回发生事件的时间点</span></span><br><span class="line">    std::unique_ptr&lt;Poller&gt; poller_;  <span class="comment">// EventLoop 使用的 Poller（I/O 多路复用器）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeupFd_;                            <span class="comment">// 用于唤醒 EventLoop 所在的线程的 fd</span></span><br><span class="line">    std::unique_ptr&lt;Channel&gt; wakeupChannel_;  <span class="comment">// 用于唤醒 EventLoop 所在的线程的 Channel</span></span><br><span class="line"></span><br><span class="line">    ChannelList activeChannels_;  <span class="comment">// 保存 Poller 返回的活跃的 Channel 列表</span></span><br><span class="line"></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> callingPendingFunctors_;  <span class="comment">// 标识当前 EventLoop 是否正在执行回调操作</span></span><br><span class="line">    std::vector&lt;Functor&gt; pendingFunctors_;     <span class="comment">// 保存当前 EventLoop 需要执行的所有回调操作</span></span><br><span class="line">    std::mutex mutex_;                         <span class="comment">// 保证 pendingFunctors_ 容器线程安全的互斥锁</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>EventLoop.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoop.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Channel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CurrentThread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Poller.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程局部变量（thread-local），用于防止一个线程创建多个 EventLoop</span></span><br><span class="line">__thread EventLoop* t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Poller（I/O 多路复用器）的默认超时时间，比如 10 秒</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kPollTimeMs = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 wakeupFd，用来 Notify（唤醒）SubReactor 处理新来的 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createEventFd</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> evtfd = ::<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (evtfd &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; eventfd error:%d"</span>, __PRETTY_FUNCTION__, errno);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> evtfd;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">EventLoop::<span class="built_in">EventLoop</span>()</span><br><span class="line">    : <span class="built_in">looping_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">quit_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">callingPendingFunctors_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">threadId_</span>(CurrentThread::<span class="built_in">tid</span>()),</span><br><span class="line">      <span class="built_in">poller_</span>(Poller::<span class="built_in">newDefaultPoller</span>(<span class="keyword">this</span>)),</span><br><span class="line">      <span class="built_in">wakeupFd_</span>(<span class="built_in">createEventFd</span>()),</span><br><span class="line">      <span class="built_in">wakeupChannel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(<span class="keyword">this</span>, wakeupFd_)) {</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; EventLoop created %p in thread %d"</span>, __PRETTY_FUNCTION__, <span class="keyword">this</span>, threadId_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止一个线程创建多个 EventLoop</span></span><br><span class="line">    <span class="keyword">if</span> (t_loopInThisThread) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; Another EventLoop existed in this thread %d"</span>, __PRETTY_FUNCTION__, threadId_);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 将当前 EventLoop 对象赋值给线程局部变量</span></span><br><span class="line">        t_loopInThisThread = <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Wakeup Channel 的读事件回调函数</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 Wakeup Channel 的读事件监听</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">enableReading</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">EventLoop::~<span class="built_in">EventLoop</span>() {</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; EventLoop %p of thread %d destructs in thread"</span>, __PRETTY_FUNCTION__, <span class="keyword">this</span>, CurrentThread::<span class="built_in">tid</span>());</span><br><span class="line">    <span class="comment">// 关闭 Wakeup Channel</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line">    <span class="comment">// 移除 Wakeup Channel</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">remove</span>();</span><br><span class="line">    <span class="comment">// 关闭 wakeupFd_</span></span><br><span class="line">    ::<span class="built_in">close</span>(wakeupFd_);</span><br><span class="line">    <span class="comment">// 重置线程局部变量</span></span><br><span class="line">    t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 标记事件循环开始</span></span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记退出事件循环的状态</span></span><br><span class="line">    quit_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; EventLoop %p start looping"</span>, __PRETTY_FUNCTION__, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!quit_) {</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// Poller 会阻塞监听有哪些 Channel 发生了事件，然后上报给 EventLoop，通知 Channel 处理相应的事件</span></span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">        <span class="keyword">for</span> (Channel* channel : activeChannels_) {</span><br><span class="line">            channel-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 执行当前 EventLoop 需要处理的回调操作</span></span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; EventLoop %p stop looping"</span>, __PRETTY_FUNCTION__, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记事件循环结束</span></span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::quit</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 标记退出事件循环的状态</span></span><br><span class="line">    quit_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是在当前 EventLoop 所在的线程上调用的 quit() 方法，则需要唤醒 EventLoop 所在的线程</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>()) {</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒 EventLoop 所在的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 向 wakeupFd_ 写一个数据，wakeupChannel_ 就会发生读事件，当前的 EventLoop 就会被唤醒</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n = ::<span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"%s write %zd bytes instead of 8"</span>, __PRETTY_FUNCTION__, n);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Poller 返回发生事件的时间点</span></span><br><span class="line"><span class="function">Timestamp <span class="title">EventLoop::pollReturnTime</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> pollReturnTime_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前线程是否是 EventLoop 所在的线程</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventLoop::isInLoopThread</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> threadId_ == CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前线程不是 EventLoop 所在的线程，则触发断言失败</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::assertInLoopThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>()) {</span><br><span class="line">        <span class="built_in">abortNotInLoopThread</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前线程不是 EventLoop 所在的线程，则中止程序运行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::abortNotInLoopThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; EventLoop %p was created in threadId_ = %d, current thread id = %d"</span>, __PRETTY_FUNCTION__, <span class="keyword">this</span>,</span><br><span class="line">              threadId_, CurrentThread::<span class="built_in">tid</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前 EventLoop 所在的线程上执行回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果在 EventLoop 所在的线程上执行回调操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isInLoopThread</span>()) {</span><br><span class="line">        <span class="comment">// 则直接执行回调操作</span></span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 否则，将回调操作添加到队列中，并唤醒 EventLoop 所在的线程执行回调操作</span></span><br><span class="line">        <span class="built_in">queueInLoop</span>(std::<span class="built_in">move</span>(cb));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将回调操作添加到队列中，并唤醒 EventLoop 所在的线程执行回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span> </span>{</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 将回调操作添加到队列中（需要保证线程安全）</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是在当前 EventLoop 所在的线程上执行回调操作，或者当前 EventLoop 正在执行回调操作</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_) {</span><br><span class="line">        <span class="comment">// 则唤醒当前 EventLoop 所在的线程去执行回调操作</span></span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel* channel)</span> </span>{</span><br><span class="line">    poller_-&gt;<span class="built_in">updateChannel</span>(channel);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::removeChannel</span><span class="params">(Channel* channel)</span> </span>{</span><br><span class="line">    poller_-&gt;<span class="built_in">removeChannel</span>(channel);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 EventLoop 中是否存在某个 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel* channel)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;<span class="built_in">hasChannel</span>(channel);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 Wakeup Channel 的读事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = ::<span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"%s reads %zd bytes instead of 8"</span>, __PRETTY_FUNCTION__, n);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行当前 EventLoop 需要执行的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记当前 EventLoop 正在执行回调操作</span></span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="comment">// 将需要执行的回调操作交换到局部变量 functors 中，以减少锁的持有时间，提高运行效率</span></span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行当前 EventLoop 需要执行的回调操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Functor&amp; functor : functors) {</span><br><span class="line">        <span class="built_in">functor</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记当前 EventLoop 已经执行完回调操作</span></span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><ul><li><code>Thread.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程执行函数的类型定义</span></span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(ThreadFunc func, <span class="keyword">const</span> std::string&amp; name = std::string())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行结束</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程 ID</span></span><br><span class="line">    <span class="function"><span class="keyword">pid_t</span> <span class="title">tid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程名称</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取已创建的线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numCreated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 设置线程的默认名称</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDefaultName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> started_;                         <span class="comment">// 标记线程是否已启动</span></span><br><span class="line">    <span class="keyword">bool</span> joined_;                          <span class="comment">// 标记线程是否已经 join，防止重复 join 或析构时未 join</span></span><br><span class="line">    std::shared_ptr&lt;std::thread&gt; thread_;  <span class="comment">// 线程对象</span></span><br><span class="line">    <span class="keyword">pid_t</span> tid_;                            <span class="comment">// 线程 ID</span></span><br><span class="line">    ThreadFunc func_;                      <span class="comment">// 线程执行函数</span></span><br><span class="line">    std::string name_;                     <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="keyword">static</span> std::<span class="keyword">atomic_int</span> numCreated_;    <span class="comment">// 已创建的线程数量</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Thread.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Thread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CurrentThread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="keyword">atomic_int</span> <span class="title">Thread::numCreated_</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func, <span class="keyword">const</span> std::string&amp; name)</span><br><span class="line">    : <span class="built_in">started_</span>(<span class="literal">false</span>), <span class="built_in">joined_</span>(<span class="literal">false</span>), <span class="built_in">tid_</span>(<span class="number">0</span>), <span class="built_in">func_</span>(std::<span class="built_in">move</span>(func)), <span class="built_in">name_</span>(name) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() {</span><br><span class="line">    <span class="comment">// 如果线程已启动且未被 join</span></span><br><span class="line">    <span class="keyword">if</span> (started_ &amp;&amp; !joined_) {</span><br><span class="line">        <span class="comment">// 设置分离线程（避免资源泄露）</span></span><br><span class="line">        thread_-&gt;<span class="built_in">detach</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 标记线程为已启动</span></span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动新的线程</span></span><br><span class="line">    thread_ = std::shared_ptr&lt;std::thread&gt;(<span class="keyword">new</span> std::<span class="built_in">thread</span>([&amp;]() {</span><br><span class="line">        <span class="comment">// 获取新线程的 ID</span></span><br><span class="line">        tid_ = CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知主线程已获取新线程的 ID</span></span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新线程执行线程函数</span></span><br><span class="line">        <span class="built_in">func_</span>();</span><br><span class="line">    }));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待新线程获取线程 ID</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程执行结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::join</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果线程已启动且未被 join</span></span><br><span class="line">    <span class="keyword">if</span> (started_ &amp;&amp; !joined_) {</span><br><span class="line">        <span class="comment">// 标记线程已 join</span></span><br><span class="line">        joined_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 等待线程执行结束</span></span><br><span class="line">        thread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程 ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">Thread::tid</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> tid_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">Thread::name</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取已创建的线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread::numCreated</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> numCreated_.<span class="built_in">load</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程的默认名称</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::setDefaultName</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> num = ++numCreated_;</span><br><span class="line">    <span class="keyword">if</span> (name_.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"Thread%d"</span>, num);</span><br><span class="line">        name_ = buf;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="CurrentThread"><a href="#CurrentThread" class="headerlink" title="CurrentThread"></a>CurrentThread</h3><ul><li><code>CurrentThread.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CurrentThread {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明线程局部变量（thread-local），用于缓存当前线程的 ID</span></span><br><span class="line">    <span class="keyword">extern</span> __thread <span class="keyword">int</span> t_cachedTid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明缓存当前线程的 ID 的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cacheTid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的 ID</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tid</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(t_cachedTid == <span class="number">0</span>, <span class="number">0</span>)) {</span><br><span class="line">            <span class="built_in">cacheTid</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> t_cachedTid;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>CurrentThread.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CurrentThread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CurrentThread {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义线程局部变量（thread-local），用于缓存当前线程的 ID</span></span><br><span class="line">    __thread <span class="keyword">int</span> t_cachedTid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义缓存当前线程的 ID 的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cacheTid</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (t_cachedTid == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 通过 Linux 系统调用，获取当前线程的 ID</span></span><br><span class="line">            t_cachedTid = <span class="keyword">static_cast</span>&lt;<span class="keyword">pid_t</span>&gt;(::<span class="built_in">syscall</span>(SYS_gettid));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="EventLoopThread"><a href="#EventLoopThread" class="headerlink" title="EventLoopThread"></a>EventLoopThread</h3><ul><li><code>EventLoopThread.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Thread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环线程类，封装了 EventLoop 与 Thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoopThread</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程初始化回调操作的类型定义</span></span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(EventLoop *)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">EventLoopThread</span>(<span class="keyword">const</span> ThreadInitCallback &amp;cb = <span class="built_in">ThreadInitCallback</span>(), <span class="keyword">const</span> std::string &amp;name = std::<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">EventLoopThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在对应的线程中启动事件循环</span></span><br><span class="line">    <span class="function">EventLoop *<span class="title">startLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程执行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;               <span class="comment">// 事件循环</span></span><br><span class="line">    <span class="keyword">bool</span> exiting_;                  <span class="comment">// 标记线程是否正在退出</span></span><br><span class="line">    Thread thread_;                 <span class="comment">// 线程对象（EventLoop 所在的线程）</span></span><br><span class="line">    std::mutex mutex_;              <span class="comment">// 互斥锁</span></span><br><span class="line">    std::condition_variable cond_;  <span class="comment">// 条件变量</span></span><br><span class="line">    ThreadInitCallback callback_;   <span class="comment">// 线程初始化回调操作</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>EventLoopThread.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoopThread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;EventLoop.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">EventLoopThread::<span class="built_in">EventLoopThread</span>(<span class="keyword">const</span> ThreadInitCallback &amp;cb, <span class="keyword">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">exiting_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">thread_</span>(std::<span class="built_in">bind</span>(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>), name),</span><br><span class="line">      <span class="built_in">mutex_</span>(),</span><br><span class="line">      <span class="built_in">cond_</span>(),</span><br><span class="line">      <span class="built_in">callback_</span>(cb) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">EventLoopThread::~<span class="built_in">EventLoopThread</span>() {</span><br><span class="line">    <span class="comment">// 标记线程正在退出</span></span><br><span class="line">    exiting_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loop_ != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// 退出线程循环</span></span><br><span class="line">        loop_-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        <span class="comment">// 等待线程执行结束</span></span><br><span class="line">        thread_.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对应的线程中启动事件循环</span></span><br><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThread::startLoop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 启动底层新创建的线程</span></span><br><span class="line">    thread_.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    EventLoop *loop = <span class="literal">nullptr</span>;</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 等待线程函数 threadFunc() 创建好 EventLoop 对象</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (loop_ == <span class="literal">nullptr</span>) {</span><br><span class="line">            cond_.<span class="built_in">wait</span>(lock);</span><br><span class="line">        }</span><br><span class="line">        loop = loop_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 新创建一个独立的事件循环，和上面底层新创建的线程一一对应</span></span><br><span class="line">    EventLoop loop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行线程初始化回调操作</span></span><br><span class="line">    <span class="keyword">if</span> (callback_) {</span><br><span class="line">        <span class="built_in">callback_</span>(&amp;loop);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 将新创建的事件循环对象赋值给成员变量 loop_，需要保证线程安全</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知 startLoop() 成员函数，成员变量 loop_ 已经赋值完毕</span></span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启事件循环</span></span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件循环退出后，重置成员变量 loop_</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_ = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="EventLoopThreadPool"><a href="#EventLoopThreadPool" class="headerlink" title="EventLoopThreadPool"></a>EventLoopThreadPool</h3><ul><li><code>EventLoopThreadPool.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoopThread</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环线程池类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程初始化回调操作的类型定义</span></span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(EventLoop*)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class="keyword">const</span> std::string&amp; nameArg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">EventLoopThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="keyword">int</span> numThreads)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> ThreadInitCallback&amp; cb = ThreadInitCallback())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个被选中的事件循环（如果工作在多线程中，baseLoop 默认以轮询的方式分配 Channel 给 subLoop）</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getNextLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回所有事件循环</span></span><br><span class="line">    <span class="function">std::vector&lt;EventLoop*&gt; <span class="title">getAllLoops</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回线程池是否已启动</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">started</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回线程池的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop* baseLoop_;  <span class="comment">// 基础事件循环（通常是主线程上的事件循环，也称作 mainLoop）</span></span><br><span class="line">    std::string name_;     <span class="comment">// 线程池名称</span></span><br><span class="line">    <span class="keyword">bool</span> started_;         <span class="comment">// 标记线程池是否已启动</span></span><br><span class="line">    <span class="keyword">int</span> numThreads_;       <span class="comment">// 线程数量</span></span><br><span class="line">    <span class="keyword">int</span> next_;             <span class="comment">// 下一个被选中的事件循环的索引</span></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_;  <span class="comment">// 事件循环线程对象的集合</span></span><br><span class="line">    std::vector&lt;EventLoop*&gt; loops_;                          <span class="comment">// 事件循环对象的集合</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>EventLoopThreadPool.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoopThreadPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoopThread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">EventLoopThreadPool::<span class="built_in">EventLoopThreadPool</span>(EventLoop* baseLoop, <span class="keyword">const</span> std::string&amp; nameArg)</span><br><span class="line">    : <span class="built_in">baseLoop_</span>(baseLoop), <span class="built_in">name_</span>(nameArg), <span class="built_in">started_</span>(<span class="literal">false</span>), <span class="built_in">numThreads_</span>(<span class="number">0</span>), <span class="built_in">next_</span>(<span class="number">0</span>) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">EventLoopThreadPool::~<span class="built_in">EventLoopThreadPool</span>() {</span><br><span class="line">    <span class="comment">// 析构时不需要删除 loop，因为它是栈变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoopThreadPool::setThreadNum</span><span class="params">(<span class="keyword">int</span> numThreads)</span> </span>{</span><br><span class="line">    numThreads_ = numThreads;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="keyword">const</span> ThreadInitCallback&amp; cb)</span> </span>{</span><br><span class="line">    <span class="comment">// 标记线程池已启动</span></span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当整个服务端有多个线程（负责运行一个 baseLoop 和多个 subLoop）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i) {</span><br><span class="line">        <span class="comment">// 拼接线程的名称</span></span><br><span class="line">        std::string tname = name_ + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        <span class="comment">// 创建事件循环线程</span></span><br><span class="line">        EventLoopThread* t = <span class="keyword">new</span> <span class="built_in">EventLoopThread</span>(cb, tname);</span><br><span class="line">        <span class="comment">// 将事件循环线程添加到线程池中</span></span><br><span class="line">        threads_.<span class="built_in">push_back</span>(std::unique_ptr&lt;EventLoopThread&gt;(t));</span><br><span class="line">        <span class="comment">// 启动事件循环线程，并获取该线程对应的事件循环对象，将其添加到事件循环对象的集合中</span></span><br><span class="line">        loops_.<span class="built_in">push_back</span>(t-&gt;<span class="built_in">startLoop</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当整个服务端只有一个线程（负责运行 baseLoop），就执行初始化回调操作</span></span><br><span class="line">    <span class="keyword">if</span> (numThreads_ == <span class="number">0</span> &amp;&amp; cb) {</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个被选中的事件循环（如果工作在多线程中，baseLoop 默认以轮询的方式分配 Channel 给 subLoop）</span></span><br><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThreadPool::getNextLoop</span><span class="params">()</span> </span>{</span><br><span class="line">    EventLoop* loop = baseLoop_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过轮询方式获取一下个处理事件的 EventLoop</span></span><br><span class="line">    <span class="keyword">if</span> (!loops_.<span class="built_in">empty</span>()) {</span><br><span class="line">        loop = loops_[next_];</span><br><span class="line">        ++next_;</span><br><span class="line">        <span class="keyword">if</span> (next_ &gt;= loops_.<span class="built_in">size</span>()) {</span><br><span class="line">            next_ = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回所有事件循环</span></span><br><span class="line"><span class="function">std::vector&lt;EventLoop*&gt; <span class="title">EventLoopThreadPool::getAllLoops</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (loops_.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> std::vector&lt;EventLoop*&gt;(<span class="number">1</span>, baseLoop_);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> loops_;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回线程池是否已启动</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventLoopThreadPool::started</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> started_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回线程池的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">EventLoopThreadPool::name</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul><li><code>Socket.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InetAddress</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 套接字类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Socket</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> sockFd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Socket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 socket 的文件描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bindAddress</span><span class="params">(<span class="keyword">const</span> InetAddress&amp; localaddr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接请求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受连接请求</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(InetAddress* peeraddr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭写入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdownWrite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否开启 TCP_NODELAY，开启后关闭 Nagle 算法，减少延迟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTcpNoDelay</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否开启地址重用，允许端口在短时间内被重复绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReuseAddr</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否开启端口重用，让多个进程/线程可以绑定同一端口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReusePort</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否开启 TCP 保活，用于检测对端是否还存活</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setKeepAlive</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sockFd_;  <span class="comment">// socket 的文件描述符</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Socket.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Socket.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InetAddress.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Socket::<span class="built_in">Socket</span>(<span class="keyword">int</span> sockFd) : <span class="built_in">sockFd_</span>(sockFd) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Socket::~<span class="built_in">Socket</span>() {</span><br><span class="line">    ::<span class="built_in">close</span>(sockFd_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 socket 的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket::fd</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> sockFd_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::bindAddress</span><span class="params">(<span class="keyword">const</span> InetAddress&amp; localaddr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ::<span class="built_in">bind</span>(sockFd_, (sockaddr*)localaddr.<span class="built_in">getSockAddr</span>(), <span class="built_in"><span class="keyword">sizeof</span></span>(sockaddr_in))) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; bind socketFd:%d failed, errno:%d"</span>, __PRETTY_FUNCTION__, sockFd_, errno);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::listen</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ::<span class="built_in">listen</span>(sockFd_, SOMAXCONN)) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; listen socketFd:%d failed, errno:%d"</span>, __PRETTY_FUNCTION__, sockFd_, errno);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受连接请求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket::accept</span><span class="params">(InetAddress* peeraddr)</span> </span>{</span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span> addr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr, <span class="keyword">sizeof</span> addr);</span><br><span class="line">    <span class="comment">// 接受客户端新连接，返回新连接对应的 socket fd（非阻塞的），用来和客户端进行读写</span></span><br><span class="line">    <span class="keyword">int</span> connfd = ::<span class="built_in">accept4</span>(sockFd_, (sockaddr*)&amp;addr, &amp;len, SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) {</span><br><span class="line">        peeraddr-&gt;<span class="built_in">setSockAddr</span>(addr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> connfd;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭写入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::shutdownWrite</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">shutdown</span>(sockFd_, SHUT_WR) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; shutdown write socketFd:%d failed, errno:%d"</span>, __PRETTY_FUNCTION__, sockFd_, errno);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否开启 TCP_NODELAY，开启后关闭 Nagle 算法，减少延迟</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::setTcpNoDelay</span><span class="params">(<span class="keyword">bool</span> on)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockFd_, IPPROTO_TCP, TCP_NODELAY, &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否开启地址重用，允许端口在短时间内被重复绑定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::setReuseAddr</span><span class="params">(<span class="keyword">bool</span> on)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockFd_, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否开启端口重用，让多个进程/线程可以绑定同一端口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::setReusePort</span><span class="params">(<span class="keyword">bool</span> on)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = ::<span class="built_in">setsockopt</span>(sockFd_, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; on) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; set reuse port failed, errno:%d"</span>, __PRETTY_FUNCTION__, sockFd_, errno);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否开启 TCP 保活，用于检测对端是否还存活</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::setKeepAlive</span><span class="params">(<span class="keyword">bool</span> on)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockFd_, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><ul><li><code>Buffer.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"copyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @code</span></span><br><span class="line"><span class="comment">/// +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="comment">/// | prependable bytes |  readable bytes  |  writable bytes  |</span></span><br><span class="line"><span class="comment">/// |                   |     (CONTENT)    |                  |</span></span><br><span class="line"><span class="comment">/// +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="comment">/// |                   |                  |                  |</span></span><br><span class="line"><span class="comment">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span></span><br><span class="line"><span class="comment">/// @endcode</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> :</span> <span class="keyword">public</span> copyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kCheapPrepend = <span class="number">8</span>;    <span class="comment">// 预留空间大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kInitialSize = <span class="number">1024</span>;  <span class="comment">// 初始缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Buffer</span><span class="params">(<span class="keyword">size_t</span> initialSize = kInitialSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Buffer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓冲区中可读的字节数</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓冲区中可写的字节数</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">writableBytes</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓冲区中可预留的字节数</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">prependableBtes</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区中可读数据的起始地址</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">peek</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动读指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retrieve</span><span class="params">(<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置读指针与写指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retrieveAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区中所有可读数据以字符串形式返回</span></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区中指定长度的可读数据以字符串形式返回</span></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保缓冲区有足够的可写空间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ensureWritableBytes</span><span class="params">(<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容缓冲区以容纳更多数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeSpace</span><span class="params">(<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向缓冲区追加数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知缓冲区已写入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hasWritten</span><span class="params">(<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区中可写数据的起始地址</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">beginWrite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区中可写数据的起始地址</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">beginWrite</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 fd 上读取数据，并写到缓冲区中（返回值：n &gt; 0：读取成功；n == 0：连接关闭；n &lt; 0：读取出错）</span></span><br><span class="line">    <span class="function"><span class="keyword">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲区中读取数据，并写到 fd 上（返回值：n &gt; 0：写入成功；n == 0：没有数据可写入；n &lt; 0：写入出错）</span></span><br><span class="line">    <span class="function"><span class="keyword">ssize_t</span> <span class="title">writeFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 返回 vector 底层数组的首元素地址（即数组的起始地址）</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 vector 底层数组的首元素地址（即数组的起始地址）</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">char</span>&gt; buffer_;  <span class="comment">// 底层缓冲区</span></span><br><span class="line">    <span class="keyword">size_t</span> readerIndex_;        <span class="comment">// 读指针位置</span></span><br><span class="line">    <span class="keyword">size_t</span> writerIndex_;        <span class="comment">// 写指针位置</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Buffer.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Buffer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="keyword">size_t</span> initialSize)</span><br><span class="line">    : <span class="built_in">buffer_</span>(kCheapPrepend + initialSize), <span class="built_in">readerIndex_</span>(kCheapPrepend), <span class="built_in">writerIndex_</span>(kCheapPrepend) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Buffer::~<span class="built_in">Buffer</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓冲区中可读的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Buffer::readableBytes</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> writerIndex_ - readerIndex_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓冲区中可写的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Buffer::writableBytes</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writerIndex_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓冲区中可预留的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Buffer::prependableBtes</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> readerIndex_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回缓冲区中可读数据的起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Buffer::peek</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>() + readerIndex_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动读指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Buffer::retrieve</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">    <span class="built_in">assert</span>(len &lt;= <span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="built_in">readableBytes</span>()) {</span><br><span class="line">        readerIndex_ += len;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">retrieveAll</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置读指针与写指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Buffer::retrieveAll</span><span class="params">()</span> </span>{</span><br><span class="line">    readerIndex_ = kCheapPrepend;</span><br><span class="line">    writerIndex_ = kCheapPrepend;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区中所有可读数据以字符串形式返回</span></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::retrieveAllAsString</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readableBytes</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区中指定长度的可读数据以字符串形式返回</span></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::retrieveAsString</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">    <span class="built_in">assert</span>(len &lt;= <span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="comment">// 构造字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">result</span><span class="params">(peek(), len)</span></span>;</span><br><span class="line">    <span class="comment">// 移动读指针</span></span><br><span class="line">    <span class="built_in">retrieve</span>(len);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保缓冲区有足够的可写空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Buffer::ensureWritableBytes</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len) {</span><br><span class="line">        <span class="comment">// 缓冲区扩容</span></span><br><span class="line">        <span class="built_in">makeSpace</span>(len);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">writableBytes</span>() &gt;= len);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容缓冲区以容纳更多数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Buffer::makeSpace</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断是否需要通过移动数据来腾出空间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBtes</span>() &lt; len + kCheapPrepend) {</span><br><span class="line">        <span class="comment">// 没有空闲的空间，直接扩容</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 有空闲的空间，通过移动数据来腾出空间</span></span><br><span class="line">        <span class="built_in">assert</span>(kCheapPrepend &lt; readerIndex_);</span><br><span class="line">        <span class="keyword">size_t</span> readable = <span class="built_in">readableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, <span class="built_in">begin</span>() + writerIndex_, <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        writerIndex_ = readerIndex_ + readable;</span><br><span class="line">        <span class="built_in">assert</span>(readable == <span class="built_in">readableBytes</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓冲区追加数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Buffer::append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">    <span class="built_in">ensureWritableBytes</span>(len);</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data + len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    <span class="built_in">hasWritten</span>(len);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知缓冲区已写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Buffer::hasWritten</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">    <span class="built_in">assert</span>(len &lt;= <span class="built_in">writableBytes</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回缓冲区中可写数据的起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Buffer::beginWrite</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回缓冲区中可写数据的起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Buffer::beginWrite</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 fd 上读取数据，并写到缓冲区中（返回值：n &gt; 0：读取成功；n == 0：连接关闭；n &lt; 0：读取出错）</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span>* saveErrno)</span> </span>{</span><br><span class="line">    <span class="comment">// 在栈上分配内存空间（64KB）</span></span><br><span class="line">    <span class="keyword">char</span> extrabuf[<span class="number">65536</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主缓冲区可写的字节数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> writable = <span class="built_in">writableBytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用 scatter-gather 读技术，同时将数据读入主缓冲区和 extrabuf</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当主缓冲区 writable 小于 extrabuf（64KB）时，说明主缓冲区的空间可能不够装下数据，</span></span><br><span class="line">    <span class="comment">// 需要使用两个 iovec：第一个写入 buffer_，第二个写入 extrabuf，从而尽可能读完内核中的数据。</span></span><br><span class="line">    <span class="comment">// 否则，如果主缓冲区足够大，只需一个 iovec。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发生错误</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果只写入了主缓冲区，没有写入了 extrabuf</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) {</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果不仅写入了主缓冲区，还写入了 extrabuf</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从缓冲区中读取数据，并写到 fd 上（返回值：n &gt; 0：写入成功；n == 0：没有数据可写入；n &lt; 0：写入出错）</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Buffer::writeFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span>* saveErrno)</span> </span>{</span><br><span class="line">    <span class="keyword">ssize_t</span> n = ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 写入出错，记录错误码</span></span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 vector 底层数组的首元素地址（即数组的起始地址）</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Buffer::begin</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 vector 底层数组的首元素地址（即数组的起始地址）</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Buffer::begin</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="TcpConnection"><a href="#TcpConnection" class="headerlink" title="TcpConnection"></a>TcpConnection</h3><ul><li><code>TcpConnection.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Buffer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Callbacks.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InetAddress.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Socket</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP 连接类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span> :</span> noncopyable, <span class="keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">TcpConnection</span>(EventLoop* loop, <span class="keyword">const</span> std::string&amp; nameArg, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                  <span class="keyword">const</span> InetAddress&amp; peerAddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">TcpConnection</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 TCP 连接所在的事件循环</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getLoop</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 TCP 连接的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 TCP 连接的本地网络地址</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> InetAddress&amp; <span class="title">localAddress</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 TCP 连接的远程网络地址</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> InetAddress&amp; <span class="title">peerAddress</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 TCP 连接是否处于已连接状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 TCP 连接是否处于断开状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">disconnected</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据到输出缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> std::string&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 TCP 连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制关闭连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forceClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接建立/关闭时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="keyword">const</span> ConnectionCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置有数据到来时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="keyword">const</span> MessageCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数据发送完成时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="keyword">const</span> WriteCompleteCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置触发高水位时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHighWaterMarkCallback</span><span class="params">(<span class="keyword">const</span> HighWaterMarkCallback&amp; cb, <span class="keyword">size_t</span> highWaterMark)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接关闭时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCloseCallback</span><span class="params">(<span class="keyword">const</span> CloseCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入缓冲区</span></span><br><span class="line">    <span class="function">Buffer* <span class="title">inputBuffer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输出缓冲区</span></span><br><span class="line">    <span class="function">Buffer* <span class="title">outputBuffer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接建立</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectEstablished</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectDestroyed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// TCP 连接的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">StateE</span> {</span> kDisconnected, kConnecting, kConnected, kDisconnecting };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理读事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理写事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理关闭事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理错误事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleError</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在事件循环（EventLoop）中发送数据到输出缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendInLoop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* message, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在事件循环（EventLoop）中关闭 TCP 连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdownInLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在事件循环（EventLoop）中强制关闭 TCP 连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forceCloseInLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP 连接的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(StateE state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 TCP 连接的状态转换为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">stateToString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    EventLoop* loop_;         <span class="comment">// TCP 连接所在的事件循环，TCP 连接运行在 subLoop 中</span></span><br><span class="line">    <span class="keyword">const</span> std::string name_;  <span class="comment">// TCP 连接的名称</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> state_;   <span class="comment">// TCP 连接的状态</span></span><br><span class="line">    <span class="keyword">bool</span> reading_;            <span class="comment">// 标记是否正在读数据</span></span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;Socket&gt; socket_;    <span class="comment">// TCP 连接对应的 Socket 对象</span></span><br><span class="line">    std::unique_ptr&lt;Channel&gt; channel_;  <span class="comment">// TCP 连接对应的 Channel 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> InetAddress localAddr_;  <span class="comment">// TCP 连接的本地网络地址</span></span><br><span class="line">    <span class="keyword">const</span> InetAddress peerAddr_;   <span class="comment">// TCP 连接的远程网络地址</span></span><br><span class="line"></span><br><span class="line">    ConnectionCallback connectionCallback_;        <span class="comment">// 连接建立/关闭时的回调操作</span></span><br><span class="line">    MessageCallback messageCallback_;              <span class="comment">// 有数据到来时的回调操作</span></span><br><span class="line">    WriteCompleteCallback writeCompleteCallback_;  <span class="comment">// 数据发送完成时的回调操作</span></span><br><span class="line">    HighWaterMarkCallback highWaterMarkCallback_;  <span class="comment">// 触发高水位时的回调操作</span></span><br><span class="line">    CloseCallback closeCallback_;                  <span class="comment">// 连接关闭时的回调操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> highWaterMark_;  <span class="comment">// 高水位的大小（默认 64M）</span></span><br><span class="line">    Buffer inputBuffer_;    <span class="comment">// 输入缓冲区（用于接收数据的缓冲区）</span></span><br><span class="line">    Buffer outputBuffer_;   <span class="comment">// 输出缓冲区（用于发送数据的缓冲区）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>TcpConnection.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TcpConnection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Channel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Socket.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SocketsOps.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 EventLoop 指针是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop* loop)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (loop == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; eventloop is null"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认连接建立/关闭时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultConnectionCallback</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; %s -&gt; %s is %s"</span>, __PRETTY_FUNCTION__, conn-&gt;<span class="built_in">localAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">              conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>(), (conn-&gt;<span class="built_in">connected</span>() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认有数据到来时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultMessageCallback</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp;, Buffer* buf, Timestamp)</span> </span>{</span><br><span class="line">    buf-&gt;<span class="built_in">retrieveAll</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop* loop, <span class="keyword">const</span> std::string&amp; nameArg, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                             <span class="keyword">const</span> InetAddress&amp; peerAddr)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop)),</span><br><span class="line">      <span class="built_in">name_</span>(nameArg),</span><br><span class="line">      <span class="built_in">state_</span>(kConnecting),</span><br><span class="line">      <span class="built_in">socket_</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd)),</span><br><span class="line">      <span class="built_in">channel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd)),</span><br><span class="line">      <span class="built_in">localAddr_</span>(localAddr),</span><br><span class="line">      <span class="built_in">peerAddr_</span>(peerAddr),</span><br><span class="line">      <span class="built_in">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class="line">      <span class="built_in">messageCallback_</span>(defaultMessageCallback),</span><br><span class="line">      <span class="built_in">highWaterMark_</span>(<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) {</span><br><span class="line">    <span class="comment">// 给 Channel 设置相应的回调函数，Poller 会通知 Channel 它感兴趣的事件发生了，然后 Channel 会回调相应的操作函数</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    channel_-&gt;<span class="built_in">setWriteCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line">    channel_-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">    channel_-&gt;<span class="built_in">setErrorCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; create tcp connection [%s] at %p, fd=%d"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(), <span class="keyword">this</span>, sockfd);</span><br><span class="line">    <span class="comment">// 开启 TCP 保活机制</span></span><br><span class="line">    socket_-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">TcpConnection::~<span class="built_in">TcpConnection</span>() {</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; destruct tcp connection [%s] at %p, fd=%d, state=%s"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(), <span class="keyword">this</span>,</span><br><span class="line">              channel_-&gt;<span class="built_in">fd</span>(), <span class="built_in">stateToString</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 TCP 连接所在的事件循环</span></span><br><span class="line"><span class="function">EventLoop* <span class="title">TcpConnection::getLoop</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> loop_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 TCP 连接的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">TcpConnection::name</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 TCP 连接的本地网络地址</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> InetAddress&amp; <span class="title">TcpConnection::localAddress</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> localAddr_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 TCP 连接的远程网络地址</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> InetAddress&amp; <span class="title">TcpConnection::peerAddress</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> peerAddr_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 TCP 连接是否处于已连接状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TcpConnection::connected</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> state_ == kConnected;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 TCP 连接是否处于断开状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TcpConnection::disconnected</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> state_ == kDisconnected;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据到输出缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="keyword">const</span> std::string&amp; message)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) {</span><br><span class="line">        <span class="comment">// 如果当前线程是 loop_ 所在的线程</span></span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;<span class="built_in">isInLoopThread</span>()) {</span><br><span class="line">            <span class="comment">// 直接将数据发送到输出缓冲区</span></span><br><span class="line">            <span class="built_in">sendInLoop</span>(message.<span class="built_in">c_str</span>(), message.<span class="built_in">size</span>());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 唤醒 loop_ 对应的线程将数据发送到输出缓冲区</span></span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop, <span class="keyword">this</span>, message.<span class="built_in">c_str</span>(), message.<span class="built_in">size</span>()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 TCP 连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) {</span><br><span class="line">        <span class="comment">// 设置 TCP 连接的状态</span></span><br><span class="line">        <span class="built_in">setState</span>(kDisconnecting);</span><br><span class="line">        <span class="comment">// 唤醒 loop_ 对应的线程去关闭 TCP 连接</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::shutdownInLoop, <span class="keyword">this</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceClose</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 判断 TCP 连接的状态</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) {</span><br><span class="line">        <span class="comment">// 设置连接状态</span></span><br><span class="line">        <span class="built_in">setState</span>(kDisconnecting);</span><br><span class="line">        <span class="comment">// 唤醒 loop_ 对应的线程去强制关闭 TCP 连接</span></span><br><span class="line">        loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::forceCloseInLoop, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接建立/关闭时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::setConnectionCallback</span><span class="params">(<span class="keyword">const</span> ConnectionCallback&amp; cb)</span> </span>{</span><br><span class="line">    connectionCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置有数据到来时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::setMessageCallback</span><span class="params">(<span class="keyword">const</span> MessageCallback&amp; cb)</span> </span>{</span><br><span class="line">    messageCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据发送完成时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::setWriteCompleteCallback</span><span class="params">(<span class="keyword">const</span> WriteCompleteCallback&amp; cb)</span> </span>{</span><br><span class="line">    writeCompleteCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置触发高水位时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::setHighWaterMarkCallback</span><span class="params">(<span class="keyword">const</span> HighWaterMarkCallback&amp; cb, <span class="keyword">size_t</span> highWaterMark)</span> </span>{</span><br><span class="line">    highWaterMarkCallback_ = cb;</span><br><span class="line">    highWaterMark_ = highWaterMark;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置连接关闭时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::setCloseCallback</span><span class="params">(<span class="keyword">const</span> CloseCallback&amp; cb)</span> </span>{</span><br><span class="line">    closeCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取输入缓冲区</span></span><br><span class="line"><span class="function">Buffer* <span class="title">TcpConnection::inputBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> &amp;inputBuffer_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取输出缓冲区</span></span><br><span class="line"><span class="function">Buffer* <span class="title">TcpConnection::outputBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> &amp;outputBuffer_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接建立</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">assert</span>(state_ == kConnecting);</span><br><span class="line">    <span class="comment">// 设置 TCP 连接的状态</span></span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    <span class="comment">// Channel 绑定 TCP 连接</span></span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    <span class="comment">// Channel 开启监听 fd 上的读事件</span></span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>();</span><br><span class="line">    <span class="comment">// 调用用户设置的回调操作</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) {</span><br><span class="line">        <span class="comment">// 设置 TCP 连接的状态</span></span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        <span class="comment">// Channel 禁止监听 fd 上的所有事件</span></span><br><span class="line">        channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line">        <span class="comment">// 调用用户设置的回调操作</span></span><br><span class="line">        <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从 Poller 中删除 Channel</span></span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理读事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span> </span>{</span><br><span class="line">    <span class="comment">// 临时错误码</span></span><br><span class="line">    <span class="keyword">int</span> saveErrno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 fd 上读取数据，并写入到输入缓冲区中</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;saveErrno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 已建立连接的客户端，有可读事件发生了，调用用户设置的回调操作</span></span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 处理连接关闭</span></span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 设置错误码</span></span><br><span class="line">        errno = saveErrno;</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; read fd error, fd=%d, errno=%d"</span>, __PRETTY_FUNCTION__, channel_-&gt;<span class="built_in">fd</span>(), errno);</span><br><span class="line">        <span class="comment">// 处理连接错误</span></span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理写事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 判断 Channel 是否正在监听写事件</span></span><br><span class="line">    <span class="keyword">if</span> (channel_-&gt;<span class="built_in">isWriting</span>()) {</span><br><span class="line">        <span class="comment">// 临时错误码</span></span><br><span class="line">        <span class="keyword">int</span> saveErrno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从输出缓冲区读取数据，并写入到 fd 上</span></span><br><span class="line">        <span class="keyword">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;saveErrno);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 移动输出缓冲区的读指针（标记有哪些数据被发送了）</span></span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果输出缓冲区中的所有数据都发送完了</span></span><br><span class="line">            <span class="keyword">if</span> (outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 关闭监听 fd 上的写事件</span></span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">                <span class="comment">// 调用用户设置的回调操作</span></span><br><span class="line">                <span class="keyword">if</span> (writeCompleteCallback_) {</span><br><span class="line">                    <span class="comment">// 唤醒 loop_ 所在的线程去执行用户设置的回调操作</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 如果正在断开 TCP 连接，则关闭 TCP 连接</span></span><br><span class="line">                <span class="keyword">if</span> (state_ == kDisconnecting) {</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; write fd error, fd=%d, errno=%d"</span>, __PRETTY_FUNCTION__, channel_-&gt;<span class="built_in">fd</span>(), errno);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; tcp connection [%s] is down, no more writing, fd=%d"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                  channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理关闭事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; tcp connection [%s] is close, fd=%d, state=%s"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(), channel_-&gt;<span class="built_in">fd</span>(),</span><br><span class="line">              <span class="built_in">stateToString</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP 连接的状态</span></span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止 Channel 监听 fd 上的所有事件</span></span><br><span class="line">    channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的 TCP 连接</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">guardThis</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用用户设置的连接建立/关闭时的回调操作</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(guardThis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用用户设置的连接关闭时的回调操作</span></span><br><span class="line">    <span class="keyword">if</span> (closeCallback_) {</span><br><span class="line">        <span class="built_in">closeCallback_</span>(guardThis);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理错误事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 Socket 错误码</span></span><br><span class="line">    <span class="keyword">int</span> savedErrno = <span class="built_in">getSocketError</span>(channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; tcp connection [%s] occurred error, fd=%d, SO_ERROR:%d"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(),</span><br><span class="line">              channel_-&gt;<span class="built_in">fd</span>(), savedErrno);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事件循环（EventLoop）中发送数据到输出缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* message, <span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已发送数据的字节数</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩下未发送数据的字节数</span></span><br><span class="line">    <span class="keyword">size_t</span> remaining = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否发生致命错误</span></span><br><span class="line">    <span class="keyword">bool</span> faultError = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 TCP 连接已断开，则放弃发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kDisconnected) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; tcp connection [%s] disconnected, give up writing"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 Channel 是第一次写入数据，且输出缓冲区里面没有待发送的数据</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 直接发送数据（成功：返回已发送的字节数，失败：返回小于零的数字）</span></span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(), message, len);</span><br><span class="line">        <span class="comment">// 发送数据成功</span></span><br><span class="line">        <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 剩下未发送的字节数</span></span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="comment">// 如果所有数据都发送完</span></span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_) {</span><br><span class="line">                <span class="comment">// 唤醒 loop_ 所在的线程去执行用户设置的回调操作</span></span><br><span class="line">                loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 发送数据失败</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK) {</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; occurred error"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) {</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(remaining &lt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发送数据没有发生致命错误，且有剩下的数据未发送</span></span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 输出缓冲区中原先未发送数据的字节数</span></span><br><span class="line">        <span class="keyword">size_t</span> oldLen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="comment">// 判断所有未发送数据的大小是否触及了高水位线</span></span><br><span class="line">        <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_ &amp;&amp; oldLen &lt; highWaterMark_ &amp;&amp; highWaterMarkCallback_) {</span><br><span class="line">            <span class="comment">// 唤醒 loop_ 所在的线程去执行用户设置的回调操作</span></span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(highWaterMarkCallback_, <span class="built_in">shared_from_this</span>(), oldLen + remaining));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 往输出缓冲区中写入上面未发送完的数据</span></span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(message) + nwrote, remaining);</span><br><span class="line">        <span class="comment">// 让 Channel 开启监听 fd 上的写事件</span></span><br><span class="line">        <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>()) {</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事件循环（EventLoop）中关闭 TCP 连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span> </span>{</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="comment">// 如果输出缓冲区中的所有数据都发送完</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>()) {</span><br><span class="line">        <span class="comment">// Socket 关闭写入</span></span><br><span class="line">        socket_-&gt;<span class="built_in">shutdownWrite</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事件循环（EventLoop）中强制关闭 TCP 连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceCloseInLoop</span><span class="params">()</span> </span>{</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="comment">// 判断 TCP 连接的状态</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) {</span><br><span class="line">        <span class="comment">// 处理关闭事件</span></span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 TCP 连接的状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::setState</span><span class="params">(StateE state)</span> </span>{</span><br><span class="line">    state_ = state;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 TCP 连接的状态转换为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">TcpConnection::stateToString</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (state_) {</span><br><span class="line">        <span class="keyword">case</span> kDisconnected:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"kDisconnected"</span>;</span><br><span class="line">        <span class="keyword">case</span> kConnecting:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"kConnecting"</span>;</span><br><span class="line">        <span class="keyword">case</span> kConnected:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"kConnected"</span>;</span><br><span class="line">        <span class="keyword">case</span> kDisconnecting:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"kDisconnecting"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"unknown state"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h3><ul><li><code>Acceptor.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Channel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Socket.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InetAddress</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP 连接接受器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 有新连接到来时的回调操作类型定义</span></span><br><span class="line">    <span class="keyword">using</span> NewConnectionCallback = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span> sockFd, <span class="keyword">const</span> InetAddress&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Acceptor</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">bool</span> reuseport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Acceptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置有新连接到来时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(<span class="keyword">const</span> NewConnectionCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接请求（即监听有新的客户端连接进来）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取是否正在监听连接请求</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">listenning</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 处理读事件（即处理有新客户端连接进来）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    EventLoop* loop_;        <span class="comment">// Acceptor 使用的就是用户自定义的那个 baseLoop，也称作 mainLoop</span></span><br><span class="line">    Socket acceptSocket_;    <span class="comment">// 用于监听的 socket</span></span><br><span class="line">    Channel acceptChannel_;  <span class="comment">// 用于监听 acceptSocket_ 上的可读事件（即有新连接到来）</span></span><br><span class="line">    NewConnectionCallback newConnectionCallback_;  <span class="comment">// 有新连接到来时的回调操作</span></span><br><span class="line">    <span class="keyword">bool</span> listenning_;                              <span class="comment">// 标记是否正在监听连接请求</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Acceptor.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Acceptor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InetAddress.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SocketsOps.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop),</span><br><span class="line">      <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblockingSocket</span>()),</span><br><span class="line">      <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()),</span><br><span class="line">      <span class="built_in">listenning_</span>(<span class="literal">false</span>) {</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(reuseport);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr);</span><br><span class="line">    <span class="comment">// 设置 acceptChannel_ 的读事件回调操作为 Acceptor::handleRead 方法</span></span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Acceptor::~<span class="built_in">Acceptor</span>() {</span><br><span class="line">    <span class="comment">// 关闭 acceptChannel_ 上的所有事件监听</span></span><br><span class="line">    acceptChannel_.<span class="built_in">disableAll</span>();</span><br><span class="line">    <span class="comment">// 从 Poller 中删除 acceptChannel_</span></span><br><span class="line">    acceptChannel_.<span class="built_in">remove</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置有新连接到来时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::setNewConnectionCallback</span><span class="params">(<span class="keyword">const</span> NewConnectionCallback&amp; cb)</span> </span>{</span><br><span class="line">    newConnectionCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接请求（即监听有新的客户端连接进来）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span> </span>{</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 监听客户端的连接请求</span></span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>();</span><br><span class="line">    <span class="comment">// 启用 acceptChannel_ 的读事件监听（即监听有新连接到来）</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取是否正在监听连接请求</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Acceptor::listenning</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> listenning_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理读事件（即处理有新客户端连接进来）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>{</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="comment">// 接受客户端新连接，返回新连接对应的 socket fd，用来和客户端进行读写</span></span><br><span class="line">    <span class="keyword">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 有客户端新连接到来，执行回调操作（如果存在）</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_) {</span><br><span class="line">            <span class="comment">// 回调操作的职责：轮询找到 subLoop，将新客户端的 fd 分发给 subLoop，然后唤醒 subLoop 以处理该新客户端的连接</span></span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; accept failed, errno:%d"</span>, __PRETTY_FUNCTION__, errno);</span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE) {</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; sockfd reached limit"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="TcpServer"><a href="#TcpServer" class="headerlink" title="TcpServer"></a>TcpServer</h3><ul><li><code>TcpServer.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Acceptor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Callbacks.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoopThreadPool.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InetAddress.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TcpConnection.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"atomic"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unordered_map"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP 服务器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程初始化回调操作类型定义</span></span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(EventLoop*)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 端口复用选项枚举类型定义</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Option</span> {</span></span><br><span class="line">        kNoReusePort,</span><br><span class="line">        kReusePort,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">TcpServer</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">const</span> std::string nameArg, Option option = kNoReusePort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务器监听的 IP 和端口信息</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">ipPort</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务器名称</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务器的事件循环</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getLoop</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的线程数量（即底层 subLoop 的数量）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="keyword">int</span> numThreads)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器（线程安全）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程初始化回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadInitCallback</span><span class="params">(<span class="keyword">const</span> ThreadInitCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置有新连接到来时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="keyword">const</span> ConnectionCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置有数据到来时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="keyword">const</span> MessageCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数据发送完成时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="keyword">const</span> WriteCompleteCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// TCP 连接集合类型定义</span></span><br><span class="line">    <span class="keyword">using</span> ConnectionMap = std::unordered_map&lt;std::string, TcpConnectionPtr&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TCP 连接（在 baseLoop 上执行）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress&amp; peerAddr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除 TCP 连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除 TCP 连接（在 baseLoop 上执行）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeConnectionInLoop</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    EventLoop* loop_;  <span class="comment">// 用户自定义的 EventLoop（即 baseLoop，也称作 mainLoop，运行在主线程上）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> std::string name_;              <span class="comment">// 服务器名称</span></span><br><span class="line">    <span class="keyword">const</span> std::string ipPort_;            <span class="comment">// 服务器监听的 IP 和端口信息</span></span><br><span class="line">    std::unique_ptr&lt;Acceptor&gt; acceptor_;  <span class="comment">// 用于监听新连接的 Acceptor 对象，运行在 baseLoop 上</span></span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_;  <span class="comment">// 事件循环线程池</span></span><br><span class="line"></span><br><span class="line">    ConnectionCallback connectionCallback_;        <span class="comment">// 有新连接到来时的回调操作</span></span><br><span class="line">    MessageCallback messageCallback_;              <span class="comment">// 有数据到来时的回调操作</span></span><br><span class="line">    WriteCompleteCallback writeCompleteCallback_;  <span class="comment">// 数据发送完成时的回调操作</span></span><br><span class="line">    ThreadInitCallback threadInitCallback_;        <span class="comment">// 线程初始化回调操作</span></span><br><span class="line"></span><br><span class="line">    std::<span class="keyword">atomic_int</span> started_;    <span class="comment">// 标记服务器是否已经启动</span></span><br><span class="line">    <span class="keyword">int</span> nextConnId_;             <span class="comment">// 下一个 TCP 连接的 ID</span></span><br><span class="line">    ConnectionMap connections_;  <span class="comment">// 保存所有的 TCP 连接</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>TcpServer.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TcpServer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TcpConnection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop* loop)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (loop == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; baseLoop is null"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">const</span> std::string nameArg, Option option)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop)),</span><br><span class="line">      <span class="built_in">ipPort_</span>(listenAddr.<span class="built_in">toIpPort</span>()),</span><br><span class="line">      <span class="built_in">name_</span>(nameArg),</span><br><span class="line">      <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr, option == kReusePort)),</span><br><span class="line">      <span class="built_in">threadPool_</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop, name_)),</span><br><span class="line">      <span class="built_in">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class="line">      <span class="built_in">messageCallback_</span>(defaultMessageCallback),</span><br><span class="line">      <span class="built_in">nextConnId_</span>(<span class="number">1</span>),</span><br><span class="line">      <span class="built_in">started_</span>(<span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// 当有新客户端连接进来时，会调用 TcpServer::newConnection() 函数</span></span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>() {</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; tcp server [%s] destructing"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有 TCP 连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : connections_) {</span><br><span class="line">        <span class="comment">// 这个局部的智能指针对象出了右括号后，会自动释放掉对应的 TcpConnection 资源</span></span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        <span class="comment">// 重置原有的智能指针</span></span><br><span class="line">        item.second.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="comment">// 唤醒 TCP 连接所在的 EventLoop 去执行 TcpConnection::connectDestroyed() 函数</span></span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取服务器监听的 IP 和端口信息</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">TcpServer::ipPort</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ipPort_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取服务器名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">TcpServer::name</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取服务器的事件循环</span></span><br><span class="line"><span class="function">EventLoop* <span class="title">TcpServer::getLoop</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> loop_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的线程数量（即底层 subLoop 的数量）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::setThreadNum</span><span class="params">(<span class="keyword">int</span> numThreads)</span> </span>{</span><br><span class="line">    threadPool_-&gt;<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器（线程安全）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 防止 TcpServer 被多次启动</span></span><br><span class="line">    <span class="keyword">if</span> (started_++ == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 启动多个子线程，并各自运行一个 subLoop</span></span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_);</span><br><span class="line">        <span class="comment">// 在 baseLoop（运行在主线程）上监听连接请求（即监听有新的客户端连接进来）</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程初始化回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::setThreadInitCallback</span><span class="params">(<span class="keyword">const</span> ThreadInitCallback&amp; cb)</span> </span>{</span><br><span class="line">    threadInitCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置有新连接到来时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::setConnectionCallback</span><span class="params">(<span class="keyword">const</span> ConnectionCallback&amp; cb)</span> </span>{</span><br><span class="line">    connectionCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置有数据到来时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::setMessageCallback</span><span class="params">(<span class="keyword">const</span> MessageCallback&amp; cb)</span> </span>{</span><br><span class="line">    messageCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据发送完成时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::setWriteCompleteCallback</span><span class="params">(<span class="keyword">const</span> WriteCompleteCallback&amp; cb)</span> </span>{</span><br><span class="line">    writeCompleteCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 TCP 连接（在 baseLoop 上执行）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress&amp; peerAddr)</span> </span>{</span><br><span class="line">    <span class="comment">// 通过轮询算法，获取下一个 subLoop（也称作 ioLoop）</span></span><br><span class="line">    EventLoop* ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 TCP 连接的名称</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"-%s#%d"</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; tcp server [%s] new connection [%s] from %s"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(),</span><br><span class="line">              ipPort_.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地网络地址</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local, <span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;local, &amp;addrlen) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; fail to get local internet address"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接成功的 sockfd，创建 TCP 连接对象</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新创建的 TCP 连接对象放进集合中</span></span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP 连接的回调操作（由用户自定义）</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒 ioLoop 所在的线程去执行 TcpConnection::connectEstablished() 函数</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 TCP 连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="comment">// 唤醒 baseLoop 所在的线程去执行 TcpServer::removeConnectionInLoop() 函数</span></span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 TCP 连接（在 baseLoop 上执行）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; tcp server [%s] remove connection [%s]"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(), conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除 TCP 连接</span></span><br><span class="line">    <span class="keyword">size_t</span> n = connections_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒 TCP 连接所在的 EventLoop 去执行 TcpConnection::connectDestroyed() 函数</span></span><br><span class="line">    <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line">    EventLoop* ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><ul><li><code>Connector.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InetAddress.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP 连接器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connector</span> :</span> noncopyable, <span class="keyword">public</span> std::enable_shared_from_this&lt;Connector&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 有新连接建立时的回调操作类型定义</span></span><br><span class="line">    <span class="keyword">using</span> NewConnectionCallback = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span> sockfd)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Connector</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; serverAddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Connector</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置有新连接建立时的回调操作类型定义</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(<span class="keyword">const</span> NewConnectionCallback&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动连接器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重启连接器（必须在 EventLoop 所处的线程上执行）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止连接器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务器地址</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> InetAddress&amp; <span class="title">serverAddress</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接器的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">States</span> {</span> kDisconnected, kConnecting, kConnected };</span><br><span class="line">    <span class="comment">// 最大重试延迟时间（毫秒）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxRetryDelayMs;</span><br><span class="line">    <span class="comment">// 初始重试延迟时间（毫秒）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kInitRetryDelayMs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(States s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 EventLoop 所处的线程上启动连接器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startInLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 EventLoop 所处的线程上停止连接器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopInLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起连接操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理正在连接的 Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connecting</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理写事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理错误事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleError</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retry</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除并重置 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeAndResetChannel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetChannel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    EventLoop* loop_;                              <span class="comment">// 连接器所在的事件循环</span></span><br><span class="line">    InetAddress serverAddr_;                       <span class="comment">// 服务器地址</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> connect_;                      <span class="comment">// 标记是否需要连接</span></span><br><span class="line">    States state_;                                 <span class="comment">// 连接状态</span></span><br><span class="line">    std::unique_ptr&lt;Channel&gt; channel_;             <span class="comment">// 连接器对应的 Channel</span></span><br><span class="line">    NewConnectionCallback newConnectionCallback_;  <span class="comment">// 新连接建立时的回调操作</span></span><br><span class="line">    <span class="keyword">int</span> retryDelayMs_;                             <span class="comment">// 重试连接的延迟时间（毫秒）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Connector.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Connector.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Channel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SocketsOps.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义初始重试延迟时间（毫秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Connector::kInitRetryDelayMs = <span class="number">500</span>;</span><br><span class="line"><span class="comment">// 定义最大重试延迟时间（毫秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Connector::kMaxRetryDelayMs = <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Connector::<span class="built_in">Connector</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; serverAddr)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop), <span class="built_in">serverAddr_</span>(serverAddr), <span class="built_in">connect_</span>(<span class="literal">false</span>), <span class="built_in">state_</span>(kDisconnected), <span class="built_in">retryDelayMs_</span>(kInitRetryDelayMs) {</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; create connector at %p"</span>, __PRETTY_FUNCTION__, <span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Connector::~<span class="built_in">Connector</span>() {</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; destruct connector at %p"</span>, __PRETTY_FUNCTION__, <span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置有新连接建立时的回调操作类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::setNewConnectionCallback</span><span class="params">(<span class="keyword">const</span> NewConnectionCallback&amp; cb)</span> </span>{</span><br><span class="line">    newConnectionCallback_ = cb;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动连接器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 标记需要连接</span></span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒 loop_ 对应的线程去启动连接器</span></span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Connector::startInLoop, <span class="keyword">this</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 EventLoop 所处的线程上启动连接器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::startInLoop</span><span class="params">()</span> </span>{</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">assert</span>(state_ == kDisconnected);</span><br><span class="line">    <span class="comment">// 判断是否需要连接</span></span><br><span class="line">    <span class="keyword">if</span> (connect_) {</span><br><span class="line">        <span class="comment">// 发起连接操作</span></span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; do not connect"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止连接器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::stop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 标记不再连接</span></span><br><span class="line">    connect_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 唤醒 loop_ 对应的线程去关闭连接器</span></span><br><span class="line">    loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;Connector::stopInLoop, <span class="keyword">this</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 EventLoop 所处的线程上停止连接器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::stopInLoop</span><span class="params">()</span> </span>{</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnecting) {</span><br><span class="line">        <span class="comment">// 设置连接状态为已断开</span></span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        <span class="comment">// 移除并重置 Channel</span></span><br><span class="line">        <span class="keyword">int</span> sockfd = <span class="built_in">removeAndResetChannel</span>();</span><br><span class="line">        <span class="comment">// 重试连接</span></span><br><span class="line">        <span class="built_in">retry</span>(sockfd);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重启连接器（必须在 EventLoop 所处的线程上执行）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::restart</span><span class="params">()</span> </span>{</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="comment">// 设置连接状态</span></span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">    <span class="comment">// 重置重试延迟时间</span></span><br><span class="line">    retryDelayMs_ = kInitRetryDelayMs;</span><br><span class="line">    <span class="comment">// 标记需要连接</span></span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 启动连接器</span></span><br><span class="line">    <span class="built_in">startInLoop</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取服务器地址</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> InetAddress&amp; <span class="title">Connector::serverAddress</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> serverAddr_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置连接状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::setState</span><span class="params">(States s)</span> </span>{</span><br><span class="line">    state_ = s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起连接操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::connect</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建非阻塞的 Socket</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = <span class="built_in">createNonblockingSocket</span>();</span><br><span class="line">    <span class="comment">// 连接 TCP 服务器</span></span><br><span class="line">    <span class="keyword">int</span> ret = ::<span class="built_in">connect</span>(sockfd, (sockaddr*)serverAddr_.<span class="built_in">getSockAddr</span>(), <span class="built_in"><span class="keyword">sizeof</span></span>(sockaddr_in));</span><br><span class="line">    <span class="comment">// 处理连接结果</span></span><br><span class="line">    <span class="keyword">int</span> savedErrno = (ret == <span class="number">0</span>) ? <span class="number">0</span> : errno;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (savedErrno) {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> EINPROGRESS:</span><br><span class="line">        <span class="keyword">case</span> EINTR:</span><br><span class="line">        <span class="keyword">case</span> EISCONN:</span><br><span class="line">            <span class="comment">// 处理正在连接的 Socket</span></span><br><span class="line">            <span class="built_in">connecting</span>(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EAGAIN:</span><br><span class="line">        <span class="keyword">case</span> EADDRINUSE:</span><br><span class="line">        <span class="keyword">case</span> EADDRNOTAVAIL:</span><br><span class="line">        <span class="keyword">case</span> ECONNREFUSED:</span><br><span class="line">        <span class="keyword">case</span> ENETUNREACH:</span><br><span class="line">            <span class="comment">// 重新连接</span></span><br><span class="line">            <span class="built_in">retry</span>(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EACCES:</span><br><span class="line">        <span class="keyword">case</span> EPERM:</span><br><span class="line">        <span class="keyword">case</span> EAFNOSUPPORT:</span><br><span class="line">        <span class="keyword">case</span> EALREADY:</span><br><span class="line">        <span class="keyword">case</span> EBADF:</span><br><span class="line">        <span class="keyword">case</span> EFAULT:</span><br><span class="line">        <span class="keyword">case</span> ENOTSOCK:</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; connect error, errno:%d"</span>, __PRETTY_FUNCTION__, errno);</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            ::<span class="built_in">close</span>(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; unexpected error, errno:%d"</span>, __PRETTY_FUNCTION__, errno);</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            ::<span class="built_in">close</span>(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理正在连接的 Socket</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::connecting</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置连接状态为正在连接</span></span><br><span class="line">    <span class="built_in">setState</span>(kConnecting);</span><br><span class="line">    <span class="comment">// 创建 Channel 并注册写事件和错误事件的回调操作</span></span><br><span class="line">    channel_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop_, sockfd));</span><br><span class="line">    channel_-&gt;<span class="built_in">setWriteCallback</span>(std::<span class="built_in">bind</span>(&amp;Connector::handleWrite, <span class="keyword">this</span>));</span><br><span class="line">    channel_-&gt;<span class="built_in">setErrorCallback</span>(std::<span class="built_in">bind</span>(&amp;Connector::handleError, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// Channel 开启监听 fd 上的写事件</span></span><br><span class="line">    channel_-&gt;<span class="built_in">enableWriting</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理写事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::handleWrite</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; state:%d"</span>, __PRETTY_FUNCTION__, state_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnecting) {</span><br><span class="line">        <span class="comment">// 移除并重置 Channel</span></span><br><span class="line">        <span class="keyword">int</span> sockfd = <span class="built_in">removeAndResetChannel</span>();</span><br><span class="line">        <span class="comment">// 获取 Socket 错误码</span></span><br><span class="line">        <span class="keyword">int</span> savedErrno = <span class="built_in">getSocketError</span>(sockfd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发生错误</span></span><br><span class="line">        <span class="keyword">if</span> (savedErrno) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">"%s =&gt; SO_ERROR=%d"</span>, __PRETTY_FUNCTION__, savedErrno);</span><br><span class="line">            <span class="comment">// 重新连接</span></span><br><span class="line">            <span class="built_in">retry</span>(sockfd);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 发生自连接</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isSelfConnect</span>(sockfd)) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">"%s =&gt; self connect"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">            <span class="comment">// 重新连接</span></span><br><span class="line">            <span class="built_in">retry</span>(sockfd);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 连接成功</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 设置连接状态为已连接</span></span><br><span class="line">            <span class="built_in">setState</span>(kConnected);</span><br><span class="line">            <span class="comment">// 判断是否需要连接</span></span><br><span class="line">            <span class="keyword">if</span> (connect_) {</span><br><span class="line">                <span class="comment">// 需要连接，执行有新连接建立时的回调操作</span></span><br><span class="line">                <span class="built_in">newConnectionCallback_</span>(sockfd);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 不需要连接，关闭该连接</span></span><br><span class="line">                ::<span class="built_in">close</span>(sockfd);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">assert</span>(state_ == kDisconnected);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理错误事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::handleError</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">"%s =&gt; occurred error, state:%d"</span>, __PRETTY_FUNCTION__, state_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnecting) {</span><br><span class="line">        <span class="comment">// 移除并重置 Channel</span></span><br><span class="line">        <span class="keyword">int</span> sockfd = <span class="built_in">removeAndResetChannel</span>();</span><br><span class="line">        <span class="comment">// 获取 Socket 错误码</span></span><br><span class="line">        <span class="keyword">int</span> savedErrno = <span class="built_in">getSocketError</span>(sockfd);</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; SO_ERROR:%d"</span>, __PRETTY_FUNCTION__, savedErrno);</span><br><span class="line">        <span class="comment">// 重新连接</span></span><br><span class="line">        <span class="built_in">retry</span>(sockfd);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重试连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::retry</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>{</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    ::<span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接状态</span></span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要连接</span></span><br><span class="line">    <span class="keyword">if</span> (connect_) {</span><br><span class="line">        <span class="comment">// 获取当前的重试延迟时间</span></span><br><span class="line">        <span class="keyword">int</span> delay = retryDelayMs_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 shared_ptr 指向的自身对象</span></span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"%s =&gt; retry connecting to %s in %d milliseconds"</span>, __PRETTY_FUNCTION__, serverAddr_.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">                 delay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在一个独立的线程中等待一段时间后启动连接器</span></span><br><span class="line">        std::<span class="built_in">thread</span>([self, delay]() {</span><br><span class="line">            <span class="comment">// 等待一段时间</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(delay));</span><br><span class="line">            <span class="comment">// 唤醒 loop_ 对应的线程去启动连接器</span></span><br><span class="line">            self-&gt;loop_-&gt;<span class="built_in">queueInLoop</span>([self]() { self-&gt;<span class="built_in">startInLoop</span>(); });</span><br><span class="line">        }).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指数退避算法，增加重试延迟时间</span></span><br><span class="line">        retryDelayMs_ = std::<span class="built_in">min</span>(retryDelayMs_ * <span class="number">2</span>, kMaxRetryDelayMs);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s =&gt; do not connect"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除并重置 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connector::removeAndResetChannel</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 禁用 Channel 的所有事件监听</span></span><br><span class="line">    channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line">    <span class="comment">// 从 Poller 中删除 Channel</span></span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>();</span><br><span class="line">    <span class="comment">// 获取 Channel 对应的 sockfd</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = channel_-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    <span class="comment">// 唤醒 loop_ 对应的线程去重置 Channel</span></span><br><span class="line">    loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;Connector::resetChannel, <span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置 Channel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::resetChannel</span><span class="params">()</span> </span>{</span><br><span class="line">    channel_.<span class="built_in">reset</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="TcpClient"><a href="#TcpClient" class="headerlink" title="TcpClient"></a>TcpClient</h3><ul><li><code>TcpClient.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TcpConnection.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"noncopyable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connector</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP 连接器智能指针类型定义</span></span><br><span class="line"><span class="keyword">using</span> ConnectorPtr = std::shared_ptr&lt;Connector&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP 客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span> :</span> noncopyable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">TcpClient</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; serverAddr, <span class="keyword">const</span> std::string&amp; nameArg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">TcpClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的 TCP 连接</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取事件循环</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getLoop</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否允许重试连接</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">retry</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许重试连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enableRetry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端名称</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接建立/关闭时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setConnectionCallback</span><span class="params">(ConnectionCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置有数据到来时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMessageCallback</span><span class="params">(MessageCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数据发送完成时的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(WriteCompleteCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 创建新连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newConnection</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    EventLoop* loop_;                              <span class="comment">// 事件循环</span></span><br><span class="line">    ConnectorPtr connector_;                       <span class="comment">// 连接器</span></span><br><span class="line">    <span class="keyword">const</span> std::string name_;                       <span class="comment">// 客户端名称</span></span><br><span class="line">    ConnectionCallback connectionCallback_;        <span class="comment">// 连接建立/关闭时的回调操作</span></span><br><span class="line">    MessageCallback messageCallback_;              <span class="comment">// 有数据到来时的回调操作</span></span><br><span class="line">    WriteCompleteCallback writeCompleteCallback_;  <span class="comment">// 数据发送完成时的回调操作</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> retry_;                       <span class="comment">// 是否允许重试连接（即断线重连）</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> connect_;                     <span class="comment">// 是否需要连接</span></span><br><span class="line">    <span class="keyword">int</span> nextConnId_;                               <span class="comment">// 下一个 TCP 连接的 ID</span></span><br><span class="line">    std::mutex mutex_;                             <span class="comment">// 互斥锁</span></span><br><span class="line">    TcpConnectionPtr connection_;                  <span class="comment">// TCP 连接</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>TcpClient.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TcpClient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Connector.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EventLoop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SocketsOps.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 EventLoop 指针是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop* loop)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (loop == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">"%s =&gt; eventloop is null"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> detail {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除 TCP 连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">(EventLoop* loop, <span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">        loop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除连接器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeConnector</span><span class="params">(<span class="keyword">const</span> ConnectorPtr&amp; connector)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}  <span class="comment">// namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">TcpClient::<span class="built_in">TcpClient</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; serverAddr, <span class="keyword">const</span> std::string&amp; nameArg)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop)),</span><br><span class="line">      <span class="built_in">connector_</span>(<span class="keyword">new</span> <span class="built_in">Connector</span>(loop_, serverAddr)),</span><br><span class="line">      <span class="built_in">name_</span>(nameArg),</span><br><span class="line">      <span class="built_in">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class="line">      <span class="built_in">messageCallback_</span>(defaultMessageCallback),</span><br><span class="line">      <span class="built_in">retry_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">connect_</span>(<span class="literal">true</span>),</span><br><span class="line">      <span class="built_in">nextConnId_</span>(<span class="number">1</span>) {</span><br><span class="line">    <span class="comment">// 设置有新连接建立时的回调操作</span></span><br><span class="line">    connector_-&gt;<span class="built_in">setNewConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpClient::newConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"%s =&gt; crate tcp client [%s] - connector %p"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(), connector_.<span class="built_in">get</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">TcpClient::~<span class="built_in">TcpClient</span>() {</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"%s =&gt; destruct tcp client [%s] - connector %p"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(), connector_.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前 TcpConnection 的智能指针副本，并判断它是否是唯一拥有者</span></span><br><span class="line">    TcpConnectionPtr conn;</span><br><span class="line">    <span class="keyword">bool</span> unique = <span class="literal">true</span>;</span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        unique = connection_.<span class="built_in">unique</span>();</span><br><span class="line">        conn = connection_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conn) {</span><br><span class="line">        <span class="built_in">assert</span>(loop_ == conn-&gt;<span class="built_in">getLoop</span>());</span><br><span class="line">        <span class="comment">// 设置 TCP 连接关闭时的回调操作</span></span><br><span class="line">        CloseCallback cb = std::<span class="built_in">bind</span>(&amp;detail::removeConnection, loop_, std::placeholders::_1);</span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::setCloseCallback, conn, cb));</span><br><span class="line">        <span class="comment">// 如果 TCP 连接唯一</span></span><br><span class="line">        <span class="keyword">if</span> (unique) {</span><br><span class="line">            <span class="comment">// 强制关闭 TCP 连接</span></span><br><span class="line">            conn-&gt;forceClose();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 关闭连接器</span></span><br><span class="line">        connector_-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        <span class="comment">// 获取当前的连接器</span></span><br><span class="line">        <span class="keyword">auto</span> connector = connector_;</span><br><span class="line">        <span class="comment">// 唤醒 loop_ 所在的线程去移除连接器</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>([connector]() { detail::<span class="built_in">removeConnector</span>(connector); });</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::connect</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"%s =&gt; connect to %s"</span>, __PRETTY_FUNCTION__, connector_-&gt;<span class="built_in">serverAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 标记需要连接</span></span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 启动连接器</span></span><br><span class="line">    connector_-&gt;<span class="built_in">start</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::disconnect</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 标记不需要连接</span></span><br><span class="line">    connect_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 关闭当前 TCP 连接</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (connection_) {</span><br><span class="line">            connection_-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭客户端</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::stop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 标记不需要连接</span></span><br><span class="line">    connect_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 关闭连接器</span></span><br><span class="line">    connector_-&gt;<span class="built_in">stop</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前的 TCP 连接</span></span><br><span class="line"><span class="function">TcpConnectionPtr <span class="title">TcpClient::connection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> connection_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件循环</span></span><br><span class="line"><span class="function">EventLoop* <span class="title">TcpClient::getLoop</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> loop_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否允许重试连接</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TcpClient::retry</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> retry_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许重试连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::enableRetry</span><span class="params">()</span> </span>{</span><br><span class="line">    retry_ = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取客户端名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">TcpClient::name</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置连接建立/关闭时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::setConnectionCallback</span><span class="params">(ConnectionCallback cb)</span> </span>{</span><br><span class="line">    connectionCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置有数据到来时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::setMessageCallback</span><span class="params">(MessageCallback cb)</span> </span>{</span><br><span class="line">    messageCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据发送完成时的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::setWriteCompleteCallback</span><span class="params">(WriteCompleteCallback cb)</span> </span>{</span><br><span class="line">    writeCompleteCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>{</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远端地址</span></span><br><span class="line">    <span class="function">InetAddress <span class="title">peerAddr</span><span class="params">(getPeerAddr(sockfd))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 TCP 连接的名称</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">":%s#%d"</span>, peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本端地址</span></span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(getLocalAddr(sockfd))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TCP 连接对象</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(loop_, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP 连接的回调操作</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpClient::removeConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前的 TCP 连接</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        connection_ = conn;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    conn-&gt;<span class="built_in">connectEstablished</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::removeConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">assert</span>(loop_ == conn-&gt;<span class="built_in">getLoop</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置当前的 TCP 连接</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="built_in">assert</span>(connection_ == conn);</span><br><span class="line">        connection_.<span class="built_in">reset</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒 loop_ 所在的线程去销毁 TCP 连接</span></span><br><span class="line">    loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果允许重试连接，且需要连接</span></span><br><span class="line">    <span class="keyword">if</span> (retry_ &amp;&amp; connect_) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"%s =&gt; tcp client [%s] reconnecting to %s"</span>, __PRETTY_FUNCTION__, name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                 connector_-&gt;<span class="built_in">serverAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 重启连接器</span></span><br><span class="line">        connector_-&gt;<span class="built_in">restart</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><ul><li><code>ChatClient.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 MyMuduo 网络库开发 TCP 客户端程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TcpClient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ChatClient</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; serverAddr, <span class="keyword">const</span> std::string&amp; nameArg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ChatClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 客户端绑定连接回调函数，当连接或者断开服务器时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端绑定消息回调函数，当有数据接收时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP 客户端</span></span><br><span class="line">    TcpClient client_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EventLoop 事件循环</span></span><br><span class="line">    EventLoop* loop_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ChatClient.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 MyMuduo 网络库开发 TCP 客户端程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ChatClient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ChatClient::<span class="built_in">ChatClient</span>(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; serverAddr, <span class="keyword">const</span> std::string&amp; nameArg)</span><br><span class="line">    : <span class="built_in">client_</span>(loop, serverAddr, nameArg), <span class="built_in">loop_</span>(loop) {</span><br><span class="line">    <span class="comment">// 允许重试连接</span></span><br><span class="line">    client_.<span class="built_in">enableRetry</span>();</span><br><span class="line">    <span class="comment">// 设置客户端TCP连接的回调</span></span><br><span class="line">    client_.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;ChatClient::onConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    <span class="comment">// 设置客户端接收数据的回调</span></span><br><span class="line">    client_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ChatClient::onMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ChatClient::~<span class="built_in">ChatClient</span>() {</span><br><span class="line">    <span class="comment">// 发起断开连接</span></span><br><span class="line">    client_.<span class="built_in">disconnect</span>();</span><br><span class="line">    <span class="comment">// 停止内部 Connector 的重连机制，避免异步行为</span></span><br><span class="line">    client_.<span class="built_in">stop</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatClient::connect</span><span class="params">()</span> </span>{</span><br><span class="line">    client_.<span class="built_in">connect</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端绑定连接回调函数，当连接或者断开服务器时调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatClient::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="comment">// 连接创建</span></span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;<span class="built_in">connected</span>()) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"ChatClient - new connection [%s] -&gt; [%s], state: connected"</span>, conn-&gt;<span class="built_in">localAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">                 conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(<span class="string">"I'm "</span> + client_.<span class="built_in">name</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 连接断开</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"ChatClient - close connection [%s] -&gt; [%s], state: disconnected"</span>,</span><br><span class="line">                 conn-&gt;<span class="built_in">localAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>(), conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端绑定消息回调函数，当有数据接收时调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatClient::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取服务器发送的消息</span></span><br><span class="line">    std::string message = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉消息末尾的 '\r' 和 '\n' 字符（nc 命令会发送 CRLF）</span></span><br><span class="line">    <span class="keyword">while</span> (!message.<span class="built_in">empty</span>() &amp;&amp; (message.<span class="built_in">back</span>() == <span class="string">'\n'</span> || message.<span class="built_in">back</span>() == <span class="string">'\r'</span>)) {</span><br><span class="line">        message.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"ChatClient - receive message: [%s], time: %s"</span>, message.<span class="built_in">c_str</span>(), time.<span class="built_in">toString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ChatServer.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 MyMuduo 网络库开发 TCP 服务器程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TcpServer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天服务器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ChatServer</span>(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">const</span> std::string &amp;nameArg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ChatServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 处理用户的连接创建和断开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器绑定消息回调函数，当有数据接收时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buffer, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP 服务器</span></span><br><span class="line">    TcpServer server_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EventLoop 事件循环</span></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ChatServer.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 MyMuduo 网络库开发 TCP 服务器程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ChatServer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ChatServer::<span class="built_in">ChatServer</span>(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">const</span> std::string &amp;nameArg)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, listenAddr, nameArg), <span class="built_in">loop_</span>(loop) {</span><br><span class="line">    <span class="comment">// 设置服务器注册用户连接的创建和断开回调</span></span><br><span class="line">    server_.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;ChatServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器注册用户读写事件的回调</span></span><br><span class="line">    server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ChatServer::onMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的线程数量（比如：1个I/O线程，3个Worker线程）</span></span><br><span class="line">    server_.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ChatServer::~<span class="built_in">ChatServer</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 开启事件循环处理</span></span><br><span class="line">    server_.<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"ChatServer - start success, listening on %s"</span>, server_.<span class="built_in">ipPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户的连接创建和断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>{</span><br><span class="line">    <span class="comment">// 连接创建</span></span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;<span class="built_in">connected</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"ChatServer - Connection UP : %s"</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 连接断开</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"ChatServer - Connection DOWN : %s"</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用户读写事件（比如接收客户端发送的数据）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChatServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buffer, Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取客户端发送的消息</span></span><br><span class="line">    std::string message = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉消息末尾的 '\r' 和 '\n' 字符（telnet 命令会发送 CRLF）</span></span><br><span class="line">    <span class="keyword">while</span> (!message.<span class="built_in">empty</span>() &amp;&amp; (message.<span class="built_in">back</span>() == <span class="string">'\n'</span> || message.<span class="built_in">back</span>() == <span class="string">'\r'</span>)) {</span><br><span class="line">        message.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"ChatServer - receive message: [%s], time: %s, ip: %s"</span>, message.<span class="built_in">c_str</span>(), time.<span class="built_in">toString</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">             conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据给客户端</span></span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(<span class="string">"You just said: "</span> + message + <span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>main.cc</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyMuduo 网络库的使用案例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Linux 上运行程序：./bin/mymuduo_example</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ChatClient.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ChatServer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动聊天服务器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startChatServer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">6000</span>, <span class="string">"127.0.0.1"</span>)</span></span>;</span><br><span class="line">    <span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">"ChatServer"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以阻塞方式等待新客户端的连接、已连接客户端的读写事件等</span></span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动聊天客户端</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startChatClient</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">6000</span>, <span class="string">"127.0.0.1"</span>)</span></span>;</span><br><span class="line">    <span class="function">ChatClient <span class="title">client</span><span class="params">(&amp;loop, addr, <span class="string">"ChatClient"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    client.<span class="built_in">connect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以阻塞方式等待服务器发送过来的数据</span></span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    Logger::<span class="built_in">instance</span>().<span class="built_in">setLogLevel</span>(LogLevel::INFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在独立的线程上启动聊天服务器</span></span><br><span class="line">    <span class="function">std::thread <span class="title">serverThread</span><span class="params">([]() { startChatServer(); })</span></span>;</span><br><span class="line">    serverThread.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间，让聊天服务器先启动（可选，因为聊天客户端会自动重连）</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在独立的线程上启动聊天客户端</span></span><br><span class="line">    <span class="function">std::thread <span class="title">clientThrad</span><span class="params">([]() { startChatClient(); })</span></span>;</span><br><span class="line">    clientThrad.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待用户按下任意键，然后结束程序运行</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h3><ul><li>编译项目代码</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mymuduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行项目自动构建脚本</span></span><br><span class="line">./autobuild.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>运行测试程序</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行 MyMuduo 网络库使用案例的可执行文件</span></span><br><span class="line">./bin/mymuduo_example</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 telnet 命令连接 TCP 服务器（成功连接后，输入任意字符，按回车键即可发送消息给服务器，之后服务器会返回相应的消息内容）</span></span><br><span class="line">telnet 127.0.0.1 6000</span><br></pre></td></tr></tbody></table></figure><ul><li>测试程序输出的日志信息如下：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2025-11-15 22:10:01 =&gt; 6609 [INFO] ChatServer - start success, listening on 127.0.0.1:6000</span><br><span class="line">2025-11-15 22:10:01 =&gt; 6614 [INFO] TcpClient::TcpClient(EventLoop*, const InetAddress&amp;, const std::string&amp;) =&gt; crate tcp client [ChatClient] - connector 0x7f52b8000e20</span><br><span class="line">2025-11-15 22:10:01 =&gt; 6614 [INFO] void TcpClient::connect() =&gt; connect to 127.0.0.1:6000</span><br><span class="line">2025-11-15 22:10:01 =&gt; 6614 [INFO] ChatClient - new connection [127.0.0.1:42170] -&gt; [127.0.0.1:6000], state: connected</span><br><span class="line">2025-11-15 22:10:01 =&gt; 6610 [INFO] ChatServer - Connection UP : 127.0.0.1:42170</span><br><span class="line">2025-11-15 22:10:01 =&gt; 6610 [INFO] ChatServer - receive message: [I'm ChatClient], time: 2025-11-15 22:10:01, ip: 127.0.0.1:42170</span><br><span class="line">2025-11-15 22:10:01 =&gt; 6614 [INFO] ChatClient - receive message: [You just said: I'm ChatClient], time: 2025-11-15 22:10:01</span><br></pre></td></tr></tbody></table></figure><h2 id="项目扩展"><a href="#项目扩展" class="headerlink" title="项目扩展"></a>项目扩展</h2><p>上面的 MyMuduo 网络库代码只实现了 Muduo 的核心功能，并不支持 Muduo 的定时事件机制（<code>TimerQueue</code>）、IPV6 / DNS / HTTP / RPC 协议等，日后可以从以下几方面继续对其进行扩展：</p><ul><li><p>(1) 定时事件机制</p><ul><li>TimerQueue：支持 EventLoop 内的定时任务调度，常见实现方式包括：<ul><li>链表队列：实现简单，但不适合大量定时器场景（需要线性扫描）。</li><li>红黑树（如 <code>nginx</code>）：按照到期时间排序，可快速找到最早到期的定时器，插入 / 删除的时间复杂度为 <code>O(logN)</code>。</li><li>时间轮（如 <code>libevent</code>）：适合大量、定时精度要求不高的场景，插入 / 删除的时间复杂度为 <code>O(1)</code>，整体性能出色。</li></ul></li></ul></li><li><p>(2) IPV6 / DNS / HTTP / RPC 协议支持</p><ul><li>IPV6：支持 IPv6 套接字、地址解析与双栈接入，确保网络库的所有连接与事件处理流程均可透明兼容 IPv6。</li><li>DNS：实现异步域名解析（如 <code>getaddrinfo_a</code>），将域名解析和网络事件循环结合，避免阻塞 I/O。</li><li>HTTP：构建基础的 HTTP 请求解析、响应封装，可扩展为简单的 Web 服务器或客户端；需要支持 Keep-Alive、Chunked 等机制。</li><li>RPC：在已有 TCP 框架上封装请求 / 响应协议，实现序列化、服务注册、方法调用、超时与重试等功能（可仿照 gRPC 实现）。</li></ul></li><li><p>(3) 服务器性能测试</p><ul><li>为了验证网络库的性能，需要进行专业的性能压测和系统配置优化：</li><li>系统性能优化<ul><li> Linux 最大文件描述符数设置：包括<ul><li><code>/proc/sys/fs/file-max</code>（系统级限制）</li><li><code>/etc/security/limits.conf</code>（用户 / 进程级限制）</li><li><code>ulimit -n</code>（当前会话限制）</li></ul></li></ul></li><li>性能测试工具<ul><li><a target="_blank" rel="external nofollow" href="https://github.com/apache/jmeter?utm_source=chatgpt.com">JMeter</a>：可压测 HTTP 服务与自定义 TCP 服务，能够生成聚合报告和可视化图表。</li><li><a target="_blank" rel="external nofollow" href="https://github.com/wg/wrk?utm_source=chatgpt.com">wrk</a>：高性能 HTTP 压测工具，支持多线程 + <code>epoll</code>，需要手动编译安装，仅支持 HTTP 协议。</li></ul></li></ul></li></ul><h2 id="项目问答"><a href="#项目问答" class="headerlink" title="项目问答"></a>项目问答</h2><h3 id="新-TCP-连接的派发问题"><a href="#新-TCP-连接的派发问题" class="headerlink" title="新 TCP 连接的派发问题"></a>新 TCP 连接的派发问题</h3><p>在 Muduo 网络库中，mainLoop 是如何将新来的 TCP 连接派发给 subLoop 的，同时还让新 TCP 连接的所有 I/O 事件回调操作都在 subLoop 所在的线程上执行？</p><ul><li>(1) Acceptor 在 mainLoop（运行在主线程）上监听 <code>listenfd</code></li><li>(2) mainLoop 在收到新连接事件时，会调用 <code>Acceptor::handleRead()</code>，得到 <code>connfd</code>（新连接的文件描述符）</li><li>(3) mainLoop 选择一个 subLoop（通过 <code>EventLoopThreadPool</code> 的轮询）</li><li>(4) mainLoop 创建 <code>TcpConnection</code>，并把它的所有回调操作注册到 subLoop</li><li>(5) mainLoop 调用 <code>subLoop-&gt;runInLoop()</code>，将注册 connfd 读写事件到 subLoop 的 Poller 的任务丢给 subLoop</li><li>(6) subLoop 线程最终向自己的 Poller 注册事件，使得 <code>connfd</code> 的所有读写事件（包括 I/O 事件、回调处理等）永远在 subLoop 上执行</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::listen()</span><br><span class="line">         |  </span><br><span class="line">         | 1</span><br><span class="line">         v</span><br><span class="line">Acceptor::handleRead()</span><br><span class="line">         |</span><br><span class="line">         | 2</span><br><span class="line">         v</span><br><span class="line">TcpServer::newConnection(connfd)</span><br><span class="line">         |</span><br><span class="line">         | 3</span><br><span class="line">         v</span><br><span class="line">选中一个 subLoop (ioLoop)</span><br><span class="line">         |</span><br><span class="line">         | 4</span><br><span class="line">         v</span><br><span class="line">创建 TcpConnection(subLoop)</span><br><span class="line">         |</span><br><span class="line">         | 5</span><br><span class="line">         v</span><br><span class="line">subLoop-&gt;runInLoop(connectEstablished)</span><br><span class="line">         |</span><br><span class="line">         | 6</span><br><span class="line">         v</span><br><span class="line">----------------------------------------------------</span><br><span class="line">↓ subLoop (I/O 线程) 被唤醒后执行 connectEstablished()</span><br><span class="line">----------------------------------------------------</span><br><span class="line">         |</span><br><span class="line">         | 7</span><br><span class="line">         v</span><br><span class="line">channel_-&gt;enableReading()</span><br><span class="line">         |</span><br><span class="line">         | 8</span><br><span class="line">         v</span><br><span class="line">事件到来 → Poller 触发 → 执行 TcpConnection 的回调操作 (全部都会在 subLoop 线程上执行)</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>在 Muduo 中，新连接的建立仅发生在 mainLoop：它负责监听 <code>listenfd</code>，并在有新连接到来时调用 <code>accept()</code>。mainLoop 只负责接受连接，不参与任何与该连接相关的后续 I/O 操作（读和写等）。在 mainLoop 完成 <code>accept()</code> 后，Muduo 会将得到的新连接文件描述符 <code>connfd</code> 分发给某个 subLoop（由 <code>EventLoopThreadPool</code> 按轮询算法选择）。之后，该新连接的所有读写事件（包括 I/O 事件、回调处理等）都由对应的 subLoop 独立处理，与 mainLoop 无关。</li></ul></div><h3 id="EventLoop-之间的通信问题"><a href="#EventLoop-之间的通信问题" class="headerlink" title="EventLoop 之间的通信问题"></a>EventLoop 之间的通信问题</h3><p>mainLoop 与 subLoop 分别运行在不同的线程上，它们之间是如何进行通信的，也就是说 mainLoop 是如何将新来的 TCP 连接派发给 subLoop 的，还有 mainLoop 是如何唤醒 subLoop 的？</p><ul><li>(1) mainLoop 与 subLoop 分别运行在不同线程中，每个 EventLoop 拥有自己独立的线程与 Poller。</li><li>(2) 它们之间通过 EventLoop 的异步任务队列（<code>pendingFunctors</code>）进行通信，任何跨线程的操作，都会封装成回调函数投递到目标 EventLoop 的异步任务队列中。</li><li>(3) mainLoop 接收（<code>accept()</code>）到新连接后，调用 <code>subLoop-&gt;runInLoop()</code>，将 TcpConnection 的初始化任务（如 <code>connectEstablished()</code>）投递给指定的 subLoop 执行。</li><li>(4) mainLoop 向 subLoop 的任务队列中插入新任务后，会向 subLoop 的 <code>wakeupFd</code> 写入一个字节，目的是唤醒 subLoop 去执行 <code>pendingFunctors</code> 队列中的任务。</li><li>(5) 写入 <code>wakeupFd</code> 会触发 subLoop 的 <code>wakeupChannel</code> 可读事件，wakeupChannel 是注册在 subLoop 上的一个 Channel，用来专门处理 “被唤醒” 事件。</li><li>(6) 被唤醒的 subLoop 从阻塞的 <code>epoll_wait()</code> 中立即返回，然后执行 <code>wakeupChannel</code> 的读事件回调。</li><li>(7) subLoop 随后继续执行其 <code>pendingFunctors</code> 队列中的任务，包括由 mainLoop 投递过来的 TcpConnection 初始化操作。</li><li>(8) 从此以后，该 TcpConnection 的所有 I/O 事件都由该 subLoop 负责处理，包括读写事件回调、关闭回调、错误回调等全部在 subLoop 所在线程执行。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::listen()  </span><br><span class="line">        | </span><br><span class="line">        | 1</span><br><span class="line">        v  </span><br><span class="line">Acceptor::handleRead()</span><br><span class="line">        | </span><br><span class="line">        | 2</span><br><span class="line">        v  </span><br><span class="line">TcpServer::newConnection(connfd)  </span><br><span class="line">        | </span><br><span class="line">        | 3</span><br><span class="line">        v  </span><br><span class="line">EventLoopThreadPool::getNextLoop()  </span><br><span class="line">        | </span><br><span class="line">        | 4</span><br><span class="line">        v  </span><br><span class="line">new TcpConnection(subLoop, connfd)  </span><br><span class="line">        | </span><br><span class="line">        | 5</span><br><span class="line">        v  </span><br><span class="line">subLoop-&gt;runInLoop(std::bind(&amp;TcpConnection::connectEstablished, conn))  </span><br><span class="line">        | </span><br><span class="line">        | 6</span><br><span class="line">        v  </span><br><span class="line">EventLoop::queueInLoop(cb)  </span><br><span class="line">        | </span><br><span class="line">        | 7</span><br><span class="line">        v  </span><br><span class="line">EventLoop::wakeup()  </span><br><span class="line">        | </span><br><span class="line">        | 8</span><br><span class="line">        v  </span><br><span class="line">----------------------------------------------  </span><br><span class="line">↓ subLoop 所在线程（I/O 线程）被唤醒执行  </span><br><span class="line">----------------------------------------------  </span><br><span class="line">        | </span><br><span class="line">        | 9</span><br><span class="line">        v  </span><br><span class="line">wakeupChannel-&gt;handleEvent()  </span><br><span class="line">        | </span><br><span class="line">        | 10</span><br><span class="line">        v  </span><br><span class="line">EventLoop::handleRead()  </span><br><span class="line">        | </span><br><span class="line">        | 11</span><br><span class="line">        v  </span><br><span class="line">EventLoop::doPendingFunctors()  </span><br><span class="line">        | </span><br><span class="line">        | 12</span><br><span class="line">        v  </span><br><span class="line">TcpConnection::connectEstablished()  </span><br><span class="line">        | </span><br><span class="line">        | 13</span><br><span class="line">        v  </span><br><span class="line">Channel::enableReading()  </span><br><span class="line">        | </span><br><span class="line">        | 14</span><br><span class="line">        v  </span><br><span class="line">Poller::updateChannel(channel)  </span><br><span class="line">        | </span><br><span class="line">        | 15</span><br><span class="line">        v  </span><br><span class="line">事件到来 → Poller 触发 → 返回活跃事件 → 调用 channel-&gt;handleEvent() 处理活跃事件</span><br><span class="line">        | </span><br><span class="line">        | 16</span><br><span class="line">        v  </span><br><span class="line">回调操作在 subLoop 线程执行，保证线程安全  </span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/717586901">深入分析 Muduo 网络库核心代码</a></li><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/683396341">Muduo 库核心代码及优秀编程细节剖析</a></li><li><a target="_blank" rel="external nofollow" href="https://www.ituring.com.cn/article/504549">从抄书到开源之巅：章亦春的程序人生</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/dbb10768.html" title="基于 C++ 手写 Muduo 高性能网络库">https://www.techgrow.cn/posts/dbb10768.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> Linux系统编程</a><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 网络编程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/ef54a41c.html" rel="prev" title="Java 与 Dubbo 的 SPI 机制介绍"><i class="fa fa-angle-left"></i> Java 与 Dubbo 的 SPI 机制介绍</a></div><div class="post-nav-item"> <a href="/posts/54626c2e.html" rel="next" title="DevOps 的技术选型介绍">DevOps 的技术选型介绍<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2026</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.3m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">35:32</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"/lib/mathjax/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/dbb10768.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div><div id="moon-menu-item-code" class="moon-menu-item"><i class="fa-solid fa-code"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>