<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 巩固进阶之四"><meta property="og:url" content="https://www.techgrow.cn/posts/6e5acd18.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-03-07T13:55:33.000Z"><meta property="article:modified_time" content="2025-03-07T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.techgrow.cn/posts/6e5acd18.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/6e5acd18.html","path":"posts/6e5acd18.html","title":"C++ 巩固进阶之四"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 巩固进阶之四 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">C++ 的智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-text">智能指针的几种类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-text">智能指针的基础使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">不带引用计数的智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#auto-ptr-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">auto_ptr 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">使用案例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scoped-ptr-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">scoped_ptr 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-1"><span class="nav-text">使用案例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unique-ptr-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">unique_ptr 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-2"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-2"><span class="nav-text">使用案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">带引用计数的智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#shared-ptr-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">shared_ptr 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-3"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-3"><span class="nav-text">使用案例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#weak-ptr-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">weak_ptr 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-4"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F-shared-ptr-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-text">模拟 shared_ptr 循环引用问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3-shared-ptr-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-text">解决 shared_ptr 循环引用问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#weak-ptr-%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E8%B5%84%E6%BA%90"><span class="nav-text">weak_ptr 访问对象资源</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%A0%E9%99%A4%E5%99%A8"><span class="nav-text">自定义智能指针的删除器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">删除器的介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">删除器的使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">删除器的使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-text">删除器的案例代码一</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C"><span class="nav-text">删除器的案例代码二</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%89"><span class="nav-text">删除器的案例代码三</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">多线程访问共享对象的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#thread-detach-%E4%BB%8B%E7%BB%8D"><span class="nav-text">thread::detach () 介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-text">线程安全问题的产生</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="nav-text">线程安全问题的解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="nav-text">智能指针的模拟实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1"><span class="nav-text">不带引用计数的智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1"><span class="nav-text">带引用计数的智能指针</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">682</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/6e5acd18.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 巩固进阶之四 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 的巩固教程。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 巩固进阶之四</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-03-07 21:55:33" itemprop="dateCreated datePublished" datetime="2025-03-07T21:55:33+08:00">2025-03-07</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/6e5acd18.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/6e5acd18.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5.8k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>5 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-的智能指针"><a href="#C-的智能指针" class="headerlink" title="C++ 的智能指针"></a>C++ 的智能指针</h2><h3 id="智能指针的几种类型"><a href="#智能指针的几种类型" class="headerlink" title="智能指针的几种类型"></a>智能指针的几种类型</h3><p>在 C++ 中，智能指针的类型有以下几种：</p><ul><li>(1) 带引用计数的智能指针：<code>shared_ptr</code></li><li>(2) 不带引用计数的智能指针：<code>auto_ptr</code>、<code>scoped_ptr</code>、<code>unique_ptr</code></li><li>(3) 特殊的智能指针：<code>weak_ptr</code>（不增加引用计数，可以用于避免 <code>shared_ptr</code> 发生循环引用）</li></ul><table><thead><tr><th>智能指针</th><th>所有权</th><th>带引用计数</th><th>适用场景</th><th>核心特性</th></tr></thead><tbody><tr><td><code>auto_ptr</code></td><td>独占（拷贝时转移）</td><td>否</td><td>⚠ 已废弃，建议改用 <code>unique_ptr</code></td><td>独占所有权，在复制或赋值时会转移所有权，导致原指针变为空（<code>nullptr</code>）</td></tr><tr><td><code>scoped_ptr</code></td><td>独占</td><td>否</td><td>生命周期受限于作用域，适用于简单的场景，避免资源泄漏</td><td>独占所有权，不可复制或赋值，不支持移动语义，即不可以使用 <code>std::move()</code> 函数转移所有权</td></tr><tr><td><code>unique_ptr</code></td><td>独占</td><td>否</td><td>资源独占，生命周期明确</td><td>独占所有权，不可复制（拷贝构造和赋值），但可以移动（移动构造和移动赋值），即支持使用 <code>std::move()</code> 函数转移所有权</td></tr><tr><td><code>shared_ptr</code></td><td>共享</td><td>是</td><td>资源共享，生命周期不固定</td><td>共享所有权（允许多个智能指针管理同一个资源）</td></tr><tr><td><code>weak_ptr</code></td><td>观察 <code>shared_ptr</code></td><td>否</td><td>避免 <code>shared_ptr</code> 发生循环引用</td><td>不增加引用计数，用于避免 <code>shared_ptr</code> 发生循环引用，可以通过 <code>lock()</code> 函数转换为 <code>shared_ptr</code></td></tr></tbody></table><h3 id="智能指针的基础使用"><a href="#智能指针的基础使用" class="headerlink" title="智能指针的基础使用"></a>智能指针的基础使用</h3><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="/posts/dbff2af9.html#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">C++ 智能指针使用教程</a></li></ul></div><h4 id="不带引用计数的智能指针"><a href="#不带引用计数的智能指针" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h4><h5 id="auto-ptr-智能指针"><a href="#auto-ptr-智能指针" class="headerlink" title="auto_ptr 智能指针"></a>auto_ptr 智能指针</h5><h6 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h6><p><code>auto_ptr</code> 是 C++ 98 引入的智能指针，具有独占所有权，在复制或赋值时会转移所有权，导致原指针变为空（<code>nullptr</code>）。它可以自动释放资源，但由于容易导致空指针问题，在 C++ 11 被弃用，推荐使用 <code>unique_ptr</code> 或 <code>shared_ptr</code> 代替。<code>auto_ptr</code> 的核心特性如下：</p><ul><li><p>独占所有权（所有权转移）：</p><ul><li>不能有多个 <code>auto_ptr</code> 共享同一资源。</li><li>复制或赋值时，所有权会从原指针转移到新指针，原指针会变为空（<code>nullptr</code>）。</li></ul></li><li><p>自动释放资源：</p><ul><li>在 <code>auto_ptr</code> 离开作用域时，会自动调用 <code>delete</code> 释放资源，防止内存泄漏。</li></ul></li><li><p>已被 C++ 11 弃用：</p><ul><li>由于所有权转移容易导致空指针问题，<code>auto_ptr</code> 在 C++ 11 中已经被 <code>unique_ptr</code> 或者 <code>shared_ptr</code> 取代。</li></ul></li></ul><h6 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h6><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;   <span class="comment">// ptr1 拥有这个动态分配的 int(20)</span></span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;          <span class="comment">// 可复制，ptr1 的所有权被 ptr2 接管，ptr1 变为空</span></span><br><span class="line">    *ptr2 = <span class="number">10</span>;                        <span class="comment">// 通过 ptr2 修改资源的值</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;          // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;             <span class="comment">// 正常输出 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;   <span class="comment">// ptr1 拥有这个动态分配的 int(20)</span></span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;   <span class="comment">// 可赋值，ptr2 拥有这个动态分配的 int(30)</span></span><br><span class="line">    ptr2 = ptr1;                       <span class="comment">// ptr1 的所有权被 ptr2 接管，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;          // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;             <span class="comment">// 正常输出 20</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="scoped-ptr-智能指针"><a href="#scoped-ptr-智能指针" class="headerlink" title="scoped_ptr 智能指针"></a>scoped_ptr 智能指针</h5><h6 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h6><p><code>scoped_ptr</code> 是 Boost 库提供的一种简单智能指针，独占所有权，不可复制或赋值，不支持移动语义，即不可以使用 <code>std::move()</code> 函数转移所有权，在离开作用域时自动释放资源。类似于 <code>unique_ptr</code>，但不支持移动语义，适用于 RAII（资源管理即初始化） 场景。在 C++ 11 之后，推荐使用 <code>unique_ptr</code> 代替。<code>scoped_ptr</code> 的核心特性如下：</p><ul><li><p>独占所有权：</p><ul><li>只能有一个 <code>scoped_ptr</code> 拥有资源，不可复制或赋值。</li></ul></li><li><p>自动释放资源：</p><ul><li>离开作用域时自动调用 <code>delete</code> 释放资源，防止内存泄漏。</li></ul></li><li><p>不支持移动语义：</p><ul><li>不能使用 <code>std::move()</code> 函数转移所有权（但相比 <code>unique_ptr</code>，功能更简单）。</li></ul></li><li><p>适用于 RAII（资源管理即初始化）：</p><ul><li>适合管理动态分配的对象，确保作用域结束时资源被释放。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>阅读 <code>scoped_ptr</code> 的底层源码，可以发现它的拷贝构造函数和赋值运算符重载函数都被 <code>delete</code> 掉，所以它才不支持复制或赋值（转移）。</p></div><h6 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h6><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// boost::scoped_ptr&lt;int&gt; ptr2(ptr1);       // 编译出错，不可复制</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = ptr1;     // 编译出错，不可赋值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// boost::scoped_ptr&lt;int&gt; ptr2(move(ptr1));       // 编译出错，不支持移动构造</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = move(ptr1);      // 编译出错，不支持移动赋值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="unique-ptr-智能指针"><a href="#unique-ptr-智能指针" class="headerlink" title="unique_ptr 智能指针"></a>unique_ptr 智能指针</h5><h6 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h6><p><code>unique_ptr</code> 是 C++ 11 引入的智能指针，独占所有权，不可复制（拷贝构造和赋值），但可以移动（移动构造和移动赋值），即支持使用 <code>std::move()</code> 函数转移所有权。它在离开作用域时自动释放资源，适用于 RAII（资源管理即初始化），是 <code>auto_ptr</code> 和 <code>scoped_ptr</code> 的现代替代方案。<code>unique_ptr</code> 的核心特性如下：</p><ul><li><p>独占所有权：</p><ul><li>只能有一个 <code>unique_ptr</code> 拥有同一资源，不可复制。</li></ul></li><li><p>支持移动语义：</p><ul><li>可通过 <code>std::move()</code> 函数转移所有权。</li></ul></li><li><p>自动释放资源：</p><ul><li>离开作用域时自动调用 <code>delete</code> 释放资源，防止内存泄漏。</li></ul></li><li><p>支持自定义删除器：</p><ul><li>可指定自定义删除器，如 <code>std::default_delete</code> 或 Lambda。</li></ul></li><li><p>轻量且性能优越：</p><ul><li>不会有额外的引用计数（相比 <code>shared_ptr</code> 而言），适用于 RAII 管理单一对象。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>阅读 <code>unique_ptr</code> 的底层源码，可以发现它使用了带右值引用参数的拷贝构造函数和赋值运算符重载函数，所以它才可以通过 <code>std::move()</code> 函数转移所有权。</li></ul></div><h6 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h6><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;int&gt; ptr2(ptr1);         // 编译出错，不可复制</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = ptr1;                         // 编译出错，不可赋值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(move(ptr1))</span></span>;      <span class="comment">// 支持移动构造，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    ptr2 = <span class="built_in">move</span>(ptr1);                     <span class="comment">// 支持移动赋值，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="带引用计数的智能指针"><a href="#带引用计数的智能指针" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h4><p>C++ 11 带引用计数的智能指针允许多个指针共享同一个资源。当最后一个指向资源的智能指针被销毁时，资源才会被释放。它通过引用计数来跟踪有多少个智能指针指向同一资源，确保资源在不再使用时自动释放，避免内存泄漏。</p><ul><li>C++ 11 带引用计数的智能指针有两种，分别是：<ul><li><code>shared_ptr</code>：强引用智能指针，可以改变资源的引用计数</li><li><code>weak_ptr</code>：弱引用智能指针，不会改变资源的引用计数，主要用于避免 <code>shared_ptr</code> 智能指针的循环引用</li></ul></li></ul><h5 id="shared-ptr-智能指针"><a href="#shared-ptr-智能指针" class="headerlink" title="shared_ptr 智能指针"></a>shared_ptr 智能指针</h5><h6 id="概念介绍-3"><a href="#概念介绍-3" class="headerlink" title="概念介绍"></a>概念介绍</h6><p><code>shared_ptr</code> 是 C++ 11 引入的智能指针，允许多个指针共享同一资源。它通过引用计数来跟踪有多少个指针指向同一对象，当最后一个指向该资源的 <code>shared_ptr</code> 被销毁时，资源会自动释放。适用于需要多个所有者共享同一资源的场景，即需要多个智能指针管理同一个资源。<code>shared_ptr</code> 的核心特性如下：</p><ul><li>共享所有权<ul><li>多个 <code>shared_ptr</code> 可以同时指向同一对象，共享资源的所有权。</li></ul></li><li>引用计数<ul><li>每个 <code>shared_ptr</code> 内部维护一个引用计数，表示当前有多少个指针引用该资源。</li></ul></li><li>自动管理内存<ul><li>当引用计数归零时，资源被自动释放。</li></ul></li></ul><h6 id="使用案例-3"><a href="#使用案例-3" class="headerlink" title="使用案例"></a>使用案例</h6><p>在创建 <code>shared_ptr</code> 智能指针时，建议使用 <code>make_shared()</code> 函数来创建，而不是直接 <code>new</code>，其原因如下：</p><ul><li><p>使用 <code>make_shared()</code> 函数</p><ul><li>写法：<code>shared_ptr&lt;Person&gt; sp1 = make_shared&lt;Person&gt;();</code></li><li>只进行一次内存分配（对象数据和控制块在同一块内存中），可以减少开销。</li><li>资源的内存分配和 <code>shared_ptr</code> 创建是原子操作，可以避免内存泄漏和异常安全问题。</li></ul></li><li><p>使用 <code>new</code> 关键字</p><ul><li>写法：<code>shared_ptr&lt;Person&gt; sp1(new Person());</code></li><li>需要进行两次内存分配（一次是给 Person，另一次是给 <code>shared_ptr</code> 的控制块），性能稍低。</li><li><code>new</code> 和 <code>shared_ptr</code> 绑定是分离的，如果 <code>shared_ptr</code> 还没成功创建，但 <code>new</code> 已经分配内存，这可能会导致内存泄漏。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Using Person"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个 shared_ptr sp1，并管理 Person 对象</span></span><br><span class="line">    shared_ptr&lt;Person&gt; sp1 = make_shared&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不建议这样写</span></span><br><span class="line">    <span class="comment">// shared_ptr&lt;Person&gt; sp1(new Person());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Reference count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建一个 shared_ptr sp2，共享 sp1 的资源</span></span><br><span class="line">        shared_ptr&lt;Person&gt; sp2 = sp1;</span><br><span class="line">        <span class="comment">// 打印引用计数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"Reference count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 访问资源</span></span><br><span class="line">        sp2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    } <span class="comment">// 作用域结束后，sp2 自动析构，引用计数减少</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印引用计数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Reference count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person()</span><br><span class="line">Reference count: 1</span><br><span class="line">Reference count: 2</span><br><span class="line">Using Person</span><br><span class="line">Reference count: 1</span><br><span class="line">~Person()</span><br></pre></td></tr></tbody></table></figure><h5 id="weak-ptr-智能指针"><a href="#weak-ptr-智能指针" class="headerlink" title="weak_ptr 智能指针"></a>weak_ptr 智能指针</h5><h6 id="概念介绍-4"><a href="#概念介绍-4" class="headerlink" title="概念介绍"></a>概念介绍</h6><p><code>weak_ptr</code> 是 C++ 11 的智能指针之一，主要用于避免 <code>shared_ptr</code> 智能指针之间的循环引用问题。它是 <code>shared_ptr</code> 智能指针的弱引用，不会增加引用计数，不能直接访问资源，但可以通过 <code>lock()</code> 函数将其转换为 <code>shared_ptr</code> 智能指针来访问资源。当资源已被释放时，<code>lock()</code> 函数会返回空指针，可用于判断对象是否仍然存在。<code>weak_ptr</code> 的核心特性如下：</p><ul><li>不增加引用计数<ul><li>只持有 <code>shared_ptr</code> 智能指针的弱引用，不影响对象生命周期。</li></ul></li><li>防止循环引用<ul><li>可以解决 <code>shared_ptr</code> 智能指针循环引用导致的内存泄漏问题。</li></ul></li><li>检查资源状态<ul><li>可以通过 <code>expired()</code> 函数判断资源是否仍然存在。</li></ul></li><li>访问资源<ul><li>可以通过 <code>lock()</code> 函数转换为 <code>shared_ptr</code> 智能指针，若资源已释放，则返回空指针。</li></ul></li><li>可重置与交换<ul><li>支持使用 <code>reset()</code> 函数释放关联，还支持使用 <code>swap()</code> 函数交换指针内容。</li></ul></li></ul><h6 id="模拟-shared-ptr-循环引用问题"><a href="#模拟-shared-ptr-循环引用问题" class="headerlink" title="模拟 shared_ptr 循环引用问题"></a>模拟 shared_ptr 循环引用问题</h6><p>本节将演示在使用 <code>shared_ptr</code> 智能指针时，怎样才会发生循环引用的问题。在下述代码中，会发生智能指针循环引用的问题，最终导致堆上的对象 A 和 对象 B 无法正常析构（释放内存资源），最终导致内存泄漏，详细的分析图解请看 <a href="../../../asset/2025/02/cxx_shared_pointer_1.png">这里</a>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟 shared_ptr 智能指针发生循环引用的问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;B&gt; _ptrB;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;A&gt; _ptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">ptrA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">ptrB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会造成智能指针的循环引用，导致程序结束运行后资源无法正常被析构（释放内存空间）</span></span><br><span class="line">    ptrA-&gt;_ptrB = ptrB;</span><br><span class="line">    ptrB-&gt;_ptrA = ptrA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印智能指针的引用计数</span></span><br><span class="line">    cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ptrB.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h6 id="解决-shared-ptr-循环引用问题"><a href="#解决-shared-ptr-循环引用问题" class="headerlink" title="解决 shared_ptr 循环引用问题"></a>解决 shared_ptr 循环引用问题</h6><p>为了解决 <code>shared_ptr</code> 智能指针使用不当导致的循环引用问题，可以在定义对象的时候，使用强引用智能指针（<code>shared_ptr</code>）；而在引用对象的时候，使用弱引用智能指针（<code>weak_ptr</code>）。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解決 shared_ptr 智能指针的循环引用问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 B 的存在，但未定义 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">A</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 引用对象时，使用弱引用智能指针 (weak_ptr)</span></span><br><span class="line">	weak_ptr&lt;B&gt; _ptrB;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">B</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 引用对象时，使用弱引用智能指针 (weak_ptr)</span></span><br><span class="line">	weak_ptr&lt;A&gt; _ptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">// 定义对象时，使用强引用智能指针 (shared_ptr)</span></span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">ptrA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">ptrB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里不会造成智能指针循环引用的问题</span></span><br><span class="line">	ptrA-&gt;_ptrB = ptrB;</span><br><span class="line">	ptrB-&gt;_ptrA = ptrA;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印智能指针的引用计数</span></span><br><span class="line">	cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ptrB.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><h6 id="weak-ptr-访问对象资源"><a href="#weak-ptr-访问对象资源" class="headerlink" title="weak_ptr 访问对象资源"></a>weak_ptr 访问对象资源</h6><p><code>weak_ptr</code> 智能指针是 <code>shared_ptr</code> 智能指针的弱引用，不会增加引用计数，不能直接访问资源，但可以通过 <code>lock()</code> 函数转换为 <code>shared_ptr</code> 智能指针来访问资源。当资源已被释放时，<code>lock()</code> 函数会返回空指针，可用于判断对象是否仍然存在。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weak_ptr 通过 lock() 函数访问对象资源</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 B 的存在，但未定义 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 func 方法的存在，但未定义 func 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用对象时，使用弱引用智能指针</span></span><br><span class="line">    weak_ptr&lt;B&gt; _ptrB;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 func 方法的存在，但未定义 func 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用对象时，使用弱引用智能指针</span></span><br><span class="line">    weak_ptr&lt;A&gt; _ptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::func</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"A::func()"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 必须将弱引用智能指针转换为强引用智能指针，这样才能访问被管理对象的资源</span></span><br><span class="line">    shared_ptr&lt;B&gt; ptrB = _ptrB.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (ptrB != <span class="literal">nullptr</span>) {</span><br><span class="line">        ptrB-&gt;<span class="built_in">func</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::func</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"B::func()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义对象时，使用强引用智能指针</span></span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">ptrA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">ptrB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不会造成智能指针循环引用的问题</span></span><br><span class="line">    ptrA-&gt;_ptrB = ptrB;</span><br><span class="line">    ptrA-&gt;<span class="built_in">func</span>();</span><br><span class="line">    ptrB-&gt;_ptrA = ptrA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印智能指针的引用计数</span></span><br><span class="line">    cout &lt;&lt; ptrA.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ptrB.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">A::func()</span><br><span class="line">B::func()</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义智能指针的删除器"><a href="#自定义智能指针的删除器" class="headerlink" title="自定义智能指针的删除器"></a>自定义智能指针的删除器</h4><h5 id="删除器的介绍"><a href="#删除器的介绍" class="headerlink" title="删除器的介绍"></a>删除器的介绍</h5><p>C++ 智能指针的删除器（Deleter）是一个可自定义的回调函数，用于在智能指针释放资源时自动执行自定义的删除操作。</p><ul><li><code>unique_ptr</code> 智能指针的删除器可以是函数指针或仿函数（函数对象），允许自定义释放方式，例如调用 <code>delete[]</code> 代替 <code>delete</code>。</li><li><code>shared_ptr</code> 智能指针的删除器可以确保所有引用计数归零后执行自定义删除操作。</li></ul><h5 id="删除器的使用场景"><a href="#删除器的使用场景" class="headerlink" title="删除器的使用场景"></a>删除器的使用场景</h5><p>在以下使用情况下，C++ 需要自定义智能指针的删除器。</p><ul><li>(1) 使用非 <code>new</code> 分配的资源。当对象的创建方式不是 <code>new</code>，不能用默认 <code>delete</code> 释放时，需要自定义删除器。例如，使用 <code>malloc()</code> 分配的内存必须用 <code>free()</code> 释放。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>, <span class="title">decltype</span><span class="params">(&amp;free)</span>&gt; <span class="title">ptr</span><span class="params">((<span class="keyword">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)), free)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 管理文件、网络、数据库等系统资源。智能指针默认用 <code>delete</code> 释放资源，但某些系统资源（如文件、数据库连接、网络套接字）需要调用特定 API 释放资源。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;fclose)</span>&gt; <span class="title">file</span><span class="params">(fopen(<span class="string">"data.txt"</span>, <span class="string">"w"</span>), fclose)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 数组（<code>new[]</code>）资源的正确释放。默认的 <code>unique_ptr</code> 只调用 <code>delete</code>，而不是 <code>delete[]</code>，所以管理动态数组时，需要自定义删除器。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>[], <span class="title">void</span><span class="params">(*)</span><span class="params">(<span class="keyword">int</span>*)</span>&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span>* p) { <span class="keyword">delete</span>[] p; })</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>; <span class="comment">// C++ 11 允许直接用 unique_ptr&lt;int[]&gt;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 需要额外的清理操作。对象释放时，需要额外的清理步骤，比如日志记录、计数等。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customDeleter</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Deleting pointer: "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>, <span class="title">decltype</span><span class="params">(&amp;customDeleter)</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>), customDeleter)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>(5) 使用 <code>shared_ptr</code> 时需要优化删除器大小。<code>shared_ptr</code> 允许自定义删除器，但它需要存储删除器对象，因此通常使用函数对象（仿函数）或 Lambda 来优化删除器大小。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDeleter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>* p)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Deleting shared ptr: "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>), CustomDeleter())</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> deleter = [](<span class="keyword">int</span>* p) { <span class="keyword">delete</span> p; };</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>), deleter)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="删除器的使用案例"><a href="#删除器的使用案例" class="headerlink" title="删除器的使用案例"></a>删除器的使用案例</h5><h6 id="删除器的案例代码一"><a href="#删除器的案例代码一" class="headerlink" title="删除器的案例代码一"></a>删除器的案例代码一</h6><p>通过模板类单独定义了两个函数对象（仿函数），来实现 <code>unique_ptr</code> 智能指针的删除器。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数组的删除器（函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayDeleter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * arrayPtr)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Deleting array pointer"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (arrayPtr != <span class="literal">nullptr</span>) {</span><br><span class="line">			<span class="keyword">delete</span>[] arrayPtr;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义文件的删除器（函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileDeleter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* filePtr)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Deleting file pointer"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (filePtr != <span class="literal">nullptr</span>) {</span><br><span class="line">			<span class="built_in">fclose</span>(filePtr);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">// 创建一个智能指针管理整型数组，并指定删除器</span></span><br><span class="line">	unique_ptr&lt;<span class="keyword">int</span>, ArrayDeleter&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个智能指针管理文件，并指定删除器</span></span><br><span class="line">	unique_ptr&lt;FILE, FileDeleter&lt;FILE&gt;&gt; <span class="built_in">ptr2</span>(<span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deleting file pointer</span><br><span class="line">Deleting array pointer</span><br></pre></td></tr></tbody></table></figure><h6 id="删除器的案例代码二"><a href="#删除器的案例代码二" class="headerlink" title="删除器的案例代码二"></a>删除器的案例代码二</h6><p>在上述的案例代码一中，通过模板类单独定义了两个函数对象（仿函数）来实现智能指针的删除器，这略显得冗余，因为删除器在定义之后只使用了一次。为了使代码更简洁，可以使用 Lambda 表达式来定义智能指针的删除器。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">// 创建一个智能指针管理整型数组，并通过Lambda表达指定删除器</span></span><br><span class="line">	unique_ptr&lt;<span class="keyword">int</span>, function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>*)&gt;&gt; <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>], [](<span class="keyword">int</span>* p) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"Deleting array pointer by lambda"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[] p;</span><br><span class="line">	});</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个智能指针管理文件，并通过Lambda表达指定删除器</span></span><br><span class="line">	unique_ptr&lt;FILE, function&lt;<span class="built_in"><span class="keyword">void</span></span>(FILE*)&gt;&gt; <span class="built_in">ptr2</span>(<span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>), [](FILE* p) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"Deleting file pointer by lambda"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">fclose</span>(p);</span><br><span class="line">	});</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deleting file pointer by lambda</span><br><span class="line">Deleting array pointer by lambda</span><br></pre></td></tr></tbody></table></figure><h6 id="删除器的案例代码三"><a href="#删除器的案例代码三" class="headerlink" title="删除器的案例代码三"></a>删除器的案例代码三</h6><p>除了上面介绍的删除器定义方式之外，还可以使用函数指针作为 <code>unique_ptr</code> 智能指针的删除器。通过 <code>std::decltype()</code> 来获取 <code>arrayDeleter()</code> 函数的类型，并将其作为 <code>unique_ptr</code> 智能指针的删除器类型。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayDeleter</span><span class="params">(<span class="keyword">int</span>* ptr)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Deleting array pointer: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个智能指针管理文件，并通过函数指针指定删除器</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>, <span class="title">decltype</span><span class="params">(&amp;arrayDeleter)</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], arrayDeleter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效写法之一</span></span><br><span class="line">    <span class="comment">// using DeleterType = void(*)(int*);  // 明确指定删除器类型</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int, DeleterType&gt; ptr(new int[100], arrayDeleter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效写法之二</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int(10), arrayDeleter);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deleting array pointer: 000001B05684F800</span><br></pre></td></tr></tbody></table></figure><h4 id="多线程访问共享对象的问题"><a href="#多线程访问共享对象的问题" class="headerlink" title="多线程访问共享对象的问题"></a>多线程访问共享对象的问题</h4><p>在多个线程同时访问同一个对象（共享对象）时，往往会产生线程安全问题，下面将介绍如何使用 C++ 11 的 <code>shared_ptr</code> 与 <code>weak_ptr</code> 智能指针来解决线程安全问题。</p><h5 id="thread-detach-介绍"><a href="#thread-detach-介绍" class="headerlink" title="thread::detach() 介绍"></a>thread::detach () 介绍</h5><p>这里先简单介绍一下 <code>thread::detach()</code> 函数，有助于理解后面给出的多线程案例代码。</p><ul><li><p><code>thread::detach()</code> 函数的作用</p><ul><li><code>detach()</code> 提供了一种非阻塞方式来运行线程</li><li>线程一旦 <code>detach()</code>，就会变成守护线程（Daemon Thread），独立于 <code>thread</code> 对象运行。</li><li><code>thread</code> 对象与底层线程资源分离，<code>thread</code> 对象销毁时不会影响已分离的线程。</li><li>适用于不需要等待线程结束的场景，例如后台任务或日志记录等。</li></ul></li><li><p><code>thread::detach()</code> 函数的注意事项</p><ul><li><code>不要访问已销毁的资源</code>：调用 <code>detach()</code> 后，线程对象的生命周期由操作系统管理，后续不能再通过 <code>thread</code> 访问它，否则会导致未定义行为。</li><li><code>避免主线程提前退出</code>：<code>main()</code> 退出时，所有仍在运行的分离线程会被终止，这可能导致任务未完成或资源泄漏。</li><li><code>不能 detach() 两次</code>：如果 <code>thread</code> 已经 <code>detach()</code>，再次调用 <code>detach()</code> 会导致错误。</li></ul></li><li><p><code>thread::detach()</code> 与 <code>thread::join()</code> 的区别</p><ul><li><code>join()</code>：阻塞主线程，直到子线程执行完毕，适用于必须等待子线程完成的任务（如并行计算）。</li><li><code>detach()</code>：让子线程独立运行，主线程不会等待它执行完毕，适用于不关心子线程何时完成的任务（如日志记录、异步 I/O 任务）。</li></ul></li></ul><h5 id="线程安全问题的产生"><a href="#线程安全问题的产生" class="headerlink" title="线程安全问题的产生"></a>线程安全问题的产生</h5><p>下述这段 C++ 代码会产生线程安全问题，因为主线程和子线程同时访问共享对象 Task，但是主线程在子线程访问共享对象 Task 之前，将共享对象析构掉，这会导致子线程在后续访问共享对象时产生不可预知的行为。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全问题的产生</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"invoke Task::run()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executTask</span><span class="params">(Task *task)</span> </span>{</span><br><span class="line">    <span class="comment">// 子线程等待 5 秒</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="comment">// 执行任务方法</span></span><br><span class="line">    task-&gt;<span class="built_in">run</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Task *task = <span class="keyword">new</span> <span class="built_in">Task</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(executTask, task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子线程与 thread 对象分离，使其在后台独立运行，直到子线程执行完毕</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程在子线程调用 Task::run() 函数之前析构 Task 对象（共享对象），这样就会产生线程安全问题</span></span><br><span class="line">    <span class="keyword">delete</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子线程执行完成</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="线程安全问题的解决"><a href="#线程安全问题的解决" class="headerlink" title="线程安全问题的解决"></a>线程安全问题的解决</h5><p>这里利用 <code>weak_ptr</code> 智能指针可以观察 <code>shared_ptr</code> 智能指针状态的特性，来解决多线程访问共享对象的线程安全问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全问题的解决</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Task</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Task()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"invoke Task::run()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executTask</span><span class="params">(weak_ptr&lt;Task&gt; wp)</span> </span>{</span><br><span class="line">    <span class="comment">// 子线程等待 5 秒</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子线程访问共享对象时，先检查共享对象是否存活</span></span><br><span class="line">    shared_ptr&lt;Task&gt; sp = wp.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">nullptr</span>) {</span><br><span class="line">        sp-&gt;<span class="built_in">run</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Failed to invoke Task:run()"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建强引用智能指针</span></span><br><span class="line">        shared_ptr&lt;Task&gt; task = make_shared&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(executTask, weak_ptr&lt;Task&gt;(task))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子线程与 thread 对象分离，使其在后台独立运行，直到子线程执行完毕</span></span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 共享对象 task 出了作用域后会自动释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待子线程执行完成</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task()</span><br><span class="line">~Task()</span><br><span class="line">Failed to invoke Task:run()</span><br></pre></td></tr></tbody></table></figure><h3 id="智能指针的模拟实现"><a href="#智能指针的模拟实现" class="headerlink" title="智能指针的模拟实现"></a>智能指针的模拟实现</h3><p>本节将使用 C++ 的类模板来简单模拟实现智能指针。</p><div class="admonition note"><p class="admonition-title">提示</p><p>智能指针的本质是利用栈上的对象出了作用域（比如函数作用域）后自动析构的特性，以此来实现资源的自动释放。</p></div><h4 id="不带引用计数的智能指针-1"><a href="#不带引用计数的智能指针-1" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h4><p>本节将使用类模板、右值引用、移动语义（<code>move</code> ）来简单模拟实现 C++ 11 中的 <code>unique_ptr</code> 智能指针。</p><div class="admonition note"><p class="admonition-title">扩展阅读</p><p>更多关于 C++ 11 右值引用和移动语义（<code>move</code> ）的介绍请看 <a href="/posts/e302ad63.html">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现不带引用计数的智能指针，类似 unique_ptr 智能指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSmartPtr</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(T *ptr)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~CSmartPtr()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式删除带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式删除带左值引用参数的赋值运算符重载函数</span></span><br><span class="line">    CSmartPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数，支持移动构造（即支持 move 移动语义）</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(CSmartPtr&lt;T&gt; &amp;&amp;src) <span class="keyword">noexcept</span> : _ptr(src._ptr) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(CSmartPtr&lt;T&gt; &amp;&amp;src)"</span> &lt;&lt; endl;</span><br><span class="line">        src._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载函数，支持移动赋值（即支持 move 移动语义）</span></span><br><span class="line">    CSmartPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(CSmartPtr&lt;T&gt; &amp;&amp;src) <span class="keyword">noexcept</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr&lt;T&gt; &amp;operator=(CSmartPtr&lt;T&gt; &amp;&amp;src)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 避免自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先存储当前的指针，避免删除自己后 src._ptr 变为 nullptr</span></span><br><span class="line">        T *old_ptr = _ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转移所有权</span></span><br><span class="line">        _ptr = src._ptr;</span><br><span class="line">        src._ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放旧资源</span></span><br><span class="line">        <span class="keyword">delete</span> old_ptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// * 运算符重载函数</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() {</span><br><span class="line">        <span class="keyword">if</span> (!_ptr) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Dereferencing a null pointer!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -&gt; 运算符重载函数</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() {</span><br><span class="line">        <span class="keyword">if</span> (!_ptr) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Accessing member of a null pointer!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有权，不删除对象</span></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">        T *temp = _ptr;</span><br><span class="line">        _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">        <span class="comment">// 避免 delete 自己的对象</span></span><br><span class="line">        <span class="keyword">if</span> (_ptr == ptr) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">        _ptr = ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始指针</span></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="comment">// CSmartPtr&lt;int&gt; ptr2(ptr1);         // 编译出错，不可复制</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr2 = ptr1;                         // 编译出错，不可赋值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(move(ptr1))</span></span>;      <span class="comment">// 支持移动构造，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    ptr2 = <span class="built_in">move</span>(ptr1);                     <span class="comment">// 支持移动赋值，将 ptr1 的所有权转移到 ptr2，ptr1 变为空</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; *ptr1 &lt;&lt; endl;              // 程序运行出错，试图解引用 ptr1，会导致未定义行为</span></span><br><span class="line">    cout &lt;&lt; *ptr2 &lt;&lt; endl;                 <span class="comment">// 正常输出 30</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> *rawPtr = p1.<span class="built_in">release</span>();             <span class="comment">// p1 不再管理该资源</span></span><br><span class="line">    <span class="keyword">delete</span> rawPtr;                          <span class="comment">// 需要手动释放</span></span><br><span class="line"></span><br><span class="line">    CSmartPtr&lt;<span class="keyword">int</span>&gt; p2;</span><br><span class="line">    p2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>));                 <span class="comment">// 重新分配资源</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="built_in">test05</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">C++ 11 及更高版本中的特殊成员函数行为</p><ul><li>如果用户通过右值引用参数声明了移动构造函数或移动赋值运算符重载函数，而没有显式声明拷贝构造函数或赋值运算符重载函数（带左值引用参数），则：</li><li>(1) 拷贝构造函数（带左值引用参数）会被隐式删除（<code>= delete</code>）。</li><li>(2) 赋值运算符重载函数（带左值引用参数）会被隐式删除（<code>= delete</code>）。</li></ul></div><table><thead><tr><th><strong>是否定义了用户自定义的…</strong></th><th> <strong>默认拷贝构造</strong></th><th><strong>默认拷贝赋值</strong></th><th><strong>默认移动构造</strong></th><th><strong>默认移动赋值</strong></th></tr></thead><tbody><tr><td>没有移动构造和移动赋值</td><td>✅ 自动生成</td><td>✅ 自动生成</td><td>❌ <strong>不会自动生成</strong></td><td>❌ <strong>不会自动生成</strong></td></tr><tr><td><strong>定义了移动构造或移动赋值</strong></td><td>❌ <strong>隐式删除</strong></td><td>❌ <strong>隐式删除</strong></td><td>✅ 存在</td><td>✅ 存在</td></tr></tbody></table><h4 id="带引用计数的智能指针-1"><a href="#带引用计数的智能指针-1" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h4><p>本节将使用类模板来简单模拟实现 C++ 11 中的 <code>shared_ptr</code> 智能指针，暂时不考虑线程安全问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现带引用计数的智能指针（不考虑线程安全问题），类似 shared_ptr 智能指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefCount</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RefCount</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">        <span class="comment">// 在堆上初始化引用计数，为了让智能指针在复制或赋值时共享同一个引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RefCount</span>() {</span><br><span class="line">        <span class="comment">// 释放堆上的引用计数</span></span><br><span class="line">        <span class="keyword">delete</span> _count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数自增</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increDef</span><span class="params">()</span> </span>{</span><br><span class="line">        ++(*_count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数自减</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decreRef</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (*_count &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> --(*_count);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前引用计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> *_count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;        <span class="comment">// 指向资源的指针</span></span><br><span class="line">    <span class="keyword">int</span> *_count;    <span class="comment">// 指向堆上存储的引用计数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSmartPtr</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(T* ptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 初始化引用计数对象</span></span><br><span class="line">        _refCount = <span class="keyword">new</span> RefCount&lt;T&gt;(_ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~CSmartPtr()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 减少引用计数，并且当引用计数为零时，才释放智能指针管理的资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _refCount-&gt;<span class="built_in">decreRef</span>()) {</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _refCount;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;src) : _ptr(src._ptr), _refCount(src._refCount) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr(const CSmartPtr&lt;T&gt;&amp; src)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 增加引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (_ptr != <span class="literal">nullptr</span>) {</span><br><span class="line">            _refCount-&gt;<span class="built_in">increDef</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载函数</span></span><br><span class="line">    CSmartPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;src) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"CSmartPtr&lt;T&gt; operator=(const CSmartPtr&lt;T&gt;&amp; src)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 避免自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放旧的资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _refCount-&gt;<span class="built_in">decreRef</span>()) {</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _refCount;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享新的资源</span></span><br><span class="line">        _ptr = src._ptr;</span><br><span class="line">        _refCount = src._refCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加引用计数</span></span><br><span class="line">        _refCount-&gt;<span class="built_in">increDef</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// * 运算符重载函数</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() {</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -&gt; 运算符重载函数</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() {</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;                   <span class="comment">// 指向资源的指针</span></span><br><span class="line">    RefCount&lt;T&gt; *_refCount;    <span class="comment">// 指向资源引用计数对象的指针</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age = <span class="number">0</span>) : _age(age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person(int age)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"age: "</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 测试多个智能指针管理同一个对象资源</span></span><br><span class="line">    <span class="function">CSmartPtr&lt;Person&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">20</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="function">CSmartPtr&lt;Person&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;   <span class="comment">// 可复制</span></span><br><span class="line">        ptr2-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">        CSmartPtr&lt;Person&gt; ptr3;</span><br><span class="line">        ptr3 = ptr2;                    <span class="comment">// 可赋值</span></span><br><span class="line">        ptr3-&gt;<span class="built_in">print</span>();</span><br><span class="line">    } <span class="comment">// 出了作用域后，ptr2、ptr3 析构，但不影响 ptr1，也不影响对象资源的析构</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"Leaving inner scope..."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ptr1-&gt;<span class="built_in">print</span>();  <span class="comment">// 仍然有效</span></span><br><span class="line"></span><br><span class="line">} <span class="comment">// 出了作用域后，ptr1 析构，并析构对象资源</span></span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Person(int age)</span><br><span class="line">CSmartPtr(T* ptr)</span><br><span class="line">CSmartPtr(const CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">age: 20</span><br><span class="line">CSmartPtr(T* ptr)</span><br><span class="line">CSmartPtr&lt;T&gt; operator=(const CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">age: 20</span><br><span class="line">~CSmartPtr()</span><br><span class="line">~CSmartPtr()</span><br><span class="line">Leaving inner scope...</span><br><span class="line">age: 20</span><br><span class="line">~CSmartPtr()</span><br><span class="line">~Person()</span><br></pre></td></tr></tbody></table></figure><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/6e5acd18.html" title="C++ 巩固进阶之四">https://www.techgrow.cn/posts/6e5acd18.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/bd9d2710.html" rel="prev" title="C++ 巩固进阶之三"><i class="fa fa-angle-left"></i> C++ 巩固进阶之三</a></div><div class="post-nav-item"> <a href="/posts/9fc5e76e.html" rel="next" title="UFW 导致 Docker 容器无法使用 IP 访问宿主机">UFW 导致 Docker 容器无法使用 IP 访问宿主机<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.7m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">26:03</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/6e5acd18.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>