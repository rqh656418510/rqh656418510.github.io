<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 入门基础的内容，包括友元函数、友元类、运算符重载等。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 入门基础之六"><meta property="og:url" content="https://www.techgrow.cn/posts/a54941f5.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 入门基础的内容，包括友元函数、友元类、运算符重载等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-6.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-5.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-7.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/operator-overloading-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-9.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-10.png"><meta property="article:published_time" content="2021-11-06T13:55:33.000Z"><meta property="article:modified_time" content="2024-04-02T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-overload-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/a54941f5.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/a54941f5.html","path":"posts/a54941f5.html","title":"C++ 入门基础之六"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 入门基础之六 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-text">友元函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-text">友元函数的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">友元函数的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-text">全局函数作为友元函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数作为友元函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-text">友元类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-text">友元类的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">友元类的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%9F%BA%E7%A1%80"><span class="nav-text">运算符重载基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-text">运算符重载的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">运算符重载的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">运算符重载的两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E4%B8%8E%E5%90%8E%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99"><span class="nav-text">前置与后置运算符重载规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">运算符重载的简单使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-text">二元运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-text">一元运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">[ ] 运算符的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">左移运算符的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">关系运算符的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">赋值运算符的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="nav-text">使用案例一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="nav-text">使用案例二</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">指针运算符的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">函数调用运算符的重载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%BF%9B%E9%98%B6"><span class="nav-text">运算符重载进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">运算符重载的使用注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E9%87%8D%E8%BD%BD-amp-amp-%E5%92%8C-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">为什么不要重载 &amp;&amp; 和 || 操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E4%B8%AA%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC"><span class="nav-text">同一个运算符的重载可以有多个版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">不同函数实现运算符重载的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">使用友元函数重载运算符的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E7%BB%BC%E5%90%88%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">运算符重载的综合使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%90%84%E7%A7%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">重载自定义数组类的各种运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E7%9A%84%E5%90%84%E7%A7%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">重载自定义字符串类的各种运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7%E7%9A%84%E9%99%84%E5%BD%95"><span class="nav-text">C++ 运算符和结合性的附录</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">741</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/a54941f5.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 入门基础之六 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 入门基础的内容，包括友元函数、友元类、运算符重载等。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 入门基础之六</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 21:55:33" itemprop="dateCreated datePublished" datetime="2021-11-06T21:55:33+08:00">2021-11-06</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-04-02 21:55:33" itemprop="dateModified" datetime="2024-04-02T21:55:33+08:00">2024-04-02</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/a54941f5.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/a54941f5.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5.6k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>5 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8bbc3f09.html">C++ 入门基础之一</a>、<a href="/posts/b03c11a0.html">C++ 入门基础之二</a>、<a href="/posts/f26087ad.html">C++ 入门基础之三</a></li><li><a href="/posts/beb2ebb3.html">C++ 入门基础之四</a>、<a href="/posts/a35089f6.html">C++ 入门基础之五</a>、<a href="/posts/a54941f5.html">C++ 入门基础之六</a></li><li><a href="/posts/e4826e2c.html">C++ 入门基础之七</a>、<a href="/posts/4c2ae4c0.html">C++ 入门基础之八</a>、<a href="/posts/f1a16291.html">C++ 入门基础之九</a></li></ul><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p><strong>类的友元函数是定义在类的外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型在类的声明中出现过，但是友元函数并不是类的成员函数，而是普通函数（全局函数）。</strong>如果要声明函数为一个类的友元函数，则需要在类定义中的函数原型前面使用关键字 <code>friend</code>。</p><h3 id="友元函数的规则"><a href="#友元函数的规则" class="headerlink" title="友元函数的规则"></a>友元函数的规则</h3><p>C++ 利用 <code>friend</code> 修饰符，可以让一些设定的函数能够对类中的一些保护数据进行访问，避免把类的成员全部设置成 <code>public</code>，并且最大限度的保护数据成员的安全。同时友元函数可以实现类之间的数据共享，减少系统开销，提高效率。由于友元函数破环了封装机制，因此推荐尽量使用成员函数，除非不得已的情况下才使用友元函数。</p><span id="more"></span><ul><li><p>什么时候适合使用友元函数</p><ul><li>多个类要共享数据的时候</li><li>运算符重载的某些场合需要使用友元函数</li></ul></li><li><p>友元函数的参数：因为友元函数没有 <code>this</code> 指针，所以友元函数的参数会有以下三种情况</p><ul><li>(1) 要访问非 <code>static</code> 成员时，需要对象做参数</li><li> (2) 要访问 <code>static</code> 成员或全局变量时，则不需要对象做参数</li><li> (3) 如果做参数的对象是全局对象，则不需要对象做参数</li></ul></li><li><p>友元函数的调用</p><ul><li>可以直接调用友元函数，不需要通过对象或指针</li><li>友元函数的调用与普通函数（全局函数）的调用方式和原理一致</li></ul></li><li><p>友元函数的位置</p><ul><li>因为友元函数是类外的普通函数（全局函数），所以它的声明可以放在类的私有段（private）或公有段（public），两者都是没有区别的</li><li>一个函数可以是多个类的友元函数，只需要在各个类中分别声明即可</li></ul></li></ul><h3 id="友元函数的使用"><a href="#友元函数的使用" class="headerlink" title="友元函数的使用"></a>友元函数的使用</h3><h4 id="全局函数作为友元函数"><a href="#全局函数作为友元函数" class="headerlink" title="全局函数作为友元函数"></a>全局函数作为友元函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>() {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRom = <span class="string">"sitting rom"</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"bed room"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Building *building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    string m_SittingRom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    string m_BedRoom;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义普通函数（全局函数）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Building *building)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"好朋友正在访问"</span> &lt;&lt; building-&gt;m_SittingRom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误写法，在普通函数（全局函数）内，类的私有成员不能在类外被访问</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; "好朋友正在访问" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数（全局函数）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Building *building)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Good friend visiting "</span> &lt;&lt; building-&gt;m_SittingRom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过友元函数，在类外可以访问类的私有成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Good friend visiting "</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Building *building = <span class="keyword">new</span> <span class="built_in">Building</span>();</span><br><span class="line">    <span class="comment">// 调用友元函数</span></span><br><span class="line">    <span class="built_in">visit</span>(building);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Good friend visiting sitting rom</span><br><span class="line">Good friend visiting bed room</span><br></pre></td></tr></tbody></table></figure><h4 id="成员函数作为友元函数"><a href="#成员函数作为友元函数" class="headerlink" title="成员函数作为友元函数"></a>成员函数作为友元函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodGay</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    Building *building;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明只让 GoodGay 的成员函数 visit () 作为友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() {</span><br><span class="line">    <span class="keyword">this</span>-&gt;building = <span class="keyword">new</span> <span class="built_in">Building</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GoodGay::play</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Good friend playing in "</span> &lt;&lt; <span class="keyword">this</span>-&gt;building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 这里 GoodGay 类的成员函数 play() 不可以访问 Building 类的私有成员或者保护成员</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; "Good friend playing in " &lt;&lt; this-&gt;building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Good friend visiting "</span> &lt;&lt; <span class="keyword">this</span>-&gt;building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 这里 GoodGay 类的成员函数 visit() 可以访问 Building 类的私有成员或者保护成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Good friend visiting "</span> &lt;&lt; <span class="keyword">this</span>-&gt;building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() {</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"sitting room"</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"bed room"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    GoodGay goodGay;</span><br><span class="line">    goodGay.<span class="built_in">visit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Good friend visiting sitting room</span><br><span class="line">Good friend visiting bed room</span><br></pre></td></tr></tbody></table></figure><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p><strong>友元类的所有成员函数都是另一个类的友元函数，即都可以访问另一个类中的私有（private）成员和保护（protected）成员。当希望一个类可以访问另一个类的保护数据时，可以将该类声明为另一类的友元类。</strong>定义友元类的语法格式为 <code>friend class 类名;</code>，其中类名必须是程序中的一个已定义过的类。值得一提的是，友元类通常设计为一种对数据操作或类之间传递消息的辅助类。</p><h3 id="友元类的规则"><a href="#友元类的规则" class="headerlink" title="友元类的规则"></a>友元类的规则</h3><ul><li>友元关系不能被继承</li><li>友元关系是单向的，不具有交换性。若类 B 是类 A 的友元，则类 A 不一定是类 B 的友元，要看在类 B 中是否有相应的声明</li><li>友元关系不具有传递性，若类 B 是类 A 的友元，类 C 是 类 B 的友元，则类 C 不一定是类 A 的友元，要看类 A 中是否有相应的声明</li></ul><div class="admonition note"><p class="admonition-title">C++ 是纯面向对象的语言吗？</p><p>如果一个类被声明为 <code>friend</code>，这意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此它是一个特权函数。C++ 不是完全面向对象的语言，而只是一个混合产品，增加 <code>friend</code> 关键字只是用来解决一些实际的问题，比如运算符重载。</p></div><h3 id="友元类的使用"><a href="#友元类的使用" class="headerlink" title="友元类的使用"></a>友元类的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodGay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() {</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"sitting room"</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"bed room"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodGay</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    Building *building;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() {</span><br><span class="line">    <span class="keyword">this</span>-&gt;building = <span class="keyword">new</span> <span class="built_in">Building</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Good friend visiting "</span> &lt;&lt; <span class="keyword">this</span>-&gt;building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 类 GoodGay 是类 Building 的友元类，因此 GoodGay 类的所有成员函数都可以直接访问 Building 类的私有成员或者保护成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Good friend visiting "</span> &lt;&lt; <span class="keyword">this</span>-&gt;building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    GoodGay goodGay;</span><br><span class="line">    goodGay.<span class="built_in">visit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Good friend visiting sitting room</span><br><span class="line">Good friend visiting bed room</span><br></pre></td></tr></tbody></table></figure><h2 id="运算符重载基础"><a href="#运算符重载基础" class="headerlink" title="运算符重载基础"></a>运算符重载基础</h2><p>所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是 <code>一名多用</code>。运算符也可以重载，实际上，开发者已经在不知不觉之中使用了运算符重载。例如，大家都已习惯于用加法运算符 <code>+</code> 对整数、单精度数和双精度数进行加法运算，如 <code>5 + 8，5.8 + 3.67</code> 等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的，但由于 C++ 已经对运算符 <code>+</code> 进行了重载，所以就能适用于 int、float、doUble 类型的运算。又如 <code>&lt;&lt;</code> 是 C++ 的位运算中的位移运算符（左移），但在输出操作中又是与流对象 <code>cout</code> 配合使用的流插入运算符。<code>&gt;&gt;</code> 也是位移运算符 (右移)，但在输入操作中又是与流对象 <code>cin</code> 配合使用的流提取运算符。这就是运算符重载 (Operator Overloading)。C++ 系统对 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 进行了重载，用户在不同的场合下使用它们时，作用是不同的。对 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 的重载处理是放在头文件 <code>stream</code> 中的。因此，如果要在程序中用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 作流插入运算符和流提取运算符，必须在本文件模块中包含头文件 <code>iostream</code>，当然还应当包括命名空间的使用声明 <code>using namespace std</code>。</p><div class="admonition note"><p class="admonition-title">提示</p><p>运算符重载 (Operator Overloading) 只是一种 "语法上的方便"，也就是说它的本质只是另一种函数调用方式而已。另外，操作符重载是靠函数重载来完成的。在 C++ 中，可以定义一个处理类的新运算符，这种定义很像一个普通的函数定义，只是函数的名称由关键字 <code>operator</code> 及其后面紧跟的运算符组成，差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。值得一提的是，对于内置的数据类型的运算符是不可改变的，比如想重载 <code>int</code> 类型数据的 <code>+</code> 号运算符，这是不被允许的。</p></div><h3 id="运算符重载的语法"><a href="#运算符重载的语法" class="headerlink" title="运算符重载的语法"></a>运算符重载的语法</h3><p><img data-src="../../../asset/2021/11/cplusplus-overload-1.png" alt="cplusplus-overload-1"></p><p>例如：</p><ul><li>使用类成员函数完成 <code>-</code> 运算符重载的语法：<code>Complex operator-(Complex &amp;c2)</code></li><li>使用友元函数完成 <code>+</code> 运算符重载的语法：<code>Complex operator+(Complex &amp;c1, Complex &amp;c2)</code></li><li>使用全局函数（普通函数）完成 <code>/</code> 运算符重载的语法：<code>Complex operator/(Complex &amp;c1, Complex &amp;c2)</code></li></ul><blockquote><p>值得一提的是，在企业开发中一般使用类成员函数和友元函数的方式来实现运算符重载。</p></blockquote><h3 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><p><img data-src="../../../asset/2021/11/cplusplus-overload-6.png" alt="cplusplus-overload-6"><br><img data-src="../../../asset/2021/11/cplusplus-overload-2.png" alt="cplusplus-overload-2"></p><h3 id="运算符重载的两种方式"><a href="#运算符重载的两种方式" class="headerlink" title="运算符重载的两种方式"></a>运算符重载的两种方式</h3><p><img data-src="../../../asset/2021/11/cplusplus-overload-3.png" alt="cplusplus-overload-3"><br><img data-src="../../../asset/2021/11/cplusplus-overload-4.png" alt="cplusplus-overload-4"><br><img data-src="../../../asset/2021/11/cplusplus-overload-5.png" alt="cplusplus-overload-5"></p><h3 id="前置与后置运算符重载规则"><a href="#前置与后置运算符重载规则" class="headerlink" title="前置与后置运算符重载规则"></a>前置与后置运算符重载规则</h3><p>在 C++ 中是通过一个占位参数（<code>int</code>）来区分前置运算符和后置运算符的重载，例如 <code>++a</code>、<code>a++</code>、<code>--b</code>、<code>b--</code>。</p><p><img data-src="../../../asset/2021/11/cplusplus-overload-7.png" alt="cplusplus-overload-7"></p><h3 id="运算符重载的简单使用案例"><a href="#运算符重载的简单使用案例" class="headerlink" title="运算符重载的简单使用案例"></a>运算符重载的简单使用案例</h3><h4 id="二元运算符重载"><a href="#二元运算符重载" class="headerlink" title="二元运算符重载"></a>二元运算符重载</h4><p>在下述的案例中，演示了如何使用类成员函数和友元函数实现二元运算符的重载。值得一提的是，除了使用友元函数外，还可以使用全局函数（普通函数）来实现运算符的重载，不同的是使用友元函数更方便，可以直接访问类的所有私有（private）成员和保护（protected）成员。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 使用类成员函数完成 "-" 运算符的重载</span></span><br><span class="line">	Complex <span class="keyword">operator</span>-(Complex&amp; c2) {</span><br><span class="line">		<span class="function">Complex <span class="title">c3</span><span class="params">(<span class="keyword">this</span>-&gt;a - c2.a, <span class="keyword">this</span>-&gt;b - c2.b)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> c3;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明用于 "+" 运算符重载的友元函数</span></span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(Complex&amp; c1, Complex&amp; c2);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数完成 "+" 运算符的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; c1, Complex&amp; c2) {</span><br><span class="line">	<span class="function">Complex <span class="title">c3</span><span class="params">(c1.a + c2.a, c1.b + c2.b)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> c3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接调用友元函数</span></span><br><span class="line">	Complex c3 = <span class="keyword">operator</span>+(c1, c2);</span><br><span class="line">	c3.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用友元函数完成 "+" 运算符的重载</span></span><br><span class="line">	Complex c4 = c1 + c2;</span><br><span class="line">	c4.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接调用类成员函数</span></span><br><span class="line">	Complex c5 = c1.<span class="keyword">operator</span>-(c2);</span><br><span class="line">	c5.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数完成 "-" 运算符的重载</span></span><br><span class="line">	Complex c6 = c1 - c2;</span><br><span class="line">	c6.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=4, b=6</span><br><span class="line">a=4, b=6</span><br><span class="line">a=-2, b=-2</span><br><span class="line">a=-2, b=-2</span><br></pre></td></tr></tbody></table></figure><h4 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h4><p>在下述的案例中，演示了如何使用类成员函数和友元函数实现一元运算符的重载。值得一提的是，除了使用友元函数外，还可以使用全局函数（普通函数）来实现运算符的重载，不同的是使用友元函数更方便，可以直接访问类的所有私有（private）成员和保护（protected）成员。</p><div class="admonition note"><p class="admonition-title">前置与后置递增一元运算符介绍</p><ul><li>前置 ++（++i）： 在使用前置 ++ 时，变量会先递增，然后表达式的值是递增后的值。</li><li>后置 ++（i++）： 在使用后置 ++ 时，表达式的值是变量当前的值，然后再递增变量。</li><li><strong>总结：前置 ++ 和后置 ++ 的主要区别在于返回值的顺序，前者先递增再使用，后者先使用再递增。</strong></li></ul></div><div class="admonition note"><p class="admonition-title">前置与后置递减一元运算符介绍</p><ul><li>前置 --（--i）： 在使用前置 -- 时，变量会先递减，然后表达式的值是递减后的值。</li><li>后置 --（i--）： 在使用后置 -- 时，表达式的值是变量当前的值，然后再递减变量。</li><li><strong>总结：前置 -- 和后置 -- 的主要区别在于返回值的顺序，前者先递减再使用，后者先使用再递减。</strong></li></ul></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 使用类成员函数完成 "前置--" 运算符的重载</span></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>--() {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a--;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b--;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数完成 "后置--" 运算符的重载</span></span><br><span class="line">	<span class="comment">// 使用占位参数进行函数重载，是为了解决与 "前置--" 类成员函数冲突的问题</span></span><br><span class="line">	Complex <span class="keyword">operator</span>--(<span class="keyword">int</span>) {</span><br><span class="line">		<span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a, <span class="keyword">this</span>-&gt;b)</span></span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a--;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b--;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明用于 "前置++" 运算符重载的友元函数</span></span><br><span class="line">	<span class="keyword">friend</span> Complex&amp; <span class="keyword">operator</span>++(Complex&amp; c1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明用于 "后置++" 运算符重载的友元函数</span></span><br><span class="line">	<span class="comment">// 使用占位参数进行函数重载，是为了解决与 "前置++" 友元函数冲突的问题</span></span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>++(Complex&amp; c1, <span class="keyword">int</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数完成 "前置++" 运算符的重载</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>++(Complex&amp; c1)</span><br><span class="line">{</span><br><span class="line">	c1.a++;</span><br><span class="line">	c1.b++;</span><br><span class="line">	<span class="keyword">return</span> c1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数完成 "后置++" 运算符的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>++(Complex&amp; c1, <span class="keyword">int</span>) {</span><br><span class="line">	<span class="function">Complex <span class="title">tmp</span><span class="params">(c1.a, c1.b)</span></span>;</span><br><span class="line">	c1.a++;</span><br><span class="line">	c1.b++;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">8</span>, <span class="number">9</span>)</span>, <span class="title">c3</span><span class="params">(<span class="number">15</span>, <span class="number">16</span>)</span>, <span class="title">c4</span><span class="params">(<span class="number">24</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用友元函数完成 "前置++" 运算符的重载</span></span><br><span class="line">	++c1;</span><br><span class="line">	c1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数完成 "前置--" 运算符的重载</span></span><br><span class="line">	--c2;</span><br><span class="line">	c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用友元函数完成 "后置++" 运算符的重载</span></span><br><span class="line">	Complex c5 = c3++;</span><br><span class="line">	c3.<span class="built_in">print</span>();</span><br><span class="line">	c5.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数完成 "后置--" 运算符的重载</span></span><br><span class="line">	Complex c6 = c4--;</span><br><span class="line">	c4.<span class="built_in">print</span>();</span><br><span class="line">	c6.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=2, b=3</span><br><span class="line">a=7, b=8</span><br><span class="line">a=16, b=17</span><br><span class="line">a=15, b=16</span><br><span class="line">a=23, b=24</span><br><span class="line">a=24, b=25</span><br></pre></td></tr></tbody></table></figure><h4 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="[ ] 运算符的重载"></a>[ ] 运算符的重载</h4><p>当希望创建一个自定义的数据结构，比如一个向量（Vector）或者一个矩阵（Matrix）时，那么就可能要重载 C++ 中的 <code>[ ]</code> 运算符，以便能够像访问数组一样访问自定义数据结构中的元素。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// [] 运算符重载</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="number">5</span>) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"Index out of bounds"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    MyVector vector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置向量中的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        vector[i] = i * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置向量中的值</span></span><br><span class="line">    vector[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问向量中的值并输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"vector["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; vector[i] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector[0] = 0</span><br><span class="line">vector[1] = 100</span><br><span class="line">vector[2] = 4</span><br><span class="line">vector[3] = 6</span><br><span class="line">vector[4] = 8</span><br></pre></td></tr></tbody></table></figure><h4 id="左移运算符的重载"><a href="#左移运算符的重载" class="headerlink" title="左移运算符的重载"></a>左移运算符的重载</h4><p>特别注意，<code>&lt;&lt;</code> 左移运算符和 <code>&gt;&gt;</code> 右移运算符的重载，只能使用友元函数或者全局函数（普通函数），不能使用类成员函数，这也是友元函数的重要作用之一。根本原因是：左移运算符的左操作数是输出流对象 <code>std::ostream</code>，而右操作数是要输出的对象。因为左操作数必须是一个标准库类 <code>std::ostream</code> 的对象，而类成员函数将左操作数默认绑定到当前对象，这就意味着无法直接使用类成员函数来重载 <code>&lt;&lt;</code> 左移运算符和 <code>&gt;&gt;</code> 右移运算符。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 声明友元函数实现 "&lt;&lt;" 左移运算符的重载</span></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&amp; c1);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数实现 "&lt;&lt;" 左移运算符的重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&amp; c1) {</span><br><span class="line">	out &lt;&lt; <span class="string">"a="</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b="</span> &lt;&lt; c1.b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">6</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; c1 &lt;&lt; c2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1, b=2</span><br><span class="line">a=6, b=9</span><br></pre></td></tr></tbody></table></figure><h4 id="关系运算符的重载"><a href="#关系运算符的重载" class="headerlink" title="关系运算符的重载"></a>关系运算符的重载</h4><p>在 C++ 中，关系运算符用于比较两个值的关系，例如大于、小于、等于。常见的关系运算符包括：</p><ul><li><code>==</code>：等于，用于检查两个值是否相等。</li><li><code>!=</code>：不等于，用于检查两个值是否不相等。</li><li><code>&gt;</code>：大于，用于检查左操作数是否大于右操作数。</li><li><code>&lt;</code>：小于，用于检查左操作数是否小于右操作数。</li><li><code>&gt;=</code>：大于等于，用于检查左操作数是否大于或等于右操作数。</li><li><code>&lt;=</code>：小于等于，用于检查左操作数是否小于或等于右操作数。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_Age</span>(age) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Person p) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Person p) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Age &gt; p.m_Age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Person p) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Age &lt; p.m_Age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"Peter"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"Peter"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; (p1 &lt; p2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (p1 &gt; p2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (p2 == p3) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><h4 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h4><ul><li><code>=</code> 赋值运算符的结合性是从右到左</li><li><code>=</code> 赋值运算符的重载用于对象数据的复制</li><li><code>=</code> 赋值运算符的重载，必须通过类成员函数来重载，不能使用友元函数重载</li><li><code>=</code> 赋值运算符重载的函数原型为：<code>类型 &amp; 类名 :: operator= ( const 类名 &amp; ) ;</code></li></ul><h5 id="使用案例一"><a href="#使用案例一" class="headerlink" title="使用案例一"></a>使用案例一</h5><p>特别注意，C++ 除了会默认提供无参构造函数、拷贝构造函数、析构函数，还会重载 <code>=</code> 赋值运算符。C++ 默认提供的 <code>=</code> 赋值运算符重载，属于浅拷贝，底层只会对类成员变量进行简单的拷贝（赋值），也就是会导致深拷贝和浅拷贝的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> a) : <span class="built_in">m_A</span>(a) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_A;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// C++ 除了会默认提供无参构造函数、拷贝构造函数、析构函数，还会重载 `=` 赋值运算符</span></span><br><span class="line">    <span class="comment">// C++ 默认提供的 `=` 赋值运算符重载，属于浅拷贝，底层只会对类成员变量进行简单的拷贝（赋值）</span></span><br><span class="line">    p2 = p1;</span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person2</span>(<span class="keyword">char</span> *name) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person2</span>() {</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> != <span class="keyword">this</span>-&gt;pName) {</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pName = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Person2 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Person2 &amp;p) {</span><br><span class="line">        <span class="comment">// 释放内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> != <span class="keyword">this</span>-&gt;pName) {</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pName = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 重新分配内存空间</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.pName) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, p.pName);</span><br><span class="line">        <span class="comment">// 返回引用</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">char</span> *pName;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person2 <span class="title">p1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person2 <span class="title">p2</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person2 <span class="title">p3</span><span class="params">(<span class="string">"David"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 如果不自己重载 `=` 赋值运算符，对象的析构函数在执行时会出现深拷贝和浅拷贝问题，即同一块内存空间会被释放两次，从而导致程序异常退出</span></span><br><span class="line">    p3 = p2 = p1;</span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p3.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">Peter</span><br><span class="line">Peter</span><br></pre></td></tr></tbody></table></figure><h5 id="使用案例二"><a href="#使用案例二" class="headerlink" title="使用案例二"></a>使用案例二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* p;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Name</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">		len = <span class="built_in">strlen</span>(name);</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(p, name);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 深拷贝的实现</span></span><br><span class="line">	<span class="built_in">Name</span>(<span class="keyword">const</span> Name&amp; name) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"拷贝构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">		len = name.<span class="built_in">getLen</span>();</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(p, name.<span class="built_in">getP</span>());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Name</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">			<span class="keyword">delete</span>[] p;</span><br><span class="line">			p = <span class="literal">NULL</span>;</span><br><span class="line">			len = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">char</span>* <span class="title">getP</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> len;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 使用类成员函数实现 "=" 运算符的重载</span></span><br><span class="line">	Name&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Name&amp; n) {</span><br><span class="line">		<span class="comment">// 释放内存空间</span></span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">			<span class="keyword">delete</span>[] p;</span><br><span class="line">			p = <span class="literal">NULL</span>;</span><br><span class="line">			len = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 重新分配内存空间</span></span><br><span class="line">		len = n.<span class="built_in">getLen</span>();</span><br><span class="line">		p = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(p, n.<span class="built_in">getP</span>());</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Name <span class="title">obj1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line">	<span class="function">Name <span class="title">obj2</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line">	<span class="function">Name <span class="title">obj4</span><span class="params">(<span class="string">"Tim"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 会自动调用拷贝构造函数（属于深拷贝）</span></span><br><span class="line">	Name obj3 = obj1;</span><br><span class="line">	cout &lt;&lt; <span class="string">"obj3.name: "</span> &lt;&lt; obj3.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj3.len:  "</span> &lt;&lt; obj3.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不会自动调用拷贝构造函数（属于浅拷贝）</span></span><br><span class="line">	<span class="comment">// 默认情况下，若这里不对 "=" 运算符进行重载，最终程序会异常终止运行（由于同一块内存空间被释放两次导致）</span></span><br><span class="line">	obj4 = obj1;</span><br><span class="line">	cout &lt;&lt; <span class="string">"obj4.name: "</span> &lt;&lt; obj4.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj4.len:  "</span> &lt;&lt; obj4.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">拷贝构造函数被调用了</span><br><span class="line">obj3.name: Peter, obj3.len:  5</span><br><span class="line">obj4.name: Peter, obj4.len:  5</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br></pre></td></tr></tbody></table></figure><h4 id="指针运算符的重载"><a href="#指针运算符的重载" class="headerlink" title="指针运算符的重载"></a>指针运算符的重载</h4><p>在下述的案例中，演示了如何使用重载指针运算符的方式来简单实现智能指针。在日常开发中，<code>new</code> 出来的对象，在使用完之后都需要开发人员自觉地去 <code>delete</code>，以此来释放对象所占用的内存空间。如果开发人员忘记了 <code>delete</code>，就会很容易造成内存泄漏。有了智能指针后，就可以让智能指针托管指定的对象，这样开发人员就不用关心指定对象的内存释放问题了，也就可以避免内存泄漏了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"调用Person的析构函数"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"年龄 = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 智能指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPointer</span>(Person *p) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;person = p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SmartPointer</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"调用智能指针的析构函数"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> != <span class="keyword">this</span>-&gt;person) {</span><br><span class="line">			<span class="comment">// 释放已托管的指针，会自动调用对应的析构函数</span></span><br><span class="line">            <span class="built_in"><span class="keyword">delete</span></span> (<span class="keyword">this</span>-&gt;person);</span><br><span class="line">            <span class="keyword">this</span>-&gt;person = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 -&gt; 符号</span></span><br><span class="line">    Person *<span class="keyword">operator</span>-&gt;() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 * 符号</span></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>*() {</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;person);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *person;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个Person指针，并托管给智能指针对象，且在栈上给智能指针对象动态分配内存空间</span></span><br><span class="line">    <span class="comment">// 函数作用域结束后，会自动释放智能指针对象在栈上的内存空间，并自动调用智能指针对象的析构函数</span></span><br><span class="line">    <span class="function">SmartPointer <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">20</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原本的写法是 sp-&gt;-&gt;showAge()，只不过编译器做了优化</span></span><br><span class="line">    sp-&gt;<span class="built_in">showAge</span>();</span><br><span class="line"></span><br><span class="line">    (*sp).<span class="built_in">showAge</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">年龄 = 20</span><br><span class="line">年龄 = 20</span><br><span class="line">调用智能指针的析构函数</span><br><span class="line">调用Person的析构函数</span><br></pre></td></tr></tbody></table></figure><h4 id="函数调用运算符的重载"><a href="#函数调用运算符的重载" class="headerlink" title="函数调用运算符的重载"></a>函数调用运算符的重载</h4><p>在下述的案例中，演示了如何使用类成员函数重载函数调用运算符 <code>()</code>。值得一提的是，不能用友元函数来重载函数调用运算符 <code>()</code>。</p><div class="admonition note"><p class="admonition-title">函数对象（仿函数）的实现</p><p>在 C++ 中，函数调用运算符 <code>()</code> 的重载，一般是用于在 STL 中实现函数对象（仿函数），更详细的介绍请看 <a href="/posts/98e5b160.html#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 函数调用运算符的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string &amp;content)</span> </span>{</span><br><span class="line">        cout &lt;&lt; content &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">"Hello World"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 函数调用运算符的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    MyAdd add;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">3</span><br><span class="line">7</span><br></pre></td></tr></tbody></table></figure><h2 id="运算符重载进阶"><a href="#运算符重载进阶" class="headerlink" title="运算符重载进阶"></a>运算符重载进阶</h2><h3 id="运算符重载的使用注意事项"><a href="#运算符重载的使用注意事项" class="headerlink" title="运算符重载的使用注意事项"></a>运算符重载的使用注意事项</h3><ul><li>不要重载 <code>&amp;&amp;</code> 和 <code>||</code> 运算符，因为无法实现短路规则。</li><li><code>=</code>、<code>[]</code>、<code>()</code>、<code>-&gt;</code> 运算符只能通过成员函数进行重载。</li><li><code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符只能通过普通函数（全局函数）、友元函数进行重载。</li></ul><p><img data-src="../../../asset/2024/03/operator-overloading-1.png"></p><h3 id="为什么不要重载-amp-amp-和-操作符"><a href="#为什么不要重载-amp-amp-和-操作符" class="headerlink" title="为什么不要重载 &amp;&amp; 和 || 操作符"></a>为什么不要重载 &amp;&amp; 和 || 操作符</h3><ul><li>(a) <code>&amp;&amp;</code> 和 <code>||</code> 是 C++ 中非常特殊的操作符</li><li> (b) <code>&amp;&amp;</code> 和 <code>||</code> 内置实现了短路规则</li><li> (c) 操作符重载是靠函数重载来完成的</li><li> (d) 操作数作为函数参数传递</li><li> (e) C++ 的函数参数都会被求值，无法实现短路规则</li></ul><h3 id="同一个运算符的重载可以有多个版本"><a href="#同一个运算符的重载可以有多个版本" class="headerlink" title="同一个运算符的重载可以有多个版本"></a>同一个运算符的重载可以有多个版本</h3><p>同一个运算符的重载可以有多个版本，这一点类似在函数重载中有多个同名的函数（但参数个数、参数类型、参数顺序不一样）。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加号运算符重载的第一个版本</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, Person &amp;p2) {</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加号运算符重载的第二个版本</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, <span class="keyword">int</span> &amp;a) {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="不同函数实现运算符重载的应用场景"><a href="#不同函数实现运算符重载的应用场景" class="headerlink" title="不同函数实现运算符重载的应用场景"></a>不同函数实现运算符重载的应用场景</h3><p>友元函数和类成员函数的选择建议：</p><ul><li>(a) <code>=</code>、<code>[]</code>、<code>()</code> 和 <code>-&gt;</code> 运算符，只能通过类成员函数进行重载</li><li> (b) 当无法修改左操作数的类时，只能通过友元函数进行重载，例如 <code>&lt;&lt;</code> 左移运算符与 <code>&gt;&gt;</code> 右移运算符</li></ul><p>友元函数重载 <code>&lt;&lt;</code> 与 <code>&gt;&gt;</code> 运算符：</p><ul><li><code>istream</code> 和 <code>ostream</code> 是 C++ 的预定义流类</li><li><code>cin</code> 是 <code>istream</code> 的对象，<code>cout</code> 是 <code>ostream</code> 的对象</li><li>左移运算符 <code>&lt;&lt;</code> 由 <code>ostream</code> 重载为插入操作，用于输出基本类型数据</li><li>右移运算符 <code>&gt;&gt;</code> 由 <code>istream</code> 重载为提取操作，用于输入基本类型数据</li><li>只能使用友元函数或者普通函数（全局函数）来重载 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符，以便输出和输入用户自定义的数据类型</li></ul><p>类成员函数与友元函数实现运算符重载的步骤：</p><ul><li>(a) 要承认运算符重载是一个函数，写出函数名称，如 <code>operator+()</code></li><li>(b) 根据操作数，写出函数参数</li><li> (c) 根据业务，完善函数的返回值（考虑函数是返回引用、指针还是元素），及实现函数业务；例如当函数的返回值充当左值时，需要返回一个引用</li></ul><h3 id="使用友元函数重载运算符的注意事项"><a href="#使用友元函数重载运算符的注意事项" class="headerlink" title="使用友元函数重载运算符的注意事项"></a>使用友元函数重载运算符的注意事项</h3><ul><li>(a) 友元函数重载运算符常用于运算符的左右操作数类型不相同的场景</li><li> (b) 在函数的第一个参数需要隐式转换的情形下，使用友元函数重载运算符是正确的选择</li><li> (c) 友元函数没有 <code>this</code> 指针，所需操作数都必须在函数的参数表中显式声明，这很容易实现类型的隐式转换</li><li> (d) 在 C++ 中不能用友元函数重载的运算符分别有：<code>=</code>、<code>[]</code>、<code>()</code> 和 <code>-&gt;</code></li><li>(e) 在 C++ 中不要重载 <code>&amp;&amp;</code> 和 <code>||</code> 运算符</li><li> (f) C++ 的运算符重载遵循函数重载的规则</li><li> (g) 除了 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符的重载必须使用友元函数之外，建议其他运算符的重载尽量都使用类成员函数，千万不要滥用友元函数，尤其是在类模板与友元函数一起使用的时候</li></ul><h3 id="运算符重载的综合使用案例"><a href="#运算符重载的综合使用案例" class="headerlink" title="运算符重载的综合使用案例"></a>运算符重载的综合使用案例</h3><h4 id="重载自定义数组类的各种运算符"><a href="#重载自定义数组类的各种运算符" class="headerlink" title="重载自定义数组类的各种运算符"></a>重载自定义数组类的各种运算符</h4><p>在本案例中，自定义了数组类 <code>Array</code>，并使用类成员函数分别对 <code>Array</code> 类的 <code>[]</code>、<code>=</code>、<code>==</code>、<code>!=</code> 运算符进行重载。</p><ul><li>Array.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Array</span>(<span class="keyword">int</span> length);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "[]" 数组下标运算符，用于数组元素的赋值和取值</span></span><br><span class="line">	<span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "=" 运算符，用于数组之间的赋值</span></span><br><span class="line">	Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "==" 运算符，判断两个数组是否相同</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Array &amp; array);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "!=" 运算符，判断两个数组是否不相同</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">int</span>* m_space;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>Array.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">int</span> length) {</span><br><span class="line">	cout &lt;&lt; <span class="string">"有参构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span> (length &lt; <span class="number">0</span>) {</span><br><span class="line">		length = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_length = length;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line">	cout &lt;&lt; <span class="string">"拷贝构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 深拷贝，单独分配内存空间</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_length = array.m_length;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[array.m_length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.m_length; i++) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space[i] = array.m_space[i];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Array::~<span class="built_in">Array</span>() {</span><br><span class="line">	cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 数组下标运算符，用于数组元素的赋值和取值</span></span><br><span class="line"><span class="keyword">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符，用于数组之间的赋值</span></span><br><span class="line">Array&amp; Array::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 深拷贝，单独分配内存空间</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_length = array.m_length;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[array.m_length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.m_length; i++) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space[i] = array.m_space[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符，判断两个数组是否相同</span></span><br><span class="line"><span class="keyword">bool</span> Array::<span class="keyword">operator</span>==(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length != array.m_length) {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_length; i++) {</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space[i] != array.m_space[i]) {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符，判断两个数组是否不相同</span></span><br><span class="line"><span class="keyword">bool</span> Array::<span class="keyword">operator</span>!=(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == array);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Array::length</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动调用构造函数</span></span><br><span class="line">	<span class="function">Array <span class="title">array1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">length</span>(); i++) {</span><br><span class="line">		array1[i] = i;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">length</span>(); i++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"array1["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array1[i] &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动调用拷贝构造函数（属于深拷贝）</span></span><br><span class="line">	Array array2 = array1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.<span class="built_in">length</span>(); i++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"array2["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array2[i] &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动调用拷贝构造函数（属于深拷贝）</span></span><br><span class="line">	Array array3 = array1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不会自动调用拷贝构造函数（属于浅拷贝）</span></span><br><span class="line">	<span class="comment">// 默认情况下，若这里不对 "=" 运算符进行重载，最终程序会异常终止运行（由于同一块内存空间被释放两次导致）</span></span><br><span class="line">	array3 = array2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array3.<span class="built_in">length</span>(); i++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"array3["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array3[i] &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断两个数组是否相同</span></span><br><span class="line">	<span class="keyword">bool</span> result1 = array1 == array2;</span><br><span class="line">	string strResult1 = result1 ? <span class="string">"="</span> : <span class="string">"!="</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"array1 "</span> &lt;&lt; strResult1 &lt;&lt; <span class="string">" array2 "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断两个数组是否不相同</span></span><br><span class="line">	<span class="keyword">bool</span> result2 = array1 != array2;</span><br><span class="line">	string strResult2 = result2 ? <span class="string">"!="</span> : <span class="string">"="</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"array1 "</span> &lt;&lt; strResult2 &lt;&lt; <span class="string">" array2 "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用</span><br><span class="line">array1[0] = 0</span><br><span class="line">array1[1] = 1</span><br><span class="line">array1[2] = 2</span><br><span class="line">array1[3] = 3</span><br><span class="line">array1[4] = 4</span><br><span class="line">拷贝构造函数被调用</span><br><span class="line">array2[0] = 0</span><br><span class="line">array2[1] = 1</span><br><span class="line">array2[2] = 2</span><br><span class="line">array2[3] = 3</span><br><span class="line">array2[4] = 4</span><br><span class="line">拷贝构造函数被调用</span><br><span class="line">array3[0] = 0</span><br><span class="line">array3[1] = 1</span><br><span class="line">array3[2] = 2</span><br><span class="line">array3[3] = 3</span><br><span class="line">array3[4] = 4</span><br><span class="line">array1 = array2</span><br><span class="line">array1 = array2</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h4 id="重载自定义字符串类的各种运算符"><a href="#重载自定义字符串类的各种运算符" class="headerlink" title="重载自定义字符串类的各种运算符"></a>重载自定义字符串类的各种运算符</h4><p>在本案例中，自定义了字符串类 <code>MyString</code>，并使用类成员函数和友元函数分别对 <code>MyString</code> 类的 <code>[]</code>、<code>=</code>、<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;&gt;</code>、<code>&lt;&lt;</code> 运算符进行重载。</p><ul><li>MyString.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyString</span>();</span><br><span class="line">	<span class="built_in">MyString</span>(<span class="keyword">int</span> len);</span><br><span class="line">	<span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p);</span><br><span class="line">	<span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">MyString</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "[]" 运算符</span></span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "=" 运算符</span></span><br><span class="line">	MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* p);</span><br><span class="line">	MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "==" 运算符</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "!=" 运算符</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "&gt;" 运算符</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用类成员函数重载 "&lt;" 运算符</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用友元函数重载 "&lt;&lt;" 运算符</span></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyString&amp; str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用友元函数重载 "&gt;&gt;" 运算符</span></span><br><span class="line">	<span class="keyword">friend</span> iostream&amp; <span class="keyword">operator</span>&gt;&gt;(iostream&amp; in, MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">	<span class="keyword">char</span>* m_space;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>MyString.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>() {</span><br><span class="line">	<span class="comment">// 初始化为空字符串</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">int</span> len) {</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">0</span>) {</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 初始化为空字符串</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_length = len;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p) {</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="comment">// 初始化为空字符串</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_length = <span class="built_in">strlen</span>(p);</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, p);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">	<span class="comment">// 深拷贝，重新分配内存空间</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_length = str.m_length;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MyString::~<span class="built_in">MyString</span>() {</span><br><span class="line">	<span class="comment">// 释放内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 运算符</span></span><br><span class="line"><span class="keyword">char</span>&amp; MyString::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符</span></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* p) {</span><br><span class="line">	<span class="comment">// 释放内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 深拷贝，重新分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="comment">// 初始化为空字符串</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_length = <span class="built_in">strlen</span>(p);</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, p);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符</span></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">	<span class="comment">// 释放内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 深拷贝，重新分配内存空间</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_length = str.m_length;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length != <span class="built_in">strlen</span>(p)) {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>==(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length != str.m_length) {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>!=(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> == str);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&gt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p, <span class="keyword">this</span>-&gt;m_space) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(str.m_space, <span class="keyword">this</span>-&gt;m_space) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&lt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, p) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&lt;&lt;" 运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyString&amp; str) {</span><br><span class="line">	out &lt;&lt; str.m_space;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&gt;&gt;" 运算符</span></span><br><span class="line">iostream&amp; <span class="keyword">operator</span>&gt;&gt;(iostream&amp; in, MyString&amp; str)</span><br><span class="line">{</span><br><span class="line">	in &gt;&gt; str.m_space;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyString::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">MyString::c_str</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动调用有参构造函数</span></span><br><span class="line">	<span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line">	<span class="function">MyString <span class="title">str2</span><span class="params">(<span class="literal">NULL</span>)</span></span>;</span><br><span class="line">	<span class="function">MyString <span class="title">str3</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动调用拷贝构造函数</span></span><br><span class="line">	MyString str4 = str1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载 "&lt;&lt;" 运算符</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"str2 = "</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不会自动调用拷贝构造函数（属于浅拷贝）</span></span><br><span class="line">	<span class="comment">// 重载 "=" 运算符，实现深拷贝</span></span><br><span class="line">	str4 = str3;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">	str4 = <span class="string">"Jim"</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">	str4 = <span class="literal">NULL</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载 "[]" 运算符</span></span><br><span class="line">	<span class="function">MyString <span class="title">str5</span><span class="params">(<span class="string">"David"</span>)</span></span>;</span><br><span class="line">	str5[<span class="number">0</span>] = <span class="string">'F'</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str5[0] = "</span> &lt;&lt; str5[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str5 = "</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载 "==" 运算符</span></span><br><span class="line">	<span class="function">MyString <span class="title">str6</span><span class="params">(<span class="string">"Aaron"</span>)</span></span>;</span><br><span class="line">	MyString str7 = str6;</span><br><span class="line">	cout &lt;&lt; str6 &lt;&lt; (str6 == str7 ? <span class="string">" = "</span> : <span class="string">" != "</span>) &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载 "!=" 运算符</span></span><br><span class="line">	cout &lt;&lt; str6 &lt;&lt; (str6 != <span class="literal">NULL</span> ? <span class="string">" != "</span> : <span class="string">" = "</span>) &lt;&lt; <span class="string">" NULL"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载 "&lt;" 运算符</span></span><br><span class="line">	<span class="function">MyString <span class="title">str8</span><span class="params">(<span class="string">"AAAA"</span>)</span></span>;</span><br><span class="line">	<span class="function">MyString <span class="title">str9</span><span class="params">(<span class="string">"BBBB"</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; str8 &lt;&lt; (str8 &lt; str9 ? <span class="string">" &lt; "</span> : <span class="string">" &gt; "</span>) &lt;&lt; str9 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; str8 &lt;&lt; (str8 &lt; <span class="string">"CCCC"</span> ? <span class="string">" &lt; "</span> : <span class="string">" &gt; "</span>) &lt;&lt; <span class="string">"CCCC"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载 "&gt;" 运算符</span></span><br><span class="line">	cout &lt;&lt; str9 &lt;&lt; (str9 &gt; str8 ? <span class="string">" &gt; "</span> : <span class="string">" &lt; "</span>) &lt;&lt; str8 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; str9 &lt;&lt; (str9 &gt; <span class="string">"DDDD"</span> ? <span class="string">" &gt; "</span> : <span class="string">" &lt; "</span>) &lt;&lt; <span class="string">"DDDD"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载 "&gt;&gt;" 运算符</span></span><br><span class="line">	<span class="function">MyString <span class="title">str11</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入长度为 5 的字符串："</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str11.<span class="built_in">c_str</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"str11 = "</span> &lt;&lt; str11 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MyString str4 = NULL;   此写法，会自动调用有参构造函数 `MyString(const char* p);`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MyString str1("AB");</span></span><br><span class="line">	<span class="comment">// MyString str2 = str1;</span></span><br><span class="line">	<span class="comment">// str2 = NULL:    此写法，会自动调用 "=" 运算符重载的函数 `bool operator==(const char* p) const;`</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">str2 =</span><br><span class="line">str4 = Tom</span><br><span class="line"></span><br><span class="line">str4 = Peter</span><br><span class="line">str4 = Jim</span><br><span class="line">str4 =</span><br><span class="line"></span><br><span class="line">str5[0] = F</span><br><span class="line">str5 = Favid</span><br><span class="line"></span><br><span class="line">Aaron = Aaron</span><br><span class="line">Aaron !=  NULL</span><br><span class="line"></span><br><span class="line">AAAA &lt; BBBB</span><br><span class="line">AAAA &lt; CCCC</span><br><span class="line">BBBB &gt; AAAA</span><br><span class="line">BBBB &lt; DDDD</span><br><span class="line"></span><br><span class="line">请输入长度为 5 的字符串：</span><br><span class="line">abcde</span><br><span class="line">str11 = abcde</span><br></pre></td></tr></tbody></table></figure><h2 id="C-运算符和结合性的附录"><a href="#C-运算符和结合性的附录" class="headerlink" title="C++ 运算符和结合性的附录"></a>C++ 运算符和结合性的附录</h2><p><img data-src="../../../asset/2021/11/cplusplus-overload-9.png" alt="cplusplus-overload-9"><br><img data-src="../../../asset/2021/11/cplusplus-overload-10.png" alt="cplusplus-overload-10"></p><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/a54941f5.html" title="C++ 入门基础之六">https://www.techgrow.cn/posts/a54941f5.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/65d4f633.html" rel="prev" title="Linux 安装 CMake3"><i class="fa fa-angle-left"></i> Linux 安装 CMake3</a></div><div class="post-nav-item"> <a href="/posts/543bbac0.html" rel="next" title="Windows 系统安装 CMake3">Windows 系统安装 CMake3<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.1m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">31:11</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/a54941f5.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>