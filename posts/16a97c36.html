<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要记录 Kafaka 的日常使用笔记。"><meta property="og:type" content="article"><meta property="og:title" content="Kafka 开发随笔"><meta property="og:url" content="https://www.techgrow.cn/posts/16a97c36.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要记录 Kafaka 的日常使用笔记。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-producer-optimize-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-producer-optimize-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/12/kafka-producer-9.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-consumer-optimize-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-consumer-optimize-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/11/kafka-consumer-18.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-consumer-optimize-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-consumer-optimize-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-producer-optimize-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-producer-optimize-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-global-optimize-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/11/message-queue-order-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/11/message-queue-ha-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/11/message-queue-ha-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/11/mq-expansion.png"><meta property="article:published_time" content="2023-05-14T14:13:45.000Z"><meta property="article:modified_time" content="2023-05-14T14:13:45.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="开发随笔"><meta property="article:tag" content="消息队列"><meta property="article:tag" content="大数据"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2024/12/kafka-producer-optimize-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/16a97c36.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/16a97c36.html","path":"posts/16a97c36.html","title":"Kafka 开发随笔"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Kafka 开发随笔 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E8%B0%83%E4%BC%98"><span class="nav-text">Kafka 生产者调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-text">生产者核心参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">生产者提高吞吐量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="nav-text">生产者避免消息丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E9%81%BF%E5%85%8D%E5%8D%95%E5%88%86%E5%8C%BA%E4%B9%B1%E5%BA%8F"><span class="nav-text">生产者避免单分区乱序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81"><span class="nav-text">生产者避免消息重复发送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%BC%80%E5%90%AF%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-text">生产者开启幂等性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">生产者使用事务机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-%E6%B6%88%E8%B4%B9%E8%80%85%E8%B0%83%E4%BC%98"><span class="nav-text">Kafka 消费者调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-text">消费者的核心参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">消费者提高吞吐量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">消费者分区再平衡的优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-Broker-%E8%B0%83%E4%BC%98"><span class="nav-text">Kafka Broker 调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Broker-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-text">Broker 的核心参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Broker-%E5%A2%9E%E5%8A%A0%E5%88%86%E5%8C%BA%E6%95%B0%E9%87%8F"><span class="nav-text">Broker 增加分区数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Broker-%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98"><span class="nav-text">Broker 自动创建主题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-%E6%95%B4%E4%BD%93%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-text">Kafka 整体性能调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E6%95%B4%E4%BD%93%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">提高整体吞吐量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B2%BE%E7%A1%AE%E4%B8%80%E6%AC%A1"><span class="nav-text">数据精确一次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%E5%88%86%E5%8C%BA%E6%95%B0%E9%87%8F"><span class="nav-text">合理设置分区数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%9D%A1%E6%B6%88%E6%81%AF%E5%A4%A7%E4%BA%8E-1M"><span class="nav-text">单条消息大于 1M</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Broker-%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA"><span class="nav-text">Broker 节点宕机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">生产环境最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-text">如何保证消息的顺序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">如何避免消息丢失的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-text">如何保证消息队列的高可用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%A4%A7%E9%87%8F%E7%A7%AF%E5%8E%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">如何解决消息大量积压的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%87%E6%9C%9F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="nav-text">如何解决消息队列的过期失效问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%A3%81%E7%9B%98%E6%BB%A1%E4%BA%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-text">消息队列的磁盘满了应该怎么处理</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">692</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/16a97c36.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Kafka 开发随笔 | Clay 的技术空间"><meta itemprop="description" content="本文主要记录 Kafaka 的日常使用笔记。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Kafka 开发随笔</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-05-14 22:13:45" itemprop="dateCreated datePublished" datetime="2023-05-14T22:13:45+08:00">2023-05-14</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/16a97c36.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/16a97c36.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>13k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>12 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="Kafka-生产者调优"><a href="#Kafka-生产者调优" class="headerlink" title="Kafka 生产者调优"></a>Kafka 生产者调优</h2><div class="admonition note"><p class="admonition-title">提示</p><p>本节将介绍 Kafka 生产者调优的最佳实践，若需要具体的配置和代码，请参考 <a href="/posts/60ddcede.html#%E7%94%9F%E4%BA%A7%E8%80%85%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">这里</a>。</p></div><span id="more"></span><h3 id="生产者核心参数"><a href="#生产者核心参数" class="headerlink" title="生产者核心参数"></a>生产者核心参数</h3><blockquote><p>生产者的生产流程</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-producer-optimize-1.png"></p><blockquote><p>生产者的核心参数</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-producer-optimize-2.png"></p><h3 id="生产者提高吞吐量"><a href="#生产者提高吞吐量" class="headerlink" title="生产者提高吞吐量"></a>生产者提高吞吐量</h3><p>为了让生产者提高吞吐量（发送消息的效率），可以优化以下几个参数：</p><ul><li>(1) 在生产者端设置 <code>buffer.memory</code>：RecordAccumulator 缓冲区的总大小，默认是 <code>32m</code>，修改为 <code>64m</code></li><li>(2) 在生产者端设置 <code>batch.size</code>：批次大小，默认 <code>16k</code></li><li>(3) 在生产者端设置 <code>linger.ms</code>：等待时间，默认 <code>0ms</code>，修改为 <code>5 ~ 100ms</code></li><li>(4) 在生产者端设置 <code>compression.type</code>：压缩方式，默认是 <code>none</code>，修改为 <code>snappy</code></li></ul><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>buffer.memory</code></td><td>RecordAccumulator 缓冲区的总大小，默认值为 <code>32m</code>。</td></tr><tr><td><code>batch.size</code></td><td>缓冲区中一批数据的最大大小，默认值为 <code>16k</code>。适当增加该值，可以提高吞吐量；但是，如果该值设置得太大，会导致数据传输延迟增加。</td></tr><tr><td><code>linger.ms</code></td><td>如果数据量迟迟未达到 <code>batch.size</code>，Sender 线程等待 <code>linger.ms</code> 之后就会发送数据。单位是 <code>ms</code>，默认值为 <code>0ms</code>，表示没有延迟。生产环境建议该值大小为 5 ~ 100ms 之间。</td></tr><tr><td><code>compression.type</code></td><td>生产者发送的所有数据的压缩方式。默认值为 <code>none</code>，也就是不压缩。支持压缩类型：<code>none</code>、<code>gzip</code>、<code>snappy</code>、<code>lz4</code> 和 <code>zstd</code>。</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>(1) 上述的四个参数值并不是设置得越大就越好，设置得过大会导致 Kafka 中的消息被延迟消费。</li><li>(2) 当 Topic 的分区数量比较多的时候，可以适当增加 <code>RecordAccumulator（缓冲区）</code> 的大小。</li></ul></div><h3 id="生产者避免消息丢失"><a href="#生产者避免消息丢失" class="headerlink" title="生产者避免消息丢失"></a>生产者避免消息丢失</h3><p>生产者发送消息后，由于网络故障或网络延迟，可能会导致消息在传输过程中丢失。Kafka 只要至少配置以下 4 个参数，就可以保证生产者发送的消息不会丢失：</p><ul><li>(1) 给 Topic 设置 <code>replication.factor</code> 参数：这个值必须大于等于 2，即要求每个 Partition 必须至少有 2 个副本</li><li> (2) 在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于等于 2，即要求一个 Leader 至少要有 1 个 Follower 还跟自己保持着同步，这样才能确保 Leader 宕机了，还有一个 Follower 可以使用</li><li> (3) 在生产者端设置 <code>acks=all</code>：这是要求每条消息，必须是写入到所有 Replica（副本）之后，才能认为是发送成功</li><li> (4) 在生产者端设置 <code>retries=MAX（可以是一个很大很大的值，表示无限次重试的意思）</code>：这个是要求一旦消息发送失败，就无限重试</li></ul><h3 id="生产者避免单分区乱序"><a href="#生产者避免单分区乱序" class="headerlink" title="生产者避免单分区乱序"></a>生产者避免单分区乱序</h3><p>Kafka 生产者解决<strong>单分区</strong>内的乱序问题，主要是依赖以下两个参数：</p><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>enable.idempotence</code></td><td>是否开启幂等性，默认值为 <code>true</code>， 表示默认开启幂等性。</td></tr><tr><td><code>max.in.flight.requests.per.connection</code></td><td>允许最多没有返回 ACK 应答的次数，默认为 <code>5</code>，开启幂等性后必须保证该参数值在 1 ~ 5 范围内。</td></tr></tbody></table><blockquote><p>注意事项</p></blockquote><ul><li>只开启 <code>enable.idempotence</code> 可以防止失败重试时的出现消息重复，但可能不能完全解决单分区内的乱序问题（这取决于 <code>max.in.flight.requests.per.connection</code> 参数的设置）。</li><li>要彻底解决 Kafka 单分区内的乱序问题，<code>enable.idempotence</code> 和 <code>max.in.flight.requests.per.connection</code> 这两个参数需要配合使用，这样才可以确保消息的顺序性和幂等性，但是会牺牲一定的生产吞吐量。</li><li><strong>特别注意，这两个配置参数只能保证 Kafka 单分区内的数据顺序，多分区之间的数据顺序 Kafka 无法保证。</strong></li></ul><blockquote><p>参数说明</p></blockquote><ul><li><code>max.in.flight.requests.per.connection</code> 是 Kafka Producer 的一个配置参数，用于控制在同一个 TCP 连接上未被 Broker 确认（ACK）的请求的最大数量。默认值是 <code>5</code>，意味着在同一个连接上，最多可以有 5 个未确认的请求。</li><li>如果启用了消息重试（<code>retries &gt; 0</code>，默认启用重试机制），并且设置的 <code>max.in.flight.requests.per.connection &gt; 1</code>，在某些情况下可能会导致单分区内的消息乱序。例如：一个较早的请求失败并被重试时，后续的请求可能已经被成功发送并确认。</li><li>当 <code>enable.idempotence=true</code>（启用幂等性），<code>max.in.flight.requests.per.connection</code> 的值不能超过 <code>5</code>，否则 Kafka 会拒绝启动 Producer。在启用幂等性后默认配置 <code>max.in.flight.requests.per.connection=5</code>，这是经过优化的平衡设置。</li></ul><blockquote><p>版本区别</p></blockquote><ul><li><p>Kafka 在 <code>1.x</code> 版本之前可以保证数据单分区的有序性，条件如下:</p><ul><li><code>max.in.flight.requests.per.connection = 1</code>，不需要考虑是否开启幂等性。</li></ul></li><li><p>Kafka 在 <code>1.x</code> 及以后版本可以保证数据单分区的有序性，条件如下:</p><ul><li>未开启幂等性<ul><li><code>max.in.flight.requests.per.connection</code> 需要必须设置为 1。</li></ul></li><li>开启幂等性<ul><li><code>max.in.flight.requests.per.connection</code> 的值必须设置在 1 ~ 5 之间。</li><li>原因说明：因为在 Kafka <code>1.x</code> 版本以后，启用幂等性后，Kafka 服务端会缓存 Producer 发来的最近 5 个 Request 的元数据，因此无论如何，都可以保证最近 5 个 Request 的数据都是有序的（如下图所示）。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2023/12/kafka-producer-9.png"></p><blockquote><p>情景分析</p></blockquote><ul><li><p><code>max.in.flight.requests.per.connection</code> 的值为 1（最严格的保证）</p><ul><li>每次只有一个请求正在处理，前一个请求完成后，才会发送下一个请求。</li><li>在这种配置下，绝对可以保证单分区的有序性，但会牺牲生产者的吞吐量。</li></ul></li><li><p><code>max.in.flight.requests.per.connection</code> 的值在 1 ~ 5 之间</p><ul><li>配置的前提条件：必须设置 <code>enable.idempotence=true</code> 和 <code>acks=all</code>。</li><li>当满足上述前提条件时，Kafka 的生产者重试机制会确保消息的顺序，即使发生失败重试，也能按顺序处理请求。</li><li>Kafka <code>1.1</code> 及以后版本，启用幂等性后，生产者可以保证单分区的顺序性，只要 <code>max.in.flight.requests.per.connection</code> 的值在 1 ~ 5 之间即可。</li><li>配置风险：<ul><li>如果 <code>enable.idempotence=false</code>，同时 <code>max.in.flight.requests.per.connection &gt; 1</code>，则单分区内可能会出现消息乱序。这是因为并行发送的请求，在发送失败后会重新发送，后发送的请求可能先完成，从而打破顺序。</li><li>如果 <code>enable.idempotence=false</code>，为了保证单分区的顺序性，<code>max.in.flight.requests.per.connection</code> 的值必须设置为 1。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><ul><li>当 <code>enable.idempotence=true</code> 且 <code>acks=all</code> 时，<code>max.in.flight.requests.per.connection</code> 的值在 1 ~ 5 之间，Kafka 仍然可以保证单分区的有序性。</li><li>设置为 <code>max.in.flight.requests.per.connection=1</code> 时，这是最简单、最安全的配置，但会影响生产者的吞吐量。</li><li>设置为 <code>max.in.flight.requests.per.connection &gt; 1</code> 时，能保证单分区的有序性，同时可以提高吞吐量，但需要依赖 <code>enable.idempotence=true</code>（启用幂等性）。</li><li>如果 <code>enable.idempotence=false</code>，即没有启用幂等性，那么 <code>max.in.flight.requests.per.connection</code> 的值必须设置为 1，这样才能保证单分区的有序性。</li></ul></div><h3 id="生产者避免消息重复发送"><a href="#生产者避免消息重复发送" class="headerlink" title="生产者避免消息重复发送"></a>生产者避免消息重复发送</h3><p>生产者避免消息重复发送有两种实现方案，包括开启幂等性和使用事务机制。</p><h4 id="生产者开启幂等性"><a href="#生产者开启幂等性" class="headerlink" title="生产者开启幂等性"></a>生产者开启幂等性</h4><div class="admonition note"><p class="admonition-title">什么是 Kafka 的幂等性</p><ul><li>Kafka 的幂等性是指 Producer (生产者) 无论向 Broker 发送多少条重复消息，Broker 端都只会持久化一条消息，保证了消息不重复。</li><li>精确一次 (Exactly Once) = 开启幂等性 + 至少一次 (<code>acks = -1</code> + <code>分区副本数 &gt;= 2</code> + <code>ISR 里应答的最小副本数量 &gt;= 2</code>)。</li><li>Kafka 官方文档中的幂等性详细介绍可以看 <a target="_blank" rel="external nofollow" href="https://kafka.apache.org/documentation/#producerconfigs_enable.idempotence">这里</a>。</li></ul></div><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>enable.idempotence</code></td><td>是否开启幂等性，默认值为 <code>true</code>， 表示默认开启幂等性。</td></tr><tr><td><code>max.in.flight.requests.per.connection</code></td><td>允许最多没有返回 ACK 应答的次数，默认为 <code>5</code>，开启幂等性要保证该参数值在 1 ~ 5 范围内。</td></tr></tbody></table><ul><li><p>在 Kafka 中开启幂等性的配置参数是 <code>enable.idempotence</code>，默认值为 <code>true</code>，设置 <code>false</code> 会关闭幂等性。如果没有设置冲突的配置，默认情况下会启用幂等性。如果设置了冲突的配置，并且未显式启用幂等性，则会禁用幂等性。如果显式启用了幂等性，并且设置了冲突的配置，则会抛出 ConfigException 异常。</p></li><li><p>当在生产者端设置 <code>enable.idempotence</code> 为 <code>true</code> 时，生产者将确保数据流中只写入每条消息的一个副本，即可以确保生产者不会写入重复消息。如果设置为 <code>false</code>，由于代理失败等原因，生产者重试发送消息，可能会在数据流中写入重试消息的副本，即生产者可能会写入重复消息。</p></li></ul><div class="admonition warning"><p class="admonition-title">Kafka 启用幂等性要至少满足以下 4 个条件</p><ul><li>(1) 在生产者端设置 <code>enable.idempotence</code> 参数：这个值必须为 <code>true</code>，即开启幂等性</li><li> (2) 在生产者端设置 <code>max.in.flight.requests.per.connection</code> 参数：这个值必须小于或等于 5</li><li>(3) 在生产者端设置 <code>acks = -1</code>：这是要求每条消息，必须是写入到所有 Replica（副本）之后，才能认为是发送成功</li><li> (4) 在生产者端设置 <code>retries</code>：这个值必须大于 0，即必须要有重试机制</li></ul></div><h4 id="生产者使用事务机制"><a href="#生产者使用事务机制" class="headerlink" title="生产者使用事务机制"></a>生产者使用事务机制</h4><p>Kafa 除了可以使用幂等性来解决生产者重复发送消息之外，还可以使用事务机制来解决，关于 Kafka 事务机制的详细介绍请看 <a href="/posts/60ddcede.html#%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8">这里</a>。Kafka 的事务一共有以下 5 个 API：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.初始化事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initTransactions</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.开启事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在事务内提交已经消费的偏移量(主要用于消费者)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOffsetsToTransaction</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, String consumerGroupId)</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commitTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.放弃事务(类似于回滚事务的操作)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abortTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="Kafka-消费者调优"><a href="#Kafka-消费者调优" class="headerlink" title="Kafka 消费者调优"></a>Kafka 消费者调优</h2><h3 id="消费者的核心参数"><a href="#消费者的核心参数" class="headerlink" title="消费者的核心参数"></a>消费者的核心参数</h3><blockquote><p>消费者组的消费流程</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-consumer-optimize-2.png"></p><blockquote><p>消费者的核心参数</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-consumer-optimize-3.png"></p><h3 id="消费者提高吞吐量"><a href="#消费者提高吞吐量" class="headerlink" title="消费者提高吞吐量"></a>消费者提高吞吐量</h3><p>Kafka 如何提高消费者的消费速度呢？</p><ul><li><p>(1) 如果是 Kafka 消费能力不足，则可以考虑增加 Topic 的分区数量，并且同时增加消费组的消费者数量，这两个条件缺一不可，即 <code>消费组的消费者数量 = Topic 的分区数量</code>。</p></li><li><p>(2) 如果是下游的数据处理不及时（有较大延迟），则可以提高消费者每批次拉取消息的数量（默认每批次拉取 500 条消息）。每批次拉取数据过少（拉取的数据量 / 数据处理时间 &lt; 生产速度），会使消费者处理数据的速度小于生产者生产数据的速度，从而可能导致消息积压。</p></li></ul><p><img data-src="../../../asset/2024/11/kafka-consumer-18.png"></p><ul><li>(3) 消费者提高吞吐量的相关配置参数</li></ul><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>fetch.max.bytes</code></td><td>消费者获取服务器端一批消息的最大字节数，默认值为 <code>50M</code>。如果服务器端一批次的消息大于该值，仍然可以将这批消息拉取回来，所以这不是一个绝对最大值。消费者拉取一批次消息的大小受 <code>message.max.bytes</code>（Broker 配置）或者 <code>max.message.bytes</code>（Topic 配置）影响。</td></tr><tr><td><code>max.poll.records</code></td><td>消费者每次调用 <code>poll()</code> 方法时，最多能拉取的消息数量，默认值为 <code>500</code>。</td></tr></tbody></table><h3 id="消费者分区再平衡的优化"><a href="#消费者分区再平衡的优化" class="headerlink" title="消费者分区再平衡的优化"></a>消费者分区再平衡的优化</h3><p>Kafka 消费者的分区再平衡（Partition Rebalancing）是指当消费者组中的成员发生变更时（如消费者加入、退出或故障），Kafka 自动调整分区与消费者之间的映射关系，以确保所有分区都会被消费者组中的成员消费。</p><blockquote><p>消费者组的初始化流程</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-consumer-optimize-1.png"></p><blockquote><p>分区再平衡相关的配置参数</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-consumer-optimize-4.png"></p><blockquote><p>分区再平衡的优缺点</p></blockquote><ul><li>优点：<ul><li>动态调整分区分配，支持弹性扩展。</li><li>确保分区始终被有效消费。</li></ul></li><li>缺点：<ul><li>短暂中断：再平衡期间会暂停消费，导致短时间内消息未被处理。</li><li>分区切换开销：消费者需要重新建立分区的连接和状态。</li></ul></li></ul><blockquote><p>分区再平衡的优化措施</p></blockquote><ul><li>使用静态成员 ID（<code>group.instance.id</code>），减少分区再平衡的频率。</li><li>控制心跳和会话超时（<code>heartbeat.interval.ms</code> 和 <code>session.timeout.ms</code>），避免误触发分区再平衡。</li><li>通过配置参数 <code>partition.assignment.strategy</code> 来调整分区分配策略，以适应具体场景需求。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>更多关于 Kafka 消费者的分区再平衡介绍请看 <a href="/posts/c61757ff.html#Kafka-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8">这里</a>。</li></ul></div><h2 id="Kafka-Broker-调优"><a href="#Kafka-Broker-调优" class="headerlink" title="Kafka Broker 调优"></a>Kafka Broker 调优</h2><div class="admonition note"><p class="admonition-title">提示</p><ul><li>更多关于 Kafka Broker 调优的教程请看 <a href="/posts/ed9d5bd.html#Kafka-Broker-%E8%B0%83%E4%BC%98">这里</a>。</li></ul></div><h3 id="Broker-的核心参数"><a href="#Broker-的核心参数" class="headerlink" title="Broker 的核心参数"></a>Broker 的核心参数</h3><blockquote><p>Broker 的工作流程</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-producer-optimize-3.png"></p><blockquote><p>Broker 的核心参数</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-producer-optimize-4.png"></p><h3 id="Broker-增加分区数量"><a href="#Broker-增加分区数量" class="headerlink" title="Broker 增加分区数量"></a>Broker 增加分区数量</h3><ul><li>通过 <code>kafka-topics.sh</code> 脚本增加 Topic 的分区数量</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --alter --topic first --partitions 3</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Kafka 的分区数量只能增加，不能减少。值得一提的是，Kafka 同样不支持减少已创建的主题的副本数量，但是可以通过 <code>kafka-reassign-partitions.sh</code> 脚本重新分配副本的方式来实现。</p></div><h3 id="Broker-自动创建主题"><a href="#Broker-自动创建主题" class="headerlink" title="Broker 自动创建主题"></a>Broker 自动创建主题</h3><ul><li><p>如果将 Broker 端的配置参数 <code>auto.create.topics.enable</code> 设置为 <code>true</code>（默认值是 <code>true</code>），那么当生产者向一个未创建的主题发送消息时，Broker 会自动创建一个分区数为 <code>num.partitions</code>（默认值为 1）、副本因子为 <code>default.replication.factor</code>（默认值为 1）的主题。</p></li><li><p>除此之外，当一个消费者开始从未知主题中读取消息时，或者当任意一个客户端向未知主题发送元数据请求时，都会自动创建一个相应的主题。这种创建主题的方式是非预期的，增加了主题管理和维护的难度。在生产环境下，强烈建议将 <code>auto.create.topics.enable</code> 设置为 <code>false</code>。</p></li></ul><h2 id="Kafka-整体性能调优"><a href="#Kafka-整体性能调优" class="headerlink" title="Kafka 整体性能调优"></a>Kafka 整体性能调优</h2><h3 id="提高整体吞吐量"><a href="#提高整体吞吐量" class="headerlink" title="提高整体吞吐量"></a>提高整体吞吐量</h3><p>为了提高 Kafka 整体的吞吐量，可以从以下四个角度进行优化。</p><blockquote><p>(1) 增加 Topic 的分区数量</p></blockquote><ul><li>通过 <code>kafka-topics.sh</code> 脚本增加 Topic 的分区数量（注意：分区数量只能增加，不能减少）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --alter --topic first --partitions 3</span><br></pre></td></tr></tbody></table></figure><blockquote><p>(2) 提高生产吞吐量</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>buffer.memory</code></td><td>发送消息的缓冲区大小，默认值是 <code>32m</code>，生产环境可以增加到 <code>64m</code>。</td></tr><tr><td><code>batch.size</code></td><td>缓冲区中一批数据的最大大小，默认值是 <code>16k</code>。如果 Batch 设置太小，会导致频繁发送网络请求，吞吐量下降；如果 Batch 设置太大，会导致一条消息需要等待很久才能够被发送出去，增加网络延迟。</td></tr><tr><td><code>linger.ms</code></td><td>如果数据迟迟未达到 <code>batch.size</code>，那么 Sender 等待 <code>linger.ms</code> 之后就会发送消息。默认值是 <code>0</code>，表示立刻发送消息。生产环境建议设置 5 ~ 100 毫秒之间。如果 <code>linger.ms</code> 设置太小，会导致频繁发送网络请求，吞吐量下降；如果 <code>linger.ms</code> 设置太大，会导致一条消息需要等待很久才能被发送出去，增加网络延迟。</td></tr><tr><td><code>compression.type</code></td><td>默认值是 <code>none</code>，表示不压缩直接发送消息。支持的压缩类型：<code>none</code>、<code>gzip</code>、<code>snappy</code>、<code>lz4</code> 和 <code>zstd</code>。生产环境也可以使用 <code>gzip</code> 压缩，效率还是不错的，压缩之后可以减小数据量，提升吞吐量，但是会加大 Producer 端的 CPU 开销。</td></tr></tbody></table><blockquote><p>(3) 提高消费吞吐量</p></blockquote><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>fetch.max.bytes</code></td><td>消费者获取服务器端一批消息的最大字节数，默认值为 <code>50m</code>。如果服务器端一批次的消息大于该值，仍然可以将这批消息拉取回来，所以这不是一个绝对最大值。消费者拉取一批次消息的大小受 <code>message.max.bytes</code>（Broker 配置）或者 <code>max.message.bytes</code>（Topic 配置）影响。</td></tr><tr><td><code>max.poll.records</code></td><td>消费者每次调用 <code>poll()</code> 方法时，最多能拉取的消息数量，默认值为 <code>500</code>。</td></tr></tbody></table><blockquote><p>(4) 增加消费者的数量</p></blockquote><p>当增加了 Topic 的分区数量后，还需要同时增加消费组的消费者数量，这两个条件缺一不可，即 <code>消费组的消费者数量 = Topic 的分区数量</code>，这样才能提高消费吞吐量。</p><h3 id="数据精确一次"><a href="#数据精确一次" class="headerlink" title="数据精确一次"></a>数据精确一次</h3><p>在 Kafka 中，为了保证消息被精确一次发送和消费，必须满足以下全部条件，缺一不可。</p><blockquote><p>(1) 生产者角度</p></blockquote><ul><li>将 <code>acks</code> 参数设置为 <code>-1</code>。</li><li>开启幂等性 <code>enable.idempotence = true</code>，默认开启。</li><li>在生产端使用事务机制发送消息。</li></ul><blockquote><p>(2) Broker 角度</p></blockquote><ul><li>分区的副本数量大于等于 2（<code>--replication-factor 2</code>）。</li><li>ISR 里应答的最小副本数量大于等于 2 (<code>min.insync.replicas = 2</code>)。</li></ul><blockquote><p>(3) 消费者角度</p></blockquote><ul><li>事务机制 + 手动提交 Offset（<code>enable.auto.commit = false</code>）。</li><li>消费者输出的目标存储系统必须支持事务（比如 MySQL、Kafka）。</li></ul><h3 id="合理设置分区数量"><a href="#合理设置分区数量" class="headerlink" title="合理设置分区数量"></a>合理设置分区数量</h3><p>如何为某个 Topic 合理设置分区数量呢？以下是估算分区数量的方法：</p><ul><li>(1) 创建一个只有 1 个分区的 Topic。</li><li>(2) 测试这个 Topic 的 Producer 吞吐量和 Consumer 吞吐量。</li><li>(3) 假设它们吞吐量的值分别是 Tp 和 Tc，单位是 MB/s。</li><li>(4) 然后，假设总的目标吞吐量是 Tt，那么 <code>分区数 = Tt /min (Tp, Tc)</code>。</li><li>(5) 比如：Producer 吞吐量是 20m/s，Consumer 吞吐量是 50m/s，期望吞吐量 100m/s，那么 <code>分区数 = 100 / min (20, 50) = 5 个分区</code>。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Kafka 的分区数一般设置为：3 ~ 10 个。</li><li>Kafka 的分区数并不是越多越好，也不是越少越好，需要搭建完 Kafka 集群，然后对集群进行压测，再根据压测结果调整分区的数量。</li></ul></div><h3 id="单条消息大于-1M"><a href="#单条消息大于-1M" class="headerlink" title="单条消息大于 1M"></a>单条消息大于 1M</h3><p>当 Kafka 单条消息的大小大于 1M，那么可以通过以下参数进行优化：</p><p><img data-src="../../../asset/2024/12/kafka-global-optimize-1.png"></p><h3 id="Broker-节点宕机"><a href="#Broker-节点宕机" class="headerlink" title="Broker 节点宕机"></a>Broker 节点宕机</h3><p>在 Kafka 生产环境（集群部署）中，如果某个 Broker 节点挂掉，正常的处理方法如下：</p><ul><li>(1) 先尝试重新启动 Broker 节点，如果能够正常启动，那问题直接解决。</li><li>(2) 如果无法正常重启，考虑增加内存、增加 CPU、增加网络带宽。</li><li>(3) 如果是将整个 Broker 节点误删除掉<ul><li>如果分区的副本数大于等于 2，那么可以按照 Kafka 服役新节点的方式重新服役一个新节点，并执行负载均衡，将部分数据迁移到新节点。</li><li>如果分区的副本只有一个，那么只能 “批量重导”，也就是写个临时程序将丢失的那批数据查询出来，然后重新将消息写入 Kafka 里面。</li></ul></li></ul><h2 id="生产环境最佳实践"><a href="#生产环境最佳实践" class="headerlink" title="生产环境最佳实践"></a>生产环境最佳实践</h2><h3 id="如何保证消息的顺序性"><a href="#如何保证消息的顺序性" class="headerlink" title="如何保证消息的顺序性"></a>如何保证消息的顺序性</h3><blockquote><p>关键点</p></blockquote><ul><li><p>不同 MQ 对消息顺序性的支持</p><ul><li>在 Kafka 和 RabbitMQ 中，无法保证消息的顺序性，需要开发者自己实现。</li><li>在 RocketMQ 中，有完整的针对性设计（原生支持消息的顺序性），可以保证消息的顺序性。</li></ul></li><li><p>全局有序和局部有序</p><ul><li>MQ 通常只需要保证消息在局部有序，而不需要保证消息在全局有序。</li><li>比如，在局部层面上，某个订单的多个消息必须有序的，但在全局层面上，不同订单的消息是不需要保证有序的。这类似微信的聊天窗口，在单个聊天窗口内，多个消息必须是有序的，但在多个聊天窗口中消息不一定是要有序的。</li></ul></li><li><p>生产实践案例分析</p><ul><li>大数据团队需要开发一个 MySQL Binlog 同步系统，要求同步一个 MySQL 库的数据过来，对公司业务系统的数据做各种复杂的分析。那么在 MySQL 里增删改一条数据，对应出来了增删改 3 条 Binlog，接着这三条 Binlog 发送到 MQ 里面。当消费者将消息读取出来依次执行时，这就要保证消息是有序，不然本来依次是增加、修改、删除；搞错顺序后，给执行成删除、修改、增加，这就全乱套了。因为本来这条数据同步过来，最后这条数据应该被删除了；结果搞错了这个顺序，最后这条数据保留下来了，这就造成数据同步出错了。</li></ul></li></ul><blockquote><p>解决方案</p></blockquote><ul><li><strong>在 Kafka 单分区内，数据是有序（需要满足一定的条件）。</strong><ul><li>在单个分区内，Kafka 保证消息是按生产者写入的顺序进行存储的，并且消费者在读取时也是按这个顺序读取的。因此，只要满足一定的条件，单分区内的数据是有序的。</li><li>为了保证单分区的有序性，需要满足以下任意一个条件：<ul><li>第一种情况： <code>max.in.flight.requests.per.connection=1</code>，不需要开启幂等性，但会影响生产者的吞吐量。</li><li>第二种情况：开启幂等性 <code>enable.idempotence=true</code>，并且设置 <code>max.in.flight.requests.per.connection</code> 的值在 1 ~ 5 之间。</li></ul></li></ul></li><li><strong>在 Kafka 多分区内，分区与分区之间的数据是无序。</strong><ul><li>在多分区的情况下，Kafka 会将消息分布到不同的分区中。由于分区之间是并行处理的，Kafka 不会保证分区之间的消息顺序。因此，从全局视角来看，多分区的数据是无序的。</li></ul></li><li><strong>在 MQ（比如 Kafka）中，保证消息的顺序性，最关键的是严格保证生产者、MQ 队列、消费者这三者是一对一的关系。</strong><ul><li>要保证一个生产者只对应一个 Topic，一个 Topic 只对应一个 Partition，并且一个 Partition 只对应一个消费者。</li><li>比如，生产者在发送消息的时候，可以指定一个 Key，比如指定某个订单 的 ID 作为 Key，那么这个订单相关的所有消息，一定都会被分发到同一个 Partition 中去，而且这个 Partition 中的数据一定是有顺序的。当消费者从 Partition 中读取消息的时候，也一定是有顺序的。另外，如果消费者是单线程进行消费处理，而处理比较耗时的话，假设处理一条消息耗时几十毫秒，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。建议在消费者内部使用单线程进行消费时，将消息写入 N 个内存队列，并且通过哈希算法将拥有相同 Key 的消息都写入到同一个内存队列里面；最后启动 N 个线程，每个线程分别消费一个内存队列即可，这就能保证消息的顺序性，也能大大提高消费消息的吞吐量。整个处理流程如下图所示：</li></ul></li></ul><p><img data-src="../../../asset/2024/11/message-queue-order-2.png"></p><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a target="_blank" rel="external nofollow" href="https://juejin.cn/post/6844904099540893710">《如何保证消息的顺序性》</a></li><li><a target="_blank" rel="external nofollow" href="https://juejin.cn/post/6844903605221195790">《如何解决消息顺序与消息重复两大硬伤》</a></li></ul></div><h3 id="如何避免消息丢失的问题"><a href="#如何避免消息丢失的问题" class="headerlink" title="如何避免消息丢失的问题"></a>如何避免消息丢失的问题</h3><p>这问题相当于 “如何保证消息的可靠性” 或者 “如何保证消息可靠传输”。消息丢失的问题，可能会出现在生产者、消息队列服务器、消费者中的任一环节。</p><blockquote><p>生产者发送消息丢失</p></blockquote><p>生产者发送消息后，由于网络故障或网络延迟，可能会导致消息在传输过程中丢失。</p><ul><li>解决方案<ul><li> Kafka 只要至少配置以下 4 个参数，就可以保证生产者发送的消息不会丢失<ul><li> (1) 给 Topic 设置 <code>replication.factor</code> 参数：这个值必须大于等于 2，即要求每个 Partition 必须至少有 2 个副本</li><li> (2) 在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于等于 2，即要求一个 Leader 至少要有 1 个 Follower 还跟自己保持着同步，这样才能确保 Leader 宕机了，还有一个 Follower 可以使用</li><li> (3) 在生产者端设置 <code>acks=all</code>：这是要求每条消息，必须是写入到所有 Replica（副本）之后，才能认为是发送成功</li><li> (4) 在生产者端设置 <code>retries=MAX（可以是一个很大很大的值，表示无限次重试的意思）</code>：这个是要求一旦消息发送失败，就无限重试</li></ul></li></ul></li></ul><blockquote><p>MQ 服务器消息同步丢失</p></blockquote><p>在 MQ 集群中，多个节点之间同步消息时，可能会发生消息丢失。</p><ul><li>问题发生<ul><li> Leader 与 Follower 之间同步消息时，可能会发生消息丢失。比如，Broker 上面有某个 Replica 的 Leader，刚好其他的 Follower 还有一些数据没有同步，此时 Leader 突然宕机了，然后 Kafa 选举某个 Follower 成为新的 Leader 之后，这就会丢失一些消息</li></ul></li><li>解决方案<ul><li>要求至少配置以下 4 个参数，这样至少可以保证 Leader 所在 Broker 发生故障，进行 Leader 切换时，Kafka 不会丢失数据<ul><li> (1) 给 Topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，即要求每个 Partition 必须至少有 2 个副本</li><li> (2) 在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 0，即要求一个 Leader 至少要有 1 个 Follower 还跟自己保持着同步，这样才能确保 Leader 宕机了，还有一个 Follower 可以使用</li><li> (3) 在生产者端设置 <code>acks</code> 参数为 <code>all</code>：这个是要求每条消息，必须是写入到所有 Replica（副本）之后，才能认为是发送成功</li><li> (4) 在生产者端设置 <code>retries=MAX（可以是一个很大很大的值，表示无限次重试的意思）</code>：这个是要求一旦消息发送失败，就无限重试</li></ul></li></ul></li></ul><blockquote><p>MQ 服务器消息存盘丢失</p></blockquote><p>MQ 服务器将内存中的数据持久化到硬盘时，可能会发生消息丢失（比如 MQ 在持久化之前意外宕机）。</p><ul><li>解决方案<ul><li>适当配置日志保留时间（<code>retention.ms</code>）和日志段大小（<code>segment.bytes</code>），这样可以避免日志被过早删除，特别是在高负载系统中，这可以保证数据在宕机恢复后仍然可用</li><li> Kafka 默认使用内存缓冲来写入磁盘数据，可以通过调整日志刷盘策略（以下两个参数）来控制数据的刷盘频率，避免数据在缓冲区中丢失<ul><li><code>log.flush.interval.messages</code>：达到一定数量的消息后强制刷盘</li><li><code>log.flush.interval.ms</code>：在规定的时间内强制刷盘</li></ul></li></ul></li></ul><blockquote><p>消费者消费消息丢失</p></blockquote><p>消费者拉取消息后，需要处理业务，这期间可能会发生消息丢失。</p><ul><li>解决方案<ul><li>关闭 Offset 自动提交，使用 Offset 手动提交</li></ul></li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a target="_blank" rel="external nofollow" href="https://juejin.cn/post/7022530252857409550">《如何回答消息队列的丢失、重复与积压问题》</a></li></ul></div><h3 id="如何保证消息队列的高可用性"><a href="#如何保证消息队列的高可用性" class="headerlink" title="如何保证消息队列的高可用性"></a>如何保证消息队列的高可用性</h3><ul><li><p><strong>Kafka 的概述</strong></p><ul><li>Kafka 一个最基本的架构认识：由多个 Broker 组成，每个 Broker 就是一个节点；当你创建一个 Topic 时，这个 Topic 可以划分为多个 Partition（分区），每个 Partition 可以存在于不同的 Broker 上，每个 Partition 只存放这个 Topic 的一部分数据（类似数据分片）。</li><li>Kafka 是天生的分布式消息队列，就是说一个 Topic 的数据，是分散存放在多台机器上的，每台机器只存放一部分数据。实际上像 RabbitMQ 之类的消息队列，并不是分布式消息队列，它们本质上还是传统的消息队列，只不过提供了一些集群、HA 的机制而已。因为无论怎么使用，RabbitMQ 每一个队列的数据都是存放在一个实例（节点）里的，即使在镜像集群下，也只是多个实例（节点）都存放某个队列的完整数据。</li></ul></li><li><p><strong>Kafka 0.8 版本以前</strong></p><ul><li>在 Kafka 的 <code>0.8</code> 版本以前，是没有 HA 机制的，也就是任何一个 Broker 宕机了，那个 Broker 上的 Partition 就废掉了，没法写也没法读，没有什么高可用性可言。</li><li>比如说，假设创建了一个 Topic，指定其 Partition 数量是 3 个，分布在三台机器上。但是，如果第二台机器宕机了，会导致这个 Topic 的 1/3 的数据丢失，因此这个是做不到高可用的。</li></ul><p> <img data-src="../../../asset/2024/11/message-queue-ha-3.png"></p></li><li><p><strong>Kafka 0.8 版本以后</strong></p><ul><li>在 Kafka 的 <code>0.8</code> 版本以后，提供了 HA 机制，也就是 Replica（副本）机制。每个 Partition（分区）的数据都会同步到其他机器上，形成自己的多个 Replica 副本。然后，所有 Replica 会选举一个 Leader 出来，其他 Replica 就是 Follower。</li><li>生产者和消费者都只跟 Leader 打交道。在写消息的时候，Leader 会负责将数据同步到所有 Follower 上去；在读消息的时候，就直接从 Leader 读取数据即可。为什么只能读写 Leader 呢？很简单，要是可以随意读写每一个 Follower，那么就要关心数据一致性的问题，这样系统的复杂度就太高了，很容易出现问题。Kafka 默认会均匀地将一个 Partition 的所有 Replica 分布在不同的机器上，这样才可以提高容错性。</li><li>这样一来就有所谓的高可用性了，因为如果某个 Broker 宕机了，那个 Broker 上面的 Partition 在其他机器上都是有副本的。如果在那个 Broker 上面刚好有某个 Partition 的 Leader，那么此时会重新选举一个新的 Leader 出来，然后继续读写那个新的 Leader 即可。</li><li>在写消息的时候，生产者只会写给 Leader，然后 Leader 将数据写入到本地磁盘，接着其他 Follower 自己主动从 Leader 拉取最新的数据。一旦所有 Follower 同步完数据，就会发送 ACK 给 Leader，当 Leader 收到所有 Follower 的 ACK 之后，就会返回写成功的消息给生产者（当然，这只是其中一种模式，还可以适当调整这个行为）。在读消息的时候，消费者只会从 Leader 读取消息，但是只有当一个消息已经被所有 Follower 都同步成功并返回 ACK 给 Leader 的时候，这个消息才会被消费者读取到。</li></ul><p> <img data-src="../../../asset/2024/11/message-queue-ha-4.png"></p></li></ul><h3 id="如何解决消息大量积压的问题"><a href="#如何解决消息大量积压的问题" class="headerlink" title="如何解决消息大量积压的问题"></a>如何解决消息大量积压的问题</h3><blockquote><p>消息积压的概述</p></blockquote><p>消息积压指的是消息在消息队列中堆积而未能及时处理的情况。消息的积压主要来自于两方面：要么消息生产变快了，要么消息消费变慢了。</p><ul><li>监控发现，生产和消费消息的速度没什么变化，出现消息积压的情况，检查是有消费失败反复消费的情况。</li><li>监控发现，消费消息的速度变慢，检查消费实例，日志中是否有大量消费错误、消费线程是否死锁、是否卡在某些资源上。</li><li>单位时间内发送的消息增多，比如赶上大促或者抢购，短时间内不太可能优化消费端的代码来提升消费性能，但可以<strong>通过扩容消费端的实例数来提升总体的消费能力</strong>。</li><li>如果短时间内没有服务器资源扩容，可以<strong>将系统降级，通过关闭某些不重要的业务，减少消息发送的数据量，最低限度让系统还能正常运转，保证核心业务的可用性</strong>。</li><li>严重影响 MQ 甚至整个系统时，可以考虑<strong>临时启用多个消费者，并发接收消息，同时持久化消息（比如写入数据库），过段时间再将持久化的消息重新写回 MQ 中进行消费，或者极端情况下直接丢弃消息</strong>。</li></ul><blockquote><p>消息积压的解决方案</p></blockquote><p>可以使用扩容来解决消息积压的问题，比如利用临时消费者，消费原来积压在队列中的消息。该消费者不做任何耗时的操作，将消息均匀写入新创建的队列里，最后将更多 Consumer 部署到更多的机器上消费新创建队列上的消息。等待积压的消息被消费，恢复到正常状态后，撤掉扩容服务器。具体步骤和思路如下：</p><ul><li>(1) 先修复 Consumer 的问题，确保其恢复正常的消费速度，然后将现有的 Consumer 都停掉</li><li> (2) 临时建立好原先 10 倍或者 20 倍的 Queue 数量</li><li> (3) 写一个临时的分发消息的 Consumer 程序，将这个程序部署上去消费积压的消息，消费之后不做任何耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 Queue</li><li>(4) 接着临时征用 10 倍机器来部署 Consumer 实例，每一个（或者一批） Consumer 消费一个临时 Queue 的数据</li><li> (5) 等积压的数据都被消费完之后，恢复原先的部署架构，重新用原先的 Consumer 机器来消费消息</li></ul><p>这种做法相当于临时将 Queue 资源和 Consumer 资源扩大了 10 倍，即以正常的 10 倍速度消费积压的消息，如下图所示：</p><p><img data-src="../../../asset/2024/11/mq-expansion.png"></p><h3 id="如何解决消息队列的过期失效问题"><a href="#如何解决消息队列的过期失效问题" class="headerlink" title="如何解决消息队列的过期失效问题"></a>如何解决消息队列的过期失效问题</h3><p>假设用的是 RabbitMQ，由于 RabbitMQ 是可以设置过期时间的（TTL），如果消息在 Queue 中积压超过一定的时间，就会被 RabbitMQ 清理掉。这个时候就不会有消息被大量积压的问题，而是会有大量的消息丢失了。这种情况下，就不是说要增加 Consumer 消费积压的消息了，因为实际上消息是没有积压的，而是丢了大量的消息。</p><p>可以采取的一个解决方案就是 “批量重导”。当大量的消息积压的时候，由于设置了过期时间，RabbitMQ 会直接丢弃数据，然后等业务高峰期过了之后，例如在晚上 12 点以后，写个临时程序将丢失的那批数据查询出来，然后重新将消息写入 RabbitMQ 里，即把白天丢的消息全部补回来。假设 10000 个订单积压在 RabbitMQ 里面，没有来得及处理掉，其中 2000 个订单都丢了，那么只能手动写个临时程序把那 2000 个订单查询出来，然后手动发送消息到 RabbitMQ 中重新进行消费。</p><h3 id="消息队列的磁盘满了应该怎么处理"><a href="#消息队列的磁盘满了应该怎么处理" class="headerlink" title="消息队列的磁盘满了应该怎么处理"></a>消息队列的磁盘满了应该怎么处理</h3><p>消息积压在 MQ 里，那么如果很长时间都没有处理掉，此时导致 MQ 都快将磁盘写满了，那应该怎么办？这个时候可以写一个临时程序，启用多个消费者，并发消费消息，同时将消息持久化（比如写入数据库），即快速消费掉 MQ 中积压的消息。到凌晨的时候，将持久化的消息重新写回 MQ 中进行消费；如果希望加快已持久化消息的消费速度，可以引入上述的<a href="/posts/16a97c36.html#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%A4%A7%E9%87%8F%E7%A7%AF%E5%8E%8B%E7%9A%84%E9%97%AE%E9%A2%98">消息积压扩容解决方案</a>。</p><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/16a97c36.html" title="Kafka 开发随笔">https://www.techgrow.cn/posts/16a97c36.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/" rel="tag"><i class="fa fa-tag"></i> 开发随笔</a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> 消息队列</a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag"><i class="fa fa-tag"></i> 大数据</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/2ba32056.html" rel="prev" title="推送镜像到 DockerHub"><i class="fa fa-angle-left"></i> 推送镜像到 DockerHub</a></div><div class="post-nav-item"> <a href="/posts/27a1782a.html" rel="next" title="C++ 网络编程之一网络框架介绍">C++ 网络编程之一网络框架介绍<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.8m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">27:16</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/16a97c36.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>