<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 入门基础的内容，包括 C++ 简介、基础概念、程序设计方法、对 C 语言的增强内容等。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 入门基础之一"><meta property="og:url" content="https://www.techgrow.cn/posts/8bbc3f09.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 入门基础的内容，包括 C++ 简介、基础概念、程序设计方法、对 C 语言的增强内容等。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-10-15T13:55:33.000Z"><meta property="article:modified_time" content="2024-02-16T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.techgrow.cn/posts/8bbc3f09.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/8bbc3f09.html","path":"posts/8bbc3f09.html","title":"C++ 入门基础之一"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 入门基础之一 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%AE%80%E4%BB%8B"><span class="nav-text">C++ 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%BB%8B%E7%BB%8D"><span class="nav-text">C++ 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ANSI-%E6%A0%87%E5%87%86"><span class="nav-text">ANSI 标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86-C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-text">标准 C++ 的三大组成部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA-C-%E7%A8%8B%E5%BA%8F"><span class="nav-text">第一个 C++ 程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">程序设计方法介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="nav-text">面向过程的程序设计方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="nav-text">面向对象的程序设计方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-text">面向对象的软件工程概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%9C%86%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF"><span class="nav-text">计算圆形的面积</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-text">面向过程的写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-text">面向对象的写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-text">C++ 基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">命名空间的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">命名空间的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="nav-text">命名空间的使用语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E4%B8%80"><span class="nav-text">命名空间的编程实战一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E4%BA%8C"><span class="nav-text">命名空间的编程实战二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E5%92%8C-C-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">C 语言和 C++ 的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AF%B9-C-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A2%9E%E5%BC%BA"><span class="nav-text">C++ 对 C 语言的增强</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%94%A8%E6%80%A7%E5%A2%9E%E5%BC%BA"><span class="nav-text">实用性增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A3%80%E6%B5%8B%E5%A2%9E%E5%BC%BA"><span class="nav-text">函数检测增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%A3%80%E6%B5%8B%E5%A2%9E%E5%BC%BA"><span class="nav-text">类型转换检测增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%A3%80%E6%B5%8B%E5%A2%9E%E5%BC%BA"><span class="nav-text">全局变量检测增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A2%9E%E5%BC%BA"><span class="nav-text">struct 类型的增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97%E5%A2%9E%E5%BC%BA"><span class="nav-text">const 关键字增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#register-%E5%85%B3%E9%94%AE%E5%AD%97%E5%A2%9E%E5%BC%BA"><span class="nav-text">register 关键字增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E-bool-%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">新增 bool 类型关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA"><span class="nav-text">三目运算符功能增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%86%92%E5%8F%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%AE%9A%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">双冒号作用域限定运算符</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">756</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/8bbc3f09.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 入门基础之一 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 入门基础的内容，包括 C++ 简介、基础概念、程序设计方法、对 C 语言的增强内容等。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 入门基础之一</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-15 21:55:33" itemprop="dateCreated datePublished" datetime="2021-10-15T21:55:33+08:00">2021-10-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-02-16 21:55:33" itemprop="dateModified" datetime="2024-02-16T21:55:33+08:00">2024-02-16</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/8bbc3f09.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/8bbc3f09.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>7.2k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>7 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8bbc3f09.html">C++ 入门基础之一</a>、<a href="/posts/b03c11a0.html">C++ 入门基础之二</a>、<a href="/posts/f26087ad.html">C++ 入门基础之三</a></li><li><a href="/posts/beb2ebb3.html">C++ 入门基础之四</a>、<a href="/posts/a35089f6.html">C++ 入门基础之五</a>、<a href="/posts/a54941f5.html">C++ 入门基础之六</a></li><li><a href="/posts/e4826e2c.html">C++ 入门基础之七</a>、<a href="/posts/4c2ae4c0.html">C++ 入门基础之八</a>、<a href="/posts/f1a16291.html">C++ 入门基础之九</a></li></ul><h2 id="C-简介"><a href="#C-简介" class="headerlink" title="C++ 简介"></a>C++ 简介</h2><h3 id="C-介绍"><a href="#C-介绍" class="headerlink" title="C++ 介绍"></a>C++ 介绍</h3><ul><li>C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。</li><li>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</li><li>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</li><li>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的 C，后来在 1983 年更名为 C++。</li></ul><blockquote><p>注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p></blockquote><span id="more"></span><h3 id="ANSI-标准"><a href="#ANSI-标准" class="headerlink" title="ANSI 标准"></a>ANSI 标准</h3><p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。</p><h3 id="标准-C-的三大组成部分"><a href="#标准-C-的三大组成部分" class="headerlink" title="标准 C++ 的三大组成部分"></a>标准 C++ 的三大组成部分</h3><ul><li>核心语言，提供了所有构件块，包括数据类型、变量、常量等。</li><li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li><li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li></ul><h2 id="第一个-C-程序"><a href="#第一个-C-程序" class="headerlink" title="第一个 C++ 程序"></a>第一个 C++ 程序</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含C++的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用命名空间 std（标准的命名空间），在这个命名空间中定义了很多 C++ 的标准定义</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// cout: 标准输出</span></span><br><span class="line">    <span class="comment">// endl: 换行符号，类似 "\n"</span></span><br><span class="line">    <span class="comment">// &lt;&lt; 左移操作符: 在C++里面，属于功能的改造（增强），即 C++ 语言的操作符重载</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></tbody></table></figure><hr><p>关于 <code>endl</code> 与 <code>\n</code> 的区别：</p><ul><li>在 C++ 中，终端输出换行时，用 <code>cout &lt;&lt; ... &lt;&lt; endl</code> 与 <code>\n</code> 都可以，但二者有小小的区别，用 <code>endl</code> 时会刷新缓冲区，使得栈中的东西刷新一次；但用 <code>\n</code> 则不会刷新，它只会换行，栈内的数据没有变化。一般情况，二者的这点区别是很小的，在大型的程序中可能会用到，建议用 <code>endl</code> 来换行。</li><li><code>endl</code> 除了写入 <code>\n</code> 之外，还会调用 <code>flush</code> 函数来刷新缓冲区，将缓冲区里的数据写入文件或屏幕，若考虑效率则可以直接使用 <code>\n</code></li><li><code>cout &lt;&lt; endl;</code> 等价于 <code>cout &lt;&lt; '\n' &lt;&lt; flush;</code></li></ul><h2 id="程序设计方法介绍"><a href="#程序设计方法介绍" class="headerlink" title="程序设计方法介绍"></a>程序设计方法介绍</h2><h3 id="面向过程的程序设计方法"><a href="#面向过程的程序设计方法" class="headerlink" title="面向过程的程序设计方法"></a>面向过程的程序设计方法</h3><p><strong>设计思路</strong></p><p>面向过程的结构化程序设计方法，自顶向下、逐步求精。采用模块分解与功能抽象，自顶向下、分而治之。</p><p><strong>程序结构</strong></p><ul><li>按功能划分为若干个基本模块，形成一个树状结构。</li><li>各模块间的关系尽可能简单，功能上相对独立；每一模块内部均是由顺序、选择和循环三种基本结构组成。</li><li>其模块化实现的具体方法是使用子程序。</li></ul><p><strong>优缺点</strong></p><p>优点:</p><ul><li>有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子任务，便于开发和维护。</li></ul><p>缺点:</p><ul><li>可重用性差、数据安全性差、难以开发大型软件和图形界面的应用软件</li><li>把数据和处理数据的过程分离为相互独立的实体。</li><li>当数据结构改变时，所有相关的处理过程都要进行相应的修改。</li><li>每一种相对于老问题的新方法都要带来额外的开销。</li><li>图形用户界面的应用程序，很难用过程来描述和实现，开发和维护也都很困难。</li></ul><h3 id="面向对象的程序设计方法"><a href="#面向对象的程序设计方法" class="headerlink" title="面向对象的程序设计方法"></a>面向对象的程序设计方法</h3><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： <code>封装、抽象、继承、多态</code>，更多特性如下：</p><ul><li>将数据及对数据的操作方法封装在一起，作为一个相互依存、不可分离的整体（对象）。</li><li>对同类型对象抽象出其共性，形成类。</li><li>类通过一个简单的外部接口，与外界发生关系。</li><li>对象与对象之间通过消息进行通信。</li></ul><h3 id="面向对象的软件工程概述"><a href="#面向对象的软件工程概述" class="headerlink" title="面向对象的软件工程概述"></a>面向对象的软件工程概述</h3><blockquote><p>面向对象的软件工程是面向对象方法在软件工程领域的全面应用，分别包括:</p></blockquote><ul><li>面向对象的分析（OOA）</li><li>面向对象的设计（OOD）</li><li>面向对象的编程（OOP）</li><li>面向对象的测试（OOT）</li><li>面向对象的软件维护（OOSM）</li></ul><blockquote><p>面向过程程序设计：数据结构 + 算法，主要用于解决科学计算问题，用户需求简单而固定，其特点和劣势如下：</p></blockquote><p>特点：</p><ul><li>分析解决问题所需要的步骤</li><li>利用函数实现各个步骤</li><li>依次调用函数解决问题</li></ul><p>劣势：</p><ul><li>软件可重用性差</li><li>软件可维护性差</li><li>构建的软件无法满足用户需求</li></ul><blockquote><p>面向对象程序设计：由现实世界建立软件模型，将现实世界中的事物直接映射到程序中，可直接满足用户需求，其特点和优势如下：</p></blockquote><p>特点：</p><ul><li>直接分析用户需求中涉及的各个实体</li><li>在代码中描述现实世界中的实体</li><li>在代码中关联各个实体协同工作解决问题</li></ul><p>优势：</p><ul><li>构建的软件能够适应用户需求的不断变化</li><li>直接利用面向过程方法的优势而避开其劣势</li></ul><h2 id="计算圆形的面积"><a href="#计算圆形的面积" class="headerlink" title="计算圆形的面积"></a>计算圆形的面积</h2><h3 id="面向过程的写法"><a href="#面向过程的写法" class="headerlink" title="面向过程的写法"></a>面向过程的写法</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">double</span> r = <span class="number">0</span>; <span class="comment">// 圆形的半径</span></span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">0</span>; <span class="comment">// 圆形的面积</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"请输入圆形的半径："</span>;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">    s = <span class="number">3.14</span> * r * r;</span><br><span class="line">    cout &lt;&lt; <span class="string">"圆形的面积是："</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="面向对象的写法"><a href="#面向对象的写法" class="headerlink" title="面向对象的写法"></a>面向对象的写法</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_r; <span class="comment">// 圆形的半径</span></span><br><span class="line">    <span class="keyword">double</span> m_s; <span class="comment">// 圆形的面积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> r)</span> </span>{</span><br><span class="line">        m_r = r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getR</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m_r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getS</span><span class="params">()</span> </span>{</span><br><span class="line">        m_s = <span class="number">3.14</span> * m_r * m_r;</span><br><span class="line">        <span class="keyword">return</span> m_s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    cout &lt;&lt; <span class="string">"请输入圆形的半径："</span>;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">    Circle circle;</span><br><span class="line">    circle.<span class="built_in">setR</span>(r);</span><br><span class="line">    cout &lt;&lt; <span class="string">"圆形的面积是："</span> &lt;&lt; circle.<span class="built_in">getS</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="C-基础概念"><a href="#C-基础概念" class="headerlink" title="C++ 基础概念"></a>C++ 基础概念</h2><h3 id="命名空间的概念"><a href="#命名空间的概念" class="headerlink" title="命名空间的概念"></a>命名空间的概念</h3><p>所谓 <code>namespace</code>，是指标识符的各种可见范围。C++ 标准程序库中的所有标识符都被定义于一个名为 <code>std</code> 的 <code>namespace</code> 中。<code>&lt;iostream&gt;</code> 和 <code>&lt;iostream.h&gt;</code> 格式是不一样的，前者没有后缀，实际上在编译器 <code>include</code> 文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。后缀为 <code>.h</code> 的头文件 C++ 标准已经明确提出不再支持了，早些的实现将标准库功能定义在全局命名空间里，即声明在带 <code>.h</code> 后缀的头文件里；C++ 标准为了和 C 区别开，也为了正确使用命名空间，规定头文件不再使用后缀 <code>.h</code>。<code>&lt;iostream.h&gt;</code> 与 <code>&lt;iostream&gt;</code> 的区别：</p><ul><li>当使用 <code>&lt;iostream.h&gt;</code> 时，相当于在 C 中调用库函数，使用的是全局命名空间，也就是早期的 C++ 实现</li><li>当使用 <code>&lt;iostream&gt;</code> 的时候，该头文件没有定义在全局命名空间，必须使用 <code>using namespace std;</code> 这样才能正确使用 <code>cout</code> 等关键字</li></ul><p>由于 <code>namespace</code> 的概念，使用 C++ 标准程序库的任何标识符时，可以有以下三种写法可选择：</p><ul><li><code>直接指定标识符</code>：例如 <code>std::cout</code> 而不是 <code>cout</code>，完整语句为： <code>std::cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; std::endl;</code></li><li><code>使用 using 关键字</code>：<code>using std::cout; using std::endl; using std::cin;</code>，以上语句可以写成 <code>cout &lt;&lt; hex &lt;&lt; 3.4 &lt;&lt; endl;</code></li><li><code>使用 using namespace std</code>：这种写法是最方便的，例如： <code>using namespace std;</code>，以上语句可以写成 <code>cout &lt;&lt; hex &lt;&lt; 3.4 &lt;&lt; endl;</code></li></ul><p>命名空间 <code>std</code> 内定义的所有标识符都有效（曝光），就好像它们被声明为全局变量一样，那么以上语句就可以这样写 <code>cout &lt;&lt; hex &lt;&lt; 3.4 &lt;&lt; endl;</code>。因为标准库非常的庞大，所以程序员在选择的类名称或函数名时就很有可能和标准库中的某个名称相同。因此为了避免这种情况所造成的名称冲突，就把标准库中的一切都被放在名称空间 <code>std</code> 中。但这又会带来了一个新问题，无数原有的 C++ 代码都依赖于使用了多年的伪标准库中的功能，它们都是在全局命名空间下的。所以就有了 <code>&lt;iostream.h&gt;</code> 和 <code>&lt;iostream&gt;</code> 等等这样的头文件，一个是为了兼容以前的 C++ 代码，另一个是为了支持新的标准。命名空间 <code>std</code> 封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不加后缀 <code>.h</code>。</p><h3 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h3><p>在 C++ 中，名称（name）可以是符号常量、变量、宏、函数、结构体、枚举、类和对象等等。为了避免在大规模程序的设计中，以及在程序员使用各种各样的 C++ 库时，这些标识符的命名发生冲突，标准 C++ 引入了关键字 <code>namespace</code>（命名空间 / 名字空间 / 名称空间 / 名域），这样就可以更好地控制标识符的作用域。<code>std</code> 是 C++ 标准命名空间，C++ 标准程序库中的所有标识符都被定义在 <code>std</code> 中，比如标准库中的类 <code>iostream</code>、<code>vector</code> 等都定义在该命名空间中，使用时要加上 <code>using</code> 声明（如 <code>using namespace std</code>) 或者 <code>using</code> 指示（如 <code>std::string</code>、<code>std::vector&lt;int&gt;</code>）。</p><h3 id="命名空间的使用语法"><a href="#命名空间的使用语法" class="headerlink" title="命名空间的使用语法"></a>命名空间的使用语法</h3><p>C 语言中的命名空间：</p><ul><li>标识符之间可能发生冲突</li><li>在 C 语言中只有一个全局作用域</li><li> C 语言中所有的全局标识符共享同一个作用域</li></ul><p>C++ 中的命名空间：</p><ul><li>命名空间可以起别名</li><li>命名空间可以相互嵌套定义</li><li>全局作用域也叫默认命名空间</li><li>命名空间必须定义在全局作用域下</li><li>命名空间将全局作用域分成不同的部分</li><li>不同命名空间中的标识符可以同名而不会发生冲突</li><li>在命名空间内可以放常量、变量、函数、结构体、类等</li><li>命名空间是开放的，支持随时往原先的命名空间追加内容</li><li>在无名 / 匿名命名空间中定义变量，相当于使用了 <code>static</code> 关键字定义变量，如 <code>static int age;</code></li></ul><p>C++ 命名空间定义及使用语法：</p><ul><li>命名空间定义的语法：<code>namespace name { … }</code></li><li>命名空间使用的语法：<code>using namespace name;</code></li><li>使用特定命名空间中的变量：<code>using name::variable;</code></li><li>使用默认命名空间中的变量：<code>::variable</code></li><li>默认情况下可以直接使用默认命名空间中的所有标识符</li></ul><h3 id="命名空间的编程实战一"><a href="#命名空间的编程实战一" class="headerlink" title="命名空间的编程实战一"></a>命名空间的编程实战一</h3><div class="admonition note"><p class="admonition-title">学习目标</p><p>在 C++ 中，使用命名空间。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间 NameSpaceA</span></span><br><span class="line"><span class="keyword">namespace</span> NameSpaceA {</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间 NameSpaceB</span></span><br><span class="line"><span class="keyword">namespace</span> NameSpaceB {</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套定义命名空间 NameSpaceC</span></span><br><span class="line">    <span class="keyword">namespace</span> NameSpaceC {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> {</span></span><br><span class="line">            <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">int</span> age;</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 声明 std 命名空间后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不声明 std 命名空间后的写法</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 NameSpaceA 命名空间</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> NameSpaceA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 NameSpaceC 命名空间中的变量</span></span><br><span class="line">    <span class="keyword">using</span> NameSpaceB::NameSpaceC::Teacher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名空间可以起别名</span></span><br><span class="line">    <span class="keyword">namespace</span> NameSpaceD = NameSpaceB;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, NameSpaceB::a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, NameSpaceD::a);</span><br><span class="line"></span><br><span class="line">    Teacher teacher = {<span class="string">"Jim"</span>, <span class="number">20</span>};</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"teacher.age = %d\n"</span>, teacher.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"teacher.name = %s\n"</span>, teacher.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">a = 0</span><br><span class="line">a = 1</span><br><span class="line">a = 1</span><br><span class="line">teacher.age = 20</span><br><span class="line">teacher.name = Jim</span><br></pre></td></tr></tbody></table></figure><h3 id="命名空间的编程实战二"><a href="#命名空间的编程实战二" class="headerlink" title="命名空间的编程实战二"></a>命名空间的编程实战二</h3><div class="admonition note"><p class="admonition-title">学习目标</p><p>在 C++ 中，使用 using 声明与 using 编译指令。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> NameSpaceA {</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用 using 声明后，编译器会编译失败，因为存在二义性</span></span><br><span class="line">    <span class="comment">// 因为使用 using 声明后，以后看到的 age 默认就是用 NameSpaceA 命名空间下的 age</span></span><br><span class="line">    <span class="comment">// 但是编译器又有就近原则，也就是此时出现了二义性，导致编译器会编译失败</span></span><br><span class="line">    <span class="comment">// using NameSpaceA::age;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 编译指令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 using 编译指令，不会产生二义性</span></span><br><span class="line">    <span class="comment">// 因为 using 编译指令的优先级低于编译器的就近原则</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> NameSpaceA;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">age = 30</span><br></pre></td></tr></tbody></table></figure><h2 id="C-语言和-C-的关系"><a href="#C-语言和-C-的关系" class="headerlink" title="C 语言和 C++ 的关系"></a>C 语言和 C++ 的关系</h2><p>C 语言是在实践的过程中逐步完善起来的，没有深思熟虑的设计过程，使用时存在很多 <code>灰色地带</code>，残留了过多低级语言的特征，直接利用指针进行内存操作，其最终目标是程序执行效率的高效。当面向过程方法论暴露越来越多的缺陷的时候，业界开始考虑在工程项目中引入面向对象的设计方法，而第一个需要解决的问题就是：高效的面向对象语言，并且能够兼容已经存在的代码。C 语言和 C++ 语言的关系如下：</p><ul><li>C 语言和 C++ 并不是对立的竞争关系</li><li> C++ 是 C 语言的加强，是一种更好的 C 语言</li><li> C++ 是以 C 语言为基础的，并且完全兼容 C 语言的特性</li><li> C 语言 + 面向对象方法论 = C++ / Objective C</li></ul><h2 id="C-对-C-语言的增强"><a href="#C-对-C-语言的增强" class="headerlink" title="C++ 对 C 语言的增强"></a>C++ 对 C 语言的增强</h2><h3 id="实用性增强"><a href="#实用性增强" class="headerlink" title="实用性增强"></a>实用性增强</h3><p>C 语言中的变量都必须在作用域开始的位置定义，而 C++ 中更强调语言的 <code>实用性</code>，所有的变量都可以在需要使用时再定义。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">13</span>;  <span class="comment">// C 语言编译器中编译会报错，但是 C++ 编译器中不会报错</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="函数检测增强"><a href="#函数检测增强" class="headerlink" title="函数检测增强"></a>函数检测增强</h3><p>函数检测增强包括：参数类型检测、参数个数检测、返回值检测。C 语言默认数据类型在 C++ 编译器中是不合法的，C++ 中所有变量和函数必须声明类型。以下代码在 C 语言中可以编译通过，但在 C++ 中会编译报错。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">f(i)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">g()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    f(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g() = %d\n"</span>, g(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在 C 语言中，<code>int f()</code> 表示返回值为 <code>int</code>，接受任意参数的函数</li><li>在 C 语言中，<code>int f(void)</code> 表示返回值为 <code>int</code> 的无参函数</li><li>在 C++ 中，<code>int f()</code> 和 <code>int f(void)</code> 具有相同的意义，都表示返回值为 <code>int</code> 的无参函数</li><li> C++ 更加强调类型，即任意的程序元素都必须显示声明类型</li></ul><h3 id="类型转换检测增强"><a href="#类型转换检测增强" class="headerlink" title="类型转换检测增强"></a>类型转换检测增强</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="number">64</span>));  <span class="comment">// C 语言编译器中编译不会报错，但是 C++ 编译器中会报错</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">64</span>));  <span class="comment">// 在 C++ 编译器中，需要强制转换类型，否则编译会报错</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>值得一提的是，<code>malloc()</code> 函数的返回值是 <code>void *</code>。</p></div><h3 id="全局变量检测增强"><a href="#全局变量检测增强" class="headerlink" title="全局变量检测增强"></a>全局变量检测增强</h3><p>在 C 语言中，重复定义多个同名的全局变量是合法的，但在 C++ 中，不允许定义多个同名的全局变量。在 C 语言中，多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_var;</span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">1</span>; <span class="comment">// C 语言支持重复定义多个同名的全局变量，编译不会出错</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_var;</span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">1</span>; <span class="comment">// C++ 不允许定义多个同名的全局变量，编译会出错</span></span><br></pre></td></tr></tbody></table></figure><h3 id="struct-类型的增强"><a href="#struct-类型的增强" class="headerlink" title="struct 类型的增强"></a>struct 类型的增强</h3><p>C 语言的 <code>struct</code> 定义了一组变量的集合，C 编译器并不认为这是一种新的类型，而在 C++ 中的 <code>struct</code> 是一个新类型的定义声明。值得一提的是，在 C++ 中结构体支持定义函数，而 C 语言则不支持。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++ 中结构体支持定义函数，而 C 语言则不支持</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plusAge</span><span class="params">()</span> </span>{</span><br><span class="line">        age++;</span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    Student s1 = {<span class="number">18</span>, <span class="string">"wang"</span>};                  <span class="comment">// C 语言编译器编译报错，C++ 编译器编译通过</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> {<span class="number">20</span>, <span class="string">"chen"</span>};           <span class="comment">// C 语言编译器编译通过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="const-关键字增强"><a href="#const-关键字增强" class="headerlink" title="const 关键字增强"></a>const 关键字增强</h3><div class="admonition note"><p class="admonition-title">提示</p><p>更多关于 <code>const</code> 关键字的详细使用教程，请看 <a href="/posts/b03c11a0.html#const-%E5%85%B3%E9%94%AE%E5%AD%97">这里</a>。</p></div><ul><li>在 C++ （而不是 C 语言）中，可以使用 <code>const</code> 值来声明数组的长度。</li><li>在 C 语言中， <code>const</code> 修饰的变量是伪常量，编译器会分配内存，因此可以通过指针更改常量的值。</li><li>在 C++ 中，<code>const</code> 修饰的变量是真常量，编译器一般不会分配内存（非绝对），而是使用 <code>符号表</code> 进行处理，一般无法通过指针更改常量的值（非绝对）。</li><li>在 C 语言中，<code>const</code> 默认是外部链接，而在 C++ 中 <code>const</code> 默认是内部链接。若希望在其他 C++ 源文件（非当前源文件）中可以直接访问 <code>const</code> 常量，则需要使用 <code>extern</code> 关键字修饰常量，以此提高常量的作用域；使用 <code>extern</code> 关键字后，编译器会给 <code>const</code> 常量分配内存空间。</li></ul><blockquote><p>在 C 语言中，用 <code>const</code> 关键字在局部定义的常量，可以通过指针更改值，属于伪常量，代码如下：</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的常量，受到保护，不允许更改值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部的常量，编译器会分配内存空间，可以通过指针更改值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_B = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;m_B;</span><br><span class="line">    *p = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m_B = %d\n"</span>, m_B);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*p = 30</span><br><span class="line">m_B = 30</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 C++ 中，用 <code>const</code> 关键字在局部定义的常量，一般情况下无法通过指针更改值，属于真常量，代码如下：</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的常量，受到保护，不允许更改值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部的常量，编译器不会分配内存空间，无法通过指针更改值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_B = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 对常量取地址时，编译器会临时开辟一块内存空间，指针指向的是这块临时内存空间，即无法通过指针真正改变常量的值</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;m_B;</span><br><span class="line">    *p = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*p = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"m_B = "</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">40</span>;</span><br><span class="line">    <span class="comment">// 使用普通变量初始化局部的常量，编译器会分配内存空间，可以通过指针真正改变常量的值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_C = a;</span><br><span class="line">    <span class="keyword">int</span> *q = (<span class="keyword">int</span> *) &amp;m_C;</span><br><span class="line">    *q = <span class="number">50</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*q = "</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"m_C = "</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> {</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用 const 修饰自定义数据类型，编译器会分配内存，可以通过指针真正改变常量的值</span></span><br><span class="line">    <span class="keyword">const</span> Person person = {<span class="number">18</span>, <span class="string">"Jim"</span>};</span><br><span class="line">    Person *p = (Person *) &amp;person;</span><br><span class="line">    p-&gt;age = <span class="number">20</span>;</span><br><span class="line">    p-&gt;name = <span class="string">"Tom"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">", name = "</span> &lt;&lt; p-&gt;name &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*p = 30</span><br><span class="line">m_B = 20</span><br><span class="line">*q = 50</span><br><span class="line">m_C = 50</span><br><span class="line">age = 20, name = Tom</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">C++ 编译器会给 const 常量分配内存空间的几种情况</p><ul><li>(1) 对常量取地址时，编译器会临时开辟一块内存空间，指针指向的是这块临时内存空间，即无法通过指针真正改变常量的值。</li><li>(2) 使用普通变量初始化常量时，编译器会分配内存空间，可以通过指针真正改变常量的值。</li><li>(3) 使用 <code>const</code> 修饰自定义数据类型时（结构体、类），如 <code>const Person p;</code>，编译器会分配内存空间，可以通过指针真正改变常量的值。</li><li>(4) 使用 <code>extern</code> 修饰 <code>const</code> 常量时，编译器会分配内存空间。</li><li>(5) 当使用字面量常量初始化 <code>const</code> 引用（即常量引用），如 <code>const int &amp;a = 10;</code>，编译器会分配内存空间，可以通过指针真正改变常量引用的值。</li></ul></div><p>在日常开发中，应该尽量使用 <code>const</code> 关键字替换 <code>#define</code> 预处理指令。在旧版本 C 语言中，如果想建立一个常量，必须使用 <code>#define</code> 预处理指令定义常量（也叫宏常量），如 <code>#define MAX 1024</code>。我们定义的宏 MAX 从未被编译器看到过，因为在预处理阶段，所有的 MAX 已经被替换为了 1024，于是 MAX 没有将其加入到符号表中。当我们使用这个常量获得一个编译错误信息时，可能会带来一些困感，因为这个信息可能会提到 1024，但是没有提到 MAX。如果 MAX 被定义在一个不是你写的头文件中，你可能并不知道 1024 代表什么，也许解决这个问题要花费很长时间。为了避免这种问题的产生，可以用一个常量替换上面的宏定义，如 <code>const int MAX = 1024</code>。</p><div class="admonition note"><p class="admonition-title">const 与 #define 的区别</p><ul><li><code>const</code> 有类型，可进行编译器类型安全检查；<code>#define</code> 无类型，不可以进行类型检查。</li><li><code>const</code> 有作用域，而 <code>#define</code> 没有作用域的概念，有效范围是宏定义的位置到源文件的结尾。如果需要定义在指定作用域下才有效的常量，那么 <code>#define</code> 就不能使用。</li><li><code>const</code> 常量可以拥有命名空间，而宏常量（使用 <code>#define</code> 定义的常量）并没有命名空间的概念，它们是在预处理阶段进行简单的文本替换。宏常量在整个编译单元中是全局可见的，不受命名空间的限制。</li></ul></div><h3 id="register-关键字增强"><a href="#register-关键字增强" class="headerlink" title="register 关键字增强"></a>register 关键字增强</h3><p><code>register</code> 是运行速度最快的关键字，其作用是请求编译器尽可能地将变量存在 CPU 内部的寄存器中，而不是通过内存寻址访问，以提高程序运行效率。注意这里是尽可能，不是绝对。首先，<code>register</code> 变量必须是能被 CPU 所接受的类型，这通常意味着 <code>register</code> 变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。C 语言中，<code>register</code> 关键字表示 “请求”（不一定成功）让变量直接放进寄存器中，方便访问，但是在 C 语言中不能取 <code>register</code> 变量的地址。C++ 对 <code>register</code> 进行了增强，C++ 编译器会对频繁被调用的变量主动申请为 <code>register</code>，即使没有用 <code>register</code> 关键字声明，它也会这样做。值得一提的是，C++ 编译器当发现程序中需要对 <code>register</code> 变量取地址时，<code>register</code> 对变量的声明会变得无效。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a = %x\n"</span>, &amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于寄存器的数量有限，而且某些寄存器只能接收特定类型的数据（如指针和浮点数），因此真正起作用的 <code>register</code> 修饰符的数目和类型都依赖于实际运行程序的机器，而任何多余的 <code>register</code> 修饰符都将被编译器所忽略。在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度，这因为被占用的寄存器不能再用于其它用途；或者变量被使用的次数不够多，不足以抵消装入和存储变量所带来的额外开销。早期的 C 编译器不会自动把变量保存在寄存器中，除非程序员命令它这样做，这时 <code>register</code> 修饰符是 C 语言的一种很有价值的补充。然而，随着编译程序设计技术的进步，在决定哪些变量应该被存到寄存器中时，现代的 C 编译器能比程序员做出更好的决定。实际上，许多编译器都会忽略 <code>register</code> 修饰符，尽管它完全合法，但它仅仅是暗示而不是命令。</p><h3 id="新增-bool-类型关键字"><a href="#新增-bool-类型关键字" class="headerlink" title="新增 bool 类型关键字"></a>新增 bool 类型关键字</h3><p>C++ 在 C 语言的基本类型系统之上增加了 <code>bool</code> 类型关键字，<code>bool</code> 可取的值只有 <code>true</code> 和 <code>false</code>。理论上 <code>bool</code> 变量只占用一个字节，如果多个 <code>bool</code> 变量定义在一起，可能会各占一个 <code>bit（位）</code>，这取决于编译器的实现。<code>true</code> 代表真值，编译器内部用 <code>1</code> 来表示，<code>false</code> 代表非真值，编译器内部用 <code>0</code> 来表示。C++ 编译器会在赋值时将非 <code>0</code> 值转换为 <code>true</code>，<code>0</code> 值转换为 <code>false</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"b = %d, sizeof(b) = %d\n"</span>, b, <span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = 1, sizeof(b) = 1</span><br></pre></td></tr></tbody></table></figure><h3 id="三目运算符功能增强"><a href="#三目运算符功能增强" class="headerlink" title="三目运算符功能增强"></a>三目运算符功能增强</h3><ul><li>使用三目运算符时，C 语言返回变量的值，C++ 是返回变量本身</li><li> C 语言中的三目运算符返回的是变量值，不能作为左值使用</li><li> C++ 中的三目运算符可直接返回变量本身，因此可以出现在程序的任何地方</li><li>特别注意：C++ 中三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用，例如 <code>(a &lt; b ? 1 : b )= 30;</code></li><li>C 语言如何支持类似 C++ 的三目运算特性呢？当左值的条件：要有内存空间，而 C++ 编译器只是帮助程序员取了一个地址而已，C 语言版的写法为：<code>*(a &lt; b ? &amp;a : &amp;b) = 30</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个最小数，并且给最小数赋值成30</span></span><br><span class="line">    <span class="comment">// C 语言中三目运算符是一个表达式 ，表达式不可以做左值，而 C++ 则可以</span></span><br><span class="line">    (a &lt; b ? a : b) = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 30, b = 20</span><br></pre></td></tr></tbody></table></figure><h3 id="双冒号作用域限定运算符"><a href="#双冒号作用域限定运算符" class="headerlink" title="双冒号作用域限定运算符"></a>双冒号作用域限定运算符</h3><p>双冒号作用域限定运算符，用于对当前作用域之外的同名变量进行访问，例如在下面的例子中，可以利用 <code>::</code> 实现在局部变量 a 的作用域内对全局变量 a 的访问。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">    a = <span class="number">3.14</span>;</span><br><span class="line">    ::a = <span class="number">6</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"local variable a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"global variable a = "</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a = 3.14</span><br><span class="line">global variable a = 6</span><br></pre></td></tr></tbody></table></figure><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/8bbc3f09.html" title="C++ 入门基础之一">https://www.techgrow.cn/posts/8bbc3f09.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/3baa0a8d.html" rel="prev" title="VsCode 入门教程之二打造 Markdown 编辑器"><i class="fa fa-angle-left"></i> VsCode 入门教程之二打造 Markdown 编辑器</a></div><div class="post-nav-item"> <a href="/posts/b03c11a0.html" rel="next" title="C++ 入门基础之二">C++ 入门基础之二<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.2m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">33:15</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/8bbc3f09.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>