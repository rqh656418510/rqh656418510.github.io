<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 的进阶基础教程，包括函数模板、类模板等。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 进阶基础之二"><meta property="og:url" content="https://www.techgrow.cn/posts/779107de.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 的进阶基础教程，包括函数模板、类模板等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/12/cplus-plus-template-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/12/cplus-plus-template-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/12/cplus-plus-template-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/12/cplus-plus-template-4.png"><meta property="article:published_time" content="2021-11-29T13:55:33.000Z"><meta property="article:modified_time" content="2024-06-07T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2021/12/cplus-plus-template-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/779107de.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/779107de.html","path":"posts/779107de.html","title":"C++ 进阶基础之二"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 进阶基础之二 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/app/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">函数模板和类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-text">函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">函数模板的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-text">函数模板的调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-text">函数模板的简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="nav-text">函数模板使用案例一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="nav-text">函数模板使用案例二</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="nav-text">函数模板与普通函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-text">函数模板与函数重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-text">函数模板的局限性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">函数模板的底层原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">类模板的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-text">类模板的简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">类模板作为函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">类模板与继承的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">普通类继承类模板</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">类模板继承类模板</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">类模版与友元函数的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%86%85%E5%AE%9E%E7%8E%B0"><span class="nav-text">友元函数的类内实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="nav-text">友元函数的类外实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E5%86%99%E6%B3%95"><span class="nav-text">类模板函数的三种写法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%86%99%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%EF%BC%88%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%89"><span class="nav-text">所有的类模板函数写在类的内部（第一种）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%86%99%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%89"><span class="nav-text">所有的类模板函数写在类的外部（第二种）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%86%99%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%EF%BC%88%E7%AC%AC%E4%B8%89%E7%A7%8D%EF%BC%89"><span class="nav-text">所有的类模板函数写在类的外部（第三种）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84-static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">类模板中的 static 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">类模板与函数模板的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="nav-text">数组模板类的实战案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="nav-text">函数模板与类模板的使用总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">613</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">52</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/779107de.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 进阶基础之二 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 的进阶基础教程，包括函数模板、类模板等。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 进阶基础之二</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-29 21:55:33" itemprop="dateCreated datePublished" datetime="2021-11-29T21:55:33+08:00">2021-11-29</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-06-07 21:55:33" itemprop="dateModified" datetime="2024-06-07T21:55:33+08:00">2024-06-07</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/779107de.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/779107de.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>4 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/dbff2af9.html">C++ 进阶基础之一</a>、<a href="/posts/779107de.html">C++ 进阶基础之二</a>、<a href="/posts/35cd91d3.html">C++ 进阶基础之三</a></li><li><a href="/posts/791ffdcd.html">C++ 进阶基础之四</a>、<a href="/posts/64fd9f88.html">C++ 进阶基础之五</a>、<a href="/posts/62e4578b.html">C++ 进阶基础之六</a></li><li><a href="/posts/9e89901e.html">C++ 进阶基础之七</a>、<a href="/posts/8b87f2be.html">C++ 进阶基础之八</a>、<a href="/posts/360c74ef.html">C++ 进阶基础之九</a></li><li><a href="/posts/98e5b160.html">C++ 进阶基础之十</a>、<a href="/posts/f5674448.html">C++ 进阶基础之十一</a></li></ul><h2 id="函数模板和类模板"><a href="#函数模板和类模板" class="headerlink" title="函数模板和类模板"></a>函数模板和类模板</h2><p>C++ 提供了函数模板（function template）。<strong>所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表，这个通用函数就称为函数模板</strong>。凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时，系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。</p><p><img data-src="../../../asset/2021/12/cplus-plus-template-1.png" alt="cplus-plus-template-1"></p><span id="more"></span><p>C++ 提供两种模板机制：函数模板、类模板。</p><ul><li>模板又称之为 <code>泛型编程</code>。</li><li>模板将函数或类要处理的数据类型参数化，表现为参数的多态性，称为类属。</li><li>模板用于表达逻辑结构相同，但具有数据元素类型不同的数据对象的通用行为。</li><li>类属 —— 类型参数化，又称参数模板，使得程序（算法）可以从逻辑功能上抽象，将被处理的对象（数据）类型作为参数传递。</li></ul><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="函数模板的定义"><a href="#函数模板的定义" class="headerlink" title="函数模板的定义"></a>函数模板的定义</h4><p><img data-src="../../../asset/2021/12/cplus-plus-template-2.png" alt="cplus-plus-template-2"></p><ul><li>模板声明的语法为：<code>template &lt; 类型形式参数表 &gt;</code>，例如 <code>template &lt;typename T&gt;</code></li><li>类型形式参数表的语法为：<code>typename T1 , typename T2 , …… , typename Tn</code> 或者 <code>class T1 , class T2 , …… , class Tn</code></li><li><code>typename</code> 关键字和 <code>class</code> 关键字都可以用来定义模板参数类型，也就是说 <code>template &lt;typename T&gt;</code> 与 <code>template &lt;class T&gt;</code> 的功能和效果是完全相同的，C++ 标准允许这两种方式是为了向后兼容，并提供灵活性。</li></ul><h4 id="函数模板的调用"><a href="#函数模板的调用" class="headerlink" title="函数模板的调用"></a>函数模板的调用</h4><ul><li><code>myswap(a, b);</code>：自动数据类型推导</li><li><code>myswap&lt;float&gt;(a, b);</code>：显式指定类型调用（推荐）</li></ul><h4 id="函数模板的简单使用"><a href="#函数模板的简单使用" class="headerlink" title="函数模板的简单使用"></a>函数模板的简单使用</h4><h5 id="函数模板使用案例一"><a href="#函数模板使用案例一" class="headerlink" title="函数模板使用案例一"></a>函数模板使用案例一</h5><p><img data-src="../../../asset/2021/12/cplus-plus-template-3.png" alt="cplus-plus-template-3"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>{</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动数据类型推导</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d, y = %d\n"</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动数据类型推导</span></span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">0.5</span>, m = <span class="number">0.8</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(n, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %f, m = %f\n"</span>, n, m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示指定类型调用（推荐）</span></span><br><span class="line">    <span class="keyword">char</span> i = <span class="string">'h'</span>, j = <span class="string">'e'</span>;</span><br><span class="line">    myswap&lt;<span class="keyword">char</span>&gt;(i, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %c, m = %c\n"</span>, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 2, y = 1</span><br><span class="line">n = 0.800000, m = 0.500000</span><br><span class="line">n = e, m = h</span><br></pre></td></tr></tbody></table></figure><h5 id="函数模板使用案例二"><a href="#函数模板使用案例二" class="headerlink" title="函数模板使用案例二"></a>函数模板使用案例二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数模板，实现数组排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arraySort</span><span class="params">(T1* array, <span class="keyword">int</span> size, <span class="keyword">bool</span> asc = <span class="literal">true</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">NULL</span> || size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T1 tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) {</span><br><span class="line">            <span class="comment">// 升序排序（从小到大）</span></span><br><span class="line">            <span class="keyword">if</span> (asc) {</span><br><span class="line">                <span class="keyword">if</span> (array[i] &gt; array[j]) {</span><br><span class="line">                    tmp = array[i];</span><br><span class="line">                    array[i] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 降序排序（从大到小）</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; array[j]) {</span><br><span class="line">                    tmp = array[i];</span><br><span class="line">                    array[i] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数模板，打印数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T2* array, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        cout &lt;&lt; array[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> array[] = { <span class="number">32</span>, <span class="number">16</span>, <span class="number">29</span>, <span class="number">9</span>, <span class="number">43</span>, <span class="number">53</span>, <span class="number">23</span> };</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(array) / <span class="built_in"><span class="keyword">sizeof</span></span>(*array);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之前: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">int</span>&gt;(array, size);</span><br><span class="line"></span><br><span class="line">    arraySort&lt;<span class="keyword">int</span>&gt;(array, size, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之后: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">int</span>&gt;(array, size);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> array2[] = { <span class="string">'c'</span>, <span class="string">'z'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'q'</span>, <span class="string">'m'</span> };</span><br><span class="line">    <span class="keyword">int</span> size2 = <span class="built_in"><span class="keyword">sizeof</span></span>(array2) / <span class="built_in"><span class="keyword">sizeof</span></span>(*array2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之前: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">char</span>&gt;(array2, size2);</span><br><span class="line"></span><br><span class="line">    arraySort&lt;<span class="keyword">char</span>&gt;(array2, size2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之后: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">char</span>&gt;(array2, size2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">排序之前: 32 16 29 9 43 53 23</span><br><span class="line">排序之后: 53 43 32 29 23 16 9</span><br><span class="line">------------------------------</span><br><span class="line">排序之前: c z h i q m</span><br><span class="line">排序之后: c h i m q z</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板与普通函数"><a href="#函数模板与普通函数" class="headerlink" title="函数模板与普通函数"></a>函数模板与普通函数</h4><p>函数模板和普通函数的区别：</p><ul><li>(a) 普通函数调用时，可以发生自动类型转换（隐式类型转换）。</li><li>(b) 函数模板调用时，如果利用自动类型推导，不会发生自动类型转换（隐式类型转换）。</li></ul><p>函数模板和普通函数的调用规则：</p><ul><li>(a) 当函数模板和普通函数都符合调用时，C++ 编译器优先选择调用普通函数</li><li> (b) 如果函数模板可以产生一个更好的匹配，那么 C++ 编译器会选择调用函数模板</li><li> (c) 如何希望强制调用函数模板，可以使用空模板参数列表（空参数列表）的语法来限制 C++ 编译器只使用函数模板匹配，比如 <code>mySwap&lt;&gt;(a, b)</code>，完整的示例代码如下：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>{</span><br><span class="line">    T tmp;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">    cout &lt;&lt; <span class="string">"模板函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"普通函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">65</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'z'</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(a, c);    <span class="comment">// 调用普通函数</span></span><br><span class="line">    <span class="built_in">myswap</span>(c, a);    <span class="comment">// 调用普通函数，会进行隐式类型转换</span></span><br><span class="line">    <span class="built_in">myswap</span>(a, a);    <span class="comment">// 调用函数模板（本质是类型参数化），将严格地按照类型进行匹配，不会进行隐式类型转换</span></span><br><span class="line">    myswap&lt;&gt;(a, a);  <span class="comment">// 强制调用函数模板，可以使用空模板参数列表的语法来限制 C++ 编译器只使用函数模板匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 65, b = z</span><br><span class="line">普通函数被调用</span><br><span class="line">a = 122, b = A</span><br><span class="line">普通函数被调用</span><br><span class="line">模板函数被调用</span><br><span class="line">模板函数被调用</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板与函数重载"><a href="#函数模板与函数重载" class="headerlink" title="函数模板与函数重载"></a>函数模板与函数重载</h4><ul><li>(a) 函数模板可以像普通函数一样被重载</li><li> (b) 如何出现重载，C++ 编译器优先选择调用普通函数</li><li> (c) 如果函数模板可以产生一个更好的匹配，那么 C++ 编译器会选择调用函数模板</li><li> (d) 如何希望强制调用函数模板，可以使用空模板参数列表（空参数列表）的语法来限制 C++ 编译器只使用函数模板匹配，比如 <code>mySwap&lt;&gt;(a, b)</code>，完整的示例代码如下：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"int Max(int a, int b)"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"T Max(T a, T b)"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板重载</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b, T c)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"T Max(T a, T b, T c)"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">Max</span>(a, b), c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Max</span>(a, b); <span class="comment">// 当函数模板和普通函数都符合调用时，优先选择调用普通函数</span></span><br><span class="line">    <span class="built_in">Max</span>(<span class="string">'a'</span>, <span class="number">100</span>);  <span class="comment">// 调用普通函数，可以进行隐式类型转换</span></span><br><span class="line">    Max&lt;&gt;(a, b); <span class="comment">// 通过空模板参数列表的语法，可以限制编译器只使用函数模板匹配</span></span><br><span class="line">    <span class="built_in">Max</span>(<span class="number">3.0</span>, <span class="number">4.0</span>); <span class="comment">// 如果函数模板产生更好的匹配，编译器会使用函数模板</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Max</span>(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>); <span class="comment">// 函数模板的重载</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Max(int a, int b)</span><br><span class="line">int Max(int a, int b)</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">--------------------</span><br><span class="line">T Max(T a, T b, T c)</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">T Max(T a, T b)</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板的局限性"><a href="#函数模板的局限性" class="headerlink" title="函数模板的局限性"></a>函数模板的局限性</h4><p>假设有如下的函数模板：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, Tb)</span> </span>{</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果代码实现时定义了赋值操作 <code>a = b</code>，但是 T 为数组，那么这种假设就不成立了。同样，如果代码里面的语句为判断语句 <code>if(a &gt; b)</code>，但 T 如果是结构体，该假设也不成立。另外，如果传入的是数组，由于数组名是地址，因此它比较的是地址，而这也不是预期所希望的操作。总之，编写的函数模板很可能无法处理某些类型。另一方面，有时候通用化是有意义的，但 C++ 语法不允许这么做。为了解决这种局限性问题，可以提供模板的重载，为这些特定的类型提供具体化的模板。</p><div class="admonition note"><p class="admonition-title">具体化模板的使用语法</p><ul><li>语法：<code>template&lt;&gt; 返回值 函数名&lt;具体类型&gt;(函数参数)</code></li></ul></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a == b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">bool</span> resutlt = <span class="built_in">myCompare</span>(a, b); <span class="comment">// 传入基础数据类型</span></span><br><span class="line">    cout &lt;&lt; resutlt &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过具体化自定义数据类型，解决函数模板的局限性问题</span></span><br><span class="line"><span class="comment">// 如果具体化能够优先匹配，那么就选择具体化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> myCompare&lt;Person&gt;(Person &amp;a, Person &amp;b) {</span><br><span class="line">    <span class="keyword">return</span> a.m_age == b.m_age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"Jim"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> resutlt = <span class="built_in">myCompare</span>(p1, p2);  <span class="comment">// 传入自定义数据类型</span></span><br><span class="line">    cout &lt;&lt; resutlt &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板的底层原理"><a href="#函数模板的底层原理" class="headerlink" title="函数模板的底层原理"></a>函数模板的底层原理</h4><ul><li>编译器并不是根据函数模板，产生能够处理任意参数的函数。</li><li>编译器本质上是根据具体的调用类型，从函数模板产生不同的函数（通常称为模板函数）。</li><li><strong>编译器会对函数模板进行两次编译，在声明的地方对函数模板代码本身进行第一次编译，在调用的地方对参数替换后的函数模板代码进行第二次编译。</strong></li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板与函数模板的定义和使用类似，在实际项目开发中，经常有两个或多个类，其功能是相同的，仅仅是数据类型不同，为了不重复定义功能相同的类，可以使用类模板来解决这类问题。</p><h4 id="类模板的定义"><a href="#类模板的定义" class="headerlink" title="类模板的定义"></a>类模板的定义</h4><p><img data-src="../../../asset/2021/12/cplus-plus-template-4.png"></p><ul><li>类模板用于实现类所需数据的类型参数化。</li><li>类模板在表示如数组、链表、图等数据结构显得特别重要，这些数据结构的表示和算法不受所包含的元素类型的影响。</li><li>在下述的所有代码中，<code>template &lt;typename T&gt;</code> 等价于 <code>template &lt;class T&gt;</code>，二者的功能和效果是完全相同。</li></ul><h4 id="类模板的简单使用"><a href="#类模板的简单使用" class="headerlink" title="类模板的简单使用"></a>类模板的简单使用</h4><p>值得一提的是，在类模板中如果使用了构造函数，则必须遵守 C++ 类的构造函数的调用规则。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(T t) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">T&amp; <span class="title">getT</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;t;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T t;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板做函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">(A&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>{</span><br><span class="line">	cout &lt;&lt; a.<span class="built_in">getT</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;	<span class="comment">// 模板类是抽象的，且不支持自动类型推导，需要声明具体的类型（模板参数列表）这里的 &lt;int&gt; 不能省略</span></span><br><span class="line">	cout &lt;&lt; a.<span class="built_in">getT</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printA</span>(a2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">50</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板作为函数参数"><a href="#类模板作为函数参数" class="headerlink" title="类模板作为函数参数"></a>类模板作为函数参数</h4><p>类模板作为函数参数有三种使用方式，包括：</p><ul><li>第一种传参方式：指定传入类型</li><li>第二种传参方式：参数模板化（函数模板 + 类模板）</li><li>第三种传参方式：整体模板化（函数模板）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name = "</span> + <span class="keyword">this</span>-&gt;m_Name + <span class="string">", age = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种传参方式：指定传入类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span>{</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">"Jim"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">doWork1</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种传参方式：参数模板化（函数模板 + 类模板）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>{</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// 在运行时查看对象的类型信息</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">doWork2</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种传参方式：整体模板化（函数模板）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork3</span><span class="params">(T &amp;p)</span> </span>{</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">"Peter"</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line">    <span class="built_in">doWork3</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = Jim, age = 18</span><br><span class="line">name = Tom, age = 20</span><br><span class="line">name = Peter, age = 22</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板与继承的使用"><a href="#类模板与继承的使用" class="headerlink" title="类模板与继承的使用"></a>类模板与继承的使用</h4><h5 id="普通类继承类模板"><a href="#普通类继承类模板" class="headerlink" title="普通类继承类模板"></a>普通类继承类模板</h5><p>在 C++ 中，类模板可以被普通类继承，普通类继承类模板时，需要声明父类具体的数据类型。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(T a) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">T&amp; <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T a;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类继承类模板，需要声明具体的类型（模板参数列表），这里的 &lt;int&gt; 不能省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&lt;<span class="keyword">int</span>&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : A&lt;<span class="keyword">int</span>&gt;(a) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; a.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	b.<span class="built_in">printB</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">a = 1, b = 3</span><br></pre></td></tr></tbody></table></figure><h5 id="类模板继承类模板"><a href="#类模板继承类模板" class="headerlink" title="类模板继承类模板"></a>类模板继承类模板</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(T a) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">T&amp; <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T a;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板继承类模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&lt;T&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(T a, T b) : <span class="built_in">A</span>(a) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">T&amp; <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; a.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">B&lt;<span class="keyword">double</span>&gt; <span class="title">b</span><span class="params">(<span class="number">3.2</span>, <span class="number">4.5</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; b.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b.<span class="built_in">getB</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3.2</span><br><span class="line">4.5</span><br></pre></td></tr></tbody></table></figure><h4 id="类模版与友元函数的使用"><a href="#类模版与友元函数的使用" class="headerlink" title="类模版与友元函数的使用"></a>类模版与友元函数的使用</h4><div class="admonition warning"><p class="admonition-title">特别注意</p><p>除了重载运算符 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 必须使用友元函数之外，其他运算符的重载尽量都使用类成员函数来实现。千万不要滥用友元函数，尤其类模板与友元函数一起使用的时候，这是因为需要使用怪异的语法来解决 C++ 编译器出现的错误，且不同的 C++ 编译器表现行为不一定一致。</p></div><h5 id="友元函数的类内实现"><a href="#友元函数的类内实现" class="headerlink" title="友元函数的类内实现"></a>友元函数的类内实现</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类内实现友元函数（相当于全局函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> + p.m_Name + <span class="string">", age: "</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: Tom, age: 20</span><br></pre></td></tr></tbody></table></figure><h5 id="友元函数的类外实现"><a href="#友元函数的类外实现" class="headerlink" title="友元函数的类外实现"></a>友元函数的类外实现</h5><p>在使用类模板和友元函数时，如果友元函数是在类外实现，则需要使用怪异的语法来解决 C++ 编译器出现的错误，且不同的 C++ 编译器表现行为不一定一致。解决 C++ 编译问题的语法详见 <a href="../../../asset/2021/12/cplus-plus-template-5.png">图解分析</a>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** START 解决类模板与友元函数的编译问题 *********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让编译器提前看到 Person 类的声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让编译器提前看到 printPerson 函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt; <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** END 解决类模板与友元函数的编译问题 *********/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义友元函数，并使用空参数列表来让编译器强制调用函数模板</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外实现友元函数（相当于全局函数）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"name: "</span> + p.m_Name + <span class="string">", age: "</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: Tom, age: 20</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板函数的三种写法"><a href="#类模板函数的三种写法" class="headerlink" title="类模板函数的三种写法"></a>类模板函数的三种写法</h4><p>值得一提的是，企业项目开发中，建议使用第一种或者第三种方式，STL 库一般都采用第一种方式。</p><h5 id="所有的类模板函数写在类的内部（第一种）"><a href="#所有的类模板函数写在类的内部（第一种）" class="headerlink" title="所有的类模板函数写在类的内部（第一种）"></a>所有的类模板函数写在类的内部（第一种）</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	<span class="built_in">Complex</span>(T a, T b) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line">	Complex <span class="keyword">operator</span>+(Complex&amp; c2) {</span><br><span class="line">		<span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c2.a, <span class="keyword">this</span>-&gt;b + c2.b)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&amp; c1) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; c1.b;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 友元函数</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> Complex <span class="title">sub</span><span class="params">(Complex&amp; c1, Complex&amp; c2)</span> </span>{</span><br><span class="line">		<span class="function">Complex <span class="title">tmp</span><span class="params">(c1.a - c2.a, c1.b - c2.b)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T a;</span><br><span class="line">	T b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">	c1.<span class="built_in">print</span>();</span><br><span class="line">	c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">	cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Complex&lt;<span class="keyword">int</span>&gt; c4 = <span class="built_in">sub</span>(c1, c2);</span><br><span class="line">	cout &lt;&lt; c4 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 1, b = 4</span><br><span class="line">a = 3, b = 6</span><br><span class="line">a = 4, b = 10</span><br><span class="line">a = -2, b = -2</span><br></pre></td></tr></tbody></table></figure><h5 id="所有的类模板函数写在类的外部（第二种）"><a href="#所有的类模板函数写在类的外部（第二种）" class="headerlink" title="所有的类模板函数写在类的外部（第二种）"></a>所有的类模板函数写在类的外部（第二种）</h5><p>所有的类模板函数写在类的外部（写在同一个 <code>.cpp</code> 源文件中），当使用友元函数重载了 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 运算符时，需要注意声明友元函数的写法 <code>friend ostream&amp; operator&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c1);</code>。<strong>特别注意，除了重载运算符 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 必须使用友元函数之外，其他运算符的重载尽量都使用类成员函数来实现。千万不要滥用友元函数，尤其类模板与友元函数一起使用的时候，这是因为需要使用怪异的语法来解决 C++ 编译器出现的错误，且不同的 C++ 编译器表现行为不一定一致。</strong>假设在类模板中滥用了友元函数，解决 C++ 编译问题的语法详见 <a href="../../../asset/2021/12/cplus-plus-template-5.png">图解分析</a>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** START 解决类模板与友元函数滥用（非重载左移与右移运算符）时出现的编译问题 *********/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Complex</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">Complex&lt;T&gt; <span class="title">sub</span><span class="params">(Complex&lt;T&gt;&amp; c1, Complex&lt;T&gt;&amp; c2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** END 解决类模板与友元函数滥用（非重载左移与右移运算符）时出现的编译问题 *********/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	<span class="built_in">Complex</span>(T a, T b);</span><br><span class="line">	<span class="comment">// 类成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line">	Complex <span class="keyword">operator</span>+(Complex&amp; c2);</span><br><span class="line">	<span class="comment">// 友元函数（滥用友元函数）</span></span><br><span class="line">	<span class="keyword">friend</span> Complex sub&lt;T&gt;(Complex&amp; c1, Complex&amp; c2);</span><br><span class="line">	<span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T a;</span><br><span class="line">	T b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt;::<span class="built_in">Complex</span>(T a, T b) {</span><br><span class="line">	<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">	<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Complex&lt;T&gt;::<span class="built_in">print</span>() {</span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt; Complex&lt;T&gt;::<span class="keyword">operator</span>+(Complex&lt;T&gt;&amp; c2) {</span><br><span class="line">	<span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c2.a, <span class="keyword">this</span>-&gt;b + c2.b)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&lt;T&gt;&amp; c1) {</span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; c1.b;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数（滥用友元函数）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Complex&lt;T&gt; <span class="title">sub</span><span class="params">(Complex&lt;T&gt;&amp; c1, Complex&lt;T&gt;&amp; c2)</span> </span>{</span><br><span class="line">	<span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(c1.a - c2.a, c1.b - c2.b)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">3</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">9</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">	c1.<span class="built_in">print</span>();</span><br><span class="line">	c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">	cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Complex&lt;<span class="keyword">int</span>&gt; c4 = <span class="built_in">sub</span>(c1, c2);</span><br><span class="line">	cout &lt;&lt; c4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 3, b = 8</span><br><span class="line">a = 9, b = 5</span><br><span class="line">a = 12, b = 13</span><br><span class="line">a = -6, b = 3</span><br></pre></td></tr></tbody></table></figure><h5 id="所有的类模板函数写在类的外部（第三种）"><a href="#所有的类模板函数写在类的外部（第三种）" class="headerlink" title="所有的类模板函数写在类的外部（第三种）"></a>所有的类模板函数写在类的外部（第三种）</h5><p>所有的类模板函数写在类的外部（分开写在 <code>.h</code> 和 <code>.hpp</code> 源文件中），这里除了重载运算符 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 必须使用友元函数之外，千万不要滥用友元函数；因为 C++ 编译器会出现编译错误，且没有很好的解决方法。</p><ul><li>complex.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(T a, T b);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	Complex <span class="keyword">operator</span>+(Complex&amp; c2);</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T a;</span><br><span class="line">	T b;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>complex.hpp，这里的 <code>.hpp</code> 文件与 <code>.cpp</code> 文件本质上没有区别，为了方便区分意图，只是文件的后缀不一样而已</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complex.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt;::<span class="built_in">Complex</span>(T a, T b) {</span><br><span class="line">	<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">	<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Complex&lt;T&gt;::<span class="built_in">print</span>() {</span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt; Complex&lt;T&gt;::<span class="keyword">operator</span>+(Complex&lt;T&gt;&amp; c2) {</span><br><span class="line">	<span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c2.a, <span class="keyword">this</span>-&gt;b + c2.b)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&lt;T&gt;&amp; c1) {</span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; c1.b;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp，特别注意，这里引入的是 <code>.hpp</code> 或者 <code>.cpp</code> 文件，而不是 <code>.h</code> 头文件，否则 C++ 编译器会编译失败</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complex.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">6</span>, <span class="number">13</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">23</span>, <span class="number">34</span>)</span></span>;</span><br><span class="line">	c1.<span class="built_in">print</span>();</span><br><span class="line">	c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">	cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 6, b = 13</span><br><span class="line">a = 23, b = 34</span><br><span class="line">a = 29, b = 47</span><br></pre></td></tr></tbody></table></figure><p>上面提到的，引入的是 <code>.hpp</code> 或者 <code>.cpp</code> 文件，而不是 <code>.h</code> 头文件，否则 C++ 编译器会编译失败。这是因为由于类模版的成员函数是在运行阶段才去动态创建的，也就是说使用 <code>#include</code> 指令包含 <code>.h</code> 头文件时，编译器不会创建成员函数的具体实现，最终导致编译器出现无法解析外部命令的错误。常用的解决方案有以下两种，约定俗成使用第一种方案（推荐）。</p><ul><li>解决方案一：类模板函数的声明和实现分开写，但都写在同一个源文件中，并将源文件的后缀名改为 <code>.hpp</code>，然后在需要使用的地方通过 <code>#include</code> 指令包含 <code>.hpp</code> 源文件，推荐使用此方式。</li><li>解决方案二：类模板函数的声明和实现分开写，而且是分开写在不同的源文件中，然后在需要使用的地方通过 <code>#include</code> 指令包含 <code>.cpp</code> 源文件，而不是包含 <code>.h</code> 头文件，不推荐使用此方式。</li></ul><h4 id="类模板中的-static-关键字"><a href="#类模板中的-static-关键字" class="headerlink" title="类模板中的 static 关键字"></a>类模板中的 static 关键字</h4><ul><li>从类模板实例化的每种数据类型模板类都有自己的类模板数据成员，该数据类型的模板类的所有对象共享同一个 <code>static</code> 数据成员</li><li>和非模板类的 <code>static</code> 数据成员一样，模板类的 <code>static</code> 数据成员也应该在源文件范围内定义和初始化</li><li>每种数据类型的模板类都有自己单独一份的类模板的 <code>static</code> 数据成员副本，详见 <a href="../../../asset/2021/12/cplus-plus-template-6.png">图解分析</a></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Circle</span>(T radius = <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_radius = radius;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_total++;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(T radius)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_radius = radius;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">getRadius</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_radius;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getGirth</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * pi * <span class="keyword">this</span>-&gt;m_radius;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> pi * <span class="keyword">this</span>-&gt;m_radius * <span class="keyword">this</span>-&gt;m_radius;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类模板的静态成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> m_total;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T m_radius;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类模板的静态数据成员</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_total;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类模板的静态数据成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Circle&lt;T&gt;::m_total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">// 每种数据类型的模板类都有自己单独一份的类模板的 static 数据成员副本</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Circle&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">4</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"m_total = "</span> &lt;&lt; Circle&lt;<span class="keyword">int</span>&gt;::<span class="built_in">getTotal</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c1.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c1.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c1.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c2.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c2.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c2.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Circle&lt;<span class="keyword">float</span>&gt; <span class="title">c3</span><span class="params">(<span class="number">3.2</span>)</span>, <span class="title">c4</span><span class="params">(<span class="number">4.3</span>)</span>, <span class="title">c5</span><span class="params">(<span class="number">6.2</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"m_total = "</span> &lt;&lt; Circle&lt;<span class="keyword">float</span>&gt;::<span class="built_in">getTotal</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c3.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c3.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c3.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c4.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c4.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c4.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c5.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c5.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c5.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m_total = 2</span><br><span class="line">radius = 4, girth = 25.12, area = 50.24</span><br><span class="line">radius = 6, girth = 37.68, area = 113.04</span><br><span class="line">m_total = 3</span><br><span class="line">radius = 3.2, girth = 20.096, area = 32.1536</span><br><span class="line">radius = 4.3, girth = 27.004, area = 58.0586</span><br><span class="line">radius = 6.2, girth = 38.936, area = 120.702</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板与函数模板的区别"><a href="#类模板与函数模板的区别" class="headerlink" title="类模板与函数模板的区别"></a>类模板与函数模板的区别</h4><ul><li>类模板支持默认类型，而函数模板不支持默认类型。</li><li>类模板不支持自动类型推导，而函数模板支持自动类型推导。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板声明（支持默认类型）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span> =</span> <span class="keyword">int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name = "</span> + <span class="keyword">this</span>-&gt;m_Name + <span class="string">", age = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">"Jim"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类模板支持默认类型</span></span><br><span class="line">    <span class="function">Person&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = Jim, age = 20</span><br></pre></td></tr></tbody></table></figure><h3 id="数组模板类的实战案例"><a href="#数组模板类的实战案例" class="headerlink" title="数组模板类的实战案例"></a>数组模板类的实战案例</h3><p>下面将编写数组模板类，模拟 STL 容器的实现，同时贯穿上面所讲的 C++ 模板知识点。</p><ul><li>MyVector.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyVector</span>(<span class="keyword">int</span> size = <span class="number">0</span>);</span><br><span class="line">	~<span class="built_in">MyVector</span>();</span><br><span class="line">	<span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">	MyVector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&amp; obj);</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt;(ostream&amp; out, MyVector&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* m_space; <span class="comment">// 指向数组的指针</span></span><br><span class="line">	<span class="keyword">int</span> m_size;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>MyVector.hpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyVector.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;::<span class="built_in">MyVector</span>(<span class="keyword">int</span> size) {</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_size = size;</span><br><span class="line">	<span class="comment">// 分配内存空间</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> T[size];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;::~<span class="built_in">MyVector</span>() {</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line">		<span class="comment">// 释放内存空间</span></span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;::<span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&lt;T&gt;&amp; obj) {</span><br><span class="line">	<span class="comment">// 深拷贝</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> T[obj.m_size];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> MyVector&lt;T&gt;::<span class="built_in">getSize</span>() {</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数，重载运算符 "[]"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; MyVector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数，重载运算符 "="</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;&amp; MyVector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&lt;T&gt;&amp; obj) {</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line">		<span class="comment">// 释放原本的内存空间</span></span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 深拷贝</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> T[obj.m_size];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyVector&lt;T&gt;&amp; obj) {</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">		cout &lt;&lt; obj.m_space[i] &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Teacher.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Teacher</span>();</span><br><span class="line">	<span class="built_in">Teacher</span>(<span class="keyword">int</span> age, <span class="keyword">const</span> <span class="keyword">char</span>* name);</span><br><span class="line">	<span class="built_in">Teacher</span>(<span class="keyword">const</span> Teacher&amp; obj);</span><br><span class="line">	~<span class="built_in">Teacher</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Teacher&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Teacher&amp; obj);</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Teacher&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_age;</span><br><span class="line">	<span class="keyword">char</span>* m_name;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>Teacher.hpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Teacher.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>() {</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_age = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, <span class="string">""</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="keyword">int</span> age, <span class="keyword">const</span> <span class="keyword">char</span>* name) {</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, name);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="keyword">const</span> Teacher&amp; obj) {</span><br><span class="line">	<span class="comment">// 深拷贝</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_age = obj.m_age;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(obj.m_name) + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, obj.m_name);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Teacher::~<span class="built_in">Teacher</span>() {</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line">		<span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_name);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数，重载运算符 "="</span></span><br><span class="line">Teacher&amp; Teacher::<span class="keyword">operator</span>=(<span class="keyword">const</span> Teacher&amp; obj) {</span><br><span class="line">	<span class="comment">// 释放原本的内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line">		<span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_name = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 深拷贝</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_age = obj.m_age;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(obj.m_name) + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, obj.m_name);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Teacher&amp; obj) {</span><br><span class="line">	cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; obj.m_age &lt;&lt; <span class="string">" name = "</span> &lt;&lt; obj.m_name;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Teacher::getAge</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Teacher::getName</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>{</span><br><span class="line">	<span class="comment">// 释放原本的内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line">		<span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_name = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 深拷贝</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, name);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里需要引入 <code>Teacher.hpp</code> 和 <code>MyVector.hpp</code>，而不是 <code>Teacher.h</code> 和 <code>MyVector.h</code> 头文件，否则 C++ 编译器会编译失败，本质原因是由于 C++ 编译器会对模板进行两次编译导致的，详见 <a target="_blank" rel="external nofollow" href="https://blog.csdn.net/big_bit/article/details/52289162">C++ 模板的编译错误分析</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Teacher.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyVector.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动调用构造函数</span></span><br><span class="line">	<span class="function">MyVector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载运算符 "[]"</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">		v[i] = i + <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载运算符 "&lt;&lt;"</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动调用拷贝构造函数</span></span><br><span class="line">	MyVector&lt;<span class="keyword">int</span>&gt; v2 = v;</span><br><span class="line">	cout &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载运算符 "="</span></span><br><span class="line">	<span class="function">MyVector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	v3 = v2;</span><br><span class="line">	cout &lt;&lt; v3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 容器存放类对象</span></span><br><span class="line">	<span class="function">MyVector&lt;Teacher&gt; <span class="title">teachers</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teachers.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">		<span class="function">Teacher <span class="title">t</span><span class="params">(i + <span class="number">20</span>, <span class="string">"Jim"</span>)</span></span>;</span><br><span class="line">		teachers[i] = t;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; teachers &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 容器存放指针</span></span><br><span class="line">	<span class="function">MyVector&lt;Teacher*&gt; <span class="title">points</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">		points[i] = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">25</span> + i, <span class="string">"Tom"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">		Teacher* obj = points[i];</span><br><span class="line">		cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; obj-&gt;<span class="built_in">getAge</span>() &lt;&lt; <span class="string">" name = "</span> &lt;&lt; obj-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5,</span><br><span class="line">1, 2, 3, 4, 5,</span><br><span class="line">1, 2, 3, 4, 5,</span><br><span class="line">age = 20 name = Jim, age = 21 name = Jim, age = 22 name = Jim,</span><br><span class="line">age = 25 name = Tom, age = 26 name = Tom, age = 27 name = Tom, age = 28 name = Tom,</span><br></pre></td></tr></tbody></table></figure><h3 id="函数模板与类模板的使用总结"><a href="#函数模板与类模板的使用总结" class="headerlink" title="函数模板与类模板的使用总结"></a>函数模板与类模板的使用总结</h3><ul><li>模板是 C++ 类型参数化的多态工具，C++ 为此提供了函数模板和类模板</li><li>模板定义以模板声明开始，类属参数必须在模板定义中至少出现一次</li><li>同一个类属参数可以用于多个模板</li><li>类属参数可用于函数的参数类型、返回值类型和声明函数中的变量</li><li>模板由编译器根据实际的数据类型进行实例化，生成可执行代码</li><li>模板中的函数称为模板函数，实例化的类模板称为模板类</li><li>类模板可以在类层次中使用（即可以被继承）</li><li>函数模板可以使用多种方式重载</li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/779107de.html" title="C++ 进阶基础之二">https://www.techgrow.cn/posts/779107de.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/dbff2af9.html" rel="prev" title="C++ 进阶基础之一"><i class="fa fa-angle-left"></i> C++ 进阶基础之一</a></div><div class="post-nav-item"> <a href="/posts/35cd91d3.html" rel="next" title="C++ 进阶基础之三">C++ 进阶基础之三<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.5m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">22:29</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤 ICP 备 19024664 号</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035 号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/app/api/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/app/api/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/779107de.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>