<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 入门基础的内容，包括浅拷贝与深拷贝、new 和 delete 运算符的使用、静态成员变量和静态成员函数、this 指针的使用等。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 入门基础之五"><meta property="og:url" content="https://www.techgrow.cn/posts/a35089f6.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 入门基础的内容，包括浅拷贝与深拷贝、new 和 delete 运算符的使用、静态成员变量和静态成员函数、this 指针的使用等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/10/cplusplus-new.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/10/cplusplus-delete.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/10/cplusplus-static.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/10/cplusplus-class.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/cplusplus-this-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/11/cplusplus-this.png"><meta property="article:published_time" content="2021-10-27T13:55:33.000Z"><meta property="article:modified_time" content="2024-03-19T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2021/10/cplusplus-new.png"><link rel="canonical" href="https://www.techgrow.cn/posts/a35089f6.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/a35089f6.html","path":"posts/a35089f6.html","title":"C++ 入门基础之五"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 入门基础之五 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explicit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">explicit 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#explicit-%E4%BB%8B%E7%BB%8D"><span class="nav-text">explicit 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explicit-%E4%BD%BF%E7%94%A8"><span class="nav-text">explicit 使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-text">深拷贝与浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-text">概念介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">浅拷贝的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">深拷贝的概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90"><span class="nav-text">浅拷贝问题剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA"><span class="nav-text">问题提出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="nav-text">问题解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-%E4%B8%8E-delete-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">new 与 delete 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-text">C 语言的动态分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E9%87%8A%E6%94%BE"><span class="nav-text">对象的动态创建和释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E5%92%8C-delete-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">new 和 delete 的介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E5%92%8C-delete-%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">new 和 delete 的基础语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E5%92%8C-delete-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">new 和 delete 的使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="nav-text">使用案例一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="nav-text">使用案例二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%89"><span class="nav-text">使用案例三</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E5%9B%9B"><span class="nav-text">使用案例四</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">静态成员变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">静态成员变量的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">静态成员变量的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">静态成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">静态成员函数的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">静态成员函数的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2"><span class="nav-text">C++ 面向对象模型初探</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="nav-text">对象模型概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="nav-text">成员变量和成员函数分开存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this-%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">this 指针的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">空指针访问成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">常函数与常对象的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">全局函数与成员函数的使用</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">786</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/a35089f6.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 入门基础之五 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 入门基础的内容，包括浅拷贝与深拷贝、new 和 delete 运算符的使用、静态成员变量和静态成员函数、this 指针的使用等。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 入门基础之五</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-27 21:55:33" itemprop="dateCreated datePublished" datetime="2021-10-27T21:55:33+08:00">2021-10-27</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-03-19 21:55:33" itemprop="dateModified" datetime="2024-03-19T21:55:33+08:00">2024-03-19</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/a35089f6.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/a35089f6.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>7.4k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>7 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8bbc3f09.html">C++ 入门基础之一</a>、<a href="/posts/b03c11a0.html">C++ 入门基础之二</a>、<a href="/posts/f26087ad.html">C++ 入门基础之三</a></li><li><a href="/posts/beb2ebb3.html">C++ 入门基础之四</a>、<a href="/posts/a35089f6.html">C++ 入门基础之五</a>、<a href="/posts/a54941f5.html">C++ 入门基础之六</a></li><li><a href="/posts/e4826e2c.html">C++ 入门基础之七</a>、<a href="/posts/4c2ae4c0.html">C++ 入门基础之八</a>、<a href="/posts/f1a16291.html">C++ 入门基础之九</a></li></ul><h2 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h2><h3 id="explicit-介绍"><a href="#explicit-介绍" class="headerlink" title="explicit 介绍"></a>explicit 介绍</h3><p>在 C++ 中，<code>explicit</code> 关键字用于声明类的单参数构造函数为显式构造函数，防止其被隐式调用。简而言之，<code>explicit</code> 可以显式地禁止类构造函数的隐式转换，这样可以避免一些意外的类型转换和编译器自动调用构造函数的情况。</p><div class="admonition warning"><p class="admonition-title">使用注意事项</p><ul><li><code>explicit</code> 关键字只能用于类内部的构造函数声明上。</li><li><code>explicit</code> 关键字作用于单个参数的构造函数。</li></ul></div><span id="more"></span><h3 id="explicit-使用"><a href="#explicit-使用" class="headerlink" title="explicit 使用"></a>explicit 使用</h3><p>当一个类有一个单参数的构造函数，该构造函数接受一个参数时，C++ 默认允许对参数进行隐式转换（隐式类型转换）。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> x)</span> : num(x) {</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    MyClass obj = <span class="number">42</span>;   <span class="comment">// 错误写法：使用 explicit 后不允许隐式转换</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">42</span>)</span></span>;   <span class="comment">// 正确写法：显式转换</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中，MyClass 类有一个单参数构造函数，使用 <code>explicit</code> 关键字修饰后，这意味着不允许隐式转换。尝试使用 <code>MyClass obj = 42</code> 来初始化 obj 会导致编译错误，只有显式地使用 <code>MyClass(42)</code> 来初始化 obj2 才是允许的。总结，当想要禁止某个构造函数的隐式转换，可以将该构造函数标记为 <code>explicit</code>。这样，当该构造函数被用于隐式转换时，编译器会报错。这在多参数或标准布局的类中特别有用，可以防止不正确的转换和意外的转换。</p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><div class="admonition note"><p class="admonition-title">提示</p><ul><li>C++ 提供的默认拷贝构造函数，可以完成对象的数据成员值简单的复制，属于浅拷贝。</li><li>对象的数据资源是由指针指向的堆，C++ 提供的默认拷贝构造函数仅对指针的值（内存地址）进行复制，不会对指针指向的内容进行复制，属于浅拷贝。</li></ul></div><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是涉及到对象拷贝的概念。在 C++ 中，当复制一个对象到另一个对象时，根据对象中包含的数据类型和内存分配方式，可能会触发深拷贝或者浅拷贝。</p><h4 id="浅拷贝的概念"><a href="#浅拷贝的概念" class="headerlink" title="浅拷贝的概念"></a>浅拷贝的概念</h4><p>浅拷贝会简单地复制对象的每个成员变量的值。这意味着如果对象包含指针，浅拷贝只会复制指针的值（内存地址），而不会复制指针指向的内容。这可能导致两个对象共享同一块内存，当一个对象修改了这块内存中的数据，另一个对象也会受到影响。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShallowCopyExample</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShallowCopyExample</span>(<span class="keyword">int</span> val) {</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">        *data = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShallowCopyExample</span>(<span class="keyword">const</span> ShallowCopyExample &amp;other) {</span><br><span class="line">        <span class="comment">// 浅拷贝</span></span><br><span class="line">        data = other.data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        *data = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> *data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ShallowCopyExample</span>() {</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">ShallowCopyExample <span class="title">shallowObj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    ShallowCopyExample shallowObj2 = shallowObj1;</span><br><span class="line"></span><br><span class="line">    shallowObj2.<span class="built_in">setData</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"Shallow Copy Example:\n"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Obj1 Data: "</span> &lt;&lt; shallowObj1.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Obj2 Data: "</span> &lt;&lt; shallowObj2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shallow Copy Example:</span><br><span class="line">Obj1 Data: 20</span><br><span class="line">Obj2 Data: 20</span><br></pre></td></tr></tbody></table></figure><h4 id="深拷贝的概念"><a href="#深拷贝的概念" class="headerlink" title="深拷贝的概念"></a>深拷贝的概念</h4><p>深拷贝会为目标对象分配一块新的内存，并将源对象的数据复制到新的内存空间中。这样可以确保每个对象拥有自己的数据副本，互不影响。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepCopyExample</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DeepCopyExample</span>(<span class="keyword">int</span> val) {</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">        *data = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeepCopyExample</span>(<span class="keyword">const</span> DeepCopyExample &amp;other) {</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">        *data = *other.data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        *data = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> *data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DeepCopyExample</span>() {</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">DeepCopyExample <span class="title">deepObj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    DeepCopyExample deepObj2 = deepObj1;</span><br><span class="line"></span><br><span class="line">    deepObj2.<span class="built_in">setData</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Deep Copy Example:\n"</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Obj1 Data: "</span> &lt;&lt; deepObj1.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Obj2 Data: "</span> &lt;&lt; deepObj2.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deep Copy Example:</span><br><span class="line">Obj1 Data: 10</span><br><span class="line">Obj2 Data: 20</span><br></pre></td></tr></tbody></table></figure><h3 id="浅拷贝问题剖析"><a href="#浅拷贝问题剖析" class="headerlink" title="浅拷贝问题剖析"></a>浅拷贝问题剖析</h3><h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><blockquote><p>思考：下述代码为什么会异常终止运行？</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Name</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(name);</span><br><span class="line">        p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(length + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p, name);</span><br><span class="line">        len = length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Name</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getP</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Name <span class="title">obj1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line">    Name obj2 = obj1;       <span class="comment">// 自动调用C++提供的默认拷贝构造函数，属于浅拷贝</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1.name: "</span> &lt;&lt; obj1.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj1.len:  "</span> &lt;&lt; obj1.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj2.name: "</span> &lt;&lt; obj2.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj2.len:  "</span> &lt;&lt; obj2.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">obj1.name: Peter, obj1.len:  5</span><br><span class="line">obj2.name: Peter, obj2.len:  5</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line"></span><br><span class="line">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></tbody></table></figure><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>由于在上述的代码中，没有自定义拷贝构造函数，使用的是 C++ 编译器提供的默认拷贝构造函数，因此程序异常终止运行。造成程序异常终止运行的根本原因是，C++ 提供的默认拷贝构造函数属于浅拷贝，当程序运行结束之前，在第二次调用上面的析构函数时会出现错误（同一块内存空间被释放了两次），底层的分析图解可以看<a href="../../../asset/2021/10/cplusplus-copy-1.png">这里</a>。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>显式编写自定义的拷贝构造函数，通过实现深拷贝（申请新的内存空间）来解决上述的问题，底层的分析图解可以看<a href="../../../asset/2021/10/cplusplus-copy-2.png">这里</a>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Name</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(name);</span><br><span class="line">        p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(length + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p, name);</span><br><span class="line">        len = length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝的实现</span></span><br><span class="line">    <span class="built_in">Name</span>(<span class="keyword">const</span> Name &amp;name) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> length = name.<span class="built_in">getLen</span>();</span><br><span class="line">        p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(length + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p, name.<span class="built_in">getP</span>());</span><br><span class="line">        len = length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Name</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getP</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Name <span class="title">obj1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line">    Name obj3 = obj1;       <span class="comment">// 自动调用自定义的拷贝构造函数（深拷贝）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1.name: "</span> &lt;&lt; obj1.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj1.len:  "</span> &lt;&lt; obj1.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj3.name: "</span> &lt;&lt; obj3.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj3.len:  "</span> &lt;&lt; obj3.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">拷贝构造函数被调用了</span><br><span class="line">obj1.name: Peter, obj1.len:  5</span><br><span class="line">obj3.name: Peter, obj3.len:  5</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在以下的代码中，<code>obj3 = obj1;</code> 依旧属于浅拷贝（这里不会自动调用拷贝构造函数），最终程序也会异常终止运行。若希望解决该问题，需要重载 C++ 的 <code>=</code> 操作符，这里暂时不展开讨论。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Name <span class="title">obj1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line">    <span class="function">Name <span class="title">obj3</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line">    obj3 = obj1;       <span class="comment">// 赋值操作，属于浅拷贝，不会自动调用拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1.name: "</span> &lt;&lt; obj1.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj1.len:  "</span> &lt;&lt; obj1.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj3.name: "</span> &lt;&lt; obj3.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj3.len:  "</span> &lt;&lt; obj3.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">obj1.name: Peter, obj1.len:  5</span><br><span class="line">obj3.name: Peter, obj3.len:  5</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line"></span><br><span class="line">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></tbody></table></figure><h2 id="new-与-delete-运算符"><a href="#new-与-delete-运算符" class="headerlink" title="new 与 delete 运算符"></a>new 与 delete 运算符</h2><h3 id="C-语言的动态分配内存"><a href="#C-语言的动态分配内存" class="headerlink" title="C 语言的动态分配内存"></a>C 语言的动态分配内存</h3><p>为了在运行时支持动态分配内存，C 语言在它的标准库中提供了一些函数，比如 <code>malloc</code> 以及它的变种 <code>calloc</code> 和 <code>realloc</code>，还有释放内存的 <code>free</code> 函数。这些函数都是有效的，不过都是原始的，需要程序员理解和小心使用。为了使用 C 语言的动态内存分配函数在堆上创建一个类的实例，往往需要像下面一样编写代码。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">    <span class="keyword">char</span> *pName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">        mAge = <span class="number">20</span>;</span><br><span class="line">        pName = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">"Peter"</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pName != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">strcpy</span>(pName, <span class="string">"Peter"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (pName != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">free</span>(pName);</span><br><span class="line">            pName = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name = %s, age = %d"</span>, pName, mAge);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化对象</span></span><br><span class="line">    person.<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    person.<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁对象</span></span><br><span class="line">    person.<span class="built_in">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码有以下诸多弊端，而且动态分配内存函数太复杂，容易令人混淆，所以在 C++ 中推荐使用 <code>new</code> 和 <code>delete</code> 运算符。</p><ul><li>程序员必须确定对象的长度</li><li><code>malloc</code> 函数返回一个 <code>void *</code> 指针，C++ 不允许将 <code>void *</code> 赋值给其他任何指针，必须强制转换类型</li><li><code>malloc</code> 函数可能申请内存失败，所以必须判断返回值来确保内存分配成功</li><li>在使用对象之前必须要对它初始化，用户有可能忘记调用初始化函数，导致出现意想不到的结果</li></ul><h3 id="对象的动态创建和释放"><a href="#对象的动态创建和释放" class="headerlink" title="对象的动态创建和释放"></a>对象的动态创建和释放</h3><p><strong>C++ 规定使用类名定义的对象都是静态的（如 <code>Teacher t(30);</code>），内存空间在栈上分配，在程序运行过程中，对象所占用的内存空间是不能随时释放的，只有在对象所在的作用域结束后或者程序运行结束后才会被释放。</strong>但有时候用户希望在需要用到对象时才创建对象，在不需要用该对象时就销毁它，释放它所占的内存空间以供别的数据使用，这样可提高内存空间的利用率。在 C++ 中，可以用 <code>new</code> 运算符动态创建对象，用 <code>delete</code> 运算符动态销毁对象。<strong>特别注意，使用 <code>new</code> 运算符创建对象时，是在堆上分配内存空间的，即使对象所在的作用域结束后或者程序结束后都不会自动释放内存空间，只有使用 <code>delete</code> 运算符才能释放对象所占用的内存空间。</strong></p><div class="admonition note"><p class="admonition-title">在栈上创建对象</p><p>在 C++ 中，使用类名定义的对象如 <code>Teacher t(30);</code> 是在栈上创建对象的一种方式，对象的生命周期与作用域相关。当这个对象跳出其所在的作用域时，比如函数结束、代码块结束或者程序结束，对象会被自动销毁，其析构函数会被调用，从而释放对象占用的内存空间。所以，对于 <code>Teacher t(30);</code> 这样在栈上创建的对象，在其作用域结束时会自动释放内存空间，无需手动管理内存。这是 C++ 的 RAII（资源获取即初始化）机制的体现，能够帮助避免内存泄漏和资源泄漏问题。</p></div><h3 id="new-和-delete-的介绍"><a href="#new-和-delete-的介绍" class="headerlink" title="new 和 delete 的介绍"></a>new 和 delete 的介绍</h3><p>在软件开发过程中，常常需要动态地分配和释放内存空间，例如对动态链表中结点的插入与删除。在 C 语言中是利用库函数 <code>malloc</code> 和 <code>free</code> 来分配和释放内存空间的。C++ 提供了较简便而功能较强的运算符 <code>new</code> 和 <code>delete</code> 来取代 <code>malloc</code> 和 <code>free</code> 函数。值得注意的是，<code>new</code> 和 <code>delete</code> 是运算符，不是函数，因此执行效率更高。虽然为了与 C 语言兼容，C++ 仍保留 <code>malloc</code> 和 <code>free</code> 函数，但建议用户不要使用 <code>malloc</code> 和 <code>free</code> 函数，而是使用 <code>new</code> 和 <code>delete</code> 运算符。</p><div class="admonition warning"><p class="admonition-title">delete 运算符与 free () 函数的区别</p><p>在 C++ 中，<code>delete p</code> 和 <code>free(p)</code> 都可以用来释放动态分配的内存，但它们之间有一些关键的区别：</p><ul><li><code>delete p</code> 是 C++ 中的删除动态分配的对象的操作符，它不仅会释放内存，还会调用对象的析构函数（如果有的话）来做清理工作，所以对于类类型的对象，应该始终使用 delete 运算符来释放内存。</li><li><code>free(p)</code> 是 C 标准库的函数，它只是简单地释放内存，不会调用任何析构函数。在 C++ 中使用 delete 运算符会更安全，因为它确保了对象的析构函数被正确调用，避免了内存泄漏和悬挂指针等问题。</li><li>因此，在 C++ 中，推荐使用 delete 运算符来释放使用 new 运算符分配的内存，避免使用 <code>free()</code> 来释放内存。</li></ul></div><h3 id="new-和-delete-的基础语法"><a href="#new-和-delete-的基础语法" class="headerlink" title="new 和 delete 的基础语法"></a>new 和 delete 的基础语法</h3><p><img data-src="../../../asset/2021/10/cplusplus-new.png" alt="cplusplus-new"><br><img data-src="../../../asset/2021/10/cplusplus-delete.png" alt="cplusplus-delete"></p><p><code>new</code> 运算符的简单使用例子如下：</p><ul><li><code>new int;</code>：开辟一个存放整数的内存空间，返回一个指向该内存空间的地址（即指针）</li><li><code>new int(100);</code>：开辟一个存放整数的空间，并指定该整数的初值为 100，返回一个指向该内存空间的地址（即指针）</li><li><code>new char[10];</code>：开辟一个存放字符数组（包括 10 个元素）的空间，返回首元素的地址（即指针）</li><li><code>new int[5][4];</code>：开辟一个存放二维整型数组（大小为 5*4）的空间，返回首元素的地址（即指针）</li><li><code>float *p = new float (3.14159);</code>：开辟一个存放单精度数的空间，并指定该实数的初值为 3.14159，将返回的该空间的地址赋给指针变量</li></ul><p>值得注意的是，使用 <code>new</code> 运算符创建对象时，如果由于内存不足等原因而导致无法正常分配内存空间，那么大多数 C++ 编译器都会让 <code>new</code> 返回一个 0 指针值，用户可以根据该指针的值来判断内存空间是否分配成功。</p><h3 id="new-和-delete-的使用案例"><a href="#new-和-delete-的使用案例" class="headerlink" title="new 和 delete 的使用案例"></a>new 和 delete 的使用案例</h3><p>在 C++ 中解决动态内存分配的方案是将创建一个对象所需要的操作都结合在一个称为 <code>new</code> 的运算符里。当使用 <code>new</code> 创建一个对象时，C++ 会在堆里为对象分配内存，并调用构造函数完成对象的初始化。使用 <code>new</code> 运算符后，会发现在堆里创建对象的过程变得简单多了，只需要一个简单的表达式，它带有内置的长度计算、类型转换和类型安全检查，这样在堆里创建一个对象就和在栈里创建对象一样简单。</p><h4 id="使用案例一"><a href="#使用案例一" class="headerlink" title="使用案例一"></a>使用案例一</h4><p>使用 <code>new</code> 运算符创建对象时（动态创建），是在堆上分配内存空间的，即使对象所在的作用域结束后或者程序结束后都不会自动释放内存空间，也不会自动调用析构函数。只有使用 <code>delete</code> 运算符才能释放对象所占用的内存空间，此时会自动调用析构函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"默认构造函数调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Person p1;  <span class="comment">// 创建对象（静态），会在栈上开辟内存空间，对象所在的作用域结束后或者程序结束后都会自动释放内存空间，会自动调用析构函数</span></span><br><span class="line"></span><br><span class="line">    Person *p2 = <span class="keyword">new</span> <span class="built_in">Person</span>();  <span class="comment">// 通过 new 运算符创建对象（动态），会在堆上开辟内存空间，对象所在的作用域结束后或者程序结束后都不会自动释放内存空间，不会自动调用析构函数</span></span><br><span class="line">    <span class="keyword">delete</span> p2;  <span class="comment">// 通过 delete 运算符释放对象所在的堆内存空间，会自动调用析构函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认构造函数调用</span><br><span class="line">默认构造函数调用</span><br><span class="line">析构函数调用</span><br><span class="line">析构函数调用</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例二"><a href="#使用案例二" class="headerlink" title="使用案例二"></a>使用案例二</h4><p><code>Teacher *p = new Teacher(35);</code> 这种写法，是将两个语句（定义指针变量和使用 <code>new</code> 创建新对象）合并为一个语句，并指定初值；在调用对象时，既可以通过对象名，也可以通过指针。<strong>在执行 <code>new</code> 运算符时，如果内存空间不足，无法开辟所需的内存空间，目前大多数 C++ 编译器都会返回一个 <code>0</code> 指针值。只要检测返回值是否为 <code>0</code>，就可判断内存空间是否分配成功。</strong>ANSI C++ 标准提出，在执行 <code>new</code> 出现故障时，就抛出一个异常，用户可根据异常进行相关处理，但 C++ 标准仍然允许在出现 <code>new</code> 故障时返回 <code>0</code> 指针值。值得注意的是，不同的编译器对 <code>new</code> 故障的处理方法是不同的。当不再需要使用由 <code>new</code> 创建的对象时，可以用 <code>delete</code> 运算符予以释放内存空间，以后程序不能再使用该对象。如果用一个指针变量先后指向了不同的动态对象，应注意指针变量的当前指向，以避免释放错了对象。<strong>值得一提的是，执行 <code>delete</code> 运算符时，在释放内存空间之前，会自动调用类的析构函数，完成有关善后清理工作。</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>(<span class="keyword">int</span> age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">        cout &lt;&lt; <span class="string">"构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Teacher</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAget</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_age;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言分配基础类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionA -&gt; p = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++分配基础类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionB</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *a = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionB -&gt; a = "</span> &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionB -&gt; b = "</span> &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言分配数组类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionC</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">3</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">    p[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionC -&gt; p = "</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; p[<span class="number">1</span>] &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++分配数组类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionD</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">0</span>] = <span class="string">'e'</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="string">'f'</span>;</span><br><span class="line">    p[<span class="number">2</span>] = <span class="string">'g'</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionD -&gt; p = "</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; p[<span class="number">1</span>] &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionE</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 这里不会自动调用类的构造函数和析构函数</span></span><br><span class="line">    Teacher *p = (Teacher *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">    p-&gt;<span class="built_in">setAget</span>(<span class="number">33</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionE -&gt; age = "</span> &lt;&lt; p-&gt;<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionF</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// new和delete会分别自动调用类的构造函数和析构函数</span></span><br><span class="line">    Teacher *p = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">35</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionF -&gt; age = "</span> &lt;&lt; p-&gt;<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">functionA</span>();</span><br><span class="line">    <span class="built_in">functionB</span>();</span><br><span class="line">    <span class="built_in">functionC</span>();</span><br><span class="line">    <span class="built_in">functionD</span>();</span><br><span class="line">    <span class="built_in">functionE</span>();</span><br><span class="line">    <span class="built_in">functionF</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">functionA -&gt; p = 3</span><br><span class="line">functionB -&gt; a = 3</span><br><span class="line">functionB -&gt; b = 30</span><br><span class="line">functionC -&gt; p = abc</span><br><span class="line">functionD -&gt; p = efg</span><br><span class="line">functionE -&gt; age = 33</span><br><span class="line">构造函数被调用</span><br><span class="line">functionF -&gt; age = 35</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例三"><a href="#使用案例三" class="headerlink" title="使用案例三"></a>使用案例三</h4><p>使用 <code>void *</code> 类型指针 p 来接收 <code>new</code> 运算符返回的 Person 对象的地址，这样做会导致编译器无法知道 p 所指向的内存应该如何处理。此时，使用 <code>delete</code> 运算符释放一个 <code>void *</code> 指针的内存是不安全的，因为编译器不知道该指针指向的内存分配时使用的具体类型，最终导致内存空间没有被正确释放，同时析构函数也没有被自动调用。</p><div class="admonition warning"><p class="admonition-title">警告</p><p>尽量不要使用 <code>void *</code> 类型指针去接收 <code>new</code> 运算符返回的对象的地址（指针），否则无法使用 <code>delete</code> 运算符正确释放对象所占用的内存空间。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"默认构造函数调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="keyword">new</span> <span class="built_in">Person</span>();  <span class="comment">// 当使用 void * 类型接收 new 出来的指针时，会出现内存释放问题</span></span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">// 这里无法正确释放内存空间，并且不会自动调用析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认构造函数调用</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例四"><a href="#使用案例四" class="headerlink" title="使用案例四"></a>使用案例四</h4><p>使用 <code>new</code> 运算符创建对象数组时，编译器一定会自动调用类的默认构造函数，所以必须提供类的默认构造函数，否则代码编译不通过。如果要释放对象数组的内存空间，可以使用 <code>delete[] pArray</code> 的写法，这样就可以释放 pArray 指针指向的对象数组的内存空间，避免内存泄漏。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"默认构造函数调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) : <span class="built_in">mAge</span>(age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造函数调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    Person *pArray = <span class="keyword">new</span> Person[<span class="number">3</span>]; <span class="comment">// 通过 new 运算符创建对象数组时（动态），一定会自动调用类的默认构造函数，所以必须提供类的默认构造函数，否则编译不通过</span></span><br><span class="line">    <span class="keyword">delete</span>[] pArray;   <span class="comment">// 通过 delete [] 运算符释放对象数组的内存空间，会自动调用析构函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    Person pArray2[<span class="number">2</span>] = {<span class="built_in">Person</span>(<span class="number">1</span>), <span class="built_in">Person</span>(<span class="number">2</span>)};  <span class="comment">// 创建对象数组（静态），会在栈上开辟内存空间，可以指定有参构造函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"------- test01() -------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"------- test02() -------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------- test01() -------</span><br><span class="line">默认构造函数调用</span><br><span class="line">默认构造函数调用</span><br><span class="line">默认构造函数调用</span><br><span class="line">析构函数调用</span><br><span class="line">析构函数调用</span><br><span class="line">析构函数调用</span><br><span class="line">------- test02() -------</span><br><span class="line">有参构造函数调用</span><br><span class="line">有参构造函数调用</span><br><span class="line">析构函数调用</span><br><span class="line">析构函数调用</span><br></pre></td></tr></tbody></table></figure><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p>在一个类中，若将一个成员变量声明为 <code>static</code>，这种成员称为静态成员变量。它与一般的成员变量不一样，无论创建多少个对象，都只有一份静态数据的拷贝。静态成员变量，是属于某个类的，被所有对象所共享。</p><h3 id="静态成员变量的概念"><a href="#静态成员变量的概念" class="headerlink" title="静态成员变量的概念"></a>静态成员变量的概念</h3><ul><li>静态成员变量作用于类，它不是对象成员。</li><li>静态成员变量都是以关键字 <code>static</code> 声明。</li><li>静态成员变量拥有访问控制级别，比如可以声明为 <code>private</code>。</li><li>在类外访问静态成员变量时，可以使用 <code>类名 ::</code> 作为限定词，或者通过对象名访问。</li><li>关键字 <code>static</code> 可以用于声明一个类的成员，静态成员提供了一种同类对象的共享机制。</li><li>将一个类的成员变量声明为 <code>static</code> 时，这个类无论有多少个对象被创建，这些对象都共享这个 <code>static</code> 成员变量。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li><strong>静态成员变量必须在类中声明，在类外定义（即初始化）。</strong></li><li>静态成员变量不属于某个对象，在为对象分配的内存空间中，不包括静态成员变量所占用的内存空间。</li><li>静态成员变量在编译阶段就已经分配内存空间（在全局静态区分配内存空间），也就是在对象还没有创建时，就已经分配内存空间。</li></ul></div><p><img data-src="../../../asset/2021/10/cplusplus-static.png" alt="cplusplus-static"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明静态成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数访问静态成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">        num = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态成员变量，这里不是简单的变量赋值，更重要的是告诉C++编译器，给静态成员变量分配内存</span></span><br><span class="line"><span class="keyword">int</span> Counter::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Counter a, b;</span><br><span class="line">    a.<span class="built_in">showNum</span>();</span><br><span class="line">    b.<span class="built_in">showNum</span>();</span><br><span class="line">    a.<span class="built_in">setNum</span>(<span class="number">10</span>);</span><br><span class="line">    a.<span class="built_in">showNum</span>();</span><br><span class="line">    b.<span class="built_in">showNum</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></tbody></table></figure><h3 id="静态成员变量的使用"><a href="#静态成员变量的使用" class="headerlink" title="静态成员变量的使用"></a>静态成员变量的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;             <span class="comment">// 公有成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> smem;     <span class="comment">// 公有静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="keyword">int</span> num) {</span><br><span class="line">        mem = num;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态成员变量，这里不是简单的变量赋值，更重要的是告诉C++编译器，给静态成员变量分配内存</span></span><br><span class="line"><span class="keyword">int</span>  Counter::smem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="comment">// 访问静态成员变量的第一种方法（通过类名直接访问）</span></span><br><span class="line">        Counter::smem += i;</span><br><span class="line">        cout &lt;&lt; <span class="string">"Counter::smem = "</span>&lt;&lt; Counter::smem &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问静态成员变量的第二种方法（通过对象名访问）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"c.smem = "</span> &lt;&lt; c.smem &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Counter::smem = 0</span><br><span class="line">Counter::smem = 1</span><br><span class="line">Counter::smem = 3</span><br><span class="line">Counter::smem = 6</span><br><span class="line">Counter::smem = 10</span><br><span class="line">c.smem = 10</span><br></pre></td></tr></tbody></table></figure><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><h3 id="静态成员函数的概念"><a href="#静态成员函数的概念" class="headerlink" title="静态成员函数的概念"></a>静态成员函数的概念</h3><ul><li>静态成员函数是属于类的，它不是对象成员。</li><li>静态成员函数都是以关键字 <code>static</code> 声明。</li><li>静态成员函数拥有访问控制级别，比如可以声明为 <code>private</code>。</li><li>在类外调用静态成员函数时，可以使用 <code>类名 ::</code> 作为限定词，或者通过对象名访问。</li><li>静态成员函数提供不依赖于类数据结构的共同操作，它没有 <code>this</code> 指针，而普通成员函数包含一个指向具体对象的 <code>this</code> 指针。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>在静态成员函数内，不能使用 <code>this</code> 指针。</li><li>在静态成员函数中，不能访问普通成员变量和调用普通成员函数，反之可以。这是因为静态成员函数属于整个类的，它没办法区分普通成员变量和普通成员函数是属于哪个具体的对象。</li></ul></div><h3 id="静态成员函数的使用"><a href="#静态成员函数的使用" class="headerlink" title="静态成员函数的使用"></a>静态成员函数的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明并定义静态成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(Counter *p)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> p-&gt;num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明静态成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> i, Counter *p)</span></span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Counter::setNum</span><span class="params">(<span class="keyword">int</span> i, Counter *p)</span> </span>{</span><br><span class="line">    p-&gt;num = i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Counter obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问静态成员函数的第一种方法（通过类名直接访问）</span></span><br><span class="line">    Counter::<span class="built_in">setNum</span>(<span class="number">1</span>, &amp;obj);</span><br><span class="line">    cout &lt;&lt; <span class="string">"num = "</span> &lt;&lt; Counter::<span class="built_in">getNum</span>(&amp;obj) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问静态成员函数的第二种方法（通过对象名访问）</span></span><br><span class="line">    obj.<span class="built_in">setNum</span>(<span class="number">3</span>, &amp;obj);</span><br><span class="line">    cout &lt;&lt; <span class="string">"num = "</span> &lt;&lt; obj.<span class="built_in">getNum</span>(&amp;obj) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = 1</span><br><span class="line">num = 3</span><br></pre></td></tr></tbody></table></figure><h2 id="C-面向对象模型初探"><a href="#C-面向对象模型初探" class="headerlink" title="C++ 面向对象模型初探"></a>C++ 面向对象模型初探</h2><h3 id="对象模型概述"><a href="#对象模型概述" class="headerlink" title="对象模型概述"></a>对象模型概述</h3><p>C++ 对象模型可以概括为以下两部分：</p><ul><li>对于各种特性支持的底层实现机制</li><li>语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等</li></ul><p>在 C 语言中，” 数据” 和 “处理数据的操作（函数）” 是分开来声明的，也就是说，语言本身并没有支持 “数据和函数” 之间的关联性。在 C++ 中，通过抽象数据类型 ADT（Abstract Data Type），在类中定义数据和函数来实现数据和函数直接的绑定。概括来说，在 C++ 类中有两种成员数据：<code>static</code>、<code>nonstatic</code>，三种成员函数：<code>static</code>、<code>nonstatic</code>、<code>virtual</code>。</p><p><img data-src="../../../asset/2021/10/cplusplus-class.png" alt="cplusplus-class"></p><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><p>C++ 中的 Class 从面向对象理论出发，将变量（属性）和函数（方法）集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> {</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> {</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getK</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setK</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        k = val;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s1:%d \n"</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2:%d \n"</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c1:%d \n"</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(C1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c2:%d \n"</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(C2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1:12</span><br><span class="line">s2:12</span><br><span class="line">c1:12</span><br><span class="line">c2:12</span><br></pre></td></tr></tbody></table></figure><p>通过上面的案例，可以得知 C++ 类对象中的成员变量和成员函数是分开存储的，C 语言中的内存四区模型仍然有效。值得一提的是，在 C++ 中，类的普通成员函数（非静态成员函数）都隐式包含一个指向当前对象的 <code>this</code> 指针。</p><ul><li>静态成员变量：存储在全局数据区中</li><li>普通成员变量：存储在对象中，与 <code>struct</code> 变量具有相同的内存布局和字节对齐方式</li><li>成员函数（静态与普通）：存储在代码段中，虽然内含在 <code>class</code> 声明之内，却不会出现在对象中</li><li>每一个非内联函数（non-inline member function）都只会诞生一份函数实例，也就是说多个同类型的对象会共用同一块函数代码</li></ul><blockquote><p>总结：只有普通成员变量（非静态成员变量），才存储在对象中。</p></blockquote><div class="admonition note"><p class="admonition-title">字节对齐方式的介绍</p><ul><li>在 C++ 中，可以使用 <code>#pragma pack(n)</code> 预处理指令实现字节对齐，它用于指示编译器按照指定的字节对齐方式对结构体、类等数据类型进行打包（或者称为紧凑化）。具体来说，<code>#pragma pack(n)</code> 中的 <code>n</code> 表示指定的对齐字节数，通常取 1、2、4、8 等值，表示数据在内存中的对齐方式。</li><li>使用 <code>#pragma pack(n)</code> 可以让编译器以字节对齐的方式来排列结构体或类的成员，从而减少内存占用。这对于一些特定的应用场景非常有用，例如与硬件交互时，需要确保数据结构的布局与硬件的预期一致，或者需要在网络中传输结构化数据时，确保数据的字节对齐方式与协议要求一致。</li><li>特别注意的是，使用 <code>#pragma pack(n)</code> 可能会导致性能下降，因为对齐不当可能会增加内存访问的时间。因此，在使用时需要权衡考虑。另外，<code>#pragma pack</code> 是编译器相关的特性，不同的编译器可能会有不同的行为，因此在跨平台开发时需要谨慎使用。</li></ul></div><h3 id="this-指针的使用"><a href="#this-指针的使用" class="headerlink" title="this 指针的使用"></a>this 指针的使用</h3><p>在上述的介绍中，每一个非内联函数（non-inline member function）都只会诞生一份函数实例，也就是说多个同类型的对象会共用同一块函数代码，如下图所示。那么问题是：这块代码是如何区分哪个对象调用自己的呢？</p><p><img data-src="../../../asset/2024/03/cplusplus-this-2.png"></p><p>C++ 规定，<code>this</code> 指针是隐含在成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都有一个由编译器自动生成的隐含指针 <code>this</code>，用以保存这个对象的地址。也就是说，虽然程序员没有写上 <code>this</code> 指针，但编译器在编译的时候会自动加上去。因此 <code>this</code> 也称为 “指向本对象的指针”，而且 <code>this</code> 指针并不是对象的一部分，不会影响 <code>sizeof(对象)</code> 的执行结果。<code>this</code> 指针是 C++ 实现封装的一种机制，它将对象和该对象调用的成员函数连接在一起。在外部看起来，每一个对象都拥有自己的成员函数，其实这是一种假象。一般情况下，并不需要主动写 <code>this</code>，而是让编译器进行默认设置。成员函数通过 <code>this</code> 指针就可以知道自己需要操作的是哪个对象的数据。<strong>this 指针是一种隐含指针，它隐含在每个类的非静态成员函数中。静态成员函数的内部没有 this 指针，因为静态成员函数不能操作非静态成员变量</strong>。</p><p><img data-src="../../../asset/2021/11/cplusplus-this.png"></p><p>当形参和成员变量同名时，可用 <code>this</code> 指针来区分。在类的非静态成员函数中返回对象本身时（链式编程），可以使用 <code>return *this</code>。示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当形参和成员变量同名时，可用 this 指针来区分</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器会自动加上一个 this 指针参数：Person * const this</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类的非静态成员函数中返回对象本身时（链式编程），可以使用 return *this</span></span><br><span class="line">    <span class="function">Person &amp;<span class="title">addAge</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">showAge</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">showAge</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">23</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">addAge</span>(p2).<span class="built_in">addAge</span>(p3);</span><br><span class="line">    p1.<span class="built_in">showAge</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = 18</span><br><span class="line">age = 26</span><br><span class="line">age = 67</span><br></pre></td></tr></tbody></table></figure><p>当使用 <code>const</code> 修饰类成员函数时，成员函数不能修改被调用对象的值，这是因为此时 <code>const</code> 本质上修饰的是 <code>this</code> 指针，间接也说明了 <code>const</code> 与 <code>static</code> 关键字不能同时修饰类成员函数。示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> _m) : _cm(_m) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="comment">// _cm = 10;  是错误写法，对象的_cm属性值不能被改变</span></span><br><span class="line">        <span class="keyword">return</span> _cm;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cmf</span><span class="params">(<span class="keyword">const</span> Test &amp; _tt)</span> </span>{</span><br><span class="line">    cout &lt;&lt; _tt.<span class="built_in">get_cm</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Cmf</span>(t);   <span class="comment">// 打印结果为8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><ul><li>如果成员函数的内部没有使用到 <code>this</code> 指针，那么空指针可以直接访问成员函数。</li><li>如果成员函数的内部使用到 <code>this</code> 指针，那么就要注意加 <code>if</code> 判断 <code>this</code> 指针是否为 NULL，否则成员函数在调用期间会异常退出。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Show person"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Show age is "</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 判断 this 指针是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; <span class="string">"Print age is "</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Person *p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">showPerson</span>();    <span class="comment">// 空指针可以访问 showPerson() 成员函数</span></span><br><span class="line">    p-&gt;<span class="built_in">printAge</span>();      <span class="comment">// 空指针可以访问 printAge() 成员函数</span></span><br><span class="line">    <span class="comment">// p-&gt;showAge();    // 空指针不可以访问 showAge() 成员函数，代码编译会通过，但运行期间会异常退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Show person</span><br></pre></td></tr></tbody></table></figure><h3 id="常函数与常对象的使用"><a href="#常函数与常对象的使用" class="headerlink" title="常函数与常对象的使用"></a>常函数与常对象的使用</h3><ul><li><p>常函数</p><ul><li>定义语法：<code>void func() const {}</code>，即需要在函数的小括号后面加上 <code>const</code> 关键字</li><li>常函数修饰的是 <code>this</code> 指针，即 <code>const Type * const this</code></li><li>常函数不能修改 <code>this</code> 指针指向的内存内容，即在常函数内不允许修改成员变量的值</li><li>如果希望某个成员变量的值可以在常函数内被修改，那么可以使用 <code>mutable</code> 关键字修饰该成员变量</li></ul></li><li><p>常对象</p><ul><li>定义语法：<code>const Type t;</code>，即在定义对象时，需要在最前面加上 <code>const</code> 关键字</li><li>不允许修改常对象的成员变量的值</li><li>常对象不可以调用普通的成员函数</li><li>常对象可以调用常函数</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义常函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="comment">// 错误写法，常函数内不允许修改成员变量的值</span></span><br><span class="line">        <span class="comment">// this-&gt;m_A = 10;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常函数内可修改被 mutable 修饰的成员变量的值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_A;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义普通函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_B;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_B;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="keyword">int</span> m_A = p1.<span class="built_in">getA</span>();</span><br><span class="line">    cout &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义常对象</span></span><br><span class="line">    <span class="keyword">const</span> Person p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误写法，不允许修改常对象的成员变量的值</span></span><br><span class="line">    <span class="comment">// p2.m_A = 10;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误写法，常对象不可以调用普通的成员函数</span></span><br><span class="line">    <span class="comment">// p2.getB();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常对象可以调用常函数</span></span><br><span class="line">    <span class="keyword">int</span> m_A = p2.<span class="built_in">getA</span>();</span><br><span class="line">    cout &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure><h3 id="全局函数与成员函数的使用"><a href="#全局函数与成员函数的使用" class="headerlink" title="全局函数与成员函数的使用"></a>全局函数与成员函数的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	{</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">Test <span class="title">testAdd</span><span class="params">(Test&amp; t2)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="function">Test <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + t2.a, <span class="keyword">this</span>-&gt;b + t2.b)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//t1.testAdd2(t2);</span></span><br><span class="line">	<span class="comment">//返回一个引用，相当于返回自身</span></span><br><span class="line">	<span class="comment">//返回t1这个元素，this就是&amp;t1</span></span><br><span class="line">	<span class="function">Test&amp; <span class="title">testAdd2</span><span class="params">(Test&amp; t2)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = <span class="keyword">this</span>-&gt;a + t2.a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = <span class="keyword">this</span>-&gt;b + t2.b;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//把 *(&amp;t1) 又回到了 t1元素</span></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="function">Test <span class="title">testAdd</span><span class="params">(Test&amp; t1, Test&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Test tmp;</span><br><span class="line">	tmp.a = t1.a + t2.a;</span><br><span class="line">	tmp.b = t1.b + t2.b;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printT</span><span class="params">(Test* pT)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"a:"</span> &lt;&lt; pT-&gt;a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; pT-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用全局函数</span></span><br><span class="line">	Test t3;</span><br><span class="line">	t3 = <span class="built_in">testAdd</span>(t1, t2);</span><br><span class="line">	<span class="built_in">printT</span>(&amp;t3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用成员函数</span></span><br><span class="line">	Test t4 = t1.<span class="built_in">testAdd</span>(t2); <span class="comment">// 将匿名对象直接转化成t4</span></span><br><span class="line">	t4.<span class="built_in">printT</span>();</span><br><span class="line"></span><br><span class="line">	Test t5;</span><br><span class="line">	t5 = t1.<span class="built_in">testAdd</span>(t2); <span class="comment">// 将匿名对象复制给t5</span></span><br><span class="line">	t5.<span class="built_in">printT</span>();</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">testAdd2</span>(t2); <span class="comment">// 函数内部使用了this指针</span></span><br><span class="line">	t1.<span class="built_in">printT</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:4 b: 6</span><br><span class="line">a:4 b: 6</span><br><span class="line">a:4 b: 6</span><br><span class="line">a:4 b: 6</span><br></pre></td></tr></tbody></table></figure><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/a35089f6.html" title="C++ 入门基础之五">https://www.techgrow.cn/posts/a35089f6.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/1d2ec7d.html" rel="prev" title="Debian 11 Bullseye 运维随笔"><i class="fa fa-angle-left"></i> Debian 11 Bullseye 运维随笔</a></div><div class="post-nav-item"> <a href="/posts/ab3ae9a.html" rel="next" title="Visual Studio 使用命令行编译 C/C++ 程序">Visual Studio 使用命令行编译 C/C++ 程序<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.3m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">34:56</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/a35089f6.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>