<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 入门基础的内容，包括 const 关键字、普通引用、指针引用、常引用的使用等。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 入门基础之二"><meta property="og:url" content="https://www.techgrow.cn/posts/b03c11a0.html"><meta property="og:site_name" content="Clay 的技术博客"><meta property="og:description" content="本文主要介绍 C++ 入门基础的内容，包括 const 关键字、普通引用、指针引用、常引用的使用等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/10/cplusplus-2.png"><meta property="article:published_time" content="2021-10-17T13:55:33.000Z"><meta property="article:modified_time" content="2021-10-17T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2021/10/cplusplus-2.png"><link rel="canonical" href="https://www.techgrow.cn/posts/b03c11a0.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/b03c11a0.html","path":"posts/b03c11a0.html","title":"C++ 入门基础之二"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 入门基础之二 | Clay 的技术博客</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn:9360"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术博客" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><script src="https://cdn.jsdelivr.net/npm/jquery@1.11.0/dist/jquery.min.js"></script><script data-pjax>!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><script data-ad-client="ca-pub-4014850419768221" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/color-thief-don@2.0.2/src/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=$("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=$("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}$(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://api.techgrow.cn:9080/wx/sdk/signature?url="+a+"&noncestr="+i+"&timestamp="+r;$.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt></div><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术博客</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn:9360/ui/login?lng=zh-cn" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">const 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E7%AE%80%E4%BB%8B"><span class="nav-text">const 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">const 参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">const 函数返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="nav-text">const 修饰指针变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E4%BF%AE%E9%A5%B0%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">const 修饰类成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%92%8C-define-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">const 和 #define 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E4%B8%8E-C-%E7%9A%84-const-%E5%AF%B9%E6%AF%94"><span class="nav-text">C 语言与 C++ 的 const 对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%EF%BC%88%E6%99%AE%E9%80%9A%E5%BC%95%E7%94%A8%EF%BC%89"><span class="nav-text">引用（普通引用）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D%E5%9B%9E%E9%A1%BE"><span class="nav-text">变量名回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">引用的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%98%AF-C-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">引用是 C++ 的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">引用作函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%84%8F%E4%B9%89"><span class="nav-text">引用的使用意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90"><span class="nav-text">引用的本质分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E5%BC%95%E7%94%A8"><span class="nav-text">函数返回值是引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%BD%93%E5%BC%95%E7%94%A8"><span class="nav-text">函数返回值是基础类型当引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF-static-%E5%8F%98%E9%87%8F%E5%BD%93%E5%BC%95%E7%94%A8"><span class="nav-text">函数返回值是 static 变量当引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E5%BD%A2%E5%8F%82%E5%BD%93%E5%BC%95%E7%94%A8"><span class="nav-text">函数返回值是形参当引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E9%9D%9E%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="nav-text">函数返回值是非基础类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8"><span class="nav-text">指针引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="nav-text">常引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96-const-%E5%BC%95%E7%94%A8"><span class="nav-text">使用变量初始化 const 引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E5%B8%B8%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96-const-%E5%BC%95%E7%94%A8"><span class="nav-text">使用字面量常量初始化 const 引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-%E5%BC%95%E7%94%A8%E7%BB%BC%E5%90%88%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">const 引用综合使用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-%E5%BC%95%E7%94%A8%E6%80%BB%E7%BB%93"><span class="nav-text">const 引用总结</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">325</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">39</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → &#x2F;sitemap.xml"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="external nofollow" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/b03c11a0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"><meta itemprop="description" content="专注于 Java、前端、移动端、微服务、分布式系统、数据库、系统架构、人工智能、大数据、云计算、物联网、虚拟化学习的技术博客。"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 入门基础之二</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-17 21:55:33" itemprop="dateCreated datePublished" datetime="2021-10-17T21:55:33+08:00">2021-10-17</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/b03c11a0.html#waline-comments" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" id="/posts/b03c11a0.html" data-xid="/posts/b03c11a0.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.6k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h2><h3 id="const-简介"><a href="#const-简介" class="headerlink" title="const 简介"></a>const 简介</h3><p><code>const</code> 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量、自定义对象、成员函数、返回值、函数参数。C++ 的 <code>const</code> 关键字允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用 <code>const</code>，这样可以获得编译器的帮助。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" "</span>&lt;&lt; *p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>在上述代码中，对于 <code>const</code> 变量 a，我们取变量的地址并转换赋值给 指向 <code>int</code> 的指针，然后利用 <code>*p = 8;</code> 重新赋值，然后输出查看 a 的值，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br></pre></td></tr></tbody></table></figure><p>从结果中可以看到，编译器认为 a 的值为一开始定义的 7，所以对 <code>const a</code> 的操作就会产生上面的情况。所以千万不要轻易对 <code>const</code> 变量赋值，这会产生意想不到的行为。C++ 编译器对 <code>const</code> 常量的处理机制是，当碰见常量声明时，往符号表中放入常量；在编译过程中若发现使用常量，则直接以符号表中的值替换，例如在编译过程中若发现对 <code>const</code> 常量使用了 <code>extern</code> 或者 <code>&amp;</code> 操作符，则会给对应的常量单独分配内存空间（兼容 C 语言），这也是上述代码中打印 <code>*p</code> 的值为 8 的原因，<a href="../../../asset/2021/10/cplusplus_const_1.png">点击</a>查看原理分析图。</p><hr><p>如果不想让编译器察觉到上面对 <code>const</code> 变量的操作，我们可以在 <code>const</code> 前面加上 <code>volatile</code> 关键字。<code>volatile</code> 关键字跟 <code>const</code> 刚好相反，是易变的，容易改变的意思；所以不会被编译器优化，编译器也就不会改变对 a 变量的操作。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; *p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 8</span><br></pre></td></tr></tbody></table></figure><h3 id="const-参数传递"><a href="#const-参数传递" class="headerlink" title="const 参数传递"></a>const 参数传递</h3><p>对于 <code>const</code> 修饰函数参数可以分为三种情况：</p><p>A：值传递的 <code>const</code> 修饰传递，一般这种情况不需要 <code>const</code> 修饰，因为函数会自动产生临时变量复制实参值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cpf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">    <span class="comment">// ++a;  是错误写法，a 不能被改变</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">Cpf</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>B：当 <code>const</code> 参数为指针时，可以防止指针被意外篡改。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cpf</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> a)</span> </span>{</span><br><span class="line">    cout &lt;&lt; *a &lt;&lt; endl; <span class="comment">// a 为 8</span></span><br><span class="line">    *a = <span class="number">9</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">Cpf</span>(&amp;a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// a 为 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>C：自定义类型的参数传递，需要使用临时对象复制参数，对于临时对象的构造，需要调用拷贝构造函数，比较浪费资源，因此可以采取 <code>const</code> 外加引用传递的方式。并且对于一般的 <code>int</code>、<code>double</code> 等内置类型，不需要采用引用的传递方式。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> _m) : _cm(_m) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _cm;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cmf</span><span class="params">(<span class="keyword">const</span> Test &amp; _tt)</span> </span>{</span><br><span class="line">    cout &lt;&lt; _tt.<span class="built_in">get_cm</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Cmf</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></tbody></table></figure><h3 id="const-函数返回值"><a href="#const-函数返回值" class="headerlink" title="const 函数返回值"></a>const 函数返回值</h3><p>对于 <code>const</code> 修饰函数的返回值可以分三种情况：</p><ul><li>A：<code>const</code> 修饰内置类型（如 <code>int</code>、<code>double</code>）的返回值，修饰与不修饰返回值的作用都一样。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">Cmf</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cpf</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> _m = <span class="built_in">Cmf</span>();</span><br><span class="line">    <span class="keyword">int</span> _n = <span class="built_in">Cpf</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; _m &lt;&lt; <span class="string">" "</span> &lt;&lt; _n;  <span class="comment">// 输出结果为：1 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>B：<code>const</code> 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。</p></li><li><p>C：<code>const</code> 修饰返回的指针或者引用，是否返回一个指向 <code>const</code> 的指针，取决于我们想让用户干什么。</p></li></ul><h3 id="const-修饰指针变量"><a href="#const-修饰指针变量" class="headerlink" title="const 修饰指针变量"></a>const 修饰指针变量</h3><p><code>const</code> 修饰指针变量有以下三种情况：</p><ul><li>A： <code>const</code> 修饰指针指向的内容，则内容为不可变量。</li><li>B： <code>const</code> 修饰指针，则指针为不可变量。</li><li>C： <code>const</code> 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。</li></ul><p>对于 A，则指针指向的内容不可改变，简称左定值，因为 <code>const</code> 位于 <code>*</code> 号的左边。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">// 正确写法</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//错误写法</span></span><br></pre></td></tr></tbody></table></figure><p>对于 B， <code>const</code> 指针 p 其指向的内存地址不能够被改变，但其内容可以改变。简称右定向，因为 <code>const</code> 位于 <code>*</code> 号的右边。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">*p = <span class="number">9</span>; <span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">int</span>  b = <span class="number">7</span>;</span><br><span class="line">p = &amp;b; <span class="comment">// 错误写法</span></span><br></pre></td></tr></tbody></table></figure><p>对于 C，则是 A 和 B 合并的结果，即 <code>const p</code> 指向的内容和指向的内存地址都已固定，不可改变。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br></pre></td></tr></tbody></table></figure><p>对于 A、B、C 三种情况，根据 <code>const</code> 位于 <code>*</code> 号的位置不同，可以总结三句便于记忆的话： <strong>左定值，右定向，const 修饰不变量</strong>。</p><h3 id="const-修饰类成员函数"><a href="#const-修饰类成员函数" class="headerlink" title="const 修饰类成员函数"></a>const 修饰类成员函数</h3><p><code>const</code> 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 <code>const</code> 成员函数，此时 <code>const</code> 本质上修饰的是 <code>this</code> 指针。值得一提的是，<code>const</code> 关键字不能与 <code>static</code> 关键字同时使用，因为 <code>static</code> 关键字修饰静态成员函数，而静态成员函数不含有 <code>this</code> 指针，即不能实例化，但 <code>const</code> 成员函数必须关联某一对象实例。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> _m) : _cm(_m) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="comment">// _cm = 10;  是错误写法，对象的_cm属性值不能被改变</span></span><br><span class="line">        <span class="keyword">return</span> _cm;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cmf</span><span class="params">(<span class="keyword">const</span> Test &amp; _tt)</span> </span>{</span><br><span class="line">    cout &lt;&lt; _tt.<span class="built_in">get_cm</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Cmf</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></tbody></table></figure><p>上面的 <code>int get_cm() const {}</code> 函数用到了 <code>const</code> 成员函数，如果 <code>int get_cm() {}</code> 去掉 <code>const</code> 修饰，则 <code>Cmf</code> 函数传递的 <code>const _tt</code> 即使没有改变对象的值，编译器也认为函数 <code>int get_cm() {}</code> 会改变对象的值，所以我们尽量按照要求将所有的不需要改变对象内容的函数都作为 <code>const</code> 成员函数。下述两种的写法都是合法的，效果都一样，C++ 中一般将 <code>const</code> 写在函数的末尾处。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">const</span> <span class="title">get_cm</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用 <code>mutable</code> 关键字修饰这个成员，<code>mutable</code> 的意思也是易变的，容易改变的意思，被 <code>mutable</code> 关键字修饰的成员可以处于不断变化中，如下面的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _ct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> _m, <span class="keyword">int</span> <span class="keyword">_t</span>) : _cm(_m), _ct(<span class="keyword">_t</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Kf</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="comment">// ++_cm; 错误写法</span></span><br><span class="line">        ++_ct; <span class="comment">// 正确写法</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">Kf</span>();</span><br><span class="line">    cout &lt;&lt; t._cm &lt;&lt; <span class="string">" "</span> &lt;&lt; t._ct &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 8</span><br></pre></td></tr></tbody></table></figure><p>这里在函数 <code>void Kf() const {}</code> 中可以通过 <code>++_ct;</code> 修改 <code>_ct</code> 的值，但是通过 <code>++_cm</code> 修改 <code>_cm</code> 则会报错，因为 <code>_cm</code> 没有用 <code>mutable</code> 修饰。</p><h3 id="const-和-define-的区别"><a href="#const-和-define-的区别" class="headerlink" title="const 和 #define 的区别"></a>const 和 #define 的区别</h3><p>C++ 中不但可以用 <code>#define</code> 定义常量还可以用 <code>const</code> 定义常量，例如 <code>const int c = 5; ≈ #define c 5</code>，它们的区别如下：</p><ul><li>用 <code>#define MAX 255</code> 定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，<code>#define</code> 所定义的宏变量在编译器执行预处理的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换</li><li>用 <code>const float MAX = 255;</code> 定义的常量有类型名字，存放在内存的静态区域中，在程序运行过程中 <code>const</code> 变量只有一个拷贝，而 <code>#define</code> 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比 <code>const</code> 变量的大得多</li><li>用 <code>#define</code> 定义的常量是不可以用指针变量去指向的，用 <code>const</code> 定义的常量是可以用指针去指向该常量的地址</li><li>用 <code>#define</code> 可以定义一些简单的函数，<code>const</code> 是不可以定义函数</li></ul><p><strong>编译器处理方式：</strong></p><ul><li><code>#define</code> – 在编译器的预处理阶段进行单纯的文本替换</li><li><code>const</code> – 在编译器的编译阶段确定其值</li></ul><p><strong>类型检查：</strong></p><ul><li><code>#define</code> – 无类型，不进行类型安全检查，可能会产生意想不到的错误</li><li><code>const</code> – 有数据类型，编译时会进行类型与作用域检查</li></ul><p><strong>内存空间：</strong></p><ul><li><code>#define</code> – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大</li><li><code>const</code> – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝</li></ul><p><strong>其他方面：</strong></p><ul><li>在编译时，编译器通常不为 <code>const</code> 常量分配内存空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。<code>#define</code> 宏替换只作替换，不做计算，不做表达式求解</li><li>宏定义的作用范围仅限于当前文件，默认状态下，<code>const</code> 常量只在文件内有效，当多个文件中出现了同名的 <code>const</code> 常量时，等同于在不同文件中分别定义了独立的常量。如果想在多个文件之间共享 <code>const</code> 常量，必须在常量定义之前添加 <code>extern</code> 关键字（在声明和定义时都要添加）</li></ul><h3 id="C-语言与-C-的-const-对比"><a href="#C-语言与-C-的-const-对比" class="headerlink" title="C 语言与 C++ 的 const 对比"></a>C 语言与 C++ 的 const 对比</h3><p><strong>C 语言的 const 变量：</strong></p><ul><li>C 语言中 <code>const</code> 变量是只读变量，有自己的内存空间</li><li> C 语言中，可以通过操作指针的方式来修改 <code>const</code> 变量的值</li></ul><p><strong>C++ 的 const 常量：</strong></p><ul><li>可能分配内存空间，也可能不分配内存空间</li><li>当使用 <code>&amp;</code> 操作符取 <code>const</code> 常量的地址时，会分配内存空间</li><li>当 <code>const</code> 常量为全局，并且需要在其它文件中使用，会分配内存空间</li><li>当 <code>const int &amp;a = 10;</code>，即 <code>const</code> 修饰引用时，也会分配内存空间</li></ul><blockquote><p>注意：C++ 编译器虽然可能为 <code>const</code> 常量分配内存空间，但不会使用其内存空间中的值，同时是在编译器的编译阶段分配内存空间</p></blockquote><h2 id="引用（普通引用）"><a href="#引用（普通引用）" class="headerlink" title="引用（普通引用）"></a>引用（普通引用）</h2><h3 id="变量名回顾"><a href="#变量名回顾" class="headerlink" title="变量名回顾"></a>变量名回顾</h3><ul><li>变量名实质上是一段连续内存空间的别名，是一个标号（门牌号）</li><li>程序中通过变量来申请并命名内存空间</li><li>通过变量的名称可以使用内存空间</li></ul><h3 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h3><p>在 C++ 中新增加了引用的概念：</p><ul><li>a) 引用可以看作一个已定义变量的别名</li><li> b) 引用的语法：<code>Type &amp; name = var;</code></li><li>c) 引用作为函数参数声明时，不会进行初始化</li><li> d) 普通引用在声明时必须用其它的变量进行初始化</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">// 编译器分配4个字节的内存空间，a是内存空间的别名</span></span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;  <span class="comment">// b就是a的别名，即b引用了a</span></span><br><span class="line">    a =<span class="number">11</span>;       <span class="comment">// 直接赋值</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">        *p = <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a %d \n"</span>,a);</span><br><span class="line">    }</span><br><span class="line">    b  = <span class="number">14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d b:%d"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a 12</span><br><span class="line">a:14 b:14</span><br></pre></td></tr></tbody></table></figure><h3 id="引用是-C-的概念"><a href="#引用是-C-的概念" class="headerlink" title="引用是 C++ 的概念"></a>引用是 C++ 的概念</h3><p>引用属于 C++ 编译器对 C 语言的扩展，下述代码在 C 语言中不能通过编译，这里不要用 C 语言的语法去思考 <code>b = 11</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    b = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="引用作函数参数"><a href="#引用作函数参数" class="headerlink" title="引用作函数参数"></a>引用作函数参数</h3><ul><li>普通引用在声明时必须用其它的变量进行初始化，<code>int &amp;a;</code> 这样的写法是错误的（在结构体内声明除外）</li><li>引用作为函数参数声明时，不会进行初始化</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> {</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// pT是指向t1的指针，这里相当于修改了t1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfT</span><span class="params">(Teacher *pT)</span> </span>{</span><br><span class="line">    cout &lt;&lt; pT-&gt;age &lt;&lt; endl;</span><br><span class="line">    pT-&gt;age = <span class="number">23</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// pT是t1的别名，这里相当于修改了t1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfT2</span><span class="params">(Teacher &amp; pT)</span> </span>{</span><br><span class="line">    cout &lt;&lt; pT.age &lt;&lt; endl;</span><br><span class="line">    pT.age = <span class="number">33</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// pT和t1的是两个不同的变量，这里只会修改pT变量，不会修改t1变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfT3</span><span class="params">(Teacher pT)</span> </span>{</span><br><span class="line">    cout &lt;&lt; pT.age &lt;&lt; endl;</span><br><span class="line">    pT.age = <span class="number">43</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Teacher t1;</span><br><span class="line">    t1.age = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pT是指向t1的指针</span></span><br><span class="line">    <span class="built_in">printfT</span>(&amp;t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"t1.age:%d \n"</span>, t1.age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pT是t1的别名</span></span><br><span class="line">    <span class="built_in">printfT2</span>(t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"t1.age:%d \n"</span>, t1.age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pT是形参，相当于t1复制一份数据给pT ---&gt; pT = t1</span></span><br><span class="line">    <span class="built_in">printfT3</span>(t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"t1.age:%d \n"</span>, t1.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">35</span><br><span class="line">t1.age:23</span><br><span class="line">23</span><br><span class="line">t1.age:33</span><br><span class="line">33</span><br><span class="line">t1.age:33</span><br></pre></td></tr></tbody></table></figure><h3 id="引用的使用意义"><a href="#引用的使用意义" class="headerlink" title="引用的使用意义"></a>引用的使用意义</h3><ul><li>引用作为其它变量的别名而存在，因此在一些场合可以代替指针</li><li>引用相对于指针来说，具有更好的可读性和实用性</li></ul><p>使用引用和指针，分别实现交换两个数字的 C++ 代码如下：</p><p><img data-src="../../../asset/2021/10/cplusplus-2.png" alt="cplusplus-2"></p><h3 id="引用的本质分析"><a href="#引用的本质分析" class="headerlink" title="引用的本质分析"></a>引用的本质分析</h3><ul><li>1）引用在 C++ 中的内部实现是一个常指针，<code>Type &amp; name --&gt; Type * const name</code></li><li>2）C++ 编译器在编译过程中，使用常指针作为引用的内部实现，因此引用所占用的内存空间大小与指针相同</li><li> 3）从使用的角度看，引用会让人误会其只是一个别名，没有自己的内存空间，这是 C++ 为了实用性而做出的细节隐藏</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>{</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> a)</span> </span>{</span><br><span class="line">    *a = <span class="number">15</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">func</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">func</span>(&amp;x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考上述代码，函数参数间接赋值（指针方式）成立的三个条件如下：</p><ul><li>a) 定义两个变量（一个实参一个形参）</li><li>b) 建立关联，实参取地址传给形参</li><li> c) 使用 <code>*a</code> 形参去间接的修改实参的值</li></ul><p>引用在实现上，只不过是把间接赋值成立的三个条件的后两步和二为一；当实参传给形参引用的时候，是 C++ 编译器帮程序员自动取了一个实参地址传给了形参引用（常量指针）。当我们使用引用语法的时，不需要关心编译器引用是怎么做的；当我们分析奇怪的语法现象时，我们才去考虑 C++ 编译器是怎么做的。</p><h3 id="函数返回值是引用"><a href="#函数返回值是引用" class="headerlink" title="函数返回值是引用"></a>函数返回值是引用</h3><p>当函数返回值为引用时：</p><ul><li>若函数返回的是栈变量（如作用域只在函数体内的变量），不能成为其它引用的初始值，不能作为左值使用</li><li>若函数返回的是静态变量或全局变量，可以成为其他引用的初始值，即可作为右值使用，也可作为左值使用</li></ul><h4 id="函数返回值是基础类型当引用"><a href="#函数返回值是基础类型当引用" class="headerlink" title="函数返回值是基础类型当引用"></a>函数返回值是基础类型当引用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAA1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">getAA2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">getAA3</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="built_in">getAA1</span>();</span><br><span class="line">    <span class="keyword">int</span> a2 = <span class="built_in">getAA2</span>();</span><br><span class="line">    <span class="keyword">int</span> &amp;a3 = <span class="built_in">getAA2</span>();</span><br><span class="line">    <span class="keyword">int</span> *a4 = <span class="built_in">getAA3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"a1 = "</span> &lt;&lt; a1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"a2 = "</span> &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"a3 = "</span> &lt;&lt; a3 &lt;&lt; endl;   <span class="comment">// 这里用引用去接受函数的返回值，结果是不是乱码，关键是看返回的内存空间是不是被编译器回收了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"a4 = "</span> &lt;&lt; *a4 &lt;&lt; endl;  <span class="comment">// 这里用引用去接受函数的返回值，结果是不是乱码，关键是看返回的内存空间是不是被编译器回收了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1 = 10</span><br><span class="line">a2 = 10</span><br><span class="line">a3 = 10 或者 a3 = 乱码</span><br><span class="line">a4 = 10 或者 a4 = 乱码</span><br></pre></td></tr></tbody></table></figure><h4 id="函数返回值是-static-变量当引用"><a href="#函数返回值是-static-变量当引用" class="headerlink" title="函数返回值是 static 变量当引用"></a>函数返回值是 static 变量当引用</h4><p>值得一提的是，<code>static</code> 关键字修饰变量的时候，变量是一个状态变量。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d \n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">j1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d \n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">j2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">15</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d \n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 错误写法，j()的运算结果是一个数值，没有内存地址，不能当左值，类似 11 = 100;</span></span><br><span class="line">    <span class="comment">// j() = 3;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当被调用的函数当左值的时候，必须返回一个引用</span></span><br><span class="line">    <span class="built_in">j1</span>() = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">j1</span>();</span><br><span class="line"></span><br><span class="line">    *(<span class="built_in">j2</span>()) = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">j2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:11</span><br><span class="line">a:101</span><br><span class="line">a:16</span><br><span class="line">a:201</span><br></pre></td></tr></tbody></table></figure><h4 id="函数返回值是形参当引用"><a href="#函数返回值是形参当引用" class="headerlink" title="函数返回值是形参当引用"></a>函数返回值是形参当引用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g1</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>{</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">g2</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>{</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">    a1 = <span class="built_in">g2</span>(&amp;a1);</span><br><span class="line">    <span class="keyword">int</span> &amp;a2 = <span class="built_in">g2</span>(&amp;a1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a1:%d \n"</span>, a1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a2:%d \n"</span>, a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1:100</span><br><span class="line">a2:100</span><br></pre></td></tr></tbody></table></figure><h4 id="函数返回值是非基础类型"><a href="#函数返回值是非基础类型" class="headerlink" title="函数返回值是非基础类型"></a>函数返回值是非基础类型</h4><p>如果函数返回的引用不是基础类型，而是一个类，那么此时的情况非常复杂，涉及到 <code>copy</code> 构造函数和 <code>=</code> 操作重载的知识内容，这里暂时不展开讨论。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teachar</span> {</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">struct Teachar &amp; <span class="title">OpTeacher</span><span class="params">(struct Teachar &amp;t1)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> {</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级指针作函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTe</span><span class="params">(Teacher **myp)</span> </span>{</span><br><span class="line">    Teacher *p = (Teacher *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">    p-&gt;age = <span class="number">33</span>;</span><br><span class="line">    *myp = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针引用作函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTe2</span><span class="params">(Teacher *&amp;myp)</span> </span>{</span><br><span class="line">    myp = (Teacher *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">    <span class="keyword">if</span> (myp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    myp-&gt;age = <span class="number">34</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Teacher *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">getTe</span>(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age:%d \n"</span>, p-&gt;age);</span><br><span class="line"></span><br><span class="line">    Teacher *pp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">getTe2</span>(pp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age:%d \n"</span>, pp-&gt;age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age:33</span><br><span class="line">age:34</span><br></pre></td></tr></tbody></table></figure><h3 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h3><h4 id="使用变量初始化-const-引用"><a href="#使用变量初始化-const-引用" class="headerlink" title="使用变量初始化 const 引用"></a>使用变量初始化 const 引用</h4><p>在 C++ 中可以声明 <code>const</code> 引用，例如 <code>const Type &amp; name = var;</code>，其中的 <code>const</code> 引用让变量拥有只读属性。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    <span class="comment">// b = 11;  是错误写法，这里不能通过引用改变a的值，无法通过编译</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能用指针来改变引用的值</span></span><br><span class="line">    <span class="keyword">int</span> * p = (<span class="keyword">int</span>*) &amp;b;</span><br><span class="line">    *p = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b:%d\n"</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a:%d\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;b:%d\n"</span>, &amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:11</span><br><span class="line">b:11</span><br><span class="line">&amp;a:1323872140</span><br><span class="line">&amp;b:1323872140</span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> {</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// const引用让变量(所指内存空间)拥有只读属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTe</span><span class="params">(<span class="keyword">const</span> Teacher &amp;t)</span> </span>{</span><br><span class="line">    <span class="comment">// t.age = 11;  是错误写法，无法通过编译</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 修饰指针和指针指向的内容，那么指针指向的内容都不能更改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTe2</span><span class="params">(<span class="keyword">const</span> Teacher *<span class="keyword">const</span> pt)</span> </span>{</span><br><span class="line">    <span class="comment">// pt-&gt;age = 11;  是错误写法，无法通过编译</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Teacher t1;</span><br><span class="line">    t1.age = <span class="number">33</span>;</span><br><span class="line">    <span class="built_in">printTe</span>(t1);</span><br><span class="line">    <span class="built_in">printTe2</span>(&amp;t1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用字面量常量初始化-const-引用"><a href="#使用字面量常量初始化-const-引用" class="headerlink" title="使用字面量常量初始化 const 引用"></a>使用字面量常量初始化 const 引用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b:%d\n"</span>, &amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int &amp;a = 19; 若不加const关键字，则编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;a = <span class="number">19</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a:%d \n"</span>, &amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="const-引用综合使用示例"><a href="#const-引用综合使用示例" class="headerlink" title="const 引用综合使用示例"></a>const 引用综合使用示例</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 普通引用</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量引用，让变量拥有只读属性</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;c = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量引用的初始化分为以下两种</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.用变量初始化常量引用</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;y = x;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"y:%d \n"</span>, y);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.用字面量常量初始化常量引用</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// int &amp;m = 10;  // 错误写法，引用是内存空间的别名，字面量10没有内存空间，没有方法做引用</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;m = <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="const-引用总结"><a href="#const-引用总结" class="headerlink" title="const 引用总结"></a>const 引用总结</h4><ul><li>普通引用 <code>int &amp;e = a;</code> 相当于 <code>int * const e = &amp;a;</code></li><li>常引用 <code>const int &amp; e;</code> 相当于 <code>const int * const e;</code></li><li>当使用字面量常量对 <code>const</code> 引用进行初始化时（如 <code>const int &amp;m = 10;</code>），C++ 编译器会为常量值单独分配内存空间，并将引用名作为这段内存空间的别名</li><li>使用字面量常量对 <code>const</code> 引用初始化后（如 <code>const int &amp;m = 10;</code>），将生成一个只读变量，但可以使用指针的方式更改变量的值，示例代码如下：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30</span><br><span class="line">30</span><br></pre></td></tr></tbody></table></figure></div><footer class="post-footer"><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/b03c11a0.html" title="C++ 入门基础之二">https://www.techgrow.cn/posts/b03c11a0.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎加入微信群</span><br> <img src="/img/wx-group-qr-technology.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/8bbc3f09.html" rel="prev" title="C++ 入门基础之一"><i class="fa fa-chevron-left"></i> C++ 入门基础之一</a></div><div class="post-nav-item"> <a href="/posts/f26087ad.html" rel="next" title="C++ 入门基础之三">C++ 入门基础之三<i class="fa fa-chevron-right"></i></a></div></div><div style="text-align:center"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4014850419768221" data-ad-slot="7586134725" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></footer></article></div><div class="comments" id="waline-comments"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2018 – <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">631k</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">9:34</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & NexT on Docker： "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="beian"><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备19024664号</a></div></div></footer><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-QmSAc2kIaUjleIJ46X7qPW2zrpCbXlMz3YIGgWpQ1Jo="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://unpkg.com/qiniu-js@3.3.1/dist/qiniu.min.js"></script><script>
    var qiniu_domain = "https://qiniu.techgrow.cn";
    var qiniu_token_url = "https://api.techgrow.cn:9080/qiniu/sdk/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline.techgrow.cn:9360","placeholder":"支持匿名评论啦，若希望及时收到作者的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧","pageSize":10,"visitor":false,"comment_count":true,"requiredMeta":[],"copyright":false,"allowUploadImage":true,"login":"","dark":"body.darkmode--activated","meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client@1.5.2/dist/Waline.min.js","qiniuDebug":false,"qiniuDomain":"https://qiniu.techgrow.cn","qiniuTokenUrl":"https://api.techgrow.cn:9080/qiniu/sdk/token/upload","avatar":"robohash","el":"#waline-comments","path":"/posts/b03c11a0.html"}</script><script>
document.addEventListener('page:loaded', () => {
  if(!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.uploadImage = false;
  }
  else if(CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.uploadImage = qiniuUploadImage;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),a="ipad"==i.match(/ipad/i),o="iphone os"==i.match(/iphone os/i),e="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),c="ucweb"==i.match(/ucweb/i),l="android"==i.match(/android/i),r="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(a||o||e||n||c||l||r||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;$(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||$("#aplayer").css("display","block"))}),$(window).load(function(){aplayerEnable&&$(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>