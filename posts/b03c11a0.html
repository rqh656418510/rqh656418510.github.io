<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 入门基础的内容，包括 const 关键字、普通引用、指针引用、常引用的使用等。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 入门基础之二"><meta property="og:url" content="https://www.techgrow.cn/posts/b03c11a0.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 入门基础的内容，包括 const 关键字、普通引用、指针引用、常引用的使用等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/10/cplusplus-2.png"><meta property="article:published_time" content="2021-10-17T13:55:33.000Z"><meta property="article:modified_time" content="2024-02-19T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2021/10/cplusplus-2.png"><link rel="canonical" href="https://www.techgrow.cn/posts/b03c11a0.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/b03c11a0.html","path":"posts/b03c11a0.html","title":"C++ 入门基础之二"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 入门基础之二 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-text">const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E7%AE%80%E4%BB%8B"><span class="nav-text">const 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">const 参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">const 函数返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="nav-text">const 修饰指针变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E4%BF%AE%E9%A5%B0%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">const 修饰类成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E9%92%88%E5%AF%B9%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%8D%E5%90%8C%E5%86%99%E6%B3%95"><span class="nav-text">const 针对指针的不同写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%92%8C-define-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-text">const 和 #define 的主要区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E4%B8%8E-C-%E7%9A%84-const-%E5%AF%B9%E6%AF%94"><span class="nav-text">C 语言与 C++ 的 const 对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%BC%95%E7%94%A8"><span class="nav-text">普通引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D%E5%9B%9E%E9%A1%BE"><span class="nav-text">变量名回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">引用的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%84%8F%E4%B9%89"><span class="nav-text">引用的使用意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90"><span class="nav-text">引用的本质分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">引用的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0%E7%BB%84%E5%BB%BA%E7%AB%8B%E5%BC%95%E7%94%A8"><span class="nav-text">对数组建立引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">引用作函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">引用作函数返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%BD%93%E5%BC%95%E7%94%A8"><span class="nav-text">函数返回值是基础类型当引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF-static-%E5%8F%98%E9%87%8F%E5%BD%93%E5%BC%95%E7%94%A8"><span class="nav-text">函数返回值是 static 变量当引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E5%BD%A2%E5%8F%82%E5%BD%93%E5%BC%95%E7%94%A8"><span class="nav-text">函数返回值是形参当引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E9%9D%9E%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="nav-text">函数返回值是非基础类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8"><span class="nav-text">指针引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="nav-text">常量引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96-const-%E5%BC%95%E7%94%A8"><span class="nav-text">使用普通变量初始化 const 引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E5%B8%B8%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96-const-%E5%BC%95%E7%94%A8"><span class="nav-text">使用字面量常量初始化 const 引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-const-%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">使用 const 引用作为函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="nav-text">const 引用的使用总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">770</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/b03c11a0.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 入门基础之二 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 入门基础的内容，包括 const 关键字、普通引用、指针引用、常引用的使用等。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 入门基础之二</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-17 21:55:33" itemprop="dateCreated datePublished" datetime="2021-10-17T21:55:33+08:00">2021-10-17</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-02-19 21:55:33" itemprop="dateModified" datetime="2024-02-19T21:55:33+08:00">2024-02-19</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/b03c11a0.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/b03c11a0.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>7k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>6 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8bbc3f09.html">C++ 入门基础之一</a>、<a href="/posts/b03c11a0.html">C++ 入门基础之二</a>、<a href="/posts/f26087ad.html">C++ 入门基础之三</a></li><li><a href="/posts/beb2ebb3.html">C++ 入门基础之四</a>、<a href="/posts/a35089f6.html">C++ 入门基础之五</a>、<a href="/posts/a54941f5.html">C++ 入门基础之六</a></li><li><a href="/posts/e4826e2c.html">C++ 入门基础之七</a>、<a href="/posts/4c2ae4c0.html">C++ 入门基础之八</a>、<a href="/posts/f1a16291.html">C++ 入门基础之九</a></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><div class="admonition note"><p class="admonition-title">提示</p><p><code>const</code> 关键字是 C++ 对 C 语言增强的一部分，详细介绍请看 <a href="/posts/8bbc3f09.html#const-%E5%85%B3%E9%94%AE%E5%AD%97%E5%A2%9E%E5%BC%BA">这里</a>。</p></div><h3 id="const-简介"><a href="#const-简介" class="headerlink" title="const 简介"></a>const 简介</h3><p><code>const</code> 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量、自定义对象、成员函数、返回值、函数参数等。C++ 的 <code>const</code> 关键字允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某个值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用 <code>const</code>，这样可以获得编译器的帮助。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" "</span>&lt;&lt; *p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>在上述代码中，对于 <code>const</code> 变量 a，我们取变量的地址并转换赋值给 指向 <code>int</code> 的指针，然后利用 <code>*p = 8;</code> 重新赋值，然后输出查看 a 的值，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br></pre></td></tr></tbody></table></figure><p>从结果中可以看到，编译器认为 a 的值为一开始定义的 7，所以对 <code>const a</code> 的操作就会产生上面的情况。所以千万不要轻易对 <code>const</code> 变量赋值，这会产生意想不到的行为。C++ 编译器对 <code>const</code> 常量的处理机制是，当碰见常量声明时，往符号表中放入常量；在编译过程中若发现使用常量，则直接以符号表中的值替换。特别注意，C++ 编译器在编译过程中若发现对 <code>const</code> 常量使用了 <code>extern</code> 关键字（外部链接）或者 <code>&amp;</code> 操作符（取地址），则会给对应的常量单独分配内存空间（兼容 C 语言），这也是上述代码中打印 <code>*p</code> 的值为 8 的原因，<a href="../../../asset/2021/10/cplusplus_const_1.png">点击</a>查看原理分析图。</p><hr><p>如果不想让编译器察觉到上面对 <code>const</code> 变量的操作，我们可以在 <code>const</code> 前面加上 <code>volatile</code> 关键字。<code>volatile</code> 关键字跟 <code>const</code> 刚好相反，是易变的，容易改变的意思；所以不会被编译器优化，编译器也就不会改变对 a 变量的操作。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; *p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 8</span><br></pre></td></tr></tbody></table></figure><h3 id="const-参数传递"><a href="#const-参数传递" class="headerlink" title="const 参数传递"></a>const 参数传递</h3><blockquote><p>对于 <code>const</code> 修饰函数参数可以分为以下三种情况：</p></blockquote><p>第一种情况：值传递的 <code>const</code> 修饰传递，一般这种情况不需要 <code>const</code> 修饰，因为函数会自动产生临时变量复制实参值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cpf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">    <span class="comment">// ++a;  是错误写法，a 不能改变值（只读）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">Cpf</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二种情况：当 <code>const</code> 参数为指针时，可以防止指针被意外篡改（指向其他内存地址）。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cpf</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> a)</span> </span>{</span><br><span class="line">    cout &lt;&lt; *a &lt;&lt; endl; <span class="comment">// a 为 8</span></span><br><span class="line">    *a = <span class="number">9</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">Cpf</span>(&amp;a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// a 为 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第三种情况：自定义类型的参数传递，需要使用临时对象复制参数；由于临时对象的构造需要调用拷贝构造函数，这个过程比较浪费资源，因此可以采取 <code>const</code> 外加引用传递的方式。并且对于一般的 <code>int</code>、<code>double</code> 等内置类型，不需要采用引用的传递方式。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> _m) : _cm(_m) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _cm;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cmf</span><span class="params">(<span class="keyword">const</span> Test &amp; _tt)</span> </span>{</span><br><span class="line">    cout &lt;&lt; _tt.<span class="built_in">get_cm</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Cmf</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></tbody></table></figure><h3 id="const-函数返回值"><a href="#const-函数返回值" class="headerlink" title="const 函数返回值"></a>const 函数返回值</h3><blockquote><p>对于 <code>const</code> 修饰函数的返回值可以分为以下三种情况：</p></blockquote><ul><li>第一种情况：当 <code>const</code> 修饰内置类型（如 <code>int</code>、<code>double</code>）的返回值，修饰与不修饰返回值的作用都一样。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">Cmf</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cpf</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> _m = <span class="built_in">Cmf</span>();</span><br><span class="line">    <span class="keyword">int</span> _n = <span class="built_in">Cpf</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; _m &lt;&lt; <span class="string">" "</span> &lt;&lt; _n;  <span class="comment">// 输出结果为：1 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>第二种情况：<code>const</code> 修饰自定义类型作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。</p></li><li><p>第三种情况：<code>const</code> 修饰返回的指针或者引用，是否返回一个指向 <code>const</code> 的指针，取决于我们想让用户干什么。</p></li></ul><h3 id="const-修饰指针变量"><a href="#const-修饰指针变量" class="headerlink" title="const 修饰指针变量"></a>const 修饰指针变量</h3><p><code>const</code> 修饰指针变量有以下三种情况：</p><ul><li>A： <code>const</code> 修饰指针指向的内容，则内容为不可变量。</li><li>B： <code>const</code> 修饰指针，则指针为不可变量。</li><li>C： <code>const</code> 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。</li></ul><p>对于 A，指针指向的内容不可改变，简称左定值，因为 <code>const</code> 位于 <code>*</code> 号的左边。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">// 正确写法</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//错误写法</span></span><br></pre></td></tr></tbody></table></figure><p>对于 B， <code>const</code> 指针其指向的内存地址不能够被改变，但其内容可以改变，简称右定向，因为 <code>const</code> 位于 <code>*</code> 号的右边。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">*p = <span class="number">9</span>; <span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">int</span>  b = <span class="number">7</span>;</span><br><span class="line">p = &amp;b; <span class="comment">// 错误写法</span></span><br></pre></td></tr></tbody></table></figure><p>对于 C，则是 A 和 B 合并的结果，即 <code>const</code> 指针指向的内容和指向的内存地址都已固定，不可改变。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br></pre></td></tr></tbody></table></figure><p>对于 A、B、C 三种情况，根据 <code>const</code> 相对于 <code>*</code> 号的位置不同，可以总结出三句便于记忆的话： <strong>左定值，右定向，const 修饰不变量</strong>。</p><h3 id="const-修饰类成员函数"><a href="#const-修饰类成员函数" class="headerlink" title="const 修饰类成员函数"></a>const 修饰类成员函数</h3><p><code>const</code> 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 <code>const</code> 成员函数，此时 <code>const</code> 本质上修饰的是 <code>this</code> 指针。值得一提的是，<code>const</code> 关键字不能与 <code>static</code> 关键字同时使用，因为 <code>static</code> 关键字修饰静态成员函数，而静态成员函数不含有 <code>this</code> 指针，即不能实例化，但 <code>const</code> 成员函数必须关联某一对象实例。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> _m) : _cm(_m) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="comment">// _cm = 10;  是错误写法，对象的_cm属性值不能被改变</span></span><br><span class="line">        <span class="keyword">return</span> _cm;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cmf</span><span class="params">(<span class="keyword">const</span> Test &amp; _tt)</span> </span>{</span><br><span class="line">    cout &lt;&lt; _tt.<span class="built_in">get_cm</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Cmf</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></tbody></table></figure><p>上面的 <code>int get_cm() const {}</code> 函数用到了 <code>const</code> 成员函数，如果 <code>int get_cm() {}</code> 去掉 <code>const</code> 修饰，则 <code>Cmf</code> 函数传递的 <code>const _tt</code> 即使没有改变对象的值，编译器也认为函数 <code>int get_cm() {}</code> 会改变对象的值，所以我们尽量按照要求将所有的不需要改变对象内容的函数都作为 <code>const</code> 成员函数。下述两种的写法都是合法的，效果都一样，C++ 中一般将 <code>const</code> 写在函数的末尾处。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">const</span> <span class="title">get_cm</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用 <code>mutable</code> 关键字修饰这个成员，<code>mutable</code> 的意思也是易变的，容易改变的意思，被 <code>mutable</code> 关键字修饰的成员可以处于不断变化中，如下面的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _ct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> _m, <span class="keyword">int</span> <span class="keyword">_t</span>) : _cm(_m), _ct(<span class="keyword">_t</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Kf</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="comment">// ++_cm; 错误写法</span></span><br><span class="line">        ++_ct; <span class="comment">// 正确写法</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">Kf</span>();</span><br><span class="line">    cout &lt;&lt; t._cm &lt;&lt; <span class="string">" "</span> &lt;&lt; t._ct &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 8</span><br></pre></td></tr></tbody></table></figure><p>这里在函数 <code>void Kf() const {}</code> 中可以通过 <code>++_ct;</code> 修改 <code>_ct</code> 的值，但是通过 <code>++_cm</code> 修改 <code>_cm</code> 则会报错，因为 <code>_cm</code> 没有用 <code>mutable</code> 修饰。</p><h3 id="const-针对指针的不同写法"><a href="#const-针对指针的不同写法" class="headerlink" title="const 针对指针的不同写法"></a>const 针对指针的不同写法</h3><table><thead><tr><th>写法</th><th>含义（读法）</th><th>什么是常量</th><th>类型分类</th></tr></thead><tbody><tr><td><code>const char * p</code></td><td>指向 <code>const char</code> 的指针</td><td>指针所指向的对象是常量</td><td>常量指针（pointer to const）</td></tr><tr><td><code>char const * p</code></td><td>指向 <code>const char</code> 的指针</td><td>指针所指向的对象是常量</td><td>常量指针（pointer to const）</td></tr><tr><td><code>char * const p</code></td><td>指针 <code>p</code> 本身是 <code>const</code>，但可以改指向的内容</td><td>指针本身是常量</td><td>指针常量（const pointer）</td></tr><tr><td><code>const char * const p</code></td><td>指向 <code>const char</code> 的指针常量</td><td>指针本身、指向的数据都是常量</td><td>指向常量的指针常量（const pointer to const）</td></tr><tr><td><code>char const * const p</code></td><td>指向 <code>const char</code> 的指针常量</td><td>指针本身、指向的数据都是常量</td><td>指向常量的指针常量（const pointer to const）</td></tr></tbody></table><table><thead><tr><th>写法</th><th>口诀判断（左定值，右定向）</th><th>指针是否可变</th><th>指向的数据是否可变</th><th>结果</th></tr></thead><tbody><tr><td><code>const char * p</code></td><td>const 在 <code>*</code> 左边（定值）</td><td>是</td><td>否</td><td>常量指针（指针可变，指向的数据不可改）</td></tr><tr><td><code>char const * p</code></td><td>const 在 <code>*</code> 左边（定值）</td><td>是</td><td>否</td><td>常量指针（指针可变，指向的数据不可改）</td></tr><tr><td><code>char * const p</code></td><td>const 在 <code>*</code> 右边（定向）</td><td>否</td><td>是</td><td>指针常量（指针不可变，指向的数据可改）</td></tr><tr><td><code>const char * const p</code></td><td>左定值 + 右定向 → 两者都受限</td><td>否</td><td>否</td><td>指向常量的指针常量（指针和指向的数据都不可变）</td></tr><tr><td><code>char const * const p</code></td><td>左定值 + 右定向 → 两者都受限</td><td>否</td><td>否</td><td>指向常量的指针常量（指针和指向的数据都不可变）</td></tr></tbody></table><hr><ul><li><p>(1) <code>const char *</code></p><ul><li>含义：<ul><li>指向 <code>const char</code> 的指针（常量指针）</li></ul></li><li>特性：<ul><li>指针：可以改</li><li>指向的数据：不能改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = str;</span><br><span class="line">p = other;   <span class="comment">// 正确写法：指针可变</span></span><br><span class="line">*p = <span class="string">'A'</span>;    <span class="comment">// 错误写法：不能修改指针所指向的内容</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：<ul><li>跟 <code>char const *</code> 表示的意义完全一致<strong>（<code>const</code> 放在类型前或后含义都相同）</strong>，只是写法不同</li></ul></li></ul></li><li><p> (2) <code>char const *</code></p><ul><li>含义：<ul><li>指向 <code>const char</code> 的指针（常量指针）</li></ul></li><li>特性：<ul><li>指针：可以改</li><li>指向的数据：不能改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *p = str;</span><br><span class="line">p = other;   <span class="comment">// 正确写法：指针可变</span></span><br><span class="line">*p = <span class="string">'A'</span>;    <span class="comment">// 错误写法：不能修改指针所指向的内容</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：<ul><li>跟 <code>const char *</code> 表示的意义完全一致<strong>（<code>const</code> 放在类型前或后含义都相同）</strong>，只是写法不同</li></ul></li></ul></li><li><p> (3) <code>char * const</code></p><ul><li>含义：<ul><li><code>const</code> 指针（指针常量）指向 <code>char</code></li></ul></li><li>特性：<ul><li>指针：不能改</li><li>指向的数据：可以改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = str;</span><br><span class="line">p = other;   <span class="comment">// 错误写法：指针本身不能变</span></span><br><span class="line">*p = <span class="string">'A'</span>;    <span class="comment">// 正确写法：可以修改指针所指向的内容</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>(4) <code>const char * const p</code></p><ul><li>含义：<ul><li>指向 <code>const char</code> 的 <code>const</code> 指针（指向常量的指针常量）</li><li>也就是：指针本身不能变，指向的数据也不能变</li></ul></li><li>特性：<ul><li>指针：不能改</li><li>指向的数据：不能改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p = str;</span><br><span class="line">p = other;     <span class="comment">// 错误写法：指针 p 是 const，不可改变</span></span><br><span class="line">*p = <span class="string">'A'</span>;      <span class="comment">// 错误写法：指向的数据是 const，不可修改</span></span><br><span class="line"><span class="keyword">char</span> c = p[<span class="number">0</span>]; <span class="comment">// 正确写法：可以读取数据</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：<ul><li>跟 <code>char const * const p</code> 表示的意义完全一致<strong>（<code>const</code> 放在类型前或后含义都相同）</strong>，只是写法不同</li></ul></li></ul></li><li><p> (5) <code>char const * const p</code></p><ul><li>含义：<ul><li>指向 <code>const char</code> 的 <code>const</code> 指针（指向常量的指针常量）</li><li>也就是：指针本身不能变，指向的数据也不能变</li></ul></li><li>特性：<ul><li>指针：不能改</li><li>指向的数据：不能改</li></ul></li><li>示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[]   = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> other[] = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> p = str;</span><br><span class="line">p = other;     <span class="comment">// 错误写法：指针 p 是 const，不可改变</span></span><br><span class="line">*p = <span class="string">'A'</span>;      <span class="comment">// 错误写法：指向的数据是 const，不可修改</span></span><br><span class="line"><span class="keyword">char</span> c = p[<span class="number">1</span>]; <span class="comment">// 正确写法：可以读取数据</span></span><br></pre></td></tr></tbody></table></figure></li><li>注意：<ul><li>跟 <code>const char * const p</code> 表示的意义完全一致<strong>（<code>const</code> 放在类型前或后含义都相同）</strong>，只是写法不同</li></ul></li></ul></li></ul><h3 id="const-和-define-的主要区别"><a href="#const-和-define-的主要区别" class="headerlink" title="const 和 #define 的主要区别"></a>const 和 #define 的主要区别</h3><p>C++ 中不但可以用 <code>#define</code> 定义常量（即宏常量），例如 <code>#define c 5</code>，还可以用 <code>const</code> 定义常量，例如 <code>const int c = 5;</code>，它们的区别如下：</p><ul><li>用 <code>#define MAX 255</code> 定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，<code>#define</code> 所定义的宏常量在编译器执行预处理的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换</li><li>用 <code>const float MAX = 255;</code> 定义的常量是有类型的，存放在内存的静态区域中，在程序运行过程中 <code>const</code> 变量只有一个拷贝，而 <code>#define</code> 所定义的宏常量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比 <code>const</code> 变量的大得多</li><li>用 <code>#define</code> 定义的常量是不可以用指针变量去指向的，用 <code>const</code> 定义的常量是可以用指针去指向该常量的地址</li><li>用 <code>#define</code> 可以定义一些简单的函数，<code>const</code> 是不可以定义函数</li></ul><p><strong>编译器处理方式：</strong></p><ul><li><code>#define</code>：在编译器的预处理阶段进行单纯的文本替换</li><li><code>const</code>：在编译器的编译阶段确定其值</li></ul><p><strong>类型检查：</strong></p><ul><li><code>#define</code>：无类型，不进行类型安全检查，可能会产生意想不到的错误</li><li><code>const</code>：有类型，编译时会进行类型与作用域检查</li></ul><p><strong>内存空间：</strong></p><ul><li><code>#define</code>：不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大</li><li><code>const</code>：在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝</li></ul><p><strong>其他方面：</strong></p><ul><li>在编译时，编译器通常不为 <code>const</code> 常量分配内存空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。<code>#define</code> 宏替换只作替换，不做计算，不做表达式求解</li><li>宏定义的作用范围仅限于当前文件，默认状态下，<code>const</code> 常量只在文件内有效，当多个文件中出现了同名的 <code>const</code> 常量时，等同于在不同文件中分别定义了独立的常量。如果想在多个文件之间共享 <code>const</code> 常量，必须在常量定义之前添加 <code>extern</code> 关键字（在声明和定义时都要添加）</li></ul><h3 id="C-语言与-C-的-const-对比"><a href="#C-语言与-C-的-const-对比" class="headerlink" title="C 语言与 C++ 的 const 对比"></a>C 语言与 C++ 的 const 对比</h3><p><strong>C 语言的 const 变量：</strong></p><ul><li>C 语言中的 <code>const</code> 变量属于伪常量</li><li> C 语言中的 <code>const</code> 变量是只读变量，有自己的内存空间</li><li> C 语言中，可以通过操作指针的方式来修改 <code>const</code> 变量的值</li><li> C 语言中，<code>const</code> 变量不是编译器在编译时可以确定的常量（即不属于编译期常量），而是运行时的常量，所以 <code>const</code> 变量不可以作为数组的大小</li></ul><p><strong>C++ 的 const 常量：</strong></p><ul><li>C++ 中的 <code>const</code> 常量属于真常量</li><li> C++ 中，不可以通过操作指针的方式来修改 <code>const</code> 常量的值</li><li> C++ 中，<code>const</code> 常量可能分配内存空间，也可能不分配内存空间</li><li>当使用 <code>&amp;</code> 操作符取 <code>const</code> 常量的地址时，编译器会临时开辟一块内存空间</li><li>当 <code>const</code> 常量为全局，并且需要在其它文件中使用（利用 <code>extern</code> 外部链接），编译器会分配内存空间</li><li>当使用字面量常量初始化 <code>const</code> 引用（即常量引用），如 <code>const int &amp;a = 10;</code>，编译器会分配内存空间</li><li> C++ 中，<code>const</code> 常量是编译器在编译时可以确定的常量（即属于编译期常量），而不是运行时的常量。在编译期间所有出现 <code>const</code> 常量名称的地方，都会被 <code>const</code> 常量的初始化值替换掉，所以 <code>const</code> 常量可以作为数组的大小</li><li> C++ 中，<code>const</code> 常量使用字面量来初始化（如 <code>const int a = 10;</code>）和使用变量来初始化（如 <code>int b = 10; const int a = b;</code>）是有区别的，前者不可以通过操作指针的方式来修改常量的值，而后者却是可以（通常也叫做常变量，其特性跟 C 语言的 <code>const</code> 变量一样）</li></ul><div class="admonition warning"><p class="admonition-title">注意</p><p>C++ 编译器虽然可能为 <code>const</code> 常量分配内存空间，但不会使用其内存空间中的值，而且是在编译器的编译阶段分配内存空间</p></div><h2 id="普通引用"><a href="#普通引用" class="headerlink" title="普通引用"></a>普通引用</h2><h3 id="变量名回顾"><a href="#变量名回顾" class="headerlink" title="变量名回顾"></a>变量名回顾</h3><ul><li>变量名实质上是一段连续内存空间的别名，是一个标号（门牌号）</li><li>程序中通过变量来申请并命名内存空间</li><li>通过变量的名称可以使用内存空间</li></ul><h3 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h3><p>在 C++ 中新增加了引用的概念：</p><ul><li>(a) 引用可以看作一个已定义变量的别名</li><li> (b) 引用的语法：<code>Type &amp; 别名 = 原名</code></li><li>(c) 引用作为函数参数声明时，不会进行初始化</li><li> (d) 普通引用在声明时必须用其它的变量进行初始化</li><li> (e) 当 <code>&amp;</code> 写在左侧叫引用，如 <code>int &amp;b = a;</code>，当 <code>&amp;</code> 写在右侧叫取地址，如 <code>int *p = (int *) &amp;a;</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">//编译器分配4个字节内存，a是内存空间的别名</span></span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;  <span class="comment">// b就是a的别名，即b引用了a</span></span><br><span class="line">    a = <span class="number">11</span>;      <span class="comment">//直接赋值</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">        *p = <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a = %d \n"</span>, a);</span><br><span class="line">    }</span><br><span class="line">    b = <span class="number">14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d"</span>, a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">demo1</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 12 </span><br><span class="line">a = 14, b = 14</span><br></pre></td></tr></tbody></table></figure><blockquote><p>引用是 C++ 的概念，属于 C++ 编译器对 C 语言的扩展，下述代码在 C 语言中不能通过编译，这里不要用 C 语言的语法去思考 <code>b = 11</code>。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    b = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="引用的使用意义"><a href="#引用的使用意义" class="headerlink" title="引用的使用意义"></a>引用的使用意义</h3><ul><li>引用作为其它变量的别名而存在，因此在一些场合可以代替指针</li><li>引用相对于指针来说，具有更好的可读性和实用性</li></ul><p>使用引用和指针，分别实现交换两个数字的 C++ 代码如下：</p><p><img data-src="../../../asset/2021/10/cplusplus-2.png" alt="cplusplus-2"></p><h3 id="引用的本质分析"><a href="#引用的本质分析" class="headerlink" title="引用的本质分析"></a>引用的本质分析</h3><ul><li>1）引用在 C++ 中的内部实现是一个常指针，<code>Type &amp; name --&gt; Type * const name</code></li><li>2）C++ 编译器在编译过程中，使用常指针作为引用的内部实现，因此引用所占用的内存空间大小与指针相同</li><li> 3）从使用的角度看，引用会让人误会其只是一个别名，没有自己的内存空间，这是 C++ 为了实用性而做出的细节隐藏</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 编译器发现函数参数是引用时，会自动转换为 int * const ref = &amp;a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">(<span class="keyword">int</span> &amp;ref)</span> </span>{</span><br><span class="line">    ref = <span class="number">100</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;aRef = a;      <span class="comment">// C++ 编译器会自动转换为 int * const aRef = &amp;a，这就能说明引用为什么必须初始化</span></span><br><span class="line">    aRef = <span class="number">20</span>;          <span class="comment">// C++ 编译器发现 aRef 是引用时，会自动转换为 *aRef = 20</span></span><br><span class="line">    <span class="built_in">testFunc</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"aRef = "</span> &lt;&lt; aRef &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考下述代码，函数参数间接赋值（指针方式）成立的三个条件如下：</p><ul><li>(a) 定义两个变量（一个形参一个实参）</li><li>(b) 建立关联，实参取地址传给形参</li><li> (c) 使用 <code>*a</code> 形参去间接的修改实参的值</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>{</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> a)</span> </span>{</span><br><span class="line">    *a = <span class="number">15</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">func</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">func</span>(&amp;x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>引用在实现上，只不过是把间接赋值成立的三个条件的后两步和二为一；当实参传给形参引用的时候，是 C++ 编译器帮程序员自动取了一个实参地址传给了形参引用（常量指针）。当我们使用引用语法的时，不需要关心编译器引用是怎么做的；当我们分析奇怪的语法现象时，我们才去考虑 C++ 编译器是怎么做的。</p><h3 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h3><p>在 C++ 中使用引用时，需要注意以下几点：</p><ul><li>可以对数组建立引用。</li><li><code>&amp;</code> 在引用中不是求地址运算符，而是起标识作用。</li><li>当函数的返回值是引用时，这个函数调用可以作为左值。</li><li>当函数的返回值是引用时，不要返回局部变量的引用，否则会出现意想不到的结果。</li><li>普通引用在声明时必须用其它的变量进行初始化，<code>int &amp;a;</code> 这样的写法是错误的（在结构体内声明除外）。</li><li>不允许有 NULL 引用，且引用必须是和一块合法的内存空间关联，<code>int &amp;a = 10;</code> 这样的写法是错误的。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用必须初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// int &amp;a;  必须初始化，否则编译不通过</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;d = b;</span><br><span class="line">    <span class="comment">// int &amp;d = c;  引用初始化后不可修改，否则编译不通过</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用必须是和一块合法的内存空间关联</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// int &amp;a = 10;   引用必须是和一块合法的内存空间关联，否则编译不通过</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的返回值是引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">hello</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 返回局部变量的引用</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当函数的返回值是引用时，不要返回局部变量的引用，否则会出现意想不到的结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> &amp;ref = <span class="built_in">hello</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"ref = "</span> &lt;&lt; ref &lt;&lt; endl;    <span class="comment">// 第一次正确打印值，是因为编译器做了优化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"ref = "</span> &lt;&lt; ref &lt;&lt; endl;    <span class="comment">// 第二次之后都无法正确打印值，会出现乱码现象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"ref = "</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ref = "</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ref = "</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的返回值是引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">bye</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回全局变量的引用</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当函数的返回值是引用时，这个函数调用可以作为左值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">bye</span>() = <span class="number">100</span>;    <span class="comment">// 相当于写了 a = 100</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ref = 10</span><br><span class="line">ref = 32692</span><br><span class="line">ref = 32692</span><br><span class="line">ref = 32692</span><br><span class="line">ref = 32692</span><br></pre></td></tr></tbody></table></figure><h3 id="对数组建立引用"><a href="#对数组建立引用" class="headerlink" title="对数组建立引用"></a>对数组建立引用</h3><p>在 C++ 中，对数组建立引用有两种常用的方式，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组建立引用（第一种方式）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给数组起别名</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (&amp;pArr)[<span class="number">10</span>] = arr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) {</span><br><span class="line">        cout &lt;&lt; pArr[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组建立引用（第二种方式）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个具有 10 个元素的 int 类型的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(ARRAYREF)</span>[10]</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给数组起别名</span></span><br><span class="line">    ARRAYREF &amp;pArr = arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) {</span><br><span class="line">        cout &lt;&lt; pArr[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br></pre></td></tr></tbody></table></figure><h3 id="引用作函数参数"><a href="#引用作函数参数" class="headerlink" title="引用作函数参数"></a>引用作函数参数</h3><ul><li>普通引用在声明时必须用其它的变量进行初始化，<code>int &amp;a;</code> 这样的写法是错误的（在结构体内声明除外）</li><li>引用作为函数参数声明时，不会进行初始化</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> {</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// pT是指向t1的指针，这里相当于修改了t1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfT</span><span class="params">(Teacher *pT)</span> </span>{</span><br><span class="line">    cout &lt;&lt; pT-&gt;age &lt;&lt; endl;</span><br><span class="line">    pT-&gt;age = <span class="number">23</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// pT是t1的别名，这里相当于修改了t1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfT2</span><span class="params">(Teacher &amp; pT)</span> </span>{</span><br><span class="line">    cout &lt;&lt; pT.age &lt;&lt; endl;</span><br><span class="line">    pT.age = <span class="number">33</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// pT和t1的是两个不同的变量，这里只会修改pT变量，不会修改t1变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfT3</span><span class="params">(Teacher pT)</span> </span>{</span><br><span class="line">    cout &lt;&lt; pT.age &lt;&lt; endl;</span><br><span class="line">    pT.age = <span class="number">43</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Teacher t1;</span><br><span class="line">    t1.age = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pT是指向t1的指针</span></span><br><span class="line">    <span class="built_in">printfT</span>(&amp;t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"t1.age:%d \n"</span>, t1.age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pT是t1的别名</span></span><br><span class="line">    <span class="built_in">printfT2</span>(t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"t1.age:%d \n"</span>, t1.age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pT是形参，相当于t1复制一份数据给pT ---&gt; pT = t1</span></span><br><span class="line">    <span class="built_in">printfT3</span>(t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"t1.age:%d \n"</span>, t1.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">35</span><br><span class="line">t1.age:23</span><br><span class="line">23</span><br><span class="line">t1.age:33</span><br><span class="line">33</span><br><span class="line">t1.age:33</span><br></pre></td></tr></tbody></table></figure><h3 id="引用作函数返回值"><a href="#引用作函数返回值" class="headerlink" title="引用作函数返回值"></a>引用作函数返回值</h3><p>当函数返回值为引用时：</p><ul><li>若函数返回的是栈变量（局部变量，即作用域只在函数体内的变量），不能成为其它引用的初始值，不能作为左值使用</li><li>若函数返回的是静态变量或全局变量，可以成为其他引用的初始值，即可作为右值使用，也可作为左值使用</li></ul><h4 id="函数返回值是基础类型当引用"><a href="#函数返回值是基础类型当引用" class="headerlink" title="函数返回值是基础类型当引用"></a>函数返回值是基础类型当引用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAA1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">getAA2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">getAA3</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="built_in">getAA1</span>();</span><br><span class="line">    <span class="keyword">int</span> a2 = <span class="built_in">getAA2</span>();</span><br><span class="line">    <span class="keyword">int</span> &amp;a3 = <span class="built_in">getAA2</span>();</span><br><span class="line">    <span class="keyword">int</span> *a4 = <span class="built_in">getAA3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"a1 = "</span> &lt;&lt; a1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"a2 = "</span> &lt;&lt; a2 &lt;&lt; endl;   <span class="comment">// 这里用普通变量去接受函数的返回值，结果是不是乱码，关键是看返回的内存空间是不是被编译器回收了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"a3 = "</span> &lt;&lt; a3 &lt;&lt; endl;   <span class="comment">// 这里用引用去接受函数的返回值，结果是不是乱码，关键是看返回的内存空间是不是被编译器回收了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"a4 = "</span> &lt;&lt; *a4 &lt;&lt; endl;  <span class="comment">// 这里用引用去接受函数的返回值，结果是不是乱码，关键是看返回的内存空间是不是被编译器回收了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1 = 10</span><br><span class="line">a2 = 10 或者 a2 = 乱码</span><br><span class="line">a3 = 10 或者 a3 = 乱码</span><br><span class="line">a4 = 10 或者 a4 = 乱码</span><br></pre></td></tr></tbody></table></figure><h4 id="函数返回值是-static-变量当引用"><a href="#函数返回值是-static-变量当引用" class="headerlink" title="函数返回值是 static 变量当引用"></a>函数返回值是 static 变量当引用</h4><p>值得一提的是，<code>static</code> 关键字修饰变量的时候，变量是一个状态变量。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d \n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">j1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d \n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">j2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">15</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d \n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 错误写法，j()的运算结果是一个数值，没有内存地址，不能当左值，类似 11 = 100;</span></span><br><span class="line">    <span class="comment">// j() = 3;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当被调用的函数当左值的时候，必须返回一个引用</span></span><br><span class="line">    <span class="built_in">j1</span>() = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">j1</span>();</span><br><span class="line"></span><br><span class="line">    *(<span class="built_in">j2</span>()) = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">j2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:11</span><br><span class="line">a:101</span><br><span class="line">a:16</span><br><span class="line">a:201</span><br></pre></td></tr></tbody></table></figure><h4 id="函数返回值是形参当引用"><a href="#函数返回值是形参当引用" class="headerlink" title="函数返回值是形参当引用"></a>函数返回值是形参当引用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g1</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>{</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">g2</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>{</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">    a1 = <span class="built_in">g2</span>(&amp;a1);</span><br><span class="line">    <span class="keyword">int</span> &amp;a2 = <span class="built_in">g2</span>(&amp;a1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a1:%d \n"</span>, a1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a2:%d \n"</span>, a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1:100</span><br><span class="line">a2:100</span><br></pre></td></tr></tbody></table></figure><h4 id="函数返回值是非基础类型"><a href="#函数返回值是非基础类型" class="headerlink" title="函数返回值是非基础类型"></a>函数返回值是非基础类型</h4><p>如果函数返回的引用不是基础类型，而是一个结构体或类，那么此时的情况非常复杂，涉及到拷贝构造函数和 <code>=</code> 操作符重载的知识内容，这里暂时不展开讨论。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teachar</span> {</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">struct Teachar &amp; <span class="title">OpTeacher</span><span class="params">(struct Teachar &amp;t1)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> {</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级指针作函数参数</span></span><br><span class="line"><span class="comment">// 函数参数说明： **p 是 Person 对象，*p 是 Person 对象的指针，p 是指针的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocatMemory1</span><span class="params">(Person **p)</span> </span>{</span><br><span class="line">    *p = (Person *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    (*p)-&gt;age = <span class="number">18</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    Person *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">allocatMemory1</span>(&amp;p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; p-&gt;age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针引用作函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocatMemory2</span><span class="params">(Person *&amp;p)</span> </span>{</span><br><span class="line">    p = (Person *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    p-&gt;age = <span class="number">20</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    Person *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">allocatMemory2</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; p-&gt;age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = 18</span><br><span class="line">age = 20</span><br></pre></td></tr></tbody></table></figure><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><h3 id="使用普通变量初始化-const-引用"><a href="#使用普通变量初始化-const-引用" class="headerlink" title="使用普通变量初始化 const 引用"></a>使用普通变量初始化 const 引用</h3><p>在 C++ 中可以使用普通变量声明 <code>const</code> 引用，例如 <code>const Type &amp; name = var;</code>，其中的 <code>const</code> 引用让普通变量拥有了只读属性，但可以使用指针的方式更改 <code>const</code> 引用的值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用普通变量初始化 const 引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b = 11;  错误写法，这里不能通过引用改变 a 的值，无法通过编译</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用指针的方式更改 const 引用的值</span></span><br><span class="line">    <span class="keyword">int</span> * p = (<span class="keyword">int</span>*) &amp;b;</span><br><span class="line">    *p = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b:%d\n"</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a:%d\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;b:%d\n"</span>, &amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:11</span><br><span class="line">b:11</span><br><span class="line">&amp;a:1323872140</span><br><span class="line">&amp;b:1323872140</span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> {</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// const引用让变量(所指内存空间)拥有只读属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTe</span><span class="params">(<span class="keyword">const</span> Teacher &amp;t)</span> </span>{</span><br><span class="line">    <span class="comment">// t.age = 11;  是错误写法，无法通过编译</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 修饰指针和指针指向的内容，那么指针指向的内容都不能更改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTe2</span><span class="params">(<span class="keyword">const</span> Teacher *<span class="keyword">const</span> pt)</span> </span>{</span><br><span class="line">    <span class="comment">// pt-&gt;age = 11;  是错误写法，无法通过编译</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Teacher t1;</span><br><span class="line">    t1.age = <span class="number">33</span>;</span><br><span class="line">    <span class="built_in">printTe</span>(t1);</span><br><span class="line">    <span class="built_in">printTe2</span>(&amp;t1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用字面量常量初始化-const-引用"><a href="#使用字面量常量初始化-const-引用" class="headerlink" title="使用字面量常量初始化 const 引用"></a>使用字面量常量初始化 const 引用</h3><p>当使用字面量常量对 <code>const</code> 引用进行初始化时（如 <code>const int &amp;m = 10;</code>），C++ 编译器会为常量值单独分配内存空间，并将引用名作为这段内存空间的别名；也就是会生成一个只读变量，但可以使用指针的方式更改 <code>const</code> 引用的值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用必须是和一块合法的内存空间关联，若不加 const 关键字，则编译失败</span></span><br><span class="line">    <span class="comment">// int &amp;a = 19;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用字面量常量初始化 const 引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用指针的方式更改 const 引用的值</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*p = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">*p = 20</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-const-引用作为函数参数"><a href="#使用-const-引用作为函数参数" class="headerlink" title="使用 const 引用作为函数参数"></a>使用 const 引用作为函数参数</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数是 const 引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;val)</span> </span>{</span><br><span class="line">    <span class="comment">// 无法直接更改形参的值，编译会不通过</span></span><br><span class="line">    <span class="comment">// val = 10;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但可以使用指针的方式更改形参的值</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;val;</span><br><span class="line">    *p = <span class="number">30</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">showValue</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 30</span><br></pre></td></tr></tbody></table></figure><h3 id="const-引用的使用总结"><a href="#const-引用的使用总结" class="headerlink" title="const 引用的使用总结"></a>const 引用的使用总结</h3><ul><li>普通引用语法 <code>int &amp;e = a;</code> 相当于 <code>int * const e = &amp;a;</code>，<strong>普通引用的本质是常指针</strong></li><li>常量引用语法 <code>const int &amp;e;</code> 相当于 <code>const int * const e;</code></li><li>当使用字面量常量对 <code>const</code> 引用进行初始化时（如 <code>const int &amp;m = 10;</code>），C++ 编译器会为常量值单独分配内存空间，并将引用名作为这段内存空间的别名</li><li>当使用字面量常量对 <code>const</code> 引用初始化后（如 <code>const int &amp;m = 10;</code>），将生成一个只读变量，但可以使用指针的方式更改 <code>const</code> 引用的值</li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/b03c11a0.html" title="C++ 入门基础之二">https://www.techgrow.cn/posts/b03c11a0.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/8bbc3f09.html" rel="prev" title="C++ 入门基础之一"><i class="fa fa-angle-left"></i> C++ 入门基础之一</a></div><div class="post-nav-item"> <a href="/posts/f26087ad.html" rel="next" title="C++ 入门基础之三">C++ 入门基础之三<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.3m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">34:10</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/b03c11a0.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>