<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 如何实现 RPC 分布式网络通信框架，使用了 Muduo、Protobuf、ZooKeeper 等技术。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 实现 RPC 分布式网络通信框架"><meta property="og:url" content="https://www.techgrow.cn/posts/5e6aa28a.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 如何实现 RPC 分布式网络通信框架，使用了 Muduo、Protobuf、ZooKeeper 等技术。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/06/cxx-rpc-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/06/cxx-rpc-2.png"><meta property="article:published_time" content="2025-06-08T13:55:33.000Z"><meta property="article:modified_time" content="2025-06-21T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Linux系统编程"><meta property="article:tag" content="RPC"><meta property="article:tag" content="C++"><meta property="article:tag" content="网络编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/06/cxx-rpc-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/5e6aa28a.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/5e6aa28a.html","path":"posts/5e6aa28a.html","title":"C++ 实现 RPC 分布式网络通信框架"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 实现 RPC 分布式网络通信框架 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%88%97%E8%A1%A8"><span class="nav-text">开发工具列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E6%BA%90-RPC-%E6%A1%86%E6%9E%B6"><span class="nav-text">开源 RPC 框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E5%8E%82%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6"><span class="nav-text">大厂开源框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6"><span class="nav-text">个人开源框架</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-text">集群和分布式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="nav-text">RPC 通信原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C-I-O-%E6%A8%A1%E5%9E%8B"><span class="nav-text">网络 I/O 模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="nav-text">框架介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Muduo-%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-text">Muduo 的简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Protobuf-%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-text">Protobuf 的简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper-C-API-%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-text">ZooKeeper C API 的简介</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-text">准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-Boost-%E5%BA%93"><span class="nav-text">安装 Boost 库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%9D-Muduo-%E5%BA%93"><span class="nav-text">安裝 Muduo 库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-Protobuf-%E5%BA%93"><span class="nav-text">安装 Protobuf 库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-ZooKeeper-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">安装 ZooKeeper 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-ZooKeeper-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">安装 ZooKeeper 服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-ZooKeeper-C-API-%E5%BA%93"><span class="nav-text">安装 ZooKeeper C API 库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="nav-text">项目介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="nav-text">项目结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%8E%9F%E7%90%86"><span class="nav-text">项目原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="nav-text">项目技术栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81"><span class="nav-text">项目代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC-%E6%A1%86%E6%9E%B6%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="nav-text">RPC 框架核心代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7"><span class="nav-text">网络工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="nav-text">异步日志记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="nav-text">配置文件读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Protobuf-%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6"><span class="nav-text">Protobuf 协议文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">RPC 框架的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="nav-text">RPC 框架的服务注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="nav-text">RPC 框架的服务调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZooKeeper-%E7%9A%84%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="nav-text">ZooKeeper 的访问操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC-%E6%A1%86%E6%9E%B6%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">RPC 框架测试代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Protobuf-%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6-1"><span class="nav-text">Protobuf 协议文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-RPC-%E6%A1%86%E6%9E%B6%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="nav-text">使用 RPC 框架提供服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-RPC-%E6%A1%86%E6%9E%B6%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="nav-text">使用 RPC 框架调用服务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD"><span class="nav-text">项目代码下载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95"><span class="nav-text">项目测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95"><span class="nav-text">项目调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96"><span class="nav-text">项目优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">755</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/5e6aa28a.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 实现 RPC 分布式网络通信框架 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 如何实现 RPC 分布式网络通信框架，使用了 Muduo、Protobuf、ZooKeeper 等技术。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 实现 RPC 分布式网络通信框架</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-06-08 21:55:33" itemprop="dateCreated datePublished" datetime="2025-06-08T21:55:33+08:00">2025-06-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-06-21 21:55:33" itemprop="dateModified" datetime="2025-06-21T21:55:33+08:00">2025-06-21</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/5e6aa28a.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/5e6aa28a.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>7.6k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>7 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/def1afc3.html">C++ 网络编程 Muduo 库使用</a></li><li><a href="/posts/e635f0aa.html">基于 C++ 开发集群聊天服务器</a></li><li><a href="/posts/5e6aa28a.html">C++ 实现 RPC 分布式网络通信框架</a></li><li><a href="/posts/dbb10768.html">基于 C++ 手写 Muduo 高性能网络库</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 17 + Muduo 高性能网络库 + Protobuf 开发一个 RPC 框架，并使用中间件 ZooKeeper 作为注册中心。</p><span id="more"></span><h3 id="开发工具列表"><a href="#开发工具列表" class="headerlink" title="开发工具列表"></a>开发工具列表</h3><table><thead><tr><th>软件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> C++ 标准</td><td><code>17</code></td><td>高版本的 Protobuf 库依赖 C++ 17</td></tr><tr><td>Boost</td><td><code>1.74.0.3</code></td><td>Muduo 库依赖 Boost 库</td></tr><tr><td> Muduo</td><td><code>2.0.3</code></td><td><a target="_blank" rel="external nofollow" href="https://github.com/chenshuo/muduo">Muduo 库</a>，基于 C++ 开发，用于网络编程</td></tr><tr><td> Protobuf</td><td><code>31.1</code></td><td><a target="_blank" rel="external nofollow" href="https://github.com/protocolbuffers/protobuf">Protobuf 库</a>，核心代码主要是用 C++ 开发</td></tr><tr><td> ZooKeeper C API</td><td><code>3.8.0</code></td><td>ZooKeeper 提供的原生 C API，基于 C 语言开发</td></tr><tr><td> G++（GCC）</td><td><code>12.2.0</code></td><td>建议使用 <code>9</code> 版本的 G++（GCC） 编译器</td></tr><tr><td> CMake</td><td><code>3.25.1</code></td><td>C/C++ 项目构建工具</td></tr><tr><td> ZooKeeper</td><td><code>3.8.0</code></td><td>ZooKeeper 服务器</td></tr><tr><td> Linux</td><td><code>Debian 12</code></td><td>Muduo 库不支持 Windows 平台</td></tr><tr><td> Visual Studio Code</td><td><code>1.100.2</code></td><td>使用 VSCode 远程开发特性</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">平台兼容性说明</p><p>由于使用了 Muduo 库，且 Muduo 库仅支持 Linux 平台；因此本文提供的所有 RPC 框架代码支持在 Linux 平台运行，不支持 Windows 平台，默认是基于 Debian 12 进行远程开发。</p></div><h3 id="开源-RPC-框架"><a href="#开源-RPC-框架" class="headerlink" title="开源 RPC 框架"></a>开源 RPC 框架</h3><h4 id="大厂开源框架"><a href="#大厂开源框架" class="headerlink" title="大厂开源框架"></a>大厂开源框架</h4><ul><li><a target="_blank" rel="external nofollow" href="https://github.com/grpc/grpc">gRPC</a> 是一个由 Google 开源、基于 HTTP/2 和 Protocol Buffers 的高性能 RPC 框架，使用 C++ 开发，支持多种语言（如 Go、Java、Python 等）。</li><li><a target="_blank" rel="external nofollow" href="https://github.com/apache/brpc">bRPC</a> 是百度开源的高性能、可扩展的 RPC 框架，主要用于服务器间通信，采用 C++ 编写，广泛应用于百度内部大规模分布式系统中。</li><li><a target="_blank" rel="external nofollow" href="https://github.com/Tencent/phxrpc">phxrpc</a> 是腾讯微信后台团队推出的一个非常简洁小巧的 RPC 框架，编译生成的库只有 450K。</li></ul><h4 id="个人开源框架"><a href="#个人开源框架" class="headerlink" title="个人开源框架"></a>个人开源框架</h4><ul><li><a target="_blank" rel="external nofollow" href="https://github.com/Gooddbird/tinyrpc">tinyrpc</a> - c++ async rpc framework. 14w+ qps.</li><li><a target="_blank" rel="external nofollow" href="https://github.com/Gooddbird/rocket">rocket</a> - c++ rpc framework, simplified version of tinyrpc.</li><li><a target="_blank" rel="external nofollow" href="https://github.com/qicosmos/rest_rpc">rest_rpc</a> - modern c++, simple, easy to use rpc framework.</li><li><a target="_blank" rel="external nofollow" href="https://github.com/rpclib/rpclib">rpclib</a> - a modern c++ msgpack-RPC server and client library.</li><li><a target="_blank" rel="external nofollow" href="https://github.com/TarsCloud/TarsCpp?tab=readme-ov-file">TarsCpp</a> - c++ language framework rpc source code implementation.</li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="集群和分布式"><a href="#集群和分布式" class="headerlink" title="集群和分布式"></a>集群和分布式</h3><ul><li><p><strong>集群</strong></p><ul><li>概念<ul><li>每一台服务器独立运行一个工程的所有模块。</li></ul></li><li>优点<ul><li>部署简单：每台机器部署一样的工程，维护相对简单。</li><li>容错性强：某台机器宕机，其它机器可以顶上，保证服务连续。</li><li>扩展方便：增加机器即可横向扩展，提高并发处理能力。</li><li>负载均衡容易：前端加个负载均衡器即可实现请求均衡分发。</li></ul></li><li>缺点<ul><li>资源浪费：每台机器都部署所有模块，某些模块可能资源使用率低。</li><li>维护更新不灵活：改动一个模块需要重新部署整个工程。</li><li>扩展粒度粗：不能单独扩展某个压力大的模块（有些模块是 CPU 密集型，有些模块是 I/O 密集型），只能整体扩容。</li></ul></li></ul></li><li><p><strong>分布式</strong></p><ul><li>概念<ul><li>一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务。</li><li>每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</li></ul></li><li>优点<ul><li>资源利用率高：按模块实际资源需求进行部署，提高系统整体资源使用效率。</li><li>扩展灵活：哪个模块压力大就单独扩展它，不影响其它模块。</li><li>服务解耦：模块之间独立部署、独立维护，开发和运维更灵活。</li><li>技术异构性好：不同模块可以使用不同的技术栈，更自由地选择工具。</li></ul></li><li>缺点<ul><li>系统复杂度高：涉及服务间通信、分布式事务、网络延迟等问题。</li><li>开发运维成本高：部署、调试、监控、容错等方面的技术要求更高。</li><li>依赖网络稳定性：模块之间通过网络通信，一旦网络出问题可能会引发级联故障。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">详细图解说明</p><ul><li><a href="../../../asset/2025/01/cluster-distribute-1.png">集群和分布式的理解</a></li><li><a href="../../../asset/2024/12/dubbo-16.png">单体架构的部署拓扑图</a></li><li><a href="../../../asset/2024/12/dubbo-15.png">集群架构的部署拓扑图</a></li><li><a href="../../../asset/2024/12/dubbo-14.png">分布式架构的部署拓扑图</a></li></ul></div><div class="admonition warning"><p class="admonition-title">特别注意</p><p><strong>在企业的生产环境中，集群和分布式是并存的，两者并不是分开的。</strong></p></div><h3 id="RPC-通信原理"><a href="#RPC-通信原理" class="headerlink" title="RPC 通信原理"></a>RPC 通信原理</h3><p>RPC（Remote Procedure Call）远程过程调用的工作流程如下图所示：</p><p><img data-src="../../../asset/2025/06/cxx-rpc-1.png"></p><ul><li><strong>黄色部分</strong>：设计 RPC 方法参数的打包和解析，也就是数据的序列化和反序列化，可以使用 Protobuf 实现。</li><li><strong>绿色部分</strong>：网络通信部分，包括寻找 RPC 服务主机、发起 RPC 调用请求和响应 RPC 调用结果，可以使用 Muduo 网络库和 ZooKeeper（用于服务注册与发现）实现 。</li></ul><h3 id="网络-I-O-模型"><a href="#网络-I-O-模型" class="headerlink" title="网络 I/O 模型"></a>网络 I/O 模型</h3><p>主流的网络 I/O 模型有以下几种，Muduo 采用的是第四种（<code>reactors in threads - one loop per thread</code>）。</p><ul><li><p>(1) <code>accept + read/write</code></p><ul><li>不适用于并发服务器</li></ul></li><li><p> (2) <code>accept + fork - process-pre-connection</code></p><ul><li>适合并发连接数不大，计算任务工作量大于 Fork 的开销。</li></ul></li><li><p>(3) <code>accept + thread - thread-pre-connection</code></p><ul><li>比第二种网络 I/O 模型的开销小了一点，但是并发造成的线程堆积过多。</li></ul></li><li><p>(4) <code>reactors in threads - one loop per thread</code></p><ul><li>这是 Muduo 库的网络设计方案，底层实质上是基于 Linux 的 <code>epoll</code> + <code>pthread</code> 线程池实现，且依赖了 Boost 库，适用于并发连接数较大的场景。</li><li>有一个 Main Reactor 负载 Accept 连接，然后将连接分发给某个 SubReactor（采用轮询的方式来选择 SubReactor），该连接的所用操作都在那个 SubReactor 所处的线程中完成。多个连接可能被分派到多个线程中被处理，以充分利用 CPU。</li><li>有一个 Base I/O Thread 负责 Accept 新的连接，接收到新的连接以后，使用轮询的方式在 Reactor Pool 中找到合适的 SubReactor 将这个连接挂载上去，这个连接上的所有任务都在这个 SubReactor 所处的线程中完成。</li><li>Reactor Poll 的大小是固定的，根据 CPU 的核心数量来确定。如果有过多的耗费 CPU 资源的计算任务，可以提交到 ThreadPool 线程池中专门处理耗时的计算任务。</li></ul></li><li><p>(5) <code>reactors in process - one loop pre process</code></p><ul><li>这是 Nginx 服务器的网络设计方案，基于进程设计，采用多个 Reactors 充当 I/O 进程和工作进程，通过一个 <code>accept</code> 锁，完美解决多个 Reactors 之间的 “惊群现象”。</li></ul></li></ul><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>本文基于 C++ 实现 RPC 框架时，使用到以下框架，主要包括 Muduo、Protobuf、ZooKeeper C API。</p><h3 id="Muduo-的简介"><a href="#Muduo-的简介" class="headerlink" title="Muduo 的简介"></a>Muduo 的简介</h3><p>Muduo 是一个用 C++ 编写的高性能、基于事件驱动的网络库，专门设计用于构建 Linux 下高并发、低延迟的网络服务，特别适合开发分布式系统、微服务、消息中间件、网络游戏服务器等后端程序。</p><ul><li><p>核心特性</p><ul><li>基于事件驱动模型：使用 Reactor 模式，即单线程 I/O + 多线程计算。</li><li>高性能：使用 <code>epoll</code> I/O 多路复用技术、非阻塞 I/O、零内存拷贝技术。</li><li>线程安全：网络部分是线程安全的，使用线程池和回调。</li><li>C++ 11 标准：需要使用支持 C++ 11 的编译器。</li><li>仅支持 Linux 平台：利用 Linux 特性优化性能，不支持跨平台。</li><li>可组合性强：解耦的模块设计，便于扩展和组合。</li></ul></li><li><p>核心模块</p><ul><li><code>base</code>（基础模块）<ul><li>非网络相关的通用工具</li><li>如线程池、时间戳、日志系统、原子操作等</li></ul></li><li><code>net</code>（网络模块）<ul><li>TCP 服务器 / 客户端模型</li><li> Reactor 事件分发器</li><li> Buffer、Channel、EventLoop、TcpConnection 等核心组件</li></ul></li></ul></li><li><p>核心组件</p><ul><li>EventLoop<ul><li> 事件循环，是每个线程的核心对象</li><li>封装了 <code>epoll</code> 库，处理文件描述符的读写事件</li></ul></li><li> Channel<ul><li> 表示一个 <code>fd</code>（文件描述符）及其感兴趣的事件（如读写）</li><li>是 EventLoop 与具体 I/O 事件之间的桥梁</li></ul></li><li> Poller<ul><li> 封装 <code>epoll</code> 或 <code>poll</code> 的接口（Muduo 默认用 <code>epoll</code>）</li></ul></li><li>TcpServer / TcpClient<ul><li> 高层封装，简化服务端和客户端的使用</li><li>支持多线程连接处理</li></ul></li><li> Callback 机制<ul><li>所有 I/O 事件都通过用户注册的回调函数处理（高扩展性）</li></ul></li></ul></li><li><p>性能优势</p><ul><li>完全采用非阻塞、异步 I/O 模型</li><li>使用智能指针管理资源（如 <code>std::shared_ptr&lt;TcpConnection&gt;</code>）</li><li>零内存拷贝的数据缓冲机制（Buffer）</li><li>合理利用多线程资源（EventLoopThreadPool）</li></ul></li><li><p>适用场景</p><ul><li>高并发 TCP 服务器（如 Redis、MQTT、游戏网关）</li><li>微服务通信框架（可自定义通信协议）</li><li>高性能 HTTP 服务（支持 HTTP 1.0/1.1）</li><li>自研 RPC 系统</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">平台兼容性</p><ul><li>Muduo 库只支持 Linux 平台，不兼容 Windows 平台，因为其底层使用了 Linux 平台的 <code>pthread</code> 和 <code>epoll</code>。</li></ul></div><h3 id="Protobuf-的简介"><a href="#Protobuf-的简介" class="headerlink" title="Protobuf 的简介"></a>Protobuf 的简介</h3><ul><li><p>Protocol Buffers（简称 Protobuf）是 Google 提出的一种高效、可扩展的结构化数据序列化格式，用于数据交换。它独立于平台和编程语言，具有良好的跨平台兼容性和扩展性。</p></li><li><p>Google 为多种主流编程语言提供了 Protobuf 的官方实现，包括 Java、C#、C++、Go 和 Python 等。每种语言的实现都包含相应的编译器插件（<code>protoc</code>）和运行时库，使得开发者可以在不同语言间无缝进行数据通信。</p></li><li><p>由于 Protobuf 采用紧凑的二进制编码格式，其序列化和反序列化效率远高于基于文本的格式。相比 XML，Protobuf 的传输效率可提高约 20 倍；相比 JSON，也有近 10 倍的性能提升。这使得它特别适用于对性能要求高的场景。</p></li><li><p>Protobuf 广泛应用于分布式系统间的数据通信、异构平台的数据交换，也适合用作网络传输协议的数据格式、高效配置文件的载体、或用于数据持久化存储。作为一种兼具效率与可维护性的序列化方案，Protobuf 在大规模系统设计中具有极高的实用价值。</p></li></ul><h3 id="ZooKeeper-C-API-的简介"><a href="#ZooKeeper-C-API-的简介" class="headerlink" title="ZooKeeper C API 的简介"></a>ZooKeeper C API 的简介</h3><p>ZooKeeper C API 是 ZooKeeper 提供的一套原生 C 语言接口，它提供两个版本，包括 <code>libzookeeper_mt</code>（多线程版）和 <code>libzookeeper_st</code>（单线程版），可以用于 C/C++ 编写客户端程序，通常使用的是 <code>libzookeeper_mt</code>（多线程版）。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-Boost-库"><a href="#安装-Boost-库" class="headerlink" title="安装 Boost 库"></a>安装 Boost 库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Boost 的所有组件和头文件</span></span><br><span class="line">sudo apt-get install -y libboost-all-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Bootst 版本</span></span><br><span class="line">sudo dpkg -s libboost-all-dev | grep Version</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>由于 Muduo 使用了 Boost 库（如 <code>boost::any</code>），因此需要安装 Boost 库。</p></div><h3 id="安裝-Muduo-库"><a href="#安裝-Muduo-库" class="headerlink" title="安裝 Muduo 库"></a>安裝 Muduo 库</h3><ul><li>编译安装 Muduo 库</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Git 克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chenshuo/muduo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入代码目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir -p build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证安装</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Muduo 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/muduo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Muduo 库的静态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib | grep muduo</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Muduo 的编译依赖 CMake 和 Boost 库，默认编译生成的是静态库（<code>.a</code>），如果需要编译生成共享库（<code>.so</code>），可以自行修改 <code>CMakeLists.txt</code> 中的配置。</li><li>Muduo 支持 C++ 11，仅支持 Linux 平台，不支持 Windows 平台，建议使用 <code>7.x</code> 及以后版本的 <code>g++</code> 编译器。</li></ul></div><h3 id="安装-Protobuf-库"><a href="#安装-Protobuf-库" class="headerlink" title="安装 Protobuf 库"></a>安装 Protobuf 库</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Protobuf 各个版本的源码包可以从 <a target="_blank" rel="external nofollow" href="https://github.com/protocolbuffers/protobuf/releases">GitHub Release</a> 下载得到。</li><li>Protobuf 从 <code>3.21</code> 版本开始，Google 官方已经弃用了 <code>autogen.sh</code> 和 <code>configure</code> 构建系统，转而使用 CMake 作为主要构建系统。</li><li>Protobuf 从源码编译后，默认只会生成 <code>.a</code> 静态库文件，若希望生成 <code>.so</code> 动态库文件，需要在编译时添加 CMake 参数 <code>-DBUILD_SHARED_LIBS=ON</code>，加上参数后只会生成 <code>.so</code> 动态库文件。</li></ul></div><ul><li>安装依赖包</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install cmake g++ make git wget</span><br></pre></td></tr></tbody></table></figure><ul><li>编译安装 Protobuf 库</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://github.com/protocolbuffers/protobuf/archive/refs/tags/v31.1.tar.gz -O protobuf-v31.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf protobuf-v31.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> protobuf-31.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化子模块</span></span><br><span class="line">git init &amp;&amp; git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入构建目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件（Makefile）</span></span><br><span class="line">cmake .. -DBUILD_SHARED_LIBS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码（耗时较长）</span></span><br><span class="line">make -j2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装（包括可执行文件、头文件和库）</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/<span class="built_in">local</span>/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 Protobuf 库安装</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Protobuf 库的版本</span></span><br><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Protobuf 库的头文件</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/include/google/protobuf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Protobuf 库的动态库</span></span><br><span class="line">ls -al /usr/<span class="built_in">local</span>/lib/libproto*</span><br></pre></td></tr></tbody></table></figure><h3 id="安装-ZooKeeper-中间件"><a href="#安装-ZooKeeper-中间件" class="headerlink" title="安装 ZooKeeper 中间件"></a>安装 ZooKeeper 中间件</h3><h4 id="安装-ZooKeeper-服务器"><a href="#安装-ZooKeeper-服务器" class="headerlink" title="安装 ZooKeeper 服务器"></a>安装 ZooKeeper 服务器</h4><ul><li>安装 ZooKeeper 服务器</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ZooKeeper 客户端和服务器</span></span><br><span class="line">sudo apt install -y zookeeper zookeeperd</span><br></pre></td></tr></tbody></table></figure><ul><li>添加 ZooKeeper 客户端的软链接</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 客户端的安装位置</span></span><br><span class="line">sudo dpkg -L zookeeper | grep -E <span class="string">'zkCli.sh|zkEnv.sh'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ZooKeeper 客户端的软链接（方便以后直接运行客户端）</span></span><br><span class="line">sudo ln -s /usr/share/zookeeper/bin/zkCli.sh /usr/<span class="built_in">local</span>/bin/zkCli.sh</span><br><span class="line">sudo ln -s /usr/share/zookeeper/bin/zkEnv.sh /usr/<span class="built_in">local</span>/bin/zkEnv.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 ZooKeeper 服务器安装</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 服务器的运行状态</span></span><br><span class="line">sudo systemctl status zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 ZooKeeper 客户端连接 ZooKeeper 服务器</span></span><br><span class="line">zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></tbody></table></figure><ul><li>ZooKeeper 服务器的安装信息</li></ul><table><thead><tr><th>安装信息</th><th>说明</th></tr></thead><tbody><tr><td>默认的监听端口</td><td><code>2181</code></td></tr><tr><td>默认的数据目录</td><td><code>/tmp/zookeeper</code></td></tr><tr><td>默认配置文件的路径</td><td><code>/etc/zookeeper/conf/zoo.cfg</code></td></tr></tbody></table><h4 id="安装-ZooKeeper-C-API-库"><a href="#安装-ZooKeeper-C-API-库" class="headerlink" title="安装 ZooKeeper C API 库"></a>安装 ZooKeeper C API 库</h4><p>由于本文的 RPC 项目使用 ZooKeeper C API 库来实现 RPC 服务动态注册和发现，因此需要安装 ZooKeeper C API 库。值得一提的是，ZooKeeper 提供了一个 <code>libzookeeper_mt</code>（多线程版）或 <code>libzookeeper_st</code>（单线程版）原生 C API，可以用于 C/C++ 编写客户端程序，通常使用的是 <code>libzookeeper_mt</code>（多线程版）。在 Linux 系统上，除了可以通过 APT / YUM 包管理工具直接安装 ZooKeeper C API 库，还可以手动编译 ZooKeeper 的源码来安装 ZooKeeper C API 库，具体编译步骤为 <code>.configure</code> + <code>make</code> + <code>makeinstall</code>，默认会编译生成多线程版本的库（<code>libzookeeper_mt.so</code>）和单线程版的库（如 <code>libzookeeper_st.so</code>）。</p><ul><li>安装 ZooKeeper C API 库</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ZooKeeper 多线程版的开发包（单线程版本是：libzookeeper-st-dev）</span></span><br><span class="line">sudo apt install -y libzookeeper-mt-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统的共享库缓存</span></span><br><span class="line">sudo ldconfig /usr/lib/</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 ZooKeeper C API 库安装</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 ZooKeeper 的头文件</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep zookeeper.h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 的静态库</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep <span class="string">'\.a$'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 的动态库</span></span><br><span class="line">sudo dpkg -L libzookeeper-mt-dev | grep <span class="string">'\.so'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>ZooKeeper C API 库的安装信息</li></ul><table><thead><tr><th>安装信息</th><th>说明</th></tr></thead><tbody><tr><td>头文件的路径</td><td><code>/usr/include/zookeeper/zookeeper.h</code></td></tr><tr><td>静态库的路径</td><td><code>/usr/lib/x86_64-linux-gnu/libzookeeper_mt.a</code></td></tr><tr><td>动态库的路径</td><td><code>/usr/lib/x86_64-linux-gnu/libzookeeper_mt.so</code></td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">使用原生 ZooKeeper C API 库的注意事项</p><ul><li>(1) 设置监听 Watcher 是一次性的，监听事件触发后 Watch 会立即失效，ZooKeeper 不会自动重新注册。若希望持续监听同一个节点变化，需要在回调中手动再次注册 Watch。</li><li>(2) ZNode 节点仅支持存储简单的 <code>byte</code> 字节数组（最大 1MB），不具备结构化存储能力。如果需要存储结构体或对象，需要自行将其转换为字节数组，例如使用 JSON、Protobuf 等序列化方式进行编码与解码。</li></ul></div><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">c++-project-mprpc</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── conf</span><br><span class="line">│   └── rpc.conf</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── consumer</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── rpcconsumer.cc</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   ├── friend.pb.cc</span><br><span class="line">│   │   ├── friend.pb.h</span><br><span class="line">│   │   ├── user.pb.cc</span><br><span class="line">│   │   └── user.pb.h</span><br><span class="line">│   ├── proto</span><br><span class="line">│   │   ├── friend.proto</span><br><span class="line">│   │   └── user.proto</span><br><span class="line">│   └── provider</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">│       └── rpcprovider.cc</span><br><span class="line">├── lib</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   ├── rpcheader.pb.cc</span><br><span class="line">│   │   └── rpcheader.pb.h</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   ├── lockqueue.h</span><br><span class="line">│   │   ├── logger.h</span><br><span class="line">│   │   ├── mprpccontext.h</span><br><span class="line">│   │   ├── mprpcchannel.h</span><br><span class="line">│   │   ├── mprpcconfig.h</span><br><span class="line">│   │   ├── mprpccontroller.h</span><br><span class="line">│   │   ├── mprpcprovider.h</span><br><span class="line">│   │   ├── networkutil.h</span><br><span class="line">│   │   └── zookeeperclient.h</span><br><span class="line">│   ├── logger.cc</span><br><span class="line">│   ├── mprpccontext.cc</span><br><span class="line">│   ├── mprpcchannel.cc</span><br><span class="line">│   ├── mprpcconfig.cc</span><br><span class="line">│   ├── mprpccontroller.cc</span><br><span class="line">│   ├── mprpcprovider.cc</span><br><span class="line">│   ├── networkutil.cc</span><br><span class="line">│   ├── proto</span><br><span class="line">│   │   └── rpcheader.proto</span><br><span class="line">│   └── zookeeperclient.cc</span><br><span class="line">└── test</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── protobuf</span><br><span class="line">    │   ├── CMakeLists.txt</span><br><span class="line">    │   ├── generated</span><br><span class="line">    │   │   ├── addressbook.pb.cc</span><br><span class="line">    │   │   ├── addressbook.pb.h</span><br><span class="line">    │   │   ├── friendservice.pb.cc</span><br><span class="line">    │   │   ├── friendservice.pb.h</span><br><span class="line">    │   │   ├── groupservice.pb.cc</span><br><span class="line">    │   │   ├── groupservice.pb.h</span><br><span class="line">    │   │   ├── userservice.pb.cc</span><br><span class="line">    │   │   └── userservice.pb.h</span><br><span class="line">    │   ├── main.cc</span><br><span class="line">    │   └── proto</span><br><span class="line">    │       ├── addressbook.proto</span><br><span class="line">    │       ├── friendservice.proto</span><br><span class="line">    │       ├── groupservice.proto</span><br><span class="line">    │       └── userservice.proto</span><br><span class="line">    └── zookeeper</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        └── main.cc</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>目录名称</th><th>目录说明</th></tr></thead><tbody><tr><td><code>build</code></td><td>CMake 编译构建项目的目录（项目首次编译后才会有）</td></tr><tr><td><code>bin</code></td><td>存放项目编译生成的可执行文件的目录（项目首次编译后才会有）</td></tr><tr><td><code>lib</code></td><td>存放项目编译生成的 RPC 框架头文件和静态库的目录（项目首次编译后才会有）</td></tr><tr><td><code>conf</code></td><td>存放 RPC 框架的配置文件</td></tr><tr><td><code>proto</code></td><td>存放 Protobuf 的 <code>.proto</code> 协议文件</td></tr><tr><td><code>generated</code></td><td>存放根据 <code>.proto</code> 协议文件生成的 C++ 头文件和源文件</td></tr><tr><td><code>src</code></td><td>RPC 框架源码</td></tr><tr><td><code>test</code></td><td>第三方库的测试代码</td></tr><tr><td><code>test/protobuf/</code></td><td>Protobuf 的测试代码</td></tr><tr><td><code>test/zookeeper/</code></td><td>ZooKeeper 的测试代码</td></tr><tr><td><code>example</code></td><td>RPC 框架的使用案例代码</td></tr><tr><td><code>example/provider</code></td><td>RPC 框架（服务提供者）的使用案例代码</td></tr><tr><td><code>example/consumer</code></td><td>RPC 框架（服务调用者）的使用案例代码</td></tr><tr><td><code>autobuild.sh</code></td><td>项目一键编译构建的脚本文件</td></tr></tbody></table><h3 id="项目原理"><a href="#项目原理" class="headerlink" title="项目原理"></a>项目原理</h3><p><img data-src="../../../asset/2025/06/cxx-rpc-2.png"></p><h3 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h3><p>基于 C++ 开发 RPC 框架时，使用到以下技术：</p><ul><li>单例模式</li><li> Conf 配置文件读取</li><li> Muduo 网络库编程</li><li> CMake 构建项目集成编译环境</li><li>异步日志记录（线程同步通信实现）</li><li>Protobuf 数据序列化和反序列化协议</li><li> ZooKeeper 分布式一致性协调服务应用以及编程</li></ul><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><h3 id="RPC-框架核心代码"><a href="#RPC-框架核心代码" class="headerlink" title="RPC 框架核心代码"></a>RPC 框架核心代码</h3><p>由于篇幅有限，下面只给出 RPC 框架项目的核心代码，完整的项目代码可以从 <a target="_blank" rel="external nofollow" href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-mprpc">这里</a> 获取得到。</p><h4 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h4><ul><li><code>networkutil.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ifaddrs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络工具类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkUtil</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkUtil&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地的 IP 地址，可指定网络接口名称（比如 eth0）</span></span><br><span class="line">    <span class="function">std::string <span class="title">FindLocalIp</span><span class="params">(<span class="keyword">const</span> std::string&amp; network_interface = <span class="string">""</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个未被占用的端口，可指定端口区间（比如 [7000, 9000]）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindAvailablePort</span><span class="params">(<span class="keyword">int</span> low = <span class="number">7000</span>, <span class="keyword">int</span> high = <span class="number">9000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">NetworkUtil</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NetworkUtil</span>(<span class="keyword">const</span> NetworkUtil&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    NetworkUtil&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NetworkUtil&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>networkutil.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"networkutil.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">NetworkUtil&amp; <span class="title">NetworkUtil::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> NetworkUtil instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本地的 IP 地址，可指定网络接口名称（比如 eth0）</span></span><br><span class="line"><span class="function">std::string <span class="title">NetworkUtil::FindLocalIp</span><span class="params">(<span class="keyword">const</span> std::string&amp; network_interface)</span> </span>{</span><br><span class="line">    std::string result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地网络接口的信息链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span>* <span class="title">ifaddr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getifaddrs</span>(&amp;ifaddr) == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// Fallback 处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历本地网络接口的信息链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* ifa = ifaddr; ifa; ifa = ifa-&gt;ifa_next) {</span><br><span class="line">        <span class="keyword">if</span> (!ifa-&gt;ifa_addr || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取网络接口的名称</span></span><br><span class="line">        <span class="function">std::string <span class="title">name</span><span class="params">(ifa-&gt;ifa_name)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过 lo 接口（回环接口）</span></span><br><span class="line">        <span class="keyword">if</span> (ifa-&gt;ifa_flags &amp; IFF_LOOPBACK) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指定了网络接口（如 eth0），且匹配上了，就直接使用</span></span><br><span class="line">        <span class="keyword">if</span> (!network_interface.<span class="built_in">empty</span>() &amp;&amp; name == network_interface) {</span><br><span class="line">            <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;((struct sockaddr_in*)ifa-&gt;ifa_addr)-&gt;sin_addr, ip, <span class="built_in"><span class="keyword">sizeof</span></span>(ip));</span><br><span class="line">            result = ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认选择 eth0、ens33、enp0s3 等常见有线网卡</span></span><br><span class="line">        <span class="keyword">if</span> (network_interface.<span class="built_in">empty</span>() &amp;&amp; (name.<span class="built_in">find</span>(<span class="string">"eth"</span>) == <span class="number">0</span> || name.<span class="built_in">find</span>(<span class="string">"en"</span>) == <span class="number">0</span>)) {</span><br><span class="line">            <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;((struct sockaddr_in*)ifa-&gt;ifa_addr)-&gt;sin_addr, ip, <span class="built_in"><span class="keyword">sizeof</span></span>(ip));</span><br><span class="line">            result = ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">freeifaddrs</span>(ifaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">empty</span>() ? <span class="string">"127.0.0.1"</span> : result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个未被占用的端口，可指定端口区间（比如 [7000, 9000]）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NetworkUtil::FindAvailablePort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历指定区间内的所有端口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> port = low; port &lt;= high; ++port) {</span><br><span class="line">        <span class="comment">// 创建一个 IPv4 TCP Socket</span></span><br><span class="line">        <span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 创建 Socket 失败，尝试下一个端口</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 Socket 地址，绑定到任意本地地址（0.0.0.0）和当前端口</span></span><br><span class="line">        sockaddr_in addr{};</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Socket 选项：SO_REUSEADDR 允许端口重复绑定（避免 TIME_WAIT 问题）</span></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in"><span class="keyword">sizeof</span></span>(opt));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试将 Socket 绑定到指定端口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (sockaddr*)&amp;addr, <span class="built_in"><span class="keyword">sizeof</span></span>(addr)) == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 绑定成功，释放资源（因为这里只是探测端口是否可用）</span></span><br><span class="line">            <span class="built_in">close</span>(sockfd);</span><br><span class="line">            <span class="comment">// 返回找到的可用端口</span></span><br><span class="line">            <span class="keyword">return</span> port;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 端口绑定失败，说明端口已被占用或其他错误，释放资源</span></span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历完指定的端口区间，没有找到可用端口，返回 -1 表示失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="异步日志记录"><a href="#异步日志记录" class="headerlink" title="异步日志记录"></a>异步日志记录</h4><ul><li><code>lockqueue.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步写日志的日志队列（线程安全）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 往队尾插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入数据</span></span><br><span class="line">        m_queue.<span class="built_in">push</span>(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒日志写入线程去消费队列中的数据</span></span><br><span class="line">        m_condvariable.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往队头弹出数据</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到队列不为空或者已退出</span></span><br><span class="line">        m_condvariable.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>() || m_exit; });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视业务逻辑而定，可以返回空数据或者抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (m_exit &amp;&amp; m_queue.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span> {};</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        T data = m_queue.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出队头元素</span></span><br><span class="line">        m_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭队列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 设置退出标志</span></span><br><span class="line">        m_exit = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 唤醒正在等待的日志写入线程</span></span><br><span class="line">        m_condvariable.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取退出标志</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isExit</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m_exit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex m_mutex;                      <span class="comment">// 互斥锁</span></span><br><span class="line">    std::queue&lt;T&gt; m_queue;                   <span class="comment">// 队列</span></span><br><span class="line">    std::condition_variable m_condvariable;  <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="keyword">bool</span> m_exit = <span class="literal">false</span>;                     <span class="comment">// 退出标志，用于避免发生线程死锁</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>logger.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lockqueue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(logmsgformat, ...)                                \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= DEBUG) {                        \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {DEBUG, c, thread_id};                 \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(logmsgformat, ...)                                 \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= INFO) {                         \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {INFO, c, thread_id};                  \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARN(logmsgformat, ...)                                 \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= WARN) {                         \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {WARN, c, thread_id};                  \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERROR(logmsgformat, ...)                                \</span></span><br><span class="line"><span class="meta">    do {                                                            \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::GetInstance();                     \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (logger.GetLogLevel() &lt;= ERROR) {                        \</span></span><br><span class="line"><span class="meta">            char c[1024] = {0};                                     \</span></span><br><span class="line"><span class="meta">            snprintf(c, 1024, logmsgformat, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">            std::thread::id thread_id = std::this_thread::get_id(); \</span></span><br><span class="line"><span class="meta">            LogMessage msg = {ERROR, c, thread_id};                 \</span></span><br><span class="line"><span class="meta">            logger.Log(msg);                                        \</span></span><br><span class="line"><span class="meta">        }                                                           \</span></span><br><span class="line"><span class="meta">    } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别（DEBUG &lt; INFO &lt; WARN &lt; ERROR）</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LogLevel</span> {</span></span><br><span class="line">    DEBUG,  <span class="comment">// 调试日志信息</span></span><br><span class="line">    INFO,   <span class="comment">// 普通日志信息</span></span><br><span class="line">    WARN,   <span class="comment">// 警告日志信息</span></span><br><span class="line">    ERROR,  <span class="comment">// 错误日志信息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LogMessage</span> {</span></span><br><span class="line">    LogLevel m_loglevel;         <span class="comment">// 日志级别</span></span><br><span class="line">    std::string m_logcontent;    <span class="comment">// 日志内容</span></span><br><span class="line">    std::thread::id m_threadid;  <span class="comment">// 打印日志的线程的 ID</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mprpc 框架提供的日志系统（单例对象，异步写入日志文件）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Logger&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入日志信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别</span></span><br><span class="line">    <span class="function">LogLevel <span class="title">GetLogLevel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetLogLevel</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LogLevel m_loglevel;             <span class="comment">// 记录日志级别</span></span><br><span class="line">    std::thread m_writeThread;       <span class="comment">// 日志写入线程</span></span><br><span class="line">    LockQueue&lt;LogMessage&gt; m_lckQue;  <span class="comment">// 日志缓冲队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="keyword">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算操作符</span></span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取日志级别的名称</span></span><br><span class="line">    <span class="function">std::string <span class="title">LogLevelToString</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>logger.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Logger::<span class="built_in">Logger</span>() {</span><br><span class="line">    <span class="comment">// 设置默认的日志级别</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_loglevel = INFO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动专门写日志文件的线程</span></span><br><span class="line">    m_writeThread = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取当前日期</span></span><br><span class="line">            <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            tm* now_tm = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取日志文件的名称</span></span><br><span class="line">            <span class="keyword">char</span> file_name[<span class="number">128</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(file_name, <span class="string">"%d-%d-%d-log.txt"</span>, now_tm-&gt;tm_year + <span class="number">1900</span>, now_tm-&gt;tm_mon + <span class="number">1</span>, now_tm-&gt;tm_mday);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开日志文件</span></span><br><span class="line">            FILE* pf = <span class="built_in">fopen</span>(file_name, <span class="string">"a+"</span>);</span><br><span class="line">            <span class="keyword">if</span> (pf == <span class="literal">nullptr</span>) {</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"logger file "</span> &lt;&lt; file_name &lt;&lt; <span class="string">" open failed!"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从日志缓冲队列获取日志信息（会阻塞当前线程，直到日志队列不为空）</span></span><br><span class="line">            LogMessage message = m_lckQue.<span class="built_in">Pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查退出标志</span></span><br><span class="line">            <span class="keyword">if</span> (m_lckQue.<span class="built_in">isExit</span>()) {</span><br><span class="line">                <span class="comment">// 关闭日志文件</span></span><br><span class="line">                <span class="built_in">fclose</span>(pf);</span><br><span class="line">                <span class="comment">// 跳出外层 For 循环，结束日志写入线程的运行（会丢失未被写入的日志信息）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取打印日志信息的线程的 ID（由外部传入，不一定是 Linux 内核线程 ID）</span></span><br><span class="line">            std::thread::id real_thread_id = message.m_threadid;</span><br><span class="line">            std::ostringstream oss;</span><br><span class="line">            oss &lt;&lt; real_thread_id;</span><br><span class="line">            std::string log_thread_id = oss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取日志内容和日志级别的名称</span></span><br><span class="line">            std::string&amp; log_content = message.m_logcontent;</span><br><span class="line">            std::string log_level_name = <span class="built_in">LogLevelToString</span>(message.m_loglevel);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前时间</span></span><br><span class="line">            <span class="keyword">char</span> time_buf[<span class="number">128</span>] = {<span class="number">0</span>};</span><br><span class="line">            <span class="built_in">sprintf</span>(time_buf, <span class="string">"%d-%d-%d %d:%d:%d =&gt; %s [%s] "</span>, now_tm-&gt;tm_year + <span class="number">1900</span>, now_tm-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                    now_tm-&gt;tm_mday, now_tm-&gt;tm_hour, now_tm-&gt;tm_min, now_tm-&gt;tm_sec, log_thread_id.<span class="built_in">c_str</span>(),</span><br><span class="line">                    log_level_name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加当前时间到日志内容的最前面</span></span><br><span class="line">            log_content.<span class="built_in">insert</span>(<span class="number">0</span>, time_buf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加换行符到日志内容的最后面</span></span><br><span class="line">            log_content.<span class="built_in">append</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志内容到控制台</span></span><br><span class="line">            std::cout &lt;&lt; log_content;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将日志内容写入日志文件</span></span><br><span class="line">            <span class="built_in">fputs</span>(log_content.<span class="built_in">c_str</span>(), pf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭日志文件</span></span><br><span class="line">            <span class="built_in">fclose</span>(pf);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Logger::~<span class="built_in">Logger</span>() {</span><br><span class="line">    <span class="comment">// 关闭队列，通知日志写入线程停止运行，避免发生线程死锁</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_lckQue.<span class="built_in">Stop</span>();</span><br><span class="line">    <span class="comment">// 等待日志线程安全退出</span></span><br><span class="line">    <span class="keyword">if</span> (m_writeThread.<span class="built_in">joinable</span>()) {</span><br><span class="line">        m_writeThread.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入日志信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::Log</span><span class="params">(<span class="keyword">const</span> LogMessage&amp; message)</span> </span>{</span><br><span class="line">    <span class="comment">// 将日志信息写入缓冲队列中</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_lckQue.<span class="built_in">Push</span>(message);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::SetLogLevel</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_loglevel = level;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别</span></span><br><span class="line"><span class="function">LogLevel <span class="title">Logger::GetLogLevel</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_loglevel;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志级别的名称</span></span><br><span class="line"><span class="function">std::string <span class="title">Logger::LogLevelToString</span><span class="params">(LogLevel level)</span> </span>{</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (level) {</span><br><span class="line">        <span class="keyword">case</span> DEBUG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DEBUG"</span>;</span><br><span class="line">        <span class="keyword">case</span> INFO:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"INFO"</span>;</span><br><span class="line">        <span class="keyword">case</span> WARN:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"WARN"</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"UNKNOWN"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h4><ul><li><code>rpc.conf</code> 配置文件</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ZooKeeper的IP地址（必填）</span><br><span class="line">zk_server_host=127.0.0.1</span><br><span class="line"># ZooKeeper的端口号（必填）</span><br><span class="line">zk_server_port=2181</span><br><span class="line"># RPC服务提供者优先使用的网卡接口（可选）</span><br><span class="line">rpc_network_interface=eth1</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcconfig.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string ZK_SERVER_HOST_KEY = <span class="string">"zk_server_host"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string ZK_SERVER_PORT_KEY = <span class="string">"zk_server_port"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string RPC_NETWORK_INTERFACE_KEY = <span class="string">"rpc_network_interface"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 框架读取配置文件的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcConfig</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* config_file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">Load</span><span class="params">(<span class="keyword">const</span> std::string&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置信息（无需考虑线程安全问题）</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Trim</span><span class="params">(std::string&amp; str)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcconfig.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcconfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcConfig::LoadConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* config_file)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断是否已经加载过配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!m_configMap.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开配置文件</span></span><br><span class="line">    FILE* pf = <span class="built_in">fopen</span>(config_file, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == pf) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"config file "</span> &lt;&lt; config_file &lt;&lt; <span class="string">" is not exist!"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析配置文件</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), pf)) {</span><br><span class="line">        <span class="function">std::string <span class="title">src_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line">        <span class="built_in">Trim</span>(src_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断注释内容</span></span><br><span class="line">        <span class="keyword">if</span> (src_buf.<span class="built_in">empty</span>() || src_buf[<span class="number">0</span>] == <span class="string">'#'</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        <span class="keyword">int</span> idx = src_buf.<span class="built_in">find_first_of</span>(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) {</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置项的 Key</span></span><br><span class="line">        std::string key = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置项的 Value</span></span><br><span class="line">        std::string value = src_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查配置项的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (key.<span class="built_in">empty</span>() || value.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储配置项</span></span><br><span class="line">        m_configMap.<span class="built_in">insert</span>({key, value});</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">"%s=%s"</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(pf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::Load</span><span class="params">(<span class="keyword">const</span> std::string&amp; key)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">return</span> it != m_configMap.<span class="built_in">end</span>() ? it-&gt;second : <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串前后的空白字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcConfig::Trim</span><span class="params">(std::string&amp; str)</span> </span>{</span><br><span class="line">    <span class="comment">// 定义空白字符</span></span><br><span class="line">    <span class="keyword">const</span> std::string whitespace = <span class="string">" \n\r\t"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除字符串前面多余的空白字符</span></span><br><span class="line">    <span class="keyword">size_t</span> start = str.<span class="built_in">find_first_not_of</span>(whitespace);</span><br><span class="line">    <span class="keyword">if</span> (start != std::string::npos) {</span><br><span class="line">        str = str.<span class="built_in">substr</span>(start);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 字符串全是空白字符</span></span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除字符串后面多余的空白字符</span></span><br><span class="line">    <span class="keyword">size_t</span> end = str.<span class="built_in">find_last_not_of</span>(whitespace);</span><br><span class="line">    <span class="keyword">if</span> (end != std::string::npos) {</span><br><span class="line">        str = str.<span class="built_in">substr</span>(<span class="number">0</span>, end + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Protobuf-协议文件"><a href="#Protobuf-协议文件" class="headerlink" title="Protobuf 协议文件"></a>Protobuf 协议文件</h4><ul><li><code>rpcheader.proto</code> 协议文件</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package mprpc;</span><br><span class="line"></span><br><span class="line">message RpcHeader {</span><br><span class="line">    // RPC 调用的服务名称</span><br><span class="line">    bytes service_name = 1;</span><br><span class="line"></span><br><span class="line">    // RPC 调用的方法名称</span><br><span class="line">    bytes method_name = 2;</span><br><span class="line"></span><br><span class="line">    // RPC 调用的参数长度（参数的序列化字符串的长度）</span><br><span class="line">    uint32 args_size = 3;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的初始化"><a href="#RPC-框架的初始化" class="headerlink" title="RPC 框架的初始化"></a>RPC 框架的初始化</h4><ul><li><code>mprpccontext.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcchannel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcconfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper 节点的路径前缀</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> std::string ZNODE_PATH_PREFIX = <span class="string">"/mprpc/services"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MPRPC 框架的上下文类（单例对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcContext</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MprpcContext&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 RPC 框架</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MprpcConfig&amp; <span class="title">GetConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置信息</span></span><br><span class="line">    <span class="keyword">static</span> MprpcConfig m_config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">MprpcContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">MprpcContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MprpcContext</span>(<span class="keyword">const</span> MprpcContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符</span></span><br><span class="line">    MprpcContext&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MprpcContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpccontext.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line">MprpcConfig MprpcContext::m_config;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MprpcContext::<span class="built_in">MprpcContext</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MprpcContext::~<span class="built_in">MprpcContext</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function">MprpcContext&amp; <span class="title">MprpcContext::GetInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 局部静态变量（线程安全）</span></span><br><span class="line">    <span class="keyword">static</span> MprpcContext singleton;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印命令帮助内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowArgsHelp</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"format: command -i &lt;configfile&gt;"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 RPC 框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcContext::Init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 校验命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">        <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">        <span class="comment">// 退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令行获取配置文件的路径</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">"i:"</span>)) != <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (c) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"invalid command args!"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">                <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">':'</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"need &lt;configfile&gt;"</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 打印命令帮助内容</span></span><br><span class="line">                <span class="built_in">ShowArgsHelp</span>();</span><br><span class="line">                <span class="comment">// 退出程序</span></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"loading rpc config file %s"</span>, config_file.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件内容</span></span><br><span class="line">    m_config.<span class="built_in">LoadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置信息</span></span><br><span class="line"><span class="function">MprpcConfig&amp; <span class="title">MprpcContext::GetConfig</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_config;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的服务注册"><a href="#RPC-框架的服务注册" class="headerlink" title="RPC 框架的服务注册"></a>RPC 框架的服务注册</h4><ul><li><code>mprpcprovider.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"google/protobuf/service.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 框架专门提供用来发布 RPC 服务的网络对象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RpcProvider</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PublishService</span><span class="params">(google::protobuf::Service* service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// TCP 服务器的事件回环</span></span><br><span class="line">    muduo::net::EventLoop m_eventloop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 服务信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ServiceInfo</span> {</span></span><br><span class="line">        <span class="comment">// RPC 服务</span></span><br><span class="line">        google::protobuf::Service* m_service;</span><br><span class="line">        <span class="comment">// RPC 服务拥有的方法</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="keyword">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储注册成功的 RPC 服务的集合</span></span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 TCP 连接的创建和断开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理已建立 TCP 连接的读写事件（比如接收客户端发送的数据）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于序列化 RPC 调用的响应结果和发送网络响应数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcprovider.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcprovider.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"networkutil.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpcheader.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布 RPC 服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::PublishService</span><span class="params">(google::protobuf::Service* service)</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 服务的信息</span></span><br><span class="line">    ServiceInfo servcieInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的描述信息</span></span><br><span class="line">    <span class="keyword">const</span> google::protobuf::ServiceDescriptor* pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的完整名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">serviceName</span><span class="params">(pserviceDesc-&gt;full_name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务的方法数量</span></span><br><span class="line">    <span class="keyword">int</span> methodCount = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 RPC 服务的所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) {</span><br><span class="line">        <span class="comment">// 获取 RPC 服务的方法的描述信息</span></span><br><span class="line">        <span class="keyword">const</span> google::protobuf::MethodDescriptor* pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        <span class="comment">// 获取 RPC 服务的方法的名称</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> std::string <span class="title">methodName</span><span class="params">(pmethodDesc-&gt;name())</span></span>;</span><br><span class="line">        <span class="comment">// 存储 RPC 服务的方法的描述信息</span></span><br><span class="line">        servcieInfo.m_methodMap.<span class="built_in">insert</span>({methodName, pmethodDesc});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 RPC 服务的信息</span></span><br><span class="line">    servcieInfo.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>({serviceName, servcieInfo});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取配置信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_host = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_HOST_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_port = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_PORT_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_network_interface =</span><br><span class="line">        MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(RPC_NETWORK_INTERFACE_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 服务提供者的 IP 和端口</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_server_ip = NetworkUtil::<span class="built_in">GetInstance</span>().<span class="built_in">FindLocalIp</span>(rpc_network_interface);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rpc_server_port = NetworkUtil::<span class="built_in">GetInstance</span>().<span class="built_in">FindAvailablePort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 服务提供者的端口是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == rpc_server_port) {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"not found available port for rpc server!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TCP 服务器</span></span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(rpc_server_ip, rpc_server_port)</span></span>;</span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">tcpServer</span><span class="params">(&amp;m_eventloop, address, <span class="string">"RpcProvider"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 TCP 连接创建和断开的回调</span></span><br><span class="line">    tcpServer.<span class="built_in">setConnectionCallback</span>(<span class="built_in">bind</span>(&amp;RpcProvider::onConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置已建立 TCP 连接读写事件的回调</span></span><br><span class="line">    tcpServer.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        <span class="built_in">bind</span>(&amp;RpcProvider::onMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 EventLoop 的线程数量（比如：1 个 I/O 线程，3 个 Worker 线程）</span></span><br><span class="line">    tcpServer.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ZK 客户端</span></span><br><span class="line">    ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="keyword">bool</span> started = zkClient.<span class="built_in">Start</span>(zk_server_host, <span class="built_in">atoi</span>(zk_server_port.<span class="built_in">c_str</span>()));</span><br><span class="line">    <span class="comment">// ZK 服务端连接失败</span></span><br><span class="line">    <span class="keyword">if</span> (!started) {</span><br><span class="line">        <span class="comment">// 停止往下继续执行，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有已发布的 RPC 服务注册进 ZK 服务端</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; service : m_serviceMap) {</span><br><span class="line">        <span class="comment">// RPC 服务的 IP 和端口信息</span></span><br><span class="line">        <span class="keyword">const</span> std::string rpc_address = rpc_server_ip + <span class="string">":"</span> + std::<span class="built_in">to_string</span>(rpc_server_port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RPC 服务的名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">        <span class="keyword">const</span> std::string service_name = service.first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的路径前缀，比如 /mprpc/services/user.UserServiceRpc</span></span><br><span class="line">        <span class="keyword">const</span> std::string path_prefix = ZNODE_PATH_PREFIX + <span class="string">"/"</span> + service_name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的完整路径，比如 /mprpc/services/user.UserServiceRpc/127.0.0.1:7070</span></span><br><span class="line">        <span class="keyword">const</span> std::string node_full_path = path_prefix + <span class="string">"/"</span> + rpc_address;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的数据，比如 127.0.0.1:7070</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* node_data = rpc_address.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZNode 节点的数据长度</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> node_data_len = rpc_address.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ZNode 节点（临时节点）</span></span><br><span class="line">        <span class="keyword">const</span> std::string created_path =</span><br><span class="line">            zkClient.<span class="built_in">CreateRecursive</span>(node_full_path.<span class="built_in">c_str</span>(), node_data, node_data_len, ZOO_EPHEMERAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 ZNode 节点是否创建成功（即 RPC 服务是否注册成功）</span></span><br><span class="line">        <span class="keyword">if</span> (!created_path.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="comment">// ZNode 节点创建成功</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"success to register rpc service, name: %s, path: %s, data: %s"</span>, service_name.<span class="built_in">c_str</span>(),</span><br><span class="line">                     node_full_path.<span class="built_in">c_str</span>(), node_data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// ZNode 节点创建失败</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"failed to register rpc service, name: %s, path: %s, data: %s"</span>, service_name.<span class="built_in">c_str</span>(),</span><br><span class="line">                      node_full_path.<span class="built_in">c_str</span>(), node_data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"rpc provider start at %s:%d"</span>, rpc_server_ip.<span class="built_in">c_str</span>(), rpc_server_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 TCP 服务器</span></span><br><span class="line">    tcpServer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以阻塞方式等待新客户端的连接、已连接客户端的读写事件等</span></span><br><span class="line">    m_eventloop.<span class="built_in">loop</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 TCP 连接的创建和断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>()) {</span><br><span class="line">        <span class="comment">// 断开连接（释放资源）</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 TCP 连接的读写事件（比如接收客户端发送的数据）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp time)</span> </span>{</span><br><span class="line">    <span class="comment">// 接收到的字符流，数据格式：header_size（4 字节） + header_str（service_name + method_name + args_size） + args_str</span></span><br><span class="line">    <span class="keyword">const</span> std::string recv_buf = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前 4 个字节的内容</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="keyword">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 header_size 读取请求数据头的原始字符流</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的基础信息</span></span><br><span class="line">    std::string service_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="keyword">uint32_t</span> args_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 请求数据头的反序列化</span></span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    <span class="keyword">if</span> (rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str)) {</span><br><span class="line">        <span class="comment">// 数据反序列化成功</span></span><br><span class="line">        service_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 数据反序列化失败</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc header string %s unserialize error!"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的参数的字符流数据</span></span><br><span class="line">    <span class="keyword">const</span> std::string rpc_args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"header_size: %u"</span>, header_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"rpc_header_str: %s"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"service_name: %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"method_name: %s"</span>, method_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_size: %u"</span>, args_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_str: %s"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 RPC 服务</span></span><br><span class="line">    <span class="keyword">auto</span> sit = m_serviceMap.<span class="built_in">find</span>(service_name);</span><br><span class="line">    <span class="comment">// 如果找不到对应的 RPC 服务</span></span><br><span class="line">    <span class="keyword">if</span> (sit == m_serviceMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc service %s is not exist!"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 RPC 服务的方法</span></span><br><span class="line">    <span class="keyword">auto</span> mit = sit-&gt;second.m_methodMap.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span> (mit == sit-&gt;second.m_methodMap.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc method %s::%s is not exist!"</span>, service_name.<span class="built_in">c_str</span>(), method_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的服务和方法</span></span><br><span class="line">    google::protobuf::Service* service = sit-&gt;second.m_service;</span><br><span class="line">    <span class="keyword">const</span> google::protobuf::MethodDescriptor* method = mit-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反序列化生成本地 RPC 方法调用的请求参数</span></span><br><span class="line">    google::protobuf::Message* request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span> (!request-&gt;<span class="built_in">ParseFromString</span>(rpc_args_str)) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc request args '%s' unserialize error!"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地 RPC 方法调用的响应结果</span></span><br><span class="line">    google::protobuf::Message* response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地 RPC 方法调用的回调，实际上调用的是 RpcProvider::SendRpcResponse()</span></span><br><span class="line">    google::protobuf::Closure* done =</span><br><span class="line">        google::protobuf::NewCallback&lt;RpcProvider, <span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp;, google::protobuf::Message*&gt;(</span><br><span class="line">            <span class="keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 节点的本地方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于序列化 RPC 调用的响应结果和发送网络响应数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcProvider::SendRpcResponse</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span> </span>{</span><br><span class="line">    <span class="comment">// 序列化 RPC 调用的响应结果</span></span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span> (response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str)) {</span><br><span class="line">        <span class="comment">// 通过网络将本地 RPC 方法的执行结果发送给 RPC 服务调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc response serialize error!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 模拟 HTTP 的短连接服务，由 RPC 服务提供方主动断开连接</span></span><br><span class="line">    conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RPC-框架的服务调用"><a href="#RPC-框架的服务调用" class="headerlink" title="RPC 框架的服务调用"></a>RPC 框架的服务调用</h4><ul><li><code>mprpccontroller.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcController</span> :</span> <span class="keyword">public</span> google::protobuf::RpcController {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MprpcController</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Failed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">ErrorText</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFailed</span><span class="params">(<span class="keyword">const</span> std::string&amp; reason)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前未实现具体的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartCancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsCanceled</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_failed;          <span class="comment">// RPC 方法执行过程中的状态</span></span><br><span class="line">    std::string m_errText;  <span class="comment">// RPC 方法执行过程中的错误信息</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpccontroller.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"></span><br><span class="line">MprpcController::<span class="built_in">MprpcController</span>() {</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errText = <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::Reset</span><span class="params">()</span> </span>{</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errText = <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MprpcController::Failed</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_failed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">MprpcController::ErrorText</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> m_errText;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::SetFailed</span><span class="params">(<span class="keyword">const</span> std::string&amp; reason)</span> </span>{</span><br><span class="line">    m_failed = <span class="literal">true</span>;</span><br><span class="line">    m_errText = reason;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(reason.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::StartCancel</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MprpcController::IsCanceled</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcController::NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcchannel.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/message.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MprpcChannel</span> :</span> <span class="keyword">public</span> google::protobuf::RpcChannel {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 随机生成一个整数，范围 [0, range-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomInt</span><span class="params">(<span class="keyword">int</span> range)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一实现 RPC 方法调用的数据序列化和网络数据发送（针对 RPC 服务调用者）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CallMethod</span><span class="params">(<span class="keyword">const</span> google::protobuf::MethodDescriptor* method, google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> google::protobuf::Message* request, google::protobuf::Message* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                    google::protobuf::Closure* done)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>mprpcchannel.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcchannel.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rpcheader.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成一个整数，范围 [0, range-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MprpcChannel::randomInt</span><span class="params">(<span class="keyword">int</span> range)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (range &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::mt19937 <span class="title">gen</span><span class="params">(std::random_device{}())</span></span>;</span><br><span class="line">        std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>, range - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dis</span>(gen);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一实现 RPC 方法调用的数据序列化和网络数据发送（针对 RPC 服务调用者）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MprpcChannel::CallMethod</span><span class="params">(<span class="keyword">const</span> google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                              google::protobuf::RpcController* controller, <span class="keyword">const</span> google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                              google::protobuf::Message* response, google::protobuf::Closure* done)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 RPC 服务的完整名称（加上包名），比如 user.UserServiceRpc</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">service_name</span><span class="params">(method-&gt;service()-&gt;full_name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的方法名称</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string <span class="title">method_name</span><span class="params">(method-&gt;name())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用参数的序列化字符串的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> args_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_args_str;</span><br><span class="line">    <span class="keyword">if</span> (request-&gt;<span class="built_in">SerializeToString</span>(&amp;rpc_args_str)) {</span><br><span class="line">        args_size = rpc_args_str.<span class="built_in">size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"rpc request serialize error!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 RPC 调用的请求数据头</span></span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    rpcHeader.<span class="built_in">set_service_name</span>(service_name);</span><br><span class="line">    rpcHeader.<span class="built_in">set_method_name</span>(method_name);</span><br><span class="line">    rpcHeader.<span class="built_in">set_args_size</span>(args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 请求数据头的序列化字符串的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    <span class="keyword">if</span> (rpcHeader.<span class="built_in">SerializeToString</span>(&amp;rpc_header_str)) {</span><br><span class="line">        header_size = rpc_header_str.<span class="built_in">size</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"rpc header serialize error!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络发送的数据，格式：header_size（4 字节） + header_str（service_name + method_name + args_size） + args_str</span></span><br><span class="line">    std::string rpc_send_str;</span><br><span class="line">    rpc_send_str.<span class="built_in">insert</span>(<span class="number">0</span>, std::<span class="built_in">string</span>((<span class="keyword">char</span>*)&amp;header_size, <span class="number">4</span>));</span><br><span class="line">    rpc_send_str += rpc_header_str;</span><br><span class="line">    rpc_send_str += rpc_args_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"header_size: %u"</span>, header_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"rpc_header_str: %s"</span>, rpc_header_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"service_name: %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"method_name: %s"</span>, method_name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_size: %u"</span>, args_size);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"args_str: %s"</span>, rpc_args_str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地创建一个 TCP 客户端</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == clientfd) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"create socket failed, errno is %d"</span>, errno);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ZK 服务端的连接信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_host = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_HOST_KEY);</span><br><span class="line">    <span class="keyword">const</span> std::string zk_server_port = MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(ZK_SERVER_PORT_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ZK 客户端</span></span><br><span class="line">    ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="keyword">bool</span> started = zkClient.<span class="built_in">Start</span>(zk_server_host, <span class="built_in">atoi</span>(zk_server_port.<span class="built_in">c_str</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ZK 服务端启动失败</span></span><br><span class="line">    <span class="keyword">if</span> (!started) {</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">"zookeeper client connect failed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 服务对应的 ZNode 节点的路径，比如 /mprpc/services/user.UserServiceRpc</span></span><br><span class="line">    <span class="keyword">const</span> std::string node_path = ZNODE_PATH_PREFIX + <span class="string">"/"</span> + service_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ZNode 子节点列表（即已注册的 RPC 服务列表），比如 127.0.0.1:7070</span></span><br><span class="line">    std::vector&lt;std::string&gt; child_list = zkClient.<span class="built_in">GetChildren</span>(node_path.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ZNode 子节点列表为空（即查找不到已注册的 RPC 服务）</span></span><br><span class="line">    <span class="keyword">if</span> (child_list.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"not found rpc service %s"</span>, service_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机获取一个 RPC 服务提供者的地址，比如 127.0.0.1:7070</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = child_list.<span class="built_in">size</span>() == <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">randomInt</span>(child_list.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_addr = child_list[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 PRC 服务提供者的 IP 和端口</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> pos = rpc_provider_addr.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">    <span class="comment">// 如果 RPC 服务提供者的地址无效</span></span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == pos) {</span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"invalid rpc service address %s"</span>, rpc_provider_addr.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_ip = rpc_provider_addr.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="keyword">const</span> std::string rpc_provider_port = rpc_provider_addr.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"ready to invoke rpc service, name: %s, address: %s"</span>, service_name.<span class="built_in">c_str</span>(), rpc_provider_addr.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装 TCP 客户端的连接信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(rpc_provider_port.<span class="built_in">c_str</span>()));</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(rpc_provider_ip.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 TCP 客户端连接 RPC 服务节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">connect</span>(clientfd, (struct sockaddr*)&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr))) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"connect server failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络发送 RPC 调用的请求参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">send</span>(clientfd, rpc_send_str.<span class="built_in">c_str</span>(), rpc_send_str.<span class="built_in">size</span>(), <span class="number">0</span>)) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"send rpc rquest failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过网络接收 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">int</span> recv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> recv_buf[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (recv_size = <span class="built_in">recv</span>(clientfd, recv_buf, <span class="number">1024</span>, <span class="number">0</span>))) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"receive rpc response failed, errno is %d"</span>, errno);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (!response-&gt;<span class="built_in">ParseFromArray</span>(recv_buf, recv_size)) {</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">        <span class="comment">// 设置 RPC 调用状态</span></span><br><span class="line">        <span class="keyword">char</span> errtxt[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">sprintf</span>(errtxt, <span class="string">"rpc response unserialize failed, response content is %s"</span>, recv_buf);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(errtxt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ZooKeeper-的访问操作"><a href="#ZooKeeper-的访问操作" class="headerlink" title="ZooKeeper 的访问操作"></a>ZooKeeper 的访问操作</h4><ul><li><code>zookeeperclient.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zookeeper/zookeeper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ZNode 节点的状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ZNodeStatus</span> {</span></span><br><span class="line">    EXIST,     <span class="comment">// 已存在</span></span><br><span class="line">    NOTEXIST,  <span class="comment">// 不存在</span></span><br><span class="line">    UNKNOWN    <span class="comment">// 未知状态</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper 客户端的封装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ZK 客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Start</span><span class="params">(<span class="keyword">const</span> std::string &amp;host, <span class="keyword">const</span> <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 创建 ZNode 节点</span></span><br><span class="line">    <span class="function">std::string <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen = <span class="number">0</span>, <span class="keyword">int</span> mode = ZOO_PERSISTENT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 递归创建 ZNode 节点</span></span><br><span class="line">    <span class="function">std::string <span class="title">CreateRecursive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen = <span class="number">0</span>, <span class="keyword">int</span> mode = ZOO_PERSISTENT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取子节点列表</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">GetChildren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的数据</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的状态</span></span><br><span class="line">    <span class="function">Stat <span class="title">GetStat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ZK 服务器上，根据指定的 Path 判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="function">ZNodeStatus <span class="title">Exist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">zhandle_t</span> *m_zhandle;  <span class="comment">// ZK 的客户端句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>zookeeperclient.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zookeeperclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////// ZK 客户端同步操作扩展代码 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步检查 ZNode 节点是否存在的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncExistsContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;              <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;  <span class="comment">// 检查结果</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步检查 ZNode 是否存在的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_exists_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> struct Stat *stat, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    SyncExistsContext *ctx = (SyncExistsContext *)data;</span><br><span class="line">    <span class="comment">// 存储检查结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line">    <span class="comment">// 唤醒正在等待检查结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步检查 ZNode 节点是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_exists_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncExistsContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aexists</span>(zh, path, watch, znode_exists_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待检查结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回检查结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建 ZNode 节点的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncCreateContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                 <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;     <span class="comment">// 创建结果</span></span><br><span class="line">    <span class="keyword">char</span> path_buf[<span class="number">512</span>] = {<span class="number">0</span>};  <span class="comment">// 用于返回实际创建的节点路径</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步创建 ZNode 节点的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_create_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncCreateContext *ctx = (SyncCreateContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储创建结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储实际创建的节点路径</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; path) {</span><br><span class="line">        <span class="built_in">strncpy</span>(ctx-&gt;path_buf, path, <span class="built_in"><span class="keyword">sizeof</span></span>(ctx-&gt;path_buf) - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待创建结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建 ZNode 节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_create_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">const</span> struct ACL_vector *acl,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> mode, <span class="keyword">char</span> *path_buf_out, <span class="keyword">int</span> path_buf_out_len)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncCreateContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_acreate</span>(zh, path, data, datalen, acl, mode, znode_create_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待检查结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回实际创建的节点路径</span></span><br><span class="line">    <span class="keyword">if</span> (path_buf_out &amp;&amp; path_buf_out_len &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">strncpy</span>(path_buf_out, ctx.path_buf, path_buf_out_len - <span class="number">1</span>);</span><br><span class="line">        path_buf_out[path_buf_out_len - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回检查结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 节点数据和状态的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncGetContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                    <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;        <span class="comment">// 操作结果</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="literal">nullptr</span>;          <span class="comment">// 数据缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> buf_len = <span class="number">0</span>;              <span class="comment">// 数据缓冲区的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> *<span class="title">stat</span> =</span> <span class="literal">nullptr</span>;  <span class="comment">// ZNode 节点的状态</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取 ZNode 节点数据和状态的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">znode_get_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> value_len, <span class="keyword">const</span> struct Stat *stat, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetContext *ctx = (SyncGetContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储操作结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 ZNode 节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (rc == ZOK &amp;&amp; stat &amp;&amp; ctx-&gt;stat) {</span><br><span class="line">        *ctx-&gt;stat = *stat;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 ZNode 节点的数据</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; value &amp;&amp; value_len &gt; <span class="number">0</span> &amp;&amp; ctx-&gt;buf &amp;&amp; ctx-&gt;buf_len &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> copy_len = (value_len &lt; ctx-&gt;buf_len - <span class="number">1</span>) ? value_len : ctx-&gt;buf_len - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ctx-&gt;buf, value, copy_len);</span><br><span class="line">        ctx-&gt;buf[copy_len] = <span class="string">'\0'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待获取结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 节点的数据和状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zoo_get_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch, <span class="keyword">char</span> *buf_out, <span class="keyword">int</span> buf_out_len, struct Stat *stat_out)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetContext ctx;</span><br><span class="line">    ctx.stat = stat_out;</span><br><span class="line">    ctx.buf = buf_out;</span><br><span class="line">    ctx.buf_len = buf_out_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aget</span>(zh, path, watch, znode_get_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回操作结果</span></span><br><span class="line">    <span class="keyword">return</span> ctx.rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 子节点列表的上下文结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncGetChildrenContext</span> {</span></span><br><span class="line">    <span class="keyword">sem_t</span> sem;                          <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">int</span> rc = ZSYSTEMERROR;              <span class="comment">// 操作结果</span></span><br><span class="line">    std::vector&lt;std::string&gt; children;  <span class="comment">// 子节点列表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步获取 ZNode 子节点列表的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zoo_get_children_completion</span><span class="params">(<span class="keyword">int</span> rc, <span class="keyword">const</span> struct String_vector *strings, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>{</span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetChildrenContext *ctx = (SyncGetChildrenContext *)data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储操作结果</span></span><br><span class="line">    ctx-&gt;rc = rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储子节点列表</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == rc &amp;&amp; strings) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings-&gt;count; i++) {</span><br><span class="line">            ctx-&gt;children.<span class="built_in">emplace_back</span>(strings-&gt;data[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒正在等待获取结果的线程</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;ctx-&gt;sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步获取 ZNode 子节点列表</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">zoo_get_children_sync</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> watch)</span> </span>{</span><br><span class="line">    <span class="comment">// 子节点列表</span></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文信息</span></span><br><span class="line">    SyncGetChildrenContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;ctx.sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 ZK 异步请求的调用</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">zoo_aget_children</span>(zh, path, watch, zoo_get_children_completion, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里必须判断 ZK 的异步请求调用是否正常，否则可能因为异步请求未正常发出，导致回调永不执行，最终造成线程死锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ZOK) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line">        <span class="comment">// ZK 的异步请求发出失败</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;ctx.sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取子节点列表成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == ctx.rc) {</span><br><span class="line">        <span class="comment">// 直接转移 children 所有权给 result</span></span><br><span class="line">        result = std::<span class="built_in">move</span>(ctx.children);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取子节点列表失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"failed to get children of node %s"</span>, path);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回子节点列表</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的 Watcher 监听器，接收 ZkServer 给 ZkClient 发送的通知</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_watcher</span><span class="params">(<span class="keyword">zhandle_t</span> *zh, <span class="keyword">int</span> type, <span class="keyword">int</span> state, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">void</span> *watcherCtx)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断接收到的事件类型是不是会话事件类型</span></span><br><span class="line">    <span class="keyword">if</span> (type == ZOO_SESSION_EVENT) {</span><br><span class="line">        <span class="comment">// ZK 客户端连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (state == ZOO_CONNECTED_STATE) {</span><br><span class="line">            <span class="comment">// 从 ZK 客户端的上下文中获取预设置的信号量</span></span><br><span class="line">            <span class="keyword">sem_t</span> *init_sem = (<span class="keyword">sem_t</span> *)<span class="built_in">zoo_get_context</span>(zh);</span><br><span class="line">            <span class="comment">// 唤醒正在等待 ZK 客户端初始化完成的线程</span></span><br><span class="line">            <span class="built_in">sem_post</span>(init_sem);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ZK 客户端身份认证失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == ZOO_AUTH_FAILED_STATE) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper auth failed"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ZK 客户端会话过期</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == ZOO_EXPIRED_SESSION_STATE) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper session expired"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////// ZK 客户端实现代码 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ZkClient::<span class="built_in">ZkClient</span>() : <span class="built_in">m_zhandle</span>(<span class="literal">nullptr</span>) {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ZkClient::~<span class="built_in">ZkClient</span>() {</span><br><span class="line">    <span class="keyword">if</span> (m_zhandle != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// 关闭 ZK 的客户端句柄（释放资源）</span></span><br><span class="line">        <span class="built_in">zookeeper_close</span>(m_zhandle);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 ZK 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ZkClient::Start</span><span class="params">(<span class="keyword">const</span> std::string &amp;host, <span class="keyword">const</span> <span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">    <span class="comment">// 拼接 ZK 服务端的连接信息</span></span><br><span class="line">    <span class="keyword">const</span> std::string conn_str = host + <span class="string">":"</span> + std::<span class="built_in">to_string</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 ZK 的客户端句柄，连接 ZK 服务端（特别注意：这里是异步初始化）</span></span><br><span class="line"><span class="comment">     * ZooKeeper C API 的多线程版本有三个线程，包括：</span></span><br><span class="line"><span class="comment">     * (1) API 调用线程（当前调用 ZK API 的线程）</span></span><br><span class="line"><span class="comment">     * (2) 网络 I/O 线程，基于 pthread_create() + poll 实现</span></span><br><span class="line"><span class="comment">     * (3) Watcher 回调线程，基于 pthread_create() 实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    m_zhandle = <span class="built_in">zookeeper_init</span>(conn_str.<span class="built_in">c_str</span>(), global_watcher, <span class="number">30000</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_zhandle) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper client init failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> init_sem;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;init_sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将信号量存放到 ZK 客户端的上下文中</span></span><br><span class="line">    <span class="built_in">zoo_set_context</span>(m_zhandle, &amp;init_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置等待 ZK 客户端连接的超时时间（10 秒）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;ts);</span><br><span class="line">    ts.tv_sec += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待 ZK 客户端初始化完成</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sem_timedwait</span>(&amp;init_sem, &amp;ts) != <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;init_sem);</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"zookeeper client connect timeout"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;init_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日志信息</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"zookeeper client init success"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上根据指定的 Path 创建 ZNode 节点</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">int</span> mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZNode 节点已存在</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">"znode %s create failed, because it existed"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ZNode 节点不存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ZNONODE == flag) {</span><br><span class="line">        <span class="comment">// 实际创建的节点路径</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> path_buf_len = <span class="number">512</span>;</span><br><span class="line">        <span class="keyword">char</span> path_buf[path_buf_len] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步创建 ZNode 节点</span></span><br><span class="line">        flag = <span class="built_in">zoo_create_sync</span>(m_zhandle, path, data, datalen, &amp;ZOO_OPEN_ACL_UNSAFE, mode, path_buf, path_buf_len);</span><br><span class="line">        <span class="comment">// 节点创建成功</span></span><br><span class="line">        <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"znode %s create success"</span>, path_buf);</span><br><span class="line">            <span class="comment">// 返回实际创建的节点路径</span></span><br><span class="line">            <span class="keyword">return</span> path_buf;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 节点创建失败</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">            <span class="comment">// 返回空字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发生错误，比如会话过期、身份认证失败等</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 递归创建 ZNode 节点</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::CreateRecursive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datalen, <span class="keyword">int</span> mode)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::string current_path;</span><br><span class="line">    std::string result_path;</span><br><span class="line">    <span class="keyword">size_t</span> current_pos = <span class="number">1</span>;       <span class="comment">// 跳过第一个 '/'</span></span><br><span class="line">    <span class="function">std::string <span class="title">full_path</span><span class="params">(path)</span></span>;  <span class="comment">// 拷贝节点路径，避免修改原始字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_pos &lt;= full_path.<span class="built_in">size</span>()) {</span><br><span class="line">        <span class="keyword">size_t</span> next_pos = full_path.<span class="built_in">find</span>(<span class="string">'/'</span>, current_pos);</span><br><span class="line">        <span class="keyword">if</span> (next_pos == std::string::npos) {</span><br><span class="line">            <span class="comment">// 最后一级路径（完整路径）</span></span><br><span class="line">            current_path = full_path;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            current_path = full_path.<span class="built_in">substr</span>(<span class="number">0</span>, next_pos);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> is_last_path = (next_pos == std::string::npos);   <span class="comment">// 是否为最后一级路径</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *path_data = is_last_path ? data : <span class="string">""</span>;      <span class="comment">// 父路径不写入数据</span></span><br><span class="line">        <span class="keyword">int</span> path_data_len = is_last_path ? datalen : <span class="number">0</span>;        <span class="comment">// 父路径的数据长度为零</span></span><br><span class="line">        <span class="keyword">int</span> path_mode = is_last_path ? mode : ZOO_PERSISTENT;  <span class="comment">// 父路径为持久节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        std::string created_path = <span class="built_in">Create</span>(current_path.<span class="built_in">c_str</span>(), path_data, path_data_len, path_mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果节点创建失败</span></span><br><span class="line">        <span class="keyword">if</span> (created_path.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="comment">// 判断节点是否存在</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, current_path.<span class="built_in">c_str</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 如果节点存在，使用（兼容）已存在的节点</span></span><br><span class="line">            <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">                created_path = current_path;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果节点不存在或者发生错误，则直接返回空字符串</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 打印日志信息</span></span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">"znode %s create failed"</span>, path);</span><br><span class="line">                <span class="comment">// 返回空字符串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是最后一级路径，则跳出 While 循环</span></span><br><span class="line">        <span class="keyword">if</span> (is_last_path) {</span><br><span class="line">            result_path = created_path;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        current_pos = next_pos + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_path;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取子节点列表</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">ZkClient::GetChildren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空列表</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取子节点列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">zoo_get_children_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的数据</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::GetData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> data_buf_len = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">char</span> data_buf[data_buf_len] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取 ZNode 节点的数据</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_get_sync</span>(m_zhandle, path, <span class="number">0</span>, data_buf, data_buf_len, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 获取节点数据成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 返回节点数据</span></span><br><span class="line">        <span class="keyword">return</span> data_buf;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取节点数据失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"get znode data failed, path: %s"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 获取 ZNode 节点的状态</span></span><br><span class="line"><span class="function">Stat <span class="title">ZkClient::GetStat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="comment">// 返回空数据</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">stat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步获取 ZNode 节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_get_sync</span>(m_zhandle, path, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;stat);</span><br><span class="line">    <span class="comment">// 获取节点状态成功</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="comment">// 返回节点状态</span></span><br><span class="line">        <span class="keyword">return</span> stat;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取节点状态失败</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"get znode stat failed, path: %s"</span>, path);</span><br><span class="line">        <span class="comment">// 返回空数据</span></span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ZK 服务器上，根据指定的 Path 判断 ZNode 节点是否存在</span></span><br><span class="line"><span class="function">ZNodeStatus <span class="title">ZkClient::Exist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查节点路径是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkPath</span>(path)) {</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步判断 ZNode 节点是否存在</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">zoo_exists_sync</span>(m_zhandle, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZNode 节点已存在</span></span><br><span class="line">    <span class="keyword">if</span> (ZOK == flag) {</span><br><span class="line">        <span class="keyword">return</span> EXIST;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ZNode 节点不存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ZNONODE == flag) {</span><br><span class="line">        <span class="keyword">return</span> NOTEXIST;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发生错误，比如会话过期、身份认证失败等</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查节点路径是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ZkClient::checkPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">nullptr</span> || path[<span class="number">0</span>] != <span class="string">'/'</span>) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"invalid node path: %s"</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="RPC-框架测试代码"><a href="#RPC-框架测试代码" class="headerlink" title="RPC 框架测试代码"></a>RPC 框架测试代码</h3><p>这里的项目测试代码位于 <code>example</code> 目录下，实质是 RPC 框架的使用案例代码，用于给 RPC 框架的第三方使用者演示如何发布和调用 RPC 服务。</p><h4 id="Protobuf-协议文件-1"><a href="#Protobuf-协议文件-1" class="headerlink" title="Protobuf 协议文件"></a>Protobuf 协议文件</h4><ul><li><code>user.proto</code> 协议文件</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package user;</span><br><span class="line"></span><br><span class="line">// 允许生成通用的 C++ 服务接口（可选项）</span><br><span class="line">option cc_generic_services = true;</span><br><span class="line"></span><br><span class="line">// 请求结果</span><br><span class="line">message ResultCode {</span><br><span class="line">    uint32 errcode = 1; </span><br><span class="line">    bytes errmsg = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 登录请求</span><br><span class="line">message LoginRequest {</span><br><span class="line">    bytes name = 1;</span><br><span class="line">    bytes password = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 登录响应</span><br><span class="line">message LoginResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    bool success = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 注册请求</span><br><span class="line">message RegisterRequest {</span><br><span class="line">    bytes name = 1;</span><br><span class="line">    bytes password = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 注册响应</span><br><span class="line">message RegisterResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    bool success = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义RPC服务接口类和服务函数</span><br><span class="line">service UserServiceRpc {</span><br><span class="line">    rpc Register(RegisterRequest) returns (RegisterResponse);</span><br><span class="line"></span><br><span class="line">    rpc Login(LoginRequest) returns (LoginResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>friend.proto</code> 协议文件</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Protobuf 语法的版本</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 定义包名，便于在生成的代码中区分不同模块（类似 C++ 的命名空间）</span><br><span class="line">package friends;</span><br><span class="line"></span><br><span class="line">// 允许生成通用的 C++ 服务接口（可选项）</span><br><span class="line">option cc_generic_services = true;</span><br><span class="line"></span><br><span class="line">// 请求结果</span><br><span class="line">message ResultCode {</span><br><span class="line">    uint32 errcode = 1; </span><br><span class="line">    bytes errmsg = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 好友信息</span><br><span class="line">message Friend {</span><br><span class="line">    uint32 userid = 1;</span><br><span class="line">    bytes username = 2;</span><br><span class="line"></span><br><span class="line">    // 枚举类型</span><br><span class="line">    enum SEX {</span><br><span class="line">        MAN = 0;</span><br><span class="line">        WOMAN = 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SEX sex = 3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取好友列表的请求</span><br><span class="line">message GetFriendListRequest {</span><br><span class="line">    uint32 userid = 1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取好友列表的响应</span><br><span class="line">message GetFriendListResponse {</span><br><span class="line">    ResultCode result = 1;</span><br><span class="line">    // 好友列表</span><br><span class="line">    repeated Friend friends = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义RPC服务接口类和服务函数</span><br><span class="line">service FriendServiceRpc {</span><br><span class="line">    rpc GetFriendList(GetFriendListRequest) returns (GetFriendListResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-RPC-框架提供服务"><a href="#使用-RPC-框架提供服务" class="headerlink" title="使用 RPC 框架提供服务"></a>使用 RPC 框架提供服务</h4><ul><li><code>rpcprovider.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpcprovider.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 服务，继承基类 UserServiceRpc（由 Protobuf 自动生成）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> :</span> <span class="keyword">public</span> user::UserServiceRpc {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本地的登录函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Login</span><span class="params">(std::string name, std::string password)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local Login function, name: %s, password: %s"</span>, name.<span class="built_in">c_str</span>(), password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地的注册函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Register</span><span class="params">(std::string name, std::string password)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local Register function, name: %s, password: %s"</span>, name.<span class="built_in">c_str</span>(), password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 UserServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Login</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::user::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">               ::user::LoginResponse* response, ::google::protobuf::Closure* done)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string password = request-&gt;<span class="built_in">password</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        <span class="keyword">bool</span> success = <span class="built_in">Login</span>(name, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        user::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给 RPC 服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 UserServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::user::RegisterRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ::user::RegisterResponse* response, ::google::protobuf::Closure* done)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string password = request-&gt;<span class="built_in">password</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        <span class="keyword">bool</span> success = <span class="built_in">Register</span>(name, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        user::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给RPC服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 服务，继承基类 FriendServiceRpc（由 Protobuf 自动生成）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendServcie</span> :</span> <span class="keyword">public</span> friends::FriendServiceRpc {</span><br><span class="line">    <span class="comment">// 本地获取好友列表的函数</span></span><br><span class="line">    <span class="function">std::vector&lt;friends::Friend&gt; <span class="title">GetFriendList</span><span class="params">(<span class="keyword">uint32_t</span> userid)</span> </span>{</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"invoke local GetFriendList function, userid: %u"</span>, userid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        std::vector&lt;friends::Friend&gt; result;</span><br><span class="line"></span><br><span class="line">        friends::Friend f1;</span><br><span class="line">        f1.<span class="built_in">set_userid</span>(<span class="number">1</span>);</span><br><span class="line">        f1.<span class="built_in">set_username</span>(<span class="string">"Jim"</span>);</span><br><span class="line">        f1.<span class="built_in">set_sex</span>(friends::Friend::MAN);</span><br><span class="line">        result.<span class="built_in">push_back</span>(f1);</span><br><span class="line"></span><br><span class="line">        friends::Friend f2;</span><br><span class="line">        f2.<span class="built_in">set_userid</span>(<span class="number">2</span>);</span><br><span class="line">        f2.<span class="built_in">set_username</span>(<span class="string">"Tom"</span>);</span><br><span class="line">        f2.<span class="built_in">set_sex</span>(friends::Friend::MAN);</span><br><span class="line">        result.<span class="built_in">push_back</span>(f2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类 FriendServiceRpc（由 Protobuf 自动生成）的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetFriendList</span><span class="params">(::google::protobuf::RpcController* controller, <span class="keyword">const</span> ::friends::GetFriendListRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::friends::GetFriendListResponse* response, ::google::protobuf::Closure* done)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取 RPC 请求参数</span></span><br><span class="line">        <span class="keyword">uint32_t</span> userid = request-&gt;<span class="built_in">userid</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地业务函数</span></span><br><span class="line">        std::vector&lt;friends::Friend&gt; friends = <span class="built_in">GetFriendList</span>(userid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RPC 响应结果</span></span><br><span class="line">        friends::ResultCode* result = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        result-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        result-&gt;<span class="built_in">set_errmsg</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应的数据</span></span><br><span class="line">        <span class="keyword">for</span> (friends::Friend&amp; item : friends) {</span><br><span class="line">            friends::Friend* f = response-&gt;<span class="built_in">add_friends</span>();</span><br><span class="line">            f-&gt;<span class="built_in">set_sex</span>(item.<span class="built_in">sex</span>());</span><br><span class="line">            f-&gt;<span class="built_in">set_userid</span>(item.<span class="built_in">userid</span>());</span><br><span class="line">            f-&gt;<span class="built_in">set_username</span>(item.<span class="built_in">username</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，返回响应结果给RPC服务调用者</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 RPC 服务的发布</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    Logger::<span class="built_in">GetInstance</span>().<span class="built_in">SetLogLevel</span>(INFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 框架的初始化操作（比如加载 RPC 配置文件）</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"init rpc framework..."</span>);</span><br><span class="line">    MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用来发布 RPC 服务的网络对象类</span></span><br><span class="line">    RpcProvider provider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    provider.<span class="built_in">PublishService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 RPC 服务</span></span><br><span class="line">    provider.<span class="built_in">PublishService</span>(<span class="keyword">new</span> <span class="built_in">FriendServcie</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 RPC 服务节点，开始对外提供 RPC 远程网络调用服务（针对 RPC 服务提供者）</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-RPC-框架调用服务"><a href="#使用-RPC-框架调用服务" class="headerlink" title="使用 RPC 框架调用服务"></a>使用 RPC 框架调用服务</h4><ul><li><code>rpcconsumer.cc</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"friend.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mprpccontroller.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 注册方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">user::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    user::RegisterRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">"jim"</span>);</span><br><span class="line">    request.<span class="built_in">set_password</span>(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    user::RegisterResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">Register</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function Register invoke success"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function Register invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 登录方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Login</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">user::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    user::LoginRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">"jim"</span>);</span><br><span class="line">    request.<span class="built_in">set_password</span>(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    user::LoginResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">Login</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function Login invoke success"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function Login invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 RPC 获取好友列表方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetFriendList</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// RPC 调用的通道</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcChannel&gt; channel = std::make_unique&lt;MprpcChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的状态控制器</span></span><br><span class="line">    std::unique_ptr&lt;google::protobuf::RpcController&gt; controller = std::make_unique&lt;MprpcController&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的代理对象</span></span><br><span class="line">    <span class="function">friends::FriendServiceRpc_Stub <span class="title">stub</span><span class="params">(channel.get())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的请求参数</span></span><br><span class="line">    friends::GetFriendListRequest request;</span><br><span class="line">    request.<span class="built_in">set_userid</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 调用的响应结果</span></span><br><span class="line">    friends::GetFriendListResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起 RPC 调用，底层实际上调用的是 MprpcChannel::CallMethod()</span></span><br><span class="line">    stub.<span class="built_in">GetFriendList</span>(controller.<span class="built_in">get</span>(), &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 RPC 调用是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">Failed</span>()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RPC 调用的响应结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == response.<span class="built_in">result</span>().<span class="built_in">errcode</span>()) {</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">"rpc function GetFriendList invoke success"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取返回的数据</span></span><br><span class="line">        <span class="keyword">auto</span> friends = response.<span class="built_in">friends</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : friends) {</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">"userid: %u, username: %s, sex: %d"</span>, item.<span class="built_in">userid</span>(), item.<span class="built_in">username</span>().<span class="built_in">c_str</span>(), item.<span class="built_in">sex</span>());</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">"rpc function GetFriendList invoke error: %s"</span>, response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 RPC 服务的调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    Logger::<span class="built_in">GetInstance</span>().<span class="built_in">SetLogLevel</span>(INFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 RPC 框架的初始化操作（比如加载 RPC 配置文件）</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">"init rpc framework..."</span>);</span><br><span class="line">    MprpcContext::<span class="built_in">GetInstance</span>().<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 注册方法</span></span><br><span class="line">    <span class="built_in">Register</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 登录方法</span></span><br><span class="line">    <span class="built_in">Login</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程的 RPC 获取好友列表方法</span></span><br><span class="line">    <span class="built_in">GetFriendList</span>();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待一段时间，在程序结束之前，尽量让日志信息都被写入日志文件</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="项目代码下载"><a href="#项目代码下载" class="headerlink" title="项目代码下载"></a>项目代码下载</h3><p>完整的 RPC 框架项目代码可以在 <a target="_blank" rel="external nofollow" href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-mprpc">这里</a> 下载得到。</p><h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><ul><li>(1) 更改 <code>conf</code> 目录下的 <code>rpc.conf</code> 配置文件，指定 ZooKeeper 服务器的 IP 和端口号等信息</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ZooKeeper的IP地址（必填）</span><br><span class="line">zk_server_host=127.0.0.1</span><br><span class="line"># ZooKeeper的端口号（必填）</span><br><span class="line">zk_server_port=2181</span><br><span class="line"># RPC服务提供者优先使用的网卡接口（可选）</span><br><span class="line">rpc_network_interface=eth1</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 通过 CMake 编译构建整个项目</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权脚本执行</span></span><br><span class="line">chmod +x autobuild.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一键编译构建脚本</span></span><br><span class="line">./autobuild.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 启动 ZooKeeper 服务器</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 ZooKeeper 服务器</span></span><br><span class="line">sudo systemctl start zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ZooKeeper 服务器的运行状态</span></span><br><span class="line">sudo systemctl status zookeeper</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 启动 RPC 服务提供者的案例程序</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 RPC 服务提供者的案例程序（可使用相同的命令启动多个 RPC 服务提供者，不需要考虑端口冲突问题）</span></span><br><span class="line">./example_rpc_provider -i rpc.conf</span><br></pre></td></tr></tbody></table></figure><ul><li>(5) 启动 RPC 服务调用者的案例程序</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 RPC 服务调用者的案例程序（可使用相同的命令启动多个 RPC 服务调用者，不需要考虑端口冲突问题）</span></span><br><span class="line">./example_rpc_consumer -i rpc.conf</span><br></pre></td></tr></tbody></table></figure><ul><li>(6) 查看 RPC 框架运行输出的日志文件</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-project-mprpc/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 RPC 框架运行输出的日志文件（请自行更改日志文件名）</span></span><br><span class="line">vim 2025-06-12-log.txt</span><br></pre></td></tr></tbody></table></figure><h2 id="项目调试"><a href="#项目调试" class="headerlink" title="项目调试"></a>项目调试</h2><ul><li>GDB 调试 C/C++ 代码，可用于定位线程死锁等问题的发生</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GDB 调试指定的可执行文件（应用程序）</span></span><br><span class="line">gdb example_rpc_provider</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 设置断点（格式：源文件名称＋行号）</span></span><br><span class="line">(gdb) <span class="built_in">break</span> mprpcconfig.cc:19</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 指定参数运行应用程序（运行后，会停留在断点处）</span></span><br><span class="line">(gdb) run -i rpc.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 断点调试 - 运行下一行代码</span></span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 断点调试 - 查看指定变量的值</span></span><br><span class="line">(gdb) p src_buf</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 退出调试</span></span><br><span class="line">(gdb) quit</span><br></pre></td></tr></tbody></table></figure><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><p>在上述的 RPC 框架代码中，每当 RPC 服务端处理完成一个 RPC 请求后，都会主动断开与 RPC 客户端的 TCP 连接；同样，RPC 客户端在获取到响应结果后，也会主动断开与 RPC 服务端的 TCP 连接。这种实现方式属于短连接模式，在生产环境中通常比较少见。原因如下：</p><ul><li><p>TCP 连接的创建和释放代价较高，每次请求都涉及：</p><ul><li>三次握手（建立连接）</li><li>四次挥手（关闭连接）</li></ul></li><li><p>在高并发场景下，频繁建立和关闭 TCP 连接会导致：</p><ul><li>系统资源消耗大（文件描述符、内核网络栈负载）</li><li>服务端的性能瓶颈，特别是处理大量短时请求时</li></ul></li></ul><p>以阿里巴巴开源的 RPC 框架 Dubbo 为例，Dubbo 默认采用 TCP 的单一长连接和 NIO 异步通信模型，其主要特点是：</p><ul><li>客户端与服务端之间建立持久化的长连接（通常是连接池或多路复用）</li><li>异步非阻塞通信（基于 Netty 实现）</li><li>复用连接发送多次请求，避免了重复的 TCP 握手和断开操作，显著降低了网络资源和 CPU 消耗</li></ul><p>因此在生产环境中，建议使用 TCP 的单一长连接和 NIO 异步通信模型（Muduo 网络库天生支持），以此保证 RPC 框架的高并发性能。值得一提的是，使用 TCP 长连接后，需要额外处理 TCP 分包的问题，也就是将 TCP 字节流里的数据识别为一个个消息（RPC 请求消息）。</p><table><thead><tr><th>模式</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td>短连接（请求 - 响应后立即断开）</td><td>简单实现，资源浪费大</td><td>一般用于简单的 HTTP/1.0 接口或调试环境</td></tr><tr><td>长连接（复用 TCP 连接）</td><td>性能优越，适合高并发</td><td> gRPC、Dubbo、Redis、数据库连接等</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/18340f27.html">ZooKeeper 入门系列教程</a></li><li><a href="/posts/46940ea4.html">C++ 快速上手使用 Protobuf</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/5e6aa28a.html" title="C++ 实现 RPC 分布式网络通信框架">https://www.techgrow.cn/posts/5e6aa28a.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> Linux系统编程</a><a href="/tags/RPC/" rel="tag"><i class="fa fa-tag"></i> RPC</a><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 网络编程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/e635f0aa.html" rel="prev" title="基于 C++ 开发集群聊天服务器"><i class="fa fa-angle-left"></i> 基于 C++ 开发集群聊天服务器</a></div><div class="post-nav-item"> <a href="/posts/5e16ffff.html" rel="next" title="CMake 开发随笔">CMake 开发随笔<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.2m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">33:09</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/5e6aa28a.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>