<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="Redis入门教程之一五大数据类型，包括字符串类型、散列类型、列表类型、集合类型、有序集合类型。"><meta property="og:type" content="article"><meta property="og:title" content="Redis 入门教程之一五大数据类型"><meta property="og:url" content="https://www.techgrow.cn/posts/fea85f3.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="Redis入门教程之一五大数据类型，包括字符串类型、散列类型、列表类型、集合类型、有序集合类型。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/redis-bit-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/redis-bit-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/redis-hash-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/redis-hash-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/redis-list-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/redis-list-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2020/06/redis-list-3.png"><meta property="article:published_time" content="2020-06-16T13:15:32.000Z"><meta property="article:modified_time" content="2020-06-16T13:15:32.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="缓存"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2020/06/redis-bit-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/fea85f3.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/fea85f3.html","path":"posts/fea85f3.html","title":"Redis 入门教程之一五大数据类型"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Redis 入门教程之一五大数据类型 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script>
  (function () {

  // 防止 Pjax 重复绑定事件
  if (window.__moonMenuCodeExpandBound) {
    return;
  }
  window.__moonMenuCodeExpandBound = true;

  const STORAGE_KEY = 'moon_menu_code_fold';

  /* ===============================
   * 1. 设置 moon-menu 按钮的 title
   * =============================== */
  (function bindMoonMenuTitles() {
    const items = [
      { selector: '#moon-menu-item-code',        title: '展开 / 折叠代码块' },
      { selector: '#moon-menu-item-back2top',    title: '回到页面顶部' },
      { selector: '#moon-menu-item-back2bottom', title: '回到页面底部' }
    ];

    let allReady = true;

    items.forEach(item => {
      const el = document.querySelector(item.selector);
      if (!el) {
        allReady = false;
        return;
      }
      el.setAttribute('title', item.title);
    });

    if (!allReady) {
      setTimeout(bindMoonMenuTitles, 100);
    }
  })();

  /* =================================
   * 2. 页面首次加载：代码块恢复展开或折叠状态
   * ================================= */
  function applyStoredCodeState() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    const state = localStorage.getItem(STORAGE_KEY);
    if (!state) {
      return;
    }

    containers.forEach(container => {
      if (state === 'expanded') {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else if (state === 'folded') {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });
  }

  // 等代码块出现后，再恢复展开或折叠状态
  function waitAndApplyState() {
    const containers = document.querySelectorAll('.code-container');

    if (!containers.length) {
      setTimeout(waitAndApplyState, 100);
      return;
    }

    applyStoredCodeState();
  }

  // 页面首次加载时恢复状态
  waitAndApplyState();
  
  // Pjax 切换页面后，必须重新恢复状态
  document.addEventListener('pjax:complete', function () {
    waitAndApplyState();
  });

  /* ===============================
   * 3. 点击按钮：切换状态并保存
   * =============================== */
  document.addEventListener('click', function (e) {
    const codeMenu = e.target.closest('#moon-menu-item-code');
    if (!codeMenu) {
      return;
    }

    toggleAllCodeBlocks();
  });

  // 展开或折叠代码块
  function toggleAllCodeBlocks() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    // 只要存在折叠的代码块，就认为当前是折叠状态
    const hasFolded = Array.from(containers).some(c => {
      return c.classList.contains('highlight-fold');
    });

    containers.forEach(container => {
      if (hasFolded) {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });

    // 记录展开或折叠状态
    localStorage.setItem(
      STORAGE_KEY,
      hasFolded ? 'expanded' : 'folded'
    );
  }

})();
</script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%91%BD%E4%BB%A4"><span class="nav-text">系统级命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%AC%A6%E5%90%88%E8%A7%84%E5%88%99%E7%9A%84%E9%94%AE%E5%90%8D%E5%88%97%E8%A1%A8"><span class="nav-text">获取符合规则的键名列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-text">判断一个键是否存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%94%AE"><span class="nav-text">删除键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E9%94%AE%E5%80%BC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">获得键值的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%A9%BA%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">清空当前数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%A9%BA%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">清空所有数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-text">设置过期时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%89%A9%E4%BD%99%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4"><span class="nav-text">查看剩余存活时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%88String%EF%BC%89"><span class="nav-text">字符串类型（String）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%8F%96%E5%80%BC%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="nav-text">赋值与取值（字符串）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E6%95%B0%E5%AD%97"><span class="nav-text">递增数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B4%E6%95%B0"><span class="nav-text">增加指定的整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B4%E6%95%B0"><span class="nav-text">减少指定的整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-text">增加指定的浮点数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%B0%BE%E9%83%A8%E8%BF%BD%E5%8A%A0%E5%80%BC"><span class="nav-text">向尾部追加值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="nav-text">获取字符串长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E8%8E%B7%E5%8F%96-%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC"><span class="nav-text">同时获取 / 设置多个键值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-text">位操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E7%B1%BB%E5%9E%8B%EF%BC%88Hash%EF%BC%89"><span class="nav-text">散列类型（Hash）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%8F%96%E5%80%BC%EF%BC%88%E6%95%A3%E5%88%97%EF%BC%89"><span class="nav-text">赋值与取值（散列）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E6%AE%B5%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-text">判断字段是否存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%E8%B5%8B%E5%80%BC"><span class="nav-text">当字段不存在时赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%AE%B5"><span class="nav-text">增加字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E6%AE%B5"><span class="nav-text">删除字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E5%90%8D%E6%88%96%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="nav-text">只获取字段名或字段值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%EF%BC%88List%EF%BC%89"><span class="nav-text">列表类型（List）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%A4%E7%AB%AF%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-text">向列表两端添加元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%A4%E7%AB%AF%E5%BC%B9%E5%87%BA%E5%85%83%E7%B4%A0"><span class="nav-text">从列表两端弹出元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%88%97%E8%A1%A8%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">获取列表中元素的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E5%88%97%E8%A1%A8%E7%89%87%E6%AE%B5"><span class="nav-text">获得列表片段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%80%BC"><span class="nav-text">删除列表中指定的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%8E%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%83%E7%B4%A0%E5%80%BC"><span class="nav-text">获取与设置指定索引的元素值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E4%BF%9D%E7%95%99%E5%88%97%E8%A1%A8%E6%8C%87%E5%AE%9A%E7%89%87%E6%AE%B5"><span class="nav-text">只保留列表指定片段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="nav-text">向列表中插入元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%85%83%E7%B4%A0%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E8%BD%AC%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8"><span class="nav-text">将元素从一个列表转到另一个列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E9%98%BB%E5%A1%9E%E6%93%8D%E4%BD%9C"><span class="nav-text">列表阻塞操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88Set%EF%BC%89"><span class="nav-text">集合类型（Set）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">增加、删除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0"><span class="nav-text">获取集合中的所有元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD"><span class="nav-text">判断元素是否在集合中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E9%97%B4%E8%BF%90%E7%AE%97"><span class="nav-text">集合间运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%9B%86%E5%90%88%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">获取集合中元素的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E5%B9%B6%E5%B0%86%E7%BB%93%E6%9E%9C%E5%AD%98%E5%82%A8"><span class="nav-text">进行集合运算并将结果存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%BE%97%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">随机获得集合中的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E9%9B%86%E5%90%88%E4%B8%AD%E5%BC%B9%E5%87%BA%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-text">从集合中弹出一个元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88Sorted-Set%EF%BC%89"><span class="nav-text">有序集合类型（Sorted Set）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-text">增加元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%86%E6%95%B0"><span class="nav-text">获取元素的分数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E6%8E%92%E5%90%8D%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%97%E8%A1%A8"><span class="nav-text">获得排名在某个范围的元素列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E6%8C%87%E5%AE%9A%E5%88%86%E6%95%B0%E8%8C%83%E5%9B%B4%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">获得指定分数范围的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%87%8F%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%86%E6%95%B0"><span class="nav-text">增减某个元素的分数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%9B%86%E5%90%88%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-text">获取集合中元素的数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E6%8C%87%E5%AE%9A%E5%88%86%E6%95%B0%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="nav-text">获得指定分数范围内的元素个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-text">删除一个或多个元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E6%8E%92%E5%90%8D%E8%8C%83%E5%9B%B4%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">按照排名范围删除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E5%88%86%E6%95%B0%E8%8C%83%E5%9B%B4%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">按照分数范围删除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E5%85%83%E7%B4%A0%E7%9A%84%E6%8E%92%E5%90%8D"><span class="nav-text">获得元素的排名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-text">计算有序集合的交集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E9%9B%86"><span class="nav-text">计算有序集合的并集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="nav-text">数据类型使用总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">795</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">56</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/fea85f3.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Redis 入门教程之一五大数据类型 | Clay 的技术空间"><meta itemprop="description" content="Redis入门教程之一五大数据类型，包括字符串类型、散列类型、列表类型、集合类型、有序集合类型。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Redis 入门教程之一五大数据类型</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-06-16 21:15:32" itemprop="dateCreated datePublished" datetime="2020-06-16T21:15:32+08:00">2020-06-16</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/fea85f3.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/fea85f3.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>11k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>10 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="系统级命令"><a href="#系统级命令" class="headerlink" title="系统级命令"></a>系统级命令</h2><h3 id="获取符合规则的键名列表"><a href="#获取符合规则的键名列表" class="headerlink" title="获取符合规则的键名列表"></a>获取符合规则的键名列表</h3><p>KEYS 命令需要遍历 Redis 中的所有键，当键的数量较多时会严重影响性能，在生产环境中应该禁用该命令。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS pattern</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; KEYS *</span><br><span class="line">1) "book"</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>pattern 支持 Glob 风格的通配符格式：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td> ?</td><td> 匹配一个字符</td></tr><tr><td> *</td><td> 匹配任意个（包括 0 个）字符</td></tr><tr><td> [ ]</td><td> 匹配括号间的任一字符，可以使用 “-” 符号来表示一个范围，如 a [b-d] 可以匹配 “ab”、”ac”、”ad”</td></tr><tr><td>\x</td><td> 匹配字符 x，用于转义字符，如需要匹配 “?” 就需要使用 <code>\?</code></td></tr></tbody></table><h3 id="判断一个键是否存在"><a href="#判断一个键是否存在" class="headerlink" title="判断一个键是否存在"></a>判断一个键是否存在</h3><p>如果键存在则返回整数类型 1，否则返回 0。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS book</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS noexists</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><h3 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h3><p>可以删除一个或多个键，返回值是删除的键的个数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL book</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; DEL noexists</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><p>DEL 命令的参数不支持通配符，但可以结合 Linux 的管道和 xargs 命令实现删除所有符合规则的键。比如要删除以 “user:” 开头的键，就可以执行以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$ redis</span>-cli KEYS <span class="string">"user:*"</span> | xargs redis-cli DEL</span><br></pre></td></tr></tbody></table></figure><p>另外由于 DEL 命令支持多个键作为参数，所以还可以执行以下命令来达到同样的效果，但是性能更好：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$ redis</span>-cli DEL `redis-cli KEYS <span class="string">"user:*"</span>`</span><br></pre></td></tr></tbody></table></figure><h3 id="获得键值的数据类型"><a href="#获得键值的数据类型" class="headerlink" title="获得键值的数据类型"></a>获得键值的数据类型</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; type book</span><br><span class="line">string</span><br></pre></td></tr></tbody></table></figure><h3 id="清空当前数据库"><a href="#清空当前数据库" class="headerlink" title="清空当前数据库"></a>清空当前数据库</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSHDB [ASYNC]</span><br></pre></td></tr></tbody></table></figure><h3 id="清空所有数据库"><a href="#清空所有数据库" class="headerlink" title="清空所有数据库"></a>清空所有数据库</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSHALL [ASYNC]</span><br></pre></td></tr></tbody></table></figure><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key seconds</span><br></pre></td></tr></tbody></table></figure><h3 id="查看剩余存活时间"><a href="#查看剩余存活时间" class="headerlink" title="查看剩余存活时间"></a>查看剩余存活时间</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL key</span><br></pre></td></tr></tbody></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串类型（String）"><a href="#字符串类型（String）" class="headerlink" title="字符串类型（String）"></a>字符串类型（String）</h3><p>字符串类型是 Redis 中最基础的数据类型，它能存储任何形式的字符串，包括二进制数据。例如存储用户的邮箱、JSON 化的对象甚至是一张图片。一个字符串类型键允许存储的最大容量是 512 MB。字符串类型是其他 4 种数据类型的基础，其他数据类型和字符串类型的差别从某种角度来说只是组织字符串的形式不同。例如，列表类型（List）是以列表的形式组织字符串，而集合类型是以集合的形式组织字符串。</p><h4 id="赋值与取值（字符串）"><a href="#赋值与取值（字符串）" class="headerlink" title="赋值与取值（字符串）"></a>赋值与取值（字符串）</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line"></span><br><span class="line">GET key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET book java</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET book</span><br><span class="line">"java"</span><br></pre></td></tr></tbody></table></figure><p>取值时，当键不存在时，会返回空结果。</p><h4 id="递增数字"><a href="#递增数字" class="headerlink" title="递增数字"></a>递增数字</h4><p>字符串类型可以存储任何形式的字符串，当存储的字符串是整数形式时，Redis 提供了一个实用的命令 INCR，其作用是让当前键值递增 1，并返回递增后的值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INCR num</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; INCR num</span><br><span class="line">(integer) 2</span><br></pre></td></tr></tbody></table></figure><p>当要操作的键不存在时，会创建该键并设置值为 0，所以第一次递增后的结果为 1。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET foo bar</span><br><span class="line"></span><br><span class="line">redis&gt; INCR foo</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br></pre></td></tr></tbody></table></figure><p>当键值不是整数时，Redis 会提示错误。</p><h4 id="增加指定的整数"><a href="#增加指定的整数" class="headerlink" title="增加指定的整数"></a>增加指定的整数</h4><p>INCRBY 命令与 INCR 命令级别一样，只不过前者可以通过 increment 参数指定一次增加的数值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key increment</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INCRBY bar 2</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY bar 3</span><br><span class="line">(integer) 5</span><br></pre></td></tr></tbody></table></figure><h4 id="减少指定的整数"><a href="#减少指定的整数" class="headerlink" title="减少指定的整数"></a>减少指定的整数</h4><p>DECR 命令与 INCR 命令的用法相同，只不过是让键值递减 1。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DECR car</span><br><span class="line">(integer) -1</span><br></pre></td></tr></tbody></table></figure><p>DECRBY 与 INCRBY 命令的用法相同，可以通过 increment 参数指定一次递减的数值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECRBY key increment</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DECRBY cat 3</span><br><span class="line">(integer) -3</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY cat 5</span><br><span class="line">(integer) -8</span><br></pre></td></tr></tbody></table></figure><h4 id="增加指定的浮点数"><a href="#增加指定的浮点数" class="headerlink" title="增加指定的浮点数"></a>增加指定的浮点数</h4><p>INCRBYFLOAT 命令类似 INCRBY 命令，差别是 INCRBYFLOAT 可以递增一个双精度浮点数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key pattern</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INCRBYFLOAT bar 2.7</span><br><span class="line">"2.7"</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT bar 5E+4</span><br><span class="line">"50002.69999999999999929"</span><br></pre></td></tr></tbody></table></figure><h4 id="向尾部追加值"><a href="#向尾部追加值" class="headerlink" title="向尾部追加值"></a>向尾部追加值</h4><p>APPEND 的作用是向键值的末尾追加 value。如果键不存在，则会创建该键并设置值为 value，返回值是追加后字符串的总长度。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key value</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set key hello</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND key " world!"</span><br><span class="line">(integer) 12</span><br><span class="line"></span><br><span class="line">redis&gt; GET key</span><br><span class="line">"hello world!"</span><br></pre></td></tr></tbody></table></figure><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>STRLEN 命令返回键值的长度，如果键不存在则返回 0。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; STRLEN key</span><br><span class="line">(integer) 12</span><br><span class="line"></span><br><span class="line">redis&gt; set key 你好</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; STRLEN key</span><br><span class="line">(integer) 6</span><br></pre></td></tr></tbody></table></figure><h4 id="同时获取-设置多个键值"><a href="#同时获取-设置多个键值" class="headerlink" title="同时获取/设置多个键值"></a>同时获取 / 设置多个键值</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MGET key [key ...]</span><br><span class="line"></span><br><span class="line">MSET key value [key value ...]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET key1 v1 key2 v2 key3 v3</span><br><span class="line"></span><br><span class="line">redis&gt; MGET key1 key2 key3</span><br><span class="line">1) "v1"</span><br><span class="line">2) "v2"</span><br><span class="line">3) "v3"</span><br></pre></td></tr></tbody></table></figure><h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><p>位操作命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GETBIT key offset</span><br><span class="line"></span><br><span class="line">SETBIT key offset value</span><br><span class="line"></span><br><span class="line">BITCOUNT key [start] [end]</span><br><span class="line"></span><br><span class="line">BITOP operation destkey key [key ...]</span><br><span class="line"></span><br><span class="line">BITPOS key value [start] [end]</span><br></pre></td></tr></tbody></table></figure><p>一个字节由 8 个二进制位组成，Redis 提供了上述 4 个命令可以直接对二进制位进行操作。为了演示，首先将 foo 键赋值为 bar：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET foo bar</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><p>bar 的 3 个字母 “b”、”a”、”r” 对应的 ASCII 码分别是 98、97 和 114，转换成二进制后分别为 1100010、1100001、1110010，所以 foo 键中的二进制位结构图如下：</p><p><img data-src="../../../asset/2020/06/redis-bit-1.png" alt="redis-bit-1"></p><p>GETBIT 命令可以获取一个字符串类型键指定位置的二进制位的值（0 或 1），索引从 0 开始。如果需要获取的二进制位的索引超出了键值的二进制位的实际长度，则默认值为 0。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETBIT foo 0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT foo 6</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT foo 100000</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><p>SETBIT 命令可以设置字符串类型键指定位置的二进制位的值，返回值是该位置的旧值。如果要将 foo 键值设置为 aar，那么可以通过位操作将 foo 键的二进制位的索引第 6 位设置为 0，第 7 位设置为 1。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT foo 6 0</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT foo 7 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET foo</span><br><span class="line">"aar"</span><br></pre></td></tr></tbody></table></figure><p>如果要设置的位置超过了键值的二进制的长度，SETBIT 命令会自动将中间的二进制位设置为 0；同理设置一个不存在的键的指定二进制位的值，会自动将前面的位赋值为 0。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT nofoo 10 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT nofoo 5</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><p>BITCOUNT 命令可以获得字符串类型键中值是 1 的二进制位个数，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BITCOUNT foo</span><br><span class="line">(integer) 10</span><br></pre></td></tr></tbody></table></figure><p>BITCOUNT 可以通过参数限制统计的字节范围，例如只希望统计前两个字节（即 “fo”），字节范围从 0 开始：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BITCOUNT foo 0 1</span><br><span class="line">(integer) 6</span><br></pre></td></tr></tbody></table></figure><p>BITOP 命令可以对多个字符串类型键进行位运算，并将结果存储在 destkey 参数指定的键中。BITOP 命令支持的运算操作有 AND、OR、XOR 和 NOT。例如可以对 bar 和 aar 进行 OR 运算：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set foo1 bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; set foo2 aar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BITOP OR res foo1 foo2</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; GET res</span><br><span class="line">"car"</span><br></pre></td></tr></tbody></table></figure><p>具体的位运算过程如下图：</p><p><img data-src="../../../asset/2020/06/redis-bit-2.png" alt="redis-bit-2"></p><p>BITPOS 命令可以获得指定键的第一个位值是 0 或者 1 的位置。以 “bar” 这个键值为例，如果想获取键值中的第一个二进制位值为 1 的位置（从 0 开始算起），则可以执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BITPOS foo 1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></tbody></table></figure><p>对比上面位运算的过程图，正如 BITPOS 命令的执行结果所示，”bar” 中第一个值为 1 的二进制位的位置为 1（同其他命令一样，BITPOS 命令的索引也是从 0 开始算起）。如果希望指定二进制位的查询范围，那么可以使用 BITPOS 命令的第二个和第三个参数，它们分别用来指定要查询的起始字节（从 0 开始算起）和结束字节。特别注意，这里第二个和第三个参数的单位不再是二进制位，而是字节。而返回的结果（位置）是从头开始算起的，与起始字节无关。如果不设置结束字节且键值的所有二进制位都是 1 的时候，则当要查询值为 0 的二进制位的位置时，返回结果会是键值长度的下一个字位的位置，这是因为 Redis 会认为键值长度之后的二进制位都是 0。举个例子，如果想查询第二个字节到第三个字节之间（即 “a” 和 “r”）出现的第一个值为 1 的二进制位的位置，则可以执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BITPOS foo 1 1 2</span><br><span class="line">(integer) 9</span><br></pre></td></tr></tbody></table></figure><p><strong>位操作应用举例：</strong></p><p>利用位操作命令可以非常紧凑地存储布尔值。比如假设网站的每个用户都有一个递增的整数 ID，如果使用一个字符串类型键配合位操作来记录每个用户的性别（用户 ID 作为索引，二进制位值 1 和 0 表示男性和女性），那么记录 100 万个用户的性别只需占用 100 KB 多的空间，而且由于 GETBIT 和 SETBIT 的时间复杂度都是 O (1)，所以读取二进制位值性能很高。</p><p><strong>SETBIT 命令使用注意事项：</strong></p><p>使用 SETBIT 命令时，如果当前键的键值长度小于要设置的二进制位的位置时，Redis 会自动分配内存并将键值的当前长度到指定的位置之间的二进制位都设置为 0。此时如果要分配的内存过大，则很可能会造成服务器的暂时阻塞而无法处理同一时间的其他请求。还是举刚才存储网站用户性别的例子，如果这个网站的用户 ID 是从 100000001 开始的，那么会造成 10 多 MB 的浪费，正确的做法是给每个用户的 ID 减去 100000000 再进行存储。</p><h3 id="散列类型（Hash）"><a href="#散列类型（Hash）" class="headerlink" title="散列类型（Hash）"></a>散列类型（Hash）</h3><p>Redis 是采用字典结构以键值对的形式存储数据的，而散列类型（Hash）的键值是一种字典结构，其存储了字段（Field）和字段值的映射，但字段值只能是字符串，不支持其他数据类型，即散列类型不能嵌套其他的数据类型。一个散列类型键可以包含之多 2^32 - 1 个字段。除了散列类型，Redis 的其他数据类型同样不支持数据类型嵌套。比如集合类型的每个元素都只能是字符串，不能是另一个集合或散列表等。散列类型适合存储对象：使用对象类别和 ID 构成键名，使用字段表示对象的属性，而字段值则存储属性值。例如要存储 ID 为 2 的汽车对象，可以分别使用名为 color、name 和 price 的 3 个字段来存储该辆汽车的颜色、名称和价格，具体存储结构图如下：</p><p><img data-src="../../../asset/2020/06/redis-hash-1.png" alt="redis-hash-1"></p><p>对比关系数据库中存储的汽车对象：</p><p><img data-src="../../../asset/2020/06/redis-hash-2.png" alt="redis-hash-2"></p><p>关系型数据库中，数据是以二维表的形式存储的，这就要求所有的记录都拥有相同的属性，无法单独为某条记录增减属性。如果想为 ID 为 1 的汽车增加生产日期的属性，就需要吧数据表更改为如上图所示的结构。增加一个属性后对于 ID 为 2 和 3 的两条记录而言 data 字段是冗余的。而 Redis 的散列类型则不存在这个问题，上图中描述了汽车对象的存储结构，但是这个结构只是人为的约定，Redis 并不强制要求每个键都依据此结构存储，完全可以自由地为任何键增减字段而不影响其他键。</p><h4 id="赋值与取值（散列）"><a href="#赋值与取值（散列）" class="headerlink" title="赋值与取值（散列）"></a>赋值与取值（散列）</h4><p>赋值与取值命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br><span class="line"></span><br><span class="line">HGET key field</span><br><span class="line"></span><br><span class="line">HMSET key field value [field value ...]</span><br><span class="line"></span><br><span class="line">HMGET key field [field ...]</span><br><span class="line"></span><br><span class="line">HGETALL key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET car price 500</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET car name BMW</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET car name</span><br><span class="line">"BMW"</span><br></pre></td></tr></tbody></table></figure><p>HSET 命令的方便之处在于不区分新增和更新操作，这意味着修改数据时不用事先判断字段是否存在来决定要执行的是新增操作（inert）还是更新操作（update）。当执行的是新增操作时（即之前字段不存在）HSET 命令会返回 1，当执行的是更新操作时（即之前字段已经存在）HSET 命令会返回 0。更进一步，当键本身不存在时，HSET 命令还会自动创建它。<strong>值得注意的是，Redis 中每个键都属于一个明确的数据类型，如通过 HSET 命令建立的键是散列类型，通过 SET 命令建立的键是字符串类型等等。使用一种数据类型的命令操作另一种数据类型的键会提示错误：”ERR Operation against a key holding the wrong kind of value”；但并不是所有命令都如此，比如 SET 命令可以覆盖已经存在的键而不管原来的键是什么类型</strong>。</p><p>若需要同时设置、获取多个字段的值时，可以使用 HMSET、HMGET 命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET car2 price 500 name BMW</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HMGET car2 price name</span><br><span class="line">1) "500"</span><br><span class="line">2) "BMW"</span><br></pre></td></tr></tbody></table></figure><p>若想获取键中所有字段和字段值却不知道键中有哪些字段，则应该使用 HGETALL 命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGETALL car</span><br><span class="line">1) "price"</span><br><span class="line">2) "500"</span><br><span class="line">3) "name"</span><br><span class="line">4) "BMW"</span><br></pre></td></tr></tbody></table></figure><h4 id="判断字段是否存在"><a href="#判断字段是否存在" class="headerlink" title="判断字段是否存在"></a>判断字段是否存在</h4><p>HEXISTS 命令用来判断一个字段是否存在，如果存在则返回 1，否则返回 0（如果键不存在也会返回 0）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HEXISTS car model</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HSET car model c200</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HEXISTS car model</span><br><span class="line">(integer) 1</span><br></pre></td></tr></tbody></table></figure><h4 id="当字段不存在时赋值"><a href="#当字段不存在时赋值" class="headerlink" title="当字段不存在时赋值"></a>当字段不存在时赋值</h4><p>HSETNX 命令与 HSET 命令类似，区别在于如果字段已经存在，HSETNX 命令将不执行任何操作。HSETNX 命令中的 “NX” 表示 “If Not Exists”（如果不存在），同时 HSETNX 命令是原子操作，不用担心竞态条件，可以用作分布式锁的实现。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field value</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET car model c200</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSETNX car model c300</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HGET car model</span><br><span class="line">"c200"</span><br></pre></td></tr></tbody></table></figure><h4 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h4><p>HINCRBY 与 INCR、INCRBY 命令类似，可以使字段值增加指定的整数。散列类型没有 HINCR 命令，但可以通过 <code>HINCRBY key field 1</code> 来实现。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HINCRBY person score 60</span><br><span class="line">(integer) 60</span><br><span class="line"></span><br><span class="line">redis&gt; HGET person score</span><br><span class="line">"60"</span><br></pre></td></tr></tbody></table></figure><p>当 persion 键不存在时，HINCRBY 命令会自动建立该键，并设置字段 score 的默认值为 0，然后再执行自增操作，命令的返回结果是增值后的字段值。</p><h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><p>HDEL 命令可以删除一个或多个字段，返回值是被删除的字段个数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HDEL car name</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HDEL car name</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><h4 id="只获取字段名或字段值"><a href="#只获取字段名或字段值" class="headerlink" title="只获取字段名或字段值"></a>只获取字段名或字段值</h4><p>若仅仅需要获取键中所有字段的名称或者字段值，那么可以使用 HKEYS、HVALS 命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br><span class="line"></span><br><span class="line">HVALS key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HKEYS car</span><br><span class="line">1) "price"</span><br><span class="line">2) "model"</span><br><span class="line"></span><br><span class="line">redis&gt; HVALS car</span><br><span class="line">1) "500"</span><br><span class="line">2) "c200"</span><br></pre></td></tr></tbody></table></figure><h3 id="列表类型（List）"><a href="#列表类型（List）" class="headerlink" title="列表类型（List）"></a>列表类型（List）</h3><p>列表类型（List）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为 O (1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的 10 条记录也是极快的（和从只有 20 个元素的列表中获取头部或尾部的 10 条记录的速度是一样的），不过使用链表的代价是通过索引访问元素比较慢，其元素遍历速度要远慢于数组。这种特性使列表类型能非常快速地完成关系数据库难以应付的场景：如社交网站的新鲜事，用户关心的只是最新的内容，使用列表类型存储，即使新鲜事的总数达到几千万个，获取其中最新的 100 条数据也是极快的。同样因为在两端插入记录的时间复杂度是 O (1)，列表类型也适合用来记录日志，可以保证加入新日志的速度不会受到已有日志数量的影响。与散列类型键最多能容纳的字段数量相同，一个列表类型键最多能容纳 2^32 − 1 个元素。借助列表类型，Redis 还可以作为队列使用。</p><h4 id="向列表两端添加元素"><a href="#向列表两端添加元素" class="headerlink" title="向列表两端添加元素"></a>向列表两端添加元素</h4><p>LPUSH 命令用来向列表左边添加元素，返回值表示添加元素后列表的总长度。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key value [value …]</span><br><span class="line"></span><br><span class="line">RPUSH key value [value …]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH numbers 1</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH numbers 2 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></tbody></table></figure><p>当通过 LPUSH 命令往列表中依次添加 “1”、”2“、”3“ 时，numbers 键中的数据如下图所示：</p><p><img data-src="../../../asset/2020/06/redis-list-1.png" alt="redis-list-1"></p><p>使用 RPUSH 命令向列表右边添加元素的话，其用法和 LPUSH 命令一样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH numbers 0 -1</span><br><span class="line">(integer) 3</span><br></pre></td></tr></tbody></table></figure><p>此时 numbers 键中的数据如下图所示：</p><p><img data-src="../../../asset/2020/06/redis-list-2.png" alt="redis-list-2"></p><h4 id="从列表两端弹出元素"><a href="#从列表两端弹出元素" class="headerlink" title="从列表两端弹出元素"></a>从列表两端弹出元素</h4><p>有进有出，LPOP 命令可以从列表左边弹出一个元素。LPOP 命令执行两步操作：第一步是将列表左边的元素从列表中移除，第二步是返回被移除的元素值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br><span class="line"></span><br><span class="line">RPOP key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPOP numbers</span><br><span class="line">"3"</span><br><span class="line"></span><br><span class="line">redis&gt; RPOP numbers</span><br><span class="line">"-1"</span><br></pre></td></tr></tbody></table></figure><p>从 numbers 列表左边弹出一个元素（也就是 ”3“），同时列表右边也弹出一个元素（即”-1“），此时 numbers 键中的数据如下图所示：</p><p><img data-src="../../../asset/2020/06/redis-list-3.png" alt="redis-list-3"></p><p><strong>综合 LPUSH、RPUSH、LPOP、RPOP 命令，可以使用列表类型来模拟栈和队列的操作。如果想把列表当做栈，则搭配使用 LPUSH、LPOP 或 RPUSH、RPOP。如果想当成队列，则搭配使用 LPUSH、RPOP 或 RPUSH、LPOP。</strong></p><h4 id="获取列表中元素的个数"><a href="#获取列表中元素的个数" class="headerlink" title="获取列表中元素的个数"></a>获取列表中元素的个数</h4><p>当键不存在时，LLEN 命令会返回 0。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LLEN numbers</span><br><span class="line">(integer) 3</span><br></pre></td></tr></tbody></table></figure><p> LLEN 命令的功能类似 SQL 语句 <code>SELECT COUNT(*) FROM table_name</code>，但是 LLEN 的时间复杂度为 O (1)，使用时 Redis 会直接读取现成的值，而不需要像部分关系数据库（如使用 InnoDB 存储引擎的 MySQL 表）那样需要遍历一遍数据表来统计条目数量。</p><h4 id="获得列表片段"><a href="#获得列表片段" class="headerlink" title="获得列表片段"></a>获得列表片段</h4><p>LRANGE 命令是列表类型最常用的命令之一，它能够获得列表中的某一片段。LRANGE 命令将返回索引从 start 到 stop 之间的所有元素（包含两端的元素：start、stop），Redis 的列表起始索引为 0。LRANGE 命令在取得列表片段时，不会像 LPOP 一样删除该片段。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LRANGE numbers 0 2</span><br><span class="line">1) "2"</span><br><span class="line">2) "1"</span><br><span class="line">3) "0"</span><br></pre></td></tr></tbody></table></figure><p>LRANGE 命令也支持负索引，表示从右边开始计算序数，如 “-1” 表示最右边第一个元素，”-2” 表示最右边第二个元素，依次类推。显然，<code>LRANGE numbers 0 -1</code> 可以获取列表中的所有元素。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LRANGE numbers 0 -1</span><br><span class="line">1) "2"</span><br><span class="line">2) "1"</span><br><span class="line">3) "0"</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE numbers -2 -1</span><br><span class="line">1) "1"</span><br><span class="line">2) "0"</span><br></pre></td></tr></tbody></table></figure><p>虽然 <code>LRANGE numbers 0 -1</code> 可以获取列表中的所有元素，但存在一些特殊情况如下：</p><ul><li>如果 start 的索引位置比 stop 的索引位置靠后，则会返回空列表</li><li>如果 stop 大于实际的索引范围，则会返回到列表最右边的元素</li></ul><h4 id="删除列表中指定的值"><a href="#删除列表中指定的值" class="headerlink" title="删除列表中指定的值"></a>删除列表中指定的值</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count value</span><br></pre></td></tr></tbody></table></figure><p>LREM 命令会删除列表中前 count 个值为 value 的元素，返回值是实际删除的元素个数。根据 count 值的不同，LREM 命令的执行方式会略有差异，具体如下：</p><ul><li>当 count &gt; 0 时 LREM 命令会从列表左边开始删除前 count 个值为 value 的元素。</li><li>当 count &lt; 0 时 LREM 命令会从列表右边开始删除前 |count| 个值为 value 的元素。</li><li>当 count = 0 是 LREM 命令会删除所有值为 value 的元素。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LRANGE numbers 0 -1</span><br><span class="line">1) "2"</span><br><span class="line">2) "1"</span><br><span class="line">3) "0"</span><br><span class="line">4) "2"</span><br><span class="line"></span><br><span class="line"># 从右边开始删除第一个值为”2“的元素</span><br><span class="line">redis&gt; LREM numbers -1 2</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE numbers 0 -1</span><br><span class="line">1) "2"</span><br><span class="line">2) "1"</span><br><span class="line">3) "0"</span><br></pre></td></tr></tbody></table></figure><h4 id="获取与设置指定索引的元素值"><a href="#获取与设置指定索引的元素值" class="headerlink" title="获取与设置指定索引的元素值"></a>获取与设置指定索引的元素值</h4><p>如果要将列表类型当作数组来用，LINDEX 命令是必不可少的。LINDEX 命令用来返回指定索引的元素，索引从 0 开始。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br><span class="line"></span><br><span class="line">LSET key index value</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LRANGE numbers 0 -1</span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br><span class="line">4) "1"</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX numbers 1</span><br><span class="line">"3"</span><br></pre></td></tr></tbody></table></figure><p>LSET 是另一个通过索引操作列表的命令，它会将索引为 index 的元素赋值为 value。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LRANGE numbers 0 -1</span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br><span class="line">4) "1"</span><br><span class="line"></span><br><span class="line">redis&gt; LSET numbers 1 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX numbers 1</span><br><span class="line">"10"</span><br></pre></td></tr></tbody></table></figure><h4 id="只保留列表指定片段"><a href="#只保留列表指定片段" class="headerlink" title="只保留列表指定片段"></a>只保留列表指定片段</h4><p>LTRIM 命令可以删除指定索引范围之外的所有元素，其指定列表范围的方法和 LRANGE 命令相同，即保留索引从 start 到 stop 之间的所有元素（包含两端的元素：start、stop）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key start stop</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LRANGE numbers 0 -1</span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br><span class="line">4) "1"</span><br><span class="line"></span><br><span class="line">redis&gt; LTRIM numbers 1 2</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE numbers 0 -1</span><br><span class="line">1) "3"</span><br><span class="line">2) "2"</span><br></pre></td></tr></tbody></table></figure><p>LTRIM 命令常和 LPUSH 命令一起使用来限制列表中元素的数量，比如记录日志时希望只保留最近的 100 条日志，则每次加入新元素时调用一次 LTRIM 命令即可：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH logs $newLog</span><br><span class="line"></span><br><span class="line">LTRIM logs 0 99</span><br></pre></td></tr></tbody></table></figure><h4 id="向列表中插入元素"><a href="#向列表中插入元素" class="headerlink" title="向列表中插入元素"></a>向列表中插入元素</h4><p>LINSERT 命令首先会在列表中从左到右查找值为 pivot 的元素，然后根据第二个参数是 BEFORE 还是 AFTER 来决定将 value 插入到该元素的前面还是后面，命令的返回值是插入后列表的元素个数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key BEFORE|AFTER pivot value</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LRANGE numbers 0 -1</span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br><span class="line">4) "1"</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT numbers after 1 0</span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE numbers 0 -1</span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br><span class="line">4) "1"</span><br><span class="line">5) "0"</span><br></pre></td></tr></tbody></table></figure><h4 id="将元素从一个列表转到另一个列表"><a href="#将元素从一个列表转到另一个列表" class="headerlink" title="将元素从一个列表转到另一个列表"></a>将元素从一个列表转到另一个列表</h4><p>RPOPLPUSH 是个很有意思的命令，从名字就可以看出它的功能：先执行 RPOP 命令再执行 LPUSH 命令。RPOPLPUSH 命令会先从 source 列表类型键的右边弹出一个元素，然后将其加入到 destination 列表类型键的左边，并返回这个元素的值，整个过程是原子的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination</span><br></pre></td></tr></tbody></table></figure><p>当把列表类型作为队列使用时，RPOPLPUSH 命令可以很直观地在多个队列中传递数据。当 source 和 destination 相同时，RPOPLPUSH 命令会不断地将队尾的元素移到队首，借助这个特性可以实现一个网站监控系统：使用一个队列存储需要监控的网址，然后监控程序不断地使用 RPOPLPUSH 命令循环取出一个网址来测试可用性。这里使用 RPOPLPUSH 命令的好处在于在程序执行过程中仍然可以不断地向网址列表中加入新网址，而且整个系统容易扩展，允许多个客户端同时处理队列。</p><h4 id="列表阻塞操作"><a href="#列表阻塞操作" class="headerlink" title="列表阻塞操作"></a>列表阻塞操作</h4><p>BLPOP 命令是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，Redis 连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。超时参数 timeout 接受一个以秒为单位的数字作为值，设为 0 表示阻塞时间可以无限期延迟。当给定多个 Key 参数时，BLPOP 命令会按参数 Key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。如果所有给定 Key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接直到等待超时，或者有另一个客户端对给定 Key 的任意一个执行 LPUSH 或 RPUSH 命令为止。BRPOP、BRPOPLPUSH 命令与 BLPOP 命令类似，这里不再累述。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"></span><br><span class="line">BRPOP key [key ...] timeout</span><br><span class="line"></span><br><span class="line">BRPOPLPUSH source destination timeout</span><br></pre></td></tr></tbody></table></figure><p>示例：假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH command "update system"</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH request "visit page"</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job command request 0</span><br><span class="line">1) "command"</span><br><span class="line">2) "update system..."</span><br></pre></td></tr></tbody></table></figure><p>上面的例子中，BLPOP 命令返回的元素来自 command 列表，因为它是按” 查找 job -&gt; 查找 command -&gt; 查找 request “这样的顺序，找到第一个非空列表 command。</p><h3 id="集合类型（Set）"><a href="#集合类型（Set）" class="headerlink" title="集合类型（Set）"></a>集合类型（Set）</h3><p>在集合中的每个元素都是不同的，且没有顺序。一个集合类型键可以存储至多 2^32 - 1 个字符串。集合类型与散列类型的对比如下：</p><table><thead><tr><th>比较内容</th><th>集合类型</th><th>列表类型</th></tr></thead><tbody><tr><td>存储内容</td><td>至多 2^32 - 1 个字符串</td><td>至多 2^32 - 1 个字符串</td></tr><tr><td>有序性</td><td>否</td><td>是</td></tr><tr><td>唯一性</td><td>是</td><td>否</td></tr></tbody></table><p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等。由于集合类型在 Redis 内部是使用值为空的散列表（Hash Table）实现的，所以这些操作的时间复杂度都是 O (1)。最方便的是多个集合类型键之间还可以进行并集、交集和差集运算。</p><h4 id="增加、删除元素"><a href="#增加、删除元素" class="headerlink" title="增加、删除元素"></a>增加、删除元素</h4><p>SADD 命令用来向集合中增加一个或多个元素，如果键不存在则会自动创建。因为在一个集合中不能有相同的元素，所以如果要加入的元素已经存在于集合中就会忽略这个元素。该命令的返回值是成功加入的元素数量（忽略的元素不计算在内）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member …]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD letters a</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SADD letters a b c</span><br><span class="line">(integer) 2</span><br></pre></td></tr></tbody></table></figure><p>SREM 命令用来从集合中删除一个或多个元素，并返回删除成功的个数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member …]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SREM letters b c</span><br><span class="line">(integer) 2</span><br></pre></td></tr></tbody></table></figure><h4 id="获取集合中的所有元素"><a href="#获取集合中的所有元素" class="headerlink" title="获取集合中的所有元素"></a>获取集合中的所有元素</h4><p>SMEMBERS 命令会返回集合中的所有元素。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS letters</span><br><span class="line">1) "a"</span><br><span class="line">2) "b"</span><br></pre></td></tr></tbody></table></figure><h4 id="判断元素是否在集合中"><a href="#判断元素是否在集合中" class="headerlink" title="判断元素是否在集合中"></a>判断元素是否在集合中</h4><p>判断一个元素是否在集合中是一个时间复杂度为 O (1) 的操作，无论集合中有多少个元素，SISMEMBER 命令始终可以极快地返回结果。当值存在时 SISMEMBER 命令返回 1，当值不存在或键不存在时返回 0。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SISMEMBER letters a</span><br><span class="line">(integer) 1</span><br></pre></td></tr></tbody></table></figure><h4 id="集合间运算"><a href="#集合间运算" class="headerlink" title="集合间运算"></a>集合间运算</h4><p>集合间运算命令（差集、交集、并集）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br><span class="line"></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"></span><br><span class="line">SUNION key [key ...]</span><br></pre></td></tr></tbody></table></figure><p>SDIFF 命令用来对多个集合执行差集运算。集合 A 与集合 B 的差集表示为 A−B，代表所有属于 A 且不属于 B 的元素构成的集合。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD setA 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SADD setB 2 3 4</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SDIFF setA setB</span><br><span class="line">1) "1"</span><br><span class="line"></span><br><span class="line">redis&gt; SDIFF setB setA</span><br><span class="line">1) "4"</span><br></pre></td></tr></tbody></table></figure><p>SDIFF 命令自持同时传入多个键，下面的例子中，计算顺序是先计算 setA 与 setB 的差集，再计算结果与 setC 的差集。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD setA 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SADD setB 2 3 4</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SADD setC 2 3</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; SDIFF setA setB setC</span><br><span class="line">1) "1"</span><br></pre></td></tr></tbody></table></figure><p>SINTER 命令用来对多个集合执行交集运算。集合 A 与集合 B 的交集表示为 A ∩ B，代表所有属于 A 且属于 B 的元素构成的集合。SINTER 同样支持同时传入多个键。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD setA 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SADD setB 2 3 4</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SINTER setA setB</span><br><span class="line">1) "2"</span><br><span class="line">2) "3"</span><br></pre></td></tr></tbody></table></figure><p>SUNION 命令用来对多个集合执行并集运算。集合 A 与集合 B 的并集表示为 A ∪ B，代表所有属于 A 或者属于 B 的元素构成的集合。SUNION 同样支持同时传入多个键。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD setA 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SADD setB 2 3 4</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SUNION setA setB</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) "4"</span><br></pre></td></tr></tbody></table></figure><h4 id="获取集合中元素的个数"><a href="#获取集合中元素的个数" class="headerlink" title="获取集合中元素的个数"></a>获取集合中元素的个数</h4><p>SCARD 命令用来获得集合中的元素个数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS setA</span><br><span class="line">1) "b"</span><br><span class="line">2) "d"</span><br><span class="line">3) "a"</span><br><span class="line">4) "c"</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD setA</span><br><span class="line">(integer) 4</span><br></pre></td></tr></tbody></table></figure><h4 id="进行集合运算并将结果存储"><a href="#进行集合运算并将结果存储" class="headerlink" title="进行集合运算并将结果存储"></a>进行集合运算并将结果存储</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination key [key …]</span><br><span class="line"></span><br><span class="line">SINTERSTORE destination key [key …]</span><br><span class="line"></span><br><span class="line">SUNIONSTORE destination key [key …]</span><br></pre></td></tr></tbody></table></figure><ul><li>SDIFFSTORE 命令和 SDIFF 命令功能一样，唯一的区别就是前者不会直接返回运算结果，而是将结果存储在 destination 键中。</li><li>SDIFFSTORE 命令常用于需要进行多步集合运算的场景中，如需要先计算差集再将结果和其他键计算交集。</li><li>SINTERSTORE 、 SUNIONSTORE 命令与 SDIFFSTORE 类似，不再赘述。</li></ul><h4 id="随机获得集合中的元素"><a href="#随机获得集合中的元素" class="headerlink" title="随机获得集合中的元素"></a>随机获得集合中的元素</h4><p>SRANDMEMBER 命令用来随机从集合中获取一个元素，还可以传递 count 参数来一次随机获得多个元素。根据 count 的正负不同，SRANDMEMBER 命令的具体表现也不同：</p><ul><li>当 count 为正数时，SRANDMEMBER 会随机从集合里获得 count 个不重复的元素。如果 count 的值大于集合中的元素个数，则 SRANDMEMBER 会返回集合中的全部元素。</li><li>当 count 为负数时，SRANDMEMBER 会随机从集合里获得 |count| 个的元素，这些元素有可能相同。</li><li>SRANDMEMBER 命令返回的结果并不是非常随机的，根本原因是由集合类型的存储结构（Hash Table）决定的，<a href="../../../asset/2020/06/redis-list-rand.png">点击查看详细解释</a></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS setA</span><br><span class="line">1) "b"</span><br><span class="line">2) "d"</span><br><span class="line">3) "a"</span><br><span class="line">4) "c"</span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER setA</span><br><span class="line">"b"</span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER setA 1</span><br><span class="line">1) "c"</span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER setA -2</span><br><span class="line">1) "c"</span><br><span class="line">2) "c"</span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER setA 5</span><br><span class="line">1) "b"</span><br><span class="line">2) "a"</span><br><span class="line">3) "d"</span><br><span class="line">4) "c"</span><br></pre></td></tr></tbody></table></figure><h4 id="从集合中弹出一个元素"><a href="#从集合中弹出一个元素" class="headerlink" title="从集合中弹出一个元素"></a>从集合中弹出一个元素</h4><p>由于集合类型的元素是无序的，所以 SPOP 命令会从集合中随机选择一个元素弹出。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS setA</span><br><span class="line">1) "b"</span><br><span class="line">2) "d"</span><br><span class="line">3) "a"</span><br><span class="line">4) "c"</span><br><span class="line"></span><br><span class="line">redis&gt; SPOP setA</span><br><span class="line">"c"</span><br></pre></td></tr></tbody></table></figure><h3 id="有序集合类型（Sorted-Set）"><a href="#有序集合类型（Sorted-Set）" class="headerlink" title="有序集合类型（Sorted Set）"></a>有序集合类型（Sorted Set）</h3><p>在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数，这使得不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前 N 个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每个元素都是不同的，但是它们的分数却可以相同。</p><p><strong>有序集合类型和列表类型的相同点：</strong></p><ul><li>都是有序的</li><li>都可以获得某一范围的元素</li></ul><p><strong>有序集合类型和列表类型的不同点：</strong></p><ul><li>列表类型是通过双向链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如 “新鲜事” 或 “日志” 这样很少访问中间元素的应用</li><li>有序集合类型是使用散列表（Hash Table）和跳跃表（Skip List）实现的，所以即使读取位于中间部分的数据速度也很快，时间复杂度是 O (log (N))</li><li> 列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）</li><li>有序集合要比列表类型更耗费内存</li></ul><h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><p>ZADD 命令用来向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。ZADD 命令的返回值是新加入到集合中的元素个数（不包含之前已经存在的元素）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member [score member …]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD scoreboard 89 Tom 67 Peter 100 Jim</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD scoreboard 80 Peter</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><p>分数不仅可以是整数，还支持双精度浮点数，其中 <code>+inf</code> 和 <code>-inf</code> 分别表示正无穷和负无穷。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD testboard 17E+307 a</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD testboard 1.5 b</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD testboard `+inf`c</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD testboard `-inf` d</span><br><span class="line">(integer) 1</span><br></pre></td></tr></tbody></table></figure><h4 id="获取元素的分数"><a href="#获取元素的分数" class="headerlink" title="获取元素的分数"></a>获取元素的分数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZSCORE scoreboard Tom</span><br><span class="line">"89"</span><br></pre></td></tr></tbody></table></figure><h4 id="获得排名在某个范围的元素列表"><a href="#获得排名在某个范围的元素列表" class="headerlink" title="获得排名在某个范围的元素列表"></a>获得排名在某个范围的元素列表</h4><p>ZRANGE 命令会按照元素分数从小到大的顺序返回索引从 start 到 stop 之间的所有元素（包含两端的元素：start、stop）。ZRANGE 命令与 LRANGE 命令十分类似，如索引都是从 0 开始，负数代表从后向前查找（−1 表示最后一个元素）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD scoreboard 89 Tom 67 Peter 100 Jim</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE scoreboard 0 2</span><br><span class="line">1) "Peter"</span><br><span class="line">2) "Tom"</span><br><span class="line">3) "Jim"</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE scoreboard 1 -1</span><br><span class="line">1) "Tom"</span><br><span class="line">2) "Jim"</span><br></pre></td></tr></tbody></table></figure><p>如果需要同时获得元素的分数的话，可以在 ZRANGE 命令的尾部加上 WITHSCORES 参数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE scoreboard 0 -1 WITHSCORES</span><br><span class="line">1) "Peter"</span><br><span class="line">2) "67"</span><br><span class="line">3) "Tom"</span><br><span class="line">4) "89"</span><br><span class="line">5) "Jim"</span><br><span class="line">6) "100"</span><br></pre></td></tr></tbody></table></figure><p>ZRANGE 命令的时间复杂度为 O (log n+m)，其中 n 为有序集合的基数，m 为返回的元素个数。如果两个元素的分数相同，Redis 会按照字典顺序（即 0 &lt; 9 &lt; A &lt; Z &lt; a &lt; z 的顺序）来进行排列。如果元素的值是中文，那么排列顺序取决于中文的编码方式，例如使用 UTF-8 编码时排列顺序如下，可见此时 Redis 依然是按照字典顺序排列这些元素。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD chineseName 0 马华 0 刘墉 0 司马光 0 赵哲</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE chineseName 0 -1</span><br><span class="line">1) "\xe5\x88\x98\xe5\xa2\x89"</span><br><span class="line">2) "\xe5\x8f\xb8\xe9\xa9\xac\xe5\x85\x89"</span><br><span class="line">3) "\xe8\xb5\xb5\xe5\x93\xb2"</span><br><span class="line">4) "\xe9\xa9\xac\xe5\x8d\x8e"</span><br></pre></td></tr></tbody></table></figure><p>ZREVRANGE 命令与 ZRANGE 命令的唯一不同在于 ZREVRANGE 命令是按照元素的分数从大到小的顺序输出结果。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZREVRANGE scoreboard 0 -1 WITHSCORES</span><br><span class="line">1) "Jim"</span><br><span class="line">2) "100"</span><br><span class="line">3) "Tom"</span><br><span class="line">4) "89"</span><br><span class="line">5) "Peter"</span><br><span class="line">6) "67"</span><br></pre></td></tr></tbody></table></figure><h4 id="获得指定分数范围的元素"><a href="#获得指定分数范围的元素" class="headerlink" title="获得指定分数范围的元素"></a>获得指定分数范围的元素</h4><p>ZRANGEBYSCORE 命令参数虽然多，但是都很好理解。该命令按照元素分数从小到大的顺序返回分数在 min 和 max 之间（包含 min 和 max ）的元素。值得注意的是，ZREVRANGEBYSCORE 命令不仅是按照元素分数从大往小的顺序输出结果，而且它的 min 和 max 参数的位置与 ZRANGEBYSCORE 命令是相反的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"></span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD scoreboard 89 Tom 67 Peter 100 Jim</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE scoreboard 80 100</span><br><span class="line">1) "Tom"</span><br><span class="line">2) "Jim"</span><br></pre></td></tr></tbody></table></figure><p>如果希望分数范围不包含端点值，可以在分数前加上 “(” 符号。例如，希望返回 80 分到 100 分的数据，可以含 80 分，但不包含 100 分，则命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGEBYSCORE scoreboard 80 (100</span><br><span class="line">1) "Tom"</span><br></pre></td></tr></tbody></table></figure><p>min 和 max 还支持无穷值，这和 ZADD 命令一样，其中 <code>+inf</code> 和 <code>-inf</code> 分别表示正无穷和负无穷。比如希望得到分数高于 80 分（不包含 80 分）的人的名单，但却不知道最高分是多少，这时候就可以用上 +inf：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGEBYSCORE scoreboard (80 +inf</span><br><span class="line">1) "Tom"</span><br><span class="line">2) "Jim"</span><br></pre></td></tr></tbody></table></figure><p><code>LIMIT offset count</code> 与 SQL 中的用法基本相同，即在获得的元素列表的基础上向后偏移 offset 个元素，并且只获取 count 个元素。例如下面的例子中，表示获得分数高于 60 分的，并从第二个人开始的 3 个人：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE scoreboard 0 -1 WITHSCORES</span><br><span class="line"> 1) "Jerry"</span><br><span class="line"> 2) "56"</span><br><span class="line"> 3) "Peter"</span><br><span class="line"> 4) "67"</span><br><span class="line"> 5) "Yvonne"</span><br><span class="line"> 6) "67"</span><br><span class="line"> 7) "Tom"</span><br><span class="line"> 8) "89"</span><br><span class="line"> 9) "Wendy"</span><br><span class="line">10) "92"</span><br><span class="line">11) "Jim"</span><br><span class="line">12) "100"</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE scoreboard 60 +inf LIMIT 1 3</span><br><span class="line">1) "Yvonne"</span><br><span class="line">2) "Tom"</span><br><span class="line">3) "Wendy"</span><br></pre></td></tr></tbody></table></figure><p>如果想获取分数低于或等于 100 分的前 3 个人，可以借助 ZREVRANGEBYSCORE 命令实现。ZREVRANGEBYSCORE 命令不仅是按照元素分数从大往小的顺序输出结果，而且它的 min 和 max 参数的位置与 ZRANGEBYSCORE 命令是相反的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZREVRANGE scoreboard 0 -1 WITHSCORES</span><br><span class="line"> 1) "Jim"</span><br><span class="line"> 2) "100"</span><br><span class="line"> 3) "Wendy"</span><br><span class="line"> 4) "92"</span><br><span class="line"> 5) "Tom"</span><br><span class="line"> 6) "89"</span><br><span class="line"> 7) "Yvonne"</span><br><span class="line"> 8) "67"</span><br><span class="line"> 9) "Peter"</span><br><span class="line">10) "67"</span><br><span class="line">11) "Jerry"</span><br><span class="line">12) "56"</span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANGEBYSCORE scoreboard 100 0 LIMIT 0 3</span><br><span class="line">1) "Jim"</span><br><span class="line">2) "Wendy"</span><br><span class="line">3) "Tom"</span><br></pre></td></tr></tbody></table></figure><h4 id="增减某个元素的分数"><a href="#增减某个元素的分数" class="headerlink" title="增减某个元素的分数"></a>增减某个元素的分数</h4><p>ZINCRBY 命令可以增加一个元素的分数，返回值是更改后的分数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZSCORE scoreboard Peter</span><br><span class="line">"67"</span><br><span class="line"></span><br><span class="line">redis&gt; ZINCRBY scoreboard 6 Peter</span><br><span class="line">"73"</span><br><span class="line"></span><br><span class="line">redis&gt; ZSCORE scoreboard Peter</span><br><span class="line">"73"</span><br></pre></td></tr></tbody></table></figure><p>increment 也可以是个负数表示减分，例如给 Peter 减 4 分：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZINCRBY scoreboard -4 Peter</span><br><span class="line">"69"</span><br></pre></td></tr></tbody></table></figure><p>如果指定的元素不存在，Redis 在执行命令前会先建立它并将它的分数值赋为 0，然后再执行增减操作。</p><h4 id="获取集合中元素的数量"><a href="#获取集合中元素的数量" class="headerlink" title="获取集合中元素的数量"></a>获取集合中元素的数量</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZCARD scoreboard</span><br><span class="line">(integer) 6</span><br></pre></td></tr></tbody></table></figure><h4 id="获得指定分数范围内的元素个数"><a href="#获得指定分数范围内的元素个数" class="headerlink" title="获得指定分数范围内的元素个数"></a>获得指定分数范围内的元素个数</h4><p>ZCOUNT 命令的 min 和 max 参数的特性与 ZRANGEBYSCORE 命令中的一样。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE scoreboard 0 -1 WITHSCORES</span><br><span class="line"> 1) "Jerry"</span><br><span class="line"> 2) "56"</span><br><span class="line"> 3) "Yvonne"</span><br><span class="line"> 4) "67"</span><br><span class="line"> 5) "Peter"</span><br><span class="line"> 6) "69"</span><br><span class="line"> 7) "Tom"</span><br><span class="line"> 8) "89"</span><br><span class="line"> 9) "Wendy"</span><br><span class="line">10) "92"</span><br><span class="line">11) "Jim"</span><br><span class="line">12) "100"</span><br><span class="line"></span><br><span class="line">redis&gt; ZCOUNT scoreboard 90 100</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZCOUNT scoreboard (80 +inf</span><br><span class="line">(integer) 3</span><br></pre></td></tr></tbody></table></figure><h4 id="删除一个或多个元素"><a href="#删除一个或多个元素" class="headerlink" title="删除一个或多个元素"></a>删除一个或多个元素</h4><p>ZREM 命令的返回值是成功删除的元素数量（不包含本来就不存在的元素）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member …]</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZREM scoreboard Wendy</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZCARD scoreboard</span><br><span class="line">(integer) 5</span><br></pre></td></tr></tbody></table></figure><h4 id="按照排名范围删除元素"><a href="#按照排名范围删除元素" class="headerlink" title="按照排名范围删除元素"></a>按照排名范围删除元素</h4><p>ZREMRANGEBYRANK 命令按照元素分数从小到大的顺序（即索引 0 表示最小的值）删除处在指定排名范围内的所有元素，并返回删除的元素数量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD testRem 1 a 2 b 3 c 4 d 5 e 6 f</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYRANK testRem 0 2</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE testRem 0 -1</span><br><span class="line">1) "d"</span><br><span class="line">2) "e"</span><br><span class="line">3) "f"</span><br></pre></td></tr></tbody></table></figure><h4 id="按照分数范围删除元素"><a href="#按照分数范围删除元素" class="headerlink" title="按照分数范围删除元素"></a>按照分数范围删除元素</h4><p>ZREMRANGEBYSCORE 命令会删除指定分数范围内的所有元素，参数 min 和 max 的特性和 ZRANGEBYSCORE 命令中的一样，返回值是删除的元素数量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD testRem 1 a 2 b 3 c 4 d 5 e 6 f</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYSCORE testRem (4 5</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE testRem 0 -1</span><br><span class="line">1) "a"</span><br><span class="line">2) "b"</span><br><span class="line">3) "c"</span><br><span class="line">4) "d"</span><br><span class="line">5) "f"</span><br></pre></td></tr></tbody></table></figure><h4 id="获得元素的排名"><a href="#获得元素的排名" class="headerlink" title="获得元素的排名"></a>获得元素的排名</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member</span><br><span class="line"></span><br><span class="line">ZREVRANK key member</span><br></pre></td></tr></tbody></table></figure><p>ZRANK 命令会按照元素分数从小到大的顺序获得指定的元素的排名（从 0 开始，即分数最小的元素排名为 0）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD testRem 1 a 2 b 3 c 4 d 5 e 6 f</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANK testRem b</span><br><span class="line">(integer) 1</span><br></pre></td></tr></tbody></table></figure><p>ZREVRANK 命令则与 ZRANK 命令相反，分数最大的元素排名为 0。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD testRem 1 a 2 b 3 c 4 d 5 e 6 f</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANK testRem f</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><h4 id="计算有序集合的交集"><a href="#计算有序集合的交集" class="headerlink" title="计算有序集合的交集"></a>计算有序集合的交集</h4><p>ZINTERSTORE 命令用来计算多个有序集合的交集并将结果存储在 destination 键中（同样以有序集合类型存储），返回值为 destination 键中的元素个数，若 destination 键已存在则会被覆盖。其中 destination 键中元素的分数是由 AGGREGATE 参数决定的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight…]] [AGGREGATE SUM|MIN|MAX]</span><br></pre></td></tr></tbody></table></figure><p>当 AGGREGATE 是 SUM 时（也就是默认值），destination 键中元素的分数是每个参与计算的集合中该元素分数的和。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD sortedSets1 1 a 2 b</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD sortedSets2 10 a 20 b</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES</span><br><span class="line">1) "a"</span><br><span class="line">2) "11"</span><br><span class="line">3) "b"</span><br><span class="line">4) "22"</span><br></pre></td></tr></tbody></table></figure><p>当 AGGREGATE 是 MIN 时，destination 键中元素的分数是每个参与计算的集合中该元素分数的最小值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD sortedSets1 1 a 2 b</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD sortedSets2 10 a 20 b</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MIN</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES</span><br><span class="line">1) "a"</span><br><span class="line">2) "1"</span><br><span class="line">3) "b"</span><br><span class="line">4) "2"</span><br></pre></td></tr></tbody></table></figure><p>当 AGGREGATE 是 MAX 时，destination 键中元素的分数是每个参与计算的集合中该元素分数的最大值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD sortedSets1 1 a 2 b</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD sortedSets2 10 a 20 b</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MAX</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES</span><br><span class="line">1) "a"</span><br><span class="line">2) "10"</span><br><span class="line">3) "b"</span><br><span class="line">4) "20"</span><br></pre></td></tr></tbody></table></figure><h4 id="计算有序集合的并集"><a href="#计算有序集合的并集" class="headerlink" title="计算有序集合的并集"></a>计算有序集合的并集</h4><p>ZUNIONSTORE 命令用于计算集合间的并集，与 ZINTERSTORE 命令的使用方法一样，这里不再累述。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight…]] [AGGREGATE SUM|MIN|MAX]</span><br></pre></td></tr></tbody></table></figure><h2 id="数据类型使用总结"><a href="#数据类型使用总结" class="headerlink" title="数据类型使用总结"></a>数据类型使用总结</h2><table><thead><tr><th>数据类型</th><th>结构存储的值</th><th>结构的读写能力</th><th>博客系统中的应用</th></tr></thead><tbody><tr><td>字符串类型</td><td>可以是字符串、整数或者浮点数</td><td>对整个字符串或字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作</td><td>（1） 博客文章访问量统计（2）生成自增 ID</td></tr><tr><td> 散列类型</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对</td><td>（1）存储文章数据（2）存储文章缩略名</td></tr><tr><td>列表类型</td><td>一个双向链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪（Trim）；读取单个或多个元素；根据值查找或者移除元素</td><td>（1）存储文章 ID 列表（2）存储评论列表</td></tr><tr><td>集合类型</td><td>包含字符串的无序收集器，并且被包含的每个字符串都不可重复</td><td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td><td>（1）存储文章标签（2）通过标签搜索文章</td></tr><tr><td>有序集合类型</td><td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围或者成员来获取元素</td><td>（1）实现按点击量排序（2）更改文章发布时间和获得指定时间范围内的文章列表</td></tr></tbody></table><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/fea85f3.html" title="Redis 入门教程之一五大数据类型">https://www.techgrow.cn/posts/fea85f3.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"><i class="fa fa-tag"></i> 缓存</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/503c34e4.html" rel="prev" title="Nginx + Keepalived 实现双机主备高可用"><i class="fa fa-angle-left"></i> Nginx + Keepalived 实现双机主备高可用</a></div><div class="post-nav-item"> <a href="/posts/ab69cb0a.html" rel="next" title="消息中间件产品对比介绍">消息中间件产品对比介绍<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2026</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.3m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">35:32</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"/lib/mathjax/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/fea85f3.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div><div id="moon-menu-item-code" class="moon-menu-item"><i class="fa-solid fa-code"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>