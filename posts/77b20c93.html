<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍分布式系统中缓存雪崩的解决方案。"><meta property="og:type" content="article"><meta property="og:title" content="分布式系统中缓存雪崩的解决方案"><meta property="og:url" content="https://www.techgrow.cn/posts/77b20c93.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍分布式系统中缓存雪崩的解决方案。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/08/redis-avalanche-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/09/multi-cache-read.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/09/multi-cache-write-through.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/09/multi-cache-write-behind.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/09/multi-cache-cache-aside.png"><meta property="article:published_time" content="2025-05-12T13:43:32.000Z"><meta property="article:modified_time" content="2025-05-12T13:43:32.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="微服务"><meta property="article:tag" content="架构设计"><meta property="article:tag" content="分布式"><meta property="article:tag" content="缓存"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/08/redis-avalanche-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/77b20c93.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/77b20c93.html","path":"posts/77b20c93.html","title":"分布式系统中缓存雪崩的解决方案"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>分布式系统中缓存雪崩的解决方案 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">缓存雪崩的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="nav-text">缓存雪崩的解决</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E7%9A%84%E9%98%B2%E6%8A%A4%E6%80%9D%E8%B7%AF"><span class="nav-text">整体的防护思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88%E4%B8%8E%E5%8F%AF%E9%80%89%E6%A1%86%E6%9E%B6"><span class="nav-text">具体方案与可选框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%8F%AF%E8%90%BD%E5%9C%B0%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-text">具体可落地的架构与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88%E8%90%BD%E5%9C%B0%E9%A1%BA%E5%BA%8F%E5%BB%BA%E8%AE%AE%EF%BC%89"><span class="nav-text">最佳实践（落地顺序建议）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-text">推荐使用技术的组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">常见误区与注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-text">多级缓存的读写流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="nav-text">读取流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="nav-text">更新流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%BB%84%E5%90%88"><span class="nav-text">最佳实践组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="nav-text">方案总结对比</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">754</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/77b20c93.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="分布式系统中缓存雪崩的解决方案 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍分布式系统中缓存雪崩的解决方案。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 分布式系统中缓存雪崩的解决方案</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-05-12 21:43:32" itemprop="dateCreated datePublished" datetime="2025-05-12T21:43:32+08:00">2025-05-12</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/77b20c93.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/77b20c93.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>5 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在中大型项目中经常会使用到 Redis，当 Redis 缓存服务（一主多从 + 哨兵架构或者集群架构）不可用时，所有请求会直接打到 MySQL，瞬间把数据库压垮（即缓存雪崩），导致整个系统不可用。那么如何设计系统架构，即使 Redis 缓存服务完全不可用，整个系统也可以正常运行（不至于完全挂掉）呢？</p><span id="more"></span><h2 id="缓存雪崩的概念"><a href="#缓存雪崩的概念" class="headerlink" title="缓存雪崩的概念"></a>缓存雪崩的概念</h2><ul><li><strong>缓存雪崩是指在设置缓存时采用了相同的过期时间，甚至缓存中间件挂掉，导致大量缓存在某一时刻同时失效，外部请求全部转发到数据库，而数据库由于瞬时压力过重导致雪崩。</strong></li><li>简单的解决方案有以下几种：<ul><li>(1) 可以在原有的缓存过期时间基础上增加一个随机值，比如 1 ~ 5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，进而很难引发缓存集体失效的事件。</li><li>(2) 使用本地缓存（Caffeine）+ Redis 哨兵 / 集群 + Hystrix 熔断 / 降级 / 限流<ul><li>其中本地缓存（Caffeine）作为一级缓存兜底；</li><li>Redis 哨兵 / 集群保证高可用，并设置 Key 错峰过期；</li><li>Hystrix 在 Redis 服务异常时触发熔断，并降级到返回本地缓存（Caffeine）数据或默认数据，从而防止缓存雪崩导致大量请求涌入冲跨数据库。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2025/08/redis-avalanche-1.png"></p><h2 id="缓存雪崩的解决"><a href="#缓存雪崩的解决" class="headerlink" title="缓存雪崩的解决"></a>缓存雪崩的解决</h2><p>不依赖单一防线，而是用「网关限流 → 应用熔断 / 熔断 / 本地缓存 → 请求合并 → 后端拒绝」多层保护，同时提升 Redis 的 HA（高可用）能力，才能有效避免 Redis 故障时的缓存雪崩把 MySQL 打垮。</p><h3 id="整体的防护思路"><a href="#整体的防护思路" class="headerlink" title="整体的防护思路"></a>整体的防护思路</h3><ul><li>事前降级：<ul><li>在缓存不可用时允许返回 “可接受的弱一致性或降级结果”（例如：部分功能只返回缓存数据、或返回静态提示页）。</li></ul></li><li>保护后端（削峰限流）：<ul><li>对外限流、熔断、队列化，防止大量并发请求落到数据库。</li></ul></li><li>多级缓存 + 回退策略：<ul><li>本地缓存（LRU） + 远端 Redis + 数据库回源。</li></ul></li><li>请求合并：<ul><li>避免大量相同 Key 的并发请求回源到数据库。</li></ul></li><li>提高 Redis 可用性：<ul><li>部署多副本、Sentinel/Cluster、跨可用区和异地多活（长期方案）。</li></ul></li><li>可观测性 + 自动化恢复：<ul><li>指标告警（QPS、错误率、数据库连接数、Redis 失败率）、并配合自动限流 / 熔断规则。</li></ul></li></ul><h3 id="具体方案与可选框架"><a href="#具体方案与可选框架" class="headerlink" title="具体方案与可选框架"></a>具体方案与可选框架</h3><ul><li><p>(1) <strong>边缘 / 网关限流（第一道防线）</strong></p><ul><li>目的：<ul><li>在流量激增或缓存不可用时，尽早拒绝 / 排队请求，保护后端。</li></ul></li><li>常用方案：<ul><li>API 网关：Kong、Nginx + Lua（OpenResty）、Envoy、Traefik。</li><li>CDN / 边缘：使用 CDN 缓存静态或部分接口响应结果（可作为快速降级）。</li></ul></li><li>实现：<ul><li>Nginx + Lua（OpenResty）实现令牌桶 / 漏桶限流算法，非常高效，放在 LB（负载均衡）层。</li><li>Envoy 支持熔断机制（Circuit-Breaking） + 全局限流器（Global Rate-Limiter），适合微服务网格。</li></ul></li></ul></li><li><p>(2) <strong>服务端限流与令牌桶（应用层）</strong></p><ul><li>目的：<ul><li>对热点接口进行精细限流，允许重要请求先行。</li></ul></li><li>常用库：<ul><li>Java：Bucket4j、Guava RateLimiter、Resilience4j Rate Limiter、Sentinel Rate Limiter、Spring Cloud Gateway Rate Limiter。</li><li>Go：Ratelimit， Uber/Ratelimit。</li></ul></li><li>要点：<ul><li>支持按用户 / 按 key / 按接口限流。</li><li>与下游熔断器联动：当 Redis 故障探测到上升，网关自动降低阈值。</li></ul></li></ul></li><li><p>(3) <strong>熔断 / 降级（保护数据库）</strong></p><ul><li>目的：<ul><li>当 Redis / 数据库或下游服务错误率（异常、超时等）上升时，自动短路请求并返回降级结果或缓存的旧数据。</li></ul></li><li>常用库：<ul><li>Sentinel（阿里开源）：支持熔断、降级、限流、系统保护，尤其适合高并发微服务场景，可与 Spring Cloud Alibaba 集成。</li><li>Resilience4j（推荐，替代 Hystrix），支持断路器、舱壁隔离、重试、限流等。</li><li>Spring Cloud Circuit Breaker（抽象层，可对接 Resilience4j）。</li><li>Hystrix（已逐步退役 / 不推荐新项目使用）。</li></ul></li><li>策略：<ul><li>熔断器触发条件：比如，10 秒内，请求数达到阈值 20，且错误率 &gt;= 50%。</li><li>熔断后：返回降级结果（例如默认值 / 本地缓存数据 / 静态页面），同时异步收集重试 / 探测请求。</li></ul></li></ul></li><li><p>(4) <strong>多级缓存（本地 + 远端）</strong></p><ul><li>目的：<ul><li>Redis 故障时，使用本地近端缓存（Caffeine）降低数据库回源率；</li><li>利用 TTL + stale-while-revalidate 策略保证可用。<ul><li>stale-while-revalidate 策略允许在缓存过期后，先从本地缓存（Caffeine）返回旧数据保证系统可用性，同时后台异步刷新最新数据写回本地缓存和 Redis，从而避免请求阻塞和缓存雪崩。</li></ul></li></ul></li><li>实现：<ul><li>应用内 LRU（本地缓存）：Caffeine、Guava Cache。</li><li>远端缓存：Redis Cluster（Lettuce / Redisson 客户端）。</li><li>读写策略：<ul><li>读取流程：本地缓存 -&gt; Redis -&gt; DB；</li><li>写入流程：DB -&gt; Redis -&gt; 本地缓存。</li></ul></li></ul></li><li>失效策略：<ul><li>当 Redis 不可用时，从本地缓存（Caffeine）返回 “过期但可接受的旧数据”，并异步刷新最新数据写回本地缓存和 Redis。</li><li>对于强一致性场景需要谨慎考虑，必须有业务允许范围。</li></ul></li></ul></li><li><p>(5) <strong>请求合并（防止大量请求回源数据库）</strong></p><ul><li>目的：<ul><li>对同一 key 的高并发请求只允许一个请求回源到数据库，其余请求等待或返回本地缓存数据。</li></ul></li><li>实现：<ul><li>Java 自行实现，或者借助 Guava 的 <code>LoadingCache</code>、Caffeine 的 <code>AsyncLoadingCache</code> + 互斥锁。</li></ul></li></ul></li><li><p>(6) <strong>后端拒绝（数据库层保护）</strong></p><ul><li>目的：<ul><li>限制数据库的并发连接数 / QPS，保证数据库不会被压垮，必要时拒绝请求或请求排队。</li></ul></li><li>实现：<ul><li>数据库代理中间件：ProxySQL、MySQL Router，用于数据库连接限流、优先级控制。</li><li>应用层的连接池设置：合理设置数据库的最大连接数、超时、最大等待队列。</li><li>在应用层使用熔断 / 限流机制，且当 DB 连接池耗尽时直接快速失败（不阻塞调用线程）。</li></ul></li></ul></li><li><p>(7) <strong>健康检查 + 自动切换（提高 Redis 可用性）</strong></p><ul><li>目的：<ul><li>及时检测 Redis 故障并自动降级到备用逻辑（或使用备用缓存）。</li></ul></li><li>实现：<ul><li>短期方案：Redis Sentinel（一主多从）或者 Redis Cluster（多主多从、分片存储），支持自动故障转移。</li><li>长期方案：跨可用区 / 跨区域多活。</li><li>使用客户端（Lettuce / Redisson）配置连接超时、重试与负载均衡策略。</li></ul></li></ul></li></ul><h3 id="具体可落地的架构与实现"><a href="#具体可落地的架构与实现" class="headerlink" title="具体可落地的架构与实现"></a>具体可落地的架构与实现</h3><div class="admonition note"><p class="admonition-title">提示</p><p>本节将给出一个典型的 Java 微服务防护栈（分层）与核心代码示例。</p></div><blockquote><p>整体业务流程（简化）</p></blockquote><ul><li>Client -&gt; API Gateway（Nginx + Lua、Envoy 限流） -&gt; Service A</li><li>Service A 读取缓存：本地缓存（Caffeine）-&gt; Redis -&gt; DB。</li><li>系统保护组件：Resilience4j（熔断 + 舱壁隔离）、Bucket4j（限流）、Singleflight（请求合并）、异步队列（重建缓存）</li></ul><blockquote><p>边缘 / 网关限流（基于 Nginx + Lua）</p></blockquote><ul><li><p>限流实现方式</p><ul><li>在 Nginx 层使用 <code>lua-resty-limit-traffic</code> 模块</li><li>或者自定义实现令牌桶（Token-Bucket）算法</li></ul></li><li><p>限流粒度</p><ul><li>按 IP 地址</li><li>按用户 ID</li><li> 按 API Key（通常代表不同的调用者或应用）</li></ul></li><li><p>动态调整</p><ul><li>通过健康探测检测后端 Redis 状态</li><li>当 Redis 健康下降时，动态降低令牌桶的速率</li></ul></li><li><p>实现目的</p><ul><li>控制请求流量，防止后端过载</li><li>提高系统可用性和稳定性</li></ul></li></ul><blockquote><p>SpringBoot + Resilience4j + Caffeine + Lettuce（伪代码）</p></blockquote><ul><li>实现要点<ul><li><code>readFromRedisOrDB</code> 的 Redis 读需要设置短超时（比如 50 ~ 200ms），避免阻塞线程池。</li><li>Resilience4j 的 CB 配置要与业务 QPS 级别匹配：最小请求数、错误率阈值、滚动窗口大小等。</li><li>Singleflight（请求合并）可以避免短时间内 N 个相同 Key 的请求并发回源到数据库。</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 本地缓存（Caffeine）</span></span><br><span class="line">Cache&lt;String, Value&gt; localCache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">    .expireAfterWrite(Duration.ofMinutes(<span class="number">5</span>))</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 请求合并（简化实现）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;Value&gt;&gt; inFlight = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">getValue</span><span class="params">(String key)</span> </span>{</span><br><span class="line">    <span class="comment">// 1) 先查本地缓存（Caffeine）</span></span><br><span class="line">    Value v = localCache.getIfPresent(key);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 尝试合并请求</span></span><br><span class="line">    CompletableFuture&lt;Value&gt; future = inFlight.computeIfAbsent(key, k -&gt; {</span><br><span class="line">        CompletableFuture&lt;Value&gt; f = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="comment">// 异步去 Redis / 数据库获取数据</span></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Value val = readFromRedisOrDB(k); <span class="comment">// 包含 Redis 超时 / 异常处理</span></span><br><span class="line">                <span class="keyword">if</span> (val != <span class="keyword">null</span>) localCache.put(k, val);</span><br><span class="line">                f.complete(val);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                f.completeExceptionally(ex);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                inFlight.remove(k);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> future.get(<span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 设置等待超时时间</span></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">// 超时或失败：返回降级数据或 Error</span></span><br><span class="line">        <span class="keyword">return</span> getFallbackValue(key);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Resilience4j 的断路器 + 降级（示例）</span></span><br><span class="line"><span class="meta">@CircuitBreaker(name = "redisCB", fallbackMethod = "redisFallback")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">readFromRedisOrDB</span><span class="params">(String key)</span> </span>{</span><br><span class="line">    <span class="comment">// 先读 Redis（配置了短超时），若 Redis 抛出异常，则会触发熔断规则</span></span><br><span class="line">    Value v = redisClient.get(key);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="comment">// Redis 缓存未命中 -&gt; 读取数据库</span></span><br><span class="line">    Value dbv = dbRepository.findByKey(key);</span><br><span class="line">    <span class="comment">// 回写 Redis 和本地缓存（Caffeine）</span></span><br><span class="line">    <span class="keyword">try</span> { redisClient.set(key, dbv, ttl); } <span class="keyword">catch</span>(Exception e) { <span class="comment">/*记录日志*/</span> }</span><br><span class="line">    <span class="keyword">return</span> dbv;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Redis 不可用或熔断时的降级逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">redisFallback</span><span class="params">(String key, Throwable t)</span> </span>{</span><br><span class="line">    <span class="comment">// 优先返回本地缓存的 "过期但可用" 数据</span></span><br><span class="line">    Value v = localCache.getIfPresent(key);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="comment">// 或返回静态默认/错误提示/降级响应</span></span><br><span class="line">    <span class="keyword">return</span> defaultFallbackValue();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最佳实践（落地顺序建议）"><a href="#最佳实践（落地顺序建议）" class="headerlink" title="最佳实践（落地顺序建议）"></a>最佳实践（落地顺序建议）</h3><ul><li><p><strong>短期（1 ~ 2 周）</strong></p><ul><li>在网关层加全局限流（简单的令牌桶），保护数据库。</li><li>在应用内增加本地缓存（Caffeine），并使用 <code>stale-while-revalidate</code> 策略。</li><li>给 Redis 客户端设置短超时 + 快速失败策略。</li><li>在关键读取接口实现 SingleFlight（请求合并）。</li><li>配置 Resilience4j 的熔断与降级（Fallback）机制。</li></ul></li><li><p><strong>中期（1 ~ 3 个月）</strong></p><ul><li>精细化限流（按接口 / 用户 / 业务），使用 Bucket4j 或 Envoy Rate-Limit。</li><li>部署数据库代理中间件（比如 ProxySQL），实现数据库连接限流与优先级控制。</li><li>增加监控 / 告警（Redis 执行命令的错误率、数据库连接数、服务断路器的开启和关闭状态）。</li></ul></li><li><p><strong>长期（3 个月以上）</strong></p><ul><li>优化 Redis 高可用架构（Sentinel 、Cluster + 跨可用区副本、多活 / 读写分离）。</li><li>建立灰度降级策略与用户体验方案（部分用户可以看到降级内容）。</li><li>容灾演练：模拟 Redis 故障，并验证熔断 / 降级 / 降级链路是否按预期工作。</li></ul></li></ul><h3 id="推荐使用技术的组合"><a href="#推荐使用技术的组合" class="headerlink" title="推荐使用技术的组合"></a>推荐使用技术的组合</h3><ul><li><p>边缘 / 网关限流：</p><ul><li>Nginx + Lua（OpenResty）或 Envoy（支持熔断和限流）</li></ul></li><li><p>Spring Cloud 微服务：</p><ul><li>本地缓存：Caffeine</li><li> 熔断 / 降级 / 限流：Resilience4j + Spring Cloud Circuit Breaker</li><li> 请求合并：Caffeine AsyncLoading / 自行实现 SingleFlight</li><li>Redis 客户端：Lettuce / Redisson（配置短超时）</li><li>API 网关：Spring Cloud Gateway + Redis 限流，或者 Envoy（支持熔断和限流）</li><li>精细限流：Bucket4j，或者 Hazelcast / Redis 限流）</li></ul></li><li><p>数据库保护：</p><ul><li>ProxySQL / MySQL Router 做数据库连接管理与慢查询保护</li></ul></li></ul><h3 id="常见误区与注意事项"><a href="#常见误区与注意事项" class="headerlink" title="常见误区与注意事项"></a>常见误区与注意事项</h3><ul><li><p>不要把分布式锁依赖在 Redis 的可用性上：</p><ul><li>当 Redis 不可用时分布式锁会失效，不能用分布式锁作为保护数据库的唯一手段。</li><li>在应用内使用 SingleFlight（请求合并）更可靠，用于热点请求合并。</li></ul></li><li><p>熔断参数太松或太紧都会有问题：</p><ul><li>需结合真实流量做压测与迭代调整。</li></ul></li><li><p>本地缓存生存期太久会造成一致性问题：</p><ul><li>对于强一致性场景，务必权衡本地缓存的有效时间（或在写路径强制失效 / 异步同步）。</li></ul></li><li><p>确保快速失败：</p><ul><li>使用快速失败机制，不等待、不重试、不排队。</li><li>一旦线程池 / 连接池资源耗尽，会导致系统级雪崩，应避免使用无限等待。</li></ul></li></ul><h2 id="多级缓存的读写流程"><a href="#多级缓存的读写流程" class="headerlink" title="多级缓存的读写流程"></a>多级缓存的读写流程</h2><p>在多级缓存（本地缓存 → Redis → 数据库）架构中，读取和更新操作的流程有所不同。下面将简单梳理一下常见模式，包含缓存命中、缓存未命中、缓存更新策略以及缓存异步刷新机制。</p><h3 id="读取流程"><a href="#读取流程" class="headerlink" title="读取流程"></a>读取流程</h3><ul><li><p><strong>读取流程（Read）</strong></p><ul><li>(1) 访问本地缓存（Caffeine）<ul><li>如果缓存命中 → 直接返回数据（延迟最低）。</li><li>如果缓存未命中 → 继续访问 Redis。</li></ul></li><li>(2) 访问 Redis（远程缓存）<ul><li>如果缓存命中 → 写回本地缓存（Caffeine） → 返回数据。</li><li>如果缓存命中 → 继续访问数据库。</li></ul></li><li>(3) 访问数据库<ul><li>获取数据库最新的数据 → 写回 Redis → 写回本地缓存（Caffeine） → 返回数据。</li><li>注意，这里先写 Redis，后写本地缓存（Caffeine）；优先保证全局缓存一致性，最后加速本节点访问。</li></ul></li></ul></li><li><p><strong>可选优化（<code>stale-while-revalidate</code> 策略）</strong></p><ul><li>当本地缓存（Caffeine）或 Redis 缓存的数据已过期：<ul><li>先返回过期数据保证系统可用；</li><li>在后台异步刷新缓存数据，即从数据库加载最新数据，然后写回本地缓存（Caffeine）和 Redis。</li></ul></li></ul></li><li><p><strong>工作流程图</strong><br> <img data-src="../../../asset/2025/09/multi-cache-read.png"></p></li></ul><h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>多级缓存的更新通常有三种策略：写穿（Write-through）、写回（Write-behind）、缓存失效（Cache-Aside）。</p><ul><li><p><strong>写穿策略（Write-through）</strong></p><ul><li>概述：<ul><li>更新数据库的同时立即更新缓存。</li></ul></li><li>流程：<br> <img data-src="../../../asset/2025/09/multi-cache-write-through.png"></li><li>优点：<ul><li>缓存与数据库保持一致。</li></ul></li><li>缺点：<ul><li>写操作延迟增加。</li></ul></li></ul></li><li><p><strong>写回策略（Write-behind）</strong></p><ul><li>概述：<ul><li>先写缓存，数据库异步刷新。</li></ul></li><li>流程：<br> <img data-src="../../../asset/2025/09/multi-cache-write-behind.png"></li><li>优点：<ul><li>写入延迟低，适合高吞吐写场景。</li></ul></li><li>缺点：<ul><li>短时间内缓存与数据库可能不一致，需要保证异步刷新数据库的可靠性。</li></ul></li></ul></li><li><p><strong>失效策略（Cache-Aside）</strong></p><ul><li>概述：<ul><li>更新数据库后，主动删除缓存，下一次读取数据时重建缓存。</li></ul></li><li>流程：<br> <img data-src="../../../asset/2025/09/multi-cache-cache-aside.png"></li><li>优点：简单、保证最终一致性。</li><li>缺点：第一次访问会有缓存未命中，可能带来突发的数据库压力，建议使用分布式锁进行控制。</li></ul></li></ul><h3 id="最佳实践组合"><a href="#最佳实践组合" class="headerlink" title="最佳实践组合"></a>最佳实践组合</h3><ul><li><p><strong>读取操作：</strong></p><ul><li>本地缓存 + Redis + 数据库回源</li><li>可选结合 <code>stale-while-revalidate</code> 策略提升性能和可用性。</li></ul></li><li><p><strong>更新操作：</strong></p><ul><li>读多写少的场景 → 缓存失效策略（Cache-Aside）</li><li>高并发写的场景 → 写回策略（Write-behind）</li><li>对一致性要求高的场景 → 写穿策略（Write-through）</li></ul></li></ul><h3 id="方案总结对比"><a href="#方案总结对比" class="headerlink" title="方案总结对比"></a>方案总结对比</h3><table><thead><tr><th>操作</th><th>流程概述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>读取</td><td>读本地缓存 → 读 Redis → 读数据库</td><td>延迟低，高可用</td><td>复杂性高，需要多级缓存同步</td></tr><tr><td>写穿策略</td><td>写数据库 → 写 Redis → 写本地缓存</td><td>数据一致性高</td><td>写延迟高</td></tr><tr><td>写回策略</td><td>写本地缓存 → 写 Redis → 异步写数据库</td><td>写性能高</td><td>数据短期不一致，需要保证异步写数据库的可靠性</td></tr><tr><td>失效策略</td><td>写数据库 → 删除 Redis → 删除本地缓存</td><td>简单，最终一致性</td><td>大量缓存突发未命中时，数据库压力大</td></tr></tbody></table><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/77b20c93.html" title="分布式系统中缓存雪崩的解决方案">https://www.techgrow.cn/posts/77b20c93.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag"><i class="fa fa-tag"></i> 微服务</a><a href="/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="tag"><i class="fa fa-tag"></i> 架构设计</a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 分布式</a><a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"><i class="fa fa-tag"></i> 缓存</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/5bc5018f.html" rel="prev" title="Nginx 内存池源码剖析"><i class="fa fa-angle-left"></i> Nginx 内存池源码剖析</a></div><div class="post-nav-item"> <a href="/posts/585aa296.html" rel="next" title="基于 C++ 手写线程池实现">基于 C++ 手写线程池实现<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.2m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">33:01</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/77b20c93.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>