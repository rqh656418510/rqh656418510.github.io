<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要记录 SpringBoot 3 的基础教程，包括核心原理等内容。"><meta property="og:type" content="article"><meta property="og:title" content="SpringBoot3 基础教程之九核心原理"><meta property="og:url" content="https://www.techgrow.cn/posts/1dfe3056.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要记录 SpringBoot 3 的基础教程，包括核心原理等内容。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/06/spring-boot3-study-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/06/spring-boot3-study-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/08/spring-boot3-study-27.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/08/spring-boot3-study-21.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/08/spring-boot3-study-22.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/08/spring-boot3-study-23.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/08/spring-boot3-study-25.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/08/spring-boot3-study-26.png"><meta property="article:published_time" content="2023-07-13T15:12:42.000Z"><meta property="article:modified_time" content="2023-07-13T15:12:42.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="微服务"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2023/06/spring-boot3-study-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/1dfe3056.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/1dfe3056.html","path":"posts/1dfe3056.html","title":"SpringBoot3 基础教程之九核心原理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>SpringBoot3 基础教程之九核心原理 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">依赖管理机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="nav-text">自动配置原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="nav-text">自动配置流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="nav-text">初步理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E7%90%86%E8%A7%A3"><span class="nav-text">进阶理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="nav-text">深入理解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI-%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D"><span class="nav-text">SPI 机制介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E5%BC%80%E5%85%B3%E4%BB%8B%E7%BB%8D"><span class="nav-text">功能开关介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">嵌入式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86-1"><span class="nav-text">自动配置原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="nav-text">内容协商</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-text">底层原理分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">事件和监听器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%91%E5%90%AC"><span class="nav-text">生命周期监听</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">自定义监听器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B"><span class="nav-text">生命周期流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-text">事件触发时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">各种事件监听器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-text">完整事件触发流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="nav-text">SpringBoot 事件驱动开发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%95%B4%E5%90%88"><span class="nav-text">Redis 整合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86-2"><span class="nav-text">自动配置原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis-%E6%95%B4%E5%90%88"><span class="nav-text">MyBatis 整合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86-3"><span class="nav-text">自动配置原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDBC-%E5%9C%BA%E6%99%AF%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-text">JDBC 场景的自动配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatisAutoConfiguration-%E5%88%86%E6%9E%90"><span class="nav-text">MyBatisAutoConfiguration 分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">701</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/1dfe3056.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="SpringBoot3 基础教程之九核心原理 | Clay 的技术空间"><meta itemprop="description" content="本文主要记录 SpringBoot 3 的基础教程，包括核心原理等内容。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> SpringBoot3 基础教程之九核心原理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-07-13 23:12:42" itemprop="dateCreated datePublished" datetime="2023-07-13T23:12:42+08:00">2023-07-13</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/1dfe3056.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/1dfe3056.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>12k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>11 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/79ae6590.html">SpringBoot3 基础教程之一快速入门</a></li><li><a href="/posts/e7a270a6.html">SpringBoot3 基础教程之二常规配置</a></li><li><a href="/posts/12fb0f17.html">SpringBoot3 基础教程之三 Web 开发</a></li><li><a href="/posts/223fd9f.html">SpringBoot3 基础教程之四 Web 开发</a></li><li><a href="/posts/6bcf09.html">SpringBoot3 基础教程之五基础特性</a></li><li><a href="/posts/b6463873.html">SpringBoot3 基础教程之六场景整合</a></li><li><a href="/posts/6b38f8f0.html">SpringBoot3 基础教程之七场景整合</a></li><li><a href="/posts/1dfe3056.html">SpringBoot3 基础教程之九核心原理</a></li></ul><h2 id="依赖管理机制"><a href="#依赖管理机制" class="headerlink" title="依赖管理机制"></a>依赖管理机制</h2><p><img data-src="../../../asset/2023/06/spring-boot3-study-1.png"></p><span id="more"></span><div class="admonition note"><p class="admonition-title">为什么导入 spring-boot-starter-web 后，所有相关的依赖都导入进来了？</p><ul><li>开发什么场景，导入什么场景启动器</li><li> Maven 依赖的传递原则。A -&gt; B -&gt; C，那么 A 就拥有 B 和 C</li><li> 导入场景启动器后，会自动把这个场景的所有核心依赖全部导入进来</li></ul></div><div class="admonition note"><p class="admonition-title">为什么版本号都不用写？</p><ul><li>每个 SpringBoot 项目都有一个父项目 <code>spring-boot-starter-parent</code></li><li><code>parent</code> 的父项目是 <code>spring-boot-dependencies</code></li><li>父项目是版本仲裁中心，会将所有常见 Jar 包的依赖版本都声明好了，比如 <code>mysql-connector-j</code></li></ul></div><div class="admonition note"><p class="admonition-title">如何自定义依赖的版本号？</p><ul><li>第一种方式：直接在当前 Maven 配置文件的 <code>&lt;properties&gt;&lt;/properties&gt;</code> 标签中声明父项目用的版本属性的 Key</li><li> 第二种方式：直接在导入依赖的时候声明版本</li><li>上述两种方式都是利用 Maven 的就近原则特性</li></ul></div><div class="admonition note"><p class="admonition-title">如何导入第三方的 Jar 包</p><ul><li>对于 <code>spring-boot-starter-parent</code> 没有管理的 Jar 包依赖，直接在 Maven 的配置文件中自行声明就可以</li></ul></div><h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><p>SpringBoot 应用关注的三大核心：<code>场景</code>、<code>配置</code>、<code>组件</code>。</p><h3 id="自动配置流程"><a href="#自动配置流程" class="headerlink" title="自动配置流程"></a>自动配置流程</h3><h4 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h4><ul><li>自动配置 SpringMVC、Tomcat 等<ul><li>导入场景，容器中就会自动配置好这个场景的核心组件</li><li>以前：DispatcherServlet、ViewResolver、CharacterEncodingFilter ….</li><li> 现在：自动配置好的这些组件</li><li>验证：容器中有了什么组件，就具有什么功能</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// JDK 10 的新特性，局部变量类型的自动推断</span></span><br><span class="line">        <span class="keyword">var</span> ioc = SpringApplication.run(MainApplication.class, args);</span><br><span class="line">        <span class="comment">// 获取容器中所有组件的名称</span></span><br><span class="line">        String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line">        <span class="comment">// 遍历容器中的所有组件，SpringBoot 把以前需要手动配置的核心组件现在都给自动配置好</span></span><br><span class="line">        <span class="keyword">for</span> (String name : names) {</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>默认的包扫描规则</p><ul><li><code>@SpringBootApplication</code> 注解标注的类就是主程序类</li><li> SpringBoot 只会扫描主程序类所在的包及其下面的子包，即自动的 <code>component-scan</code> 功能</li><li>自定义包的扫描路径<ul><li>第一种方式：<code>@SpringBootApplication(scanBasePackages = "com.clay")</code></li><li>第二种方式：<code>@ComponentScan("com.clay")</code> 直接指定扫描的包路径</li></ul></li></ul></li><li><p>配置默认值</p><ul><li>配置文件的所有配置项是和某个类的对象值进行一一绑定的</li><li>绑定了配置文件中每一项值的类，称为配置属性类</li><li>比如：<ul><li><code>ServerProperties</code> 绑定了所有 Tomcat 服务器有关的配置</li><li><code>MultipartProperties</code> 绑定了所有文件上传相关的配置</li><li>….. 参照 <a target="_blank" rel="external nofollow" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html">官方文档</a> 或者参照绑定的配置属性类</li></ul></li></ul></li><li><p>按需加载自动配置</p><ul><li>导入场景启动器 <code>spring-boot-starter-web</code></li><li>场景启动器除了会导入相关功能的依赖，还会导入 <code>spring-boot-starter</code>，它是所有 <code>starter</code> 的 <code>starter</code>，是基础核心 <code>starter</code></li><li><code>spring-boot-starter</code> 导入了一个包 <code>spring-boot-autoconfigure</code>，里面都是各种场景的 <code>AutoConfiguration</code> 自动配置类</li><li>虽然全场景的自动配置都在 <code>spring-boot-autoconfigure</code> 这个包中，但并不是全部都默认开启的，导入哪个场景启动器才会开启哪个场景的自动配置</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>导入场景启动器会触发 <code>spring-boot-autoconfigure</code> 这个包的自动配置生效，Spring 的 IOC 容器中就会具有相关场景的功能。</p></div><h4 id="进阶理解"><a href="#进阶理解" class="headerlink" title="进阶理解"></a>进阶理解</h4><div class="admonition note"><p class="admonition-title">思考以下问题</p><ul><li>1、SpringBoot 是怎么实现导一个 <code>starter</code>，写一些简单配置，开发者无需关心整合，应用就能跑起来的？</li><li>2、为什么 Tomcat 的端口号可以配置在 <code>application.properties</code> 中，并且 Tomcat 能启动成功？</li><li>3、导入场景启动器后，哪些自动配置能生效？</li></ul></div><p><img data-src="../../../asset/2023/06/spring-boot3-study-2.png"></p><ul><li><p>导入 Web 开发场景 <code>spring-boot-starter-web</code></p><ul><li>1、场景启动器导入了相关场景的所有依赖，如 <code>spring-boot-starter-json</code>、<code>spring-boot-starter-tomcat</code>、<code>spring-webmvc</code>。</li><li>2、每个场景启动器都引入了一个 <code>spring-boot-starter</code>，即核心场景启动器。</li><li>3、核心场景启动器引入了 <code>spring-boot-autoconfigure</code> 包。</li><li>4、<code>spring-boot-autoconfigure</code> 里面囊括了所有场景的自动配置。</li><li>5、只要 <code>spring-boot-autoconfigure</code> 这个包下的所有类都能生效，那么相当于 SpringBoot 官方写好的整合功能就生效了。</li><li>6、SpringBoot 默认是扫描不到 <code>spring-boot-autoconfigure</code> 下写好的所有配置类（这些配置类给我们做了整合操作），默认只扫描主程序类所在的包及其下面的子包。</li></ul></li><li><p>主程序注解 <code>@SpringBootApplication</code></p><ul><li>1、<code>@SpringBootApplication</code> 由三个注解组成，分别是 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>。</li><li>2、SpringBoot 默认只能扫描自己主程序所在的包及其下面的子包，扫描不到 <code>spring-boot-autoconfigure</code> 包中官方写好的配置类。</li><li>3、<code>@EnableAutoConfiguration</code> 是 SpringBoot 开启自动配置的核心。<ul><li>1、是由 <code>@Import(AutoConfigurationImportSelector.class)</code> 提供核心功能，批量往容器中导入组件。</li><li>2、SpringBoot 启动时会默认加载 142 个配置类，这 142 个配置类是由 <code>spring-boot-autoconfigure</code> 包下的 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件指定。</li><li>3、项目启动的时候利用 <code>@Import</code> 批量导入组件的机制，将 <code>spring-boot-autoconfigure</code> 包下的 142 个 <code>xxxxAutoConfiguration</code> 类导入进来（自动配置类）。</li><li>4、虽然导入了 142 个自动配置类，但并不是这 142 个自动配置类都能生效；每一个自动配置类，都有条件注解 <code>@ConditionalOnxxx</code>，只有条件成立才能生效。</li></ul></li></ul></li><li><p><code>xxxxAutoConfiguration</code> 自动配置类</p><ul><li>1、往容器中使用 <code>@Bean</code> 注册一堆组件</li><li> 2、每个自动配置类都可能有这个注解 <code>@EnableConfigurationProperties(ServerProperties.class)</code>，用来把配置文件中配的指定前缀的属性值封装到 <code>xxxProperties</code> 属性类中。</li><li>3、以 Tomcat 为例，把服务器的所有配置都是以 <code>server</code> 开头的配置都封装到了属性类中。</li><li>4、往容器中放的所有组件的一些核心参数，都来自于 <code>xxxProperties</code> 属性类，它都是和配置文件绑定的。</li><li>5、只需要更改配置文件的值，核心组件的底层参数就能修改。</li><li>6、将精力都用于写业务，全程无需关心各种框架的整合（底层这些整合都写好了，而且也按需生效了）</li></ul></li></ul><div class="admonition note"><p class="admonition-title">自动配置流程的总结</p><ul><li>1、导入 <code>spring-boot-starter-xxxx</code>，会导入 <code>spring-boot-starter</code>，也就会导入 <code>spring-boot-autoconfigure</code> 包。</li><li>2、<code>spring-boot-autoconfigure</code> 包里面有一个文件 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>，里面指定了应用启动时所有要加载的自动配置类。</li><li>3、<code>@EnableAutoConfiguration</code> 会自动地将上面文件里写的所有自动配置类都导入进来，同时 <code>xxxAutoConfiguration</code> 是有声明条件注解的，目的是按需加载。</li><li>4、<code>xxxAutoConfiguration</code> 往容器中导入一堆组件，这些组件都是从 <code>xxxProperties</code> 中获取属性值。</li><li>5、<code>xxxProperties</code> 又是和配置文件进行了绑定。</li></ul></div><blockquote><p>最终效果：导入 <code>starter</code>，修改配置文件，就能修改框架的底层行为。</p></blockquote><h4 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h4><p><code>@SpringBootApplication</code> 注解包含了三个核心注解，分别是 <code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>、<code>@SpringBootConfiguration</code>，它们的作用如下：</p><ul><li><code>@ComponentScan</code><ul><li>组件扫描，排除一些组件（哪些不需要的）</li><li>排除前面已经扫描进来的配置类和自动配置类</li></ul></li><li><code>@EnableAutoConfiguration</code>：开启自动配置功能<ul><li><code>@AutoConfigurationPackage</code>：扫描主程序所在的包以及其子包，加载自己的组件<ul><li>利用 <code>@Import(AutoConfigurationPackages.Registrar.class)</code>，将主程序所在的包以及其子包的所有组件导入进来</li></ul></li><li><code>@Import(AutoConfigurationImportSelector.class)</code> 加载所有自动配置类，会加载 <code>starter</code> 导入的组件<ul><li>扫描 SPI 文件 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 中的所有自动配置类</li></ul></li></ul></li><li><code>@SpringBootConfiguration</code>：本质就是 <code>@Configuration</code> 注解，标注在组件类、配置类上面，Spring IOC 容器启动时就会创建加载这些类对象</li></ul><blockquote><p>SpringBoot 完整的生命周期启动加载流程如下：</p></blockquote><p><img data-src="../../../asset/2023/08/spring-boot3-study-27.png"></p><h3 id="SPI-机制介绍"><a href="#SPI-机制介绍" class="headerlink" title="SPI 机制介绍"></a>SPI 机制介绍</h3><ul><li>Java 中的 SPI（Service Provider Interface）是一种软件设计模式，用于在应用程序中动态地发现和加载组件。SPI 的思想是，定义一个接口或抽象类，然后通过在 <code>classpath</code> 中定义实现该接口的类来实现对组件的动态发现和加载。</li><li>SPI 的主要目的是解决在应用程序中使用可插拔组件的问题。例如，一个应用程序可能需要使用不同的日志框架或数据库连接池，但是这些组件的选择可能取决于运行时的条件。通过使用 SPI，应用程序可以在运行时发现并加载适当的组件，而无需在代码中硬编码这些组件的实现类。</li><li>在 Java 中，SPI 的实现方式是通过在 <code>META-INF/services</code> 目录下创建一个以服务接口全限定名为名字的文件，文件中包含实现该服务接口的类的全限定名。当应用程序启动时，Java 的 SPI 机制会自动扫描 <code>classpath</code> 中的这些文件，并根据文件中指定的类名来加载实现类。</li><li>通过使用 SPI，应用程序可以实现更灵活、可扩展的架构，同时也可以避免硬编码依赖关系和增加代码的可维护性。</li></ul><blockquote><p>SpringBoot 的自动配置使用了 SPI 机制，但实现方式不是在 <code>META-INF/services</code> 目录下创建一个以服务接口全限定名为名字的文件，而是使用 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件进行替代。</p></blockquote><h3 id="功能开关介绍"><a href="#功能开关介绍" class="headerlink" title="功能开关介绍"></a>功能开关介绍</h3><ul><li><code>自动配置</code>：自动批量导入，全部都配置好，什么都不用管<ul><li>项目一启动，SPI 文件中指定的所有组件都会被加载</li></ul></li><li><code>@EnableXxxx</code>：手动导入，手动控制哪些功能的开启<ul><li>开启 <code>xxx</code> 功能</li><li>都是利用 <code>@Import</code> 注解把此功能要用的组件导入进去</li></ul></li></ul><h2 id="嵌入式容器"><a href="#嵌入式容器" class="headerlink" title="嵌入式容器"></a>嵌入式容器</h2><p>Servlet 容器指的是管理、运行 Servlet 组件（<code>Servlet</code>、<code>Filter</code>、<code>Listener</code>）的环境，一般指 Web 服务器。</p><h3 id="自动配置原理-1"><a href="#自动配置原理-1" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><ul><li>SpringBoot 默认使用嵌入的 Tomcat 作为 Servlet 容器</li><li>嵌入式容器的自动配置类是 <code>ServletWebServerFactoryAutoConfiguration</code>，<code>EmbeddedWebServerFactoryCustomizerAutoConfiguration</code></li><li><code>ServletWebServerFactoryAutoConfiguration</code> 自动配置了嵌入式容器场景</li><li>绑定了 <code>ServerProperties</code> 配置类，所有和服务器相关的配置都使用 <code>server</code> 作为开始前缀</li><li><code>ServletWebServerFactoryAutoConfiguration</code> 默认导入了嵌入式的三大服务器，包括 <code>Tomcat</code>、<code>Jetty</code>、<code>Undertow</code><ul><li>导入 <code>Tomcat</code>、<code>Jetty</code>、<code>Undertow</code> 时都有条件注解，系统中有对应的类才会生效（也就是导了包）</li><li>在默认情况下，Tomcat 的配置会生效，SpringBoot 往容器中放了 <code>TomcatServletWebServerFactory</code> 组件</li><li>往容器中放一个 Web 服务器工厂 <code>ServletWebServerFactory</code> 后，可以创建 Web 服务器</li><li> Web 服务器工厂都有一个功能，可以调用 <code>getWebServer()</code> 获取 Web 服务器</li><li><code>TomcatServletWebServerFactory</code> 创建了 Tomcat Web 服务器</li></ul></li><li><code>ServletWebServerApplicationContext</code> IOC 容器在启动的时候，会调用 <code>onRefresh()</code> 刷新子容器</li><li>在调用了 <code>onRefresh()</code> 之后，会调用 <code>ServletWebServerFactory</code> 创建 Web 服务器</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class="line"><span class="meta">@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span></span><br><span class="line"><span class="meta">		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span></span><br><span class="line"><span class="meta">		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span></span><br><span class="line"><span class="meta">		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerFactoryAutoConfiguration</span> </span>{</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onRefresh();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        createWebServer();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Unable to start web server"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">总结</p><ul><li>Web 场景的 Spring 容器启动，在调用 <code>onRefresh()</code> 的时候，会调用创建 Web 服务器的方法。</li><li>Web 服务器的创建是通过 <code>WebServerFactory</code> 实现的，容器中又会根据条件注解，启动相关的服务器配置，默认 <code>EmbeddedTomcat</code> 会往容器中放一个 <code>TomcatServletWebServerFactory</code> 组件，导致项目启动后，自动创建出 Tomcat 服务器。</li></ul></div><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><h3 id="底层原理分析"><a href="#底层原理分析" class="headerlink" title="底层原理分析"></a>底层原理分析</h3><blockquote><p>1、<code>@ResponseBody</code> 的底层由 <code>HttpMessageConverter</code> 处理数据，即标注了 <code>@ResponseBody</code> 的返回值，将会由支持它的 <code>HttpMessageConverter</code> 将数据返回给浏览器。</p></blockquote><ul><li><p>如果 <code>Controller</code> 方法的返回值标注了 <code>@ResponseBody</code> 注解</p><ul><li>请求进来先来到 <code>DispatcherServlet</code> 的 <code>doDispatch()</code> 进行处理</li><li>找到一个 <code>HandlerAdapter</code> 适配器，利用适配器执行目标方法</li><li><code>RequestMappingHandlerAdapter</code> 会执行，调用 <code>invokeHandlerMethod()</code> 来执行目标方法</li><li>在目标方法执行之前，需要准备好两样东西<ul><li><code>HandlerMethodArgumentResolver</code>：参数解析器，确定目标方法的每个参数值</li><li><code>HandlerMethodReturnValueHandler</code>：返回值处理器，确定目标方法的返回值该怎么处理</li></ul></li><li><code>RequestMappingHandlerAdapter</code> 里面的 <code>invokeAndHandle()</code> 真正执行目标方法</li><li>目标方法执行完成，会返回返回值的对象</li><li>去找一个合适的返回值处理器 <code>HandlerMethodReturnValueHandler</code></li><li>最终找到 <code>RequestResponseBodyMethodProcessor</code>，它能处理标注了 <code>@ResponseBody</code> 注解的方法</li><li><code>RequestResponseBodyMethodProcessor</code> 调用 <code>writeWithMessageConverters()</code>，利用 <code>MessageConverter</code> 把返回值输出给浏览器</li></ul></li><li><p><code>HttpMessageConverter</code> 会先进行内容协商</p><ul><li>遍历所有的 <code>MessageConverter</code>，看哪个支持这种内容类型的数据</li><li>默认的 <code>MessageConverter</code> 有<a href="../../../asset/2023/06/spring-boot3-study-10.png">这些</a></li><li>最终因为需要返回 JSON 数据，所以通过 <code>MappingJackson2HttpMessageConverter</code> 输出 JSON 数据</li><li> Jackson 利用 <code>ObjectMapper</code> 把返回值对象写出去</li></ul></li></ul><blockquote><p>2、<code>WebMvcAutoConfiguration</code> 提供了 <a href="../../../asset/2023/06/spring-boot3-study-11.png">6 种</a> 默认的 <code>HttpMessageConverters</code></p></blockquote><ul><li><code>EnableWebMvcConfiguration</code> 通过 <code>addDefaultHttpMessageConverters</code> 添加了默认的 <code>MessageConverter</code>，如下：<ul><li><code>ByteArrayHttpMessageConverter</code>：支持字节数据读写</li><li><code>StringHttpMessageConverter</code>：支持字符串读写</li><li><code>ResourceHttpMessageConverter</code>：支持资源读写</li><li><code>ResourceRegionHttpMessageConverter</code>：支持分区资源写出</li><li><code>AllEncompassingFormHttpMessageConverter</code>：支持表单 XML/JSON 读写</li><li><code>MappingJackson2HttpMessageConverter</code>：支持请求响应体 JSON 读写</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>SpringBoot 提供默认的 <code>MessageConverter</code> 功能有限，仅用于 JSON 或者普通的返回数据。如果需要增加新的内容协商功能，必须添加新的 <code>HttpMessageConverter</code>。</p></div><h2 id="事件和监听器"><a href="#事件和监听器" class="headerlink" title="事件和监听器"></a>事件和监听器</h2><h3 id="生命周期监听"><a href="#生命周期监听" class="headerlink" title="生命周期监听"></a>生命周期监听</h3><h4 id="自定义监听器"><a href="#自定义监听器" class="headerlink" title="自定义监听器"></a>自定义监听器</h4><p><code>SpringApplicationRunListener</code> 负责监听应用的生命周期。</p><ul><li>自定义 <code>SpringApplicationRunListener</code> 来监听应用生命周期的步骤<ul><li> 1、编写 <code>SpringApplicationRunListener</code> 接口的实现类</li><li> 2、在项目的 <code>/META-INF/spring.factories</code> 中配置 <code>org.springframework.boot.SpringApplicationRunListener=自定义的Listener</code>，还可以指定一个有参构造方法，接受两个参数（<code>SpringApplication application</code>，<code>String[] args</code>）</li><li>3、值得一提的是，SpringBoot 在 <code>spring-boot.jar</code> 中配置了默认的 Listener，即 <code>org.springframework.boot.SpringApplicationRunListener=org.springframework.boot.context.event.EventPublishingRunListener</code></li></ul></li></ul><h4 id="生命周期流程"><a href="#生命周期流程" class="headerlink" title="生命周期流程"></a>生命周期流程</h4><p><img data-src="../../../asset/2023/08/spring-boot3-study-21.png"></p><ul><li>SpringBoot 应用的生命周期流程<ul><li> 1、首先从 <code>/META-INF/spring.factories</code> 读取到 <code>Listener</code></li><li>2、引导：利用 <code>BootstrapContext</code> 引导整个项目启动<ul><li><code>starting</code>：应用开始，SpringApplication 的 <code>run()</code> 方法一调用，只要有了 <code>BootstrapContext</code> 就执行</li><li><code>environmentPrepared</code>：环境准备好（把启动参数等绑定到环境变量中），但是 IOC 容器还没有创建，此步骤只会执行一次</li></ul></li><li> 3、启动<ul><li><code>contextPrepared</code>：IOC 容器创建并准备好，但是 Sources（主配置类）还没加载，并关闭引导上下文，组件都没创建，此步骤只会执行一次</li><li><code>contextLoaded</code>：IOC 容器加载。主配置类加载进去了，但是 IOC 容器还没刷新（所有 Bean 还没创建），此步骤只会执行一次</li><li><code>started</code>：IOC 容器刷新了（所有 Bean 创建好了），但是 <code>runner</code> 没调用</li><li><code>ready</code>：IOC 容器刷新了（所有 Bean 创建好了），所有 <code>runner</code> 调用完了</li></ul></li><li> 4、运行<ul><li>以上步骤都正确执行，代表容器成功运行</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>关于 SpringBoot 应用的生命周期流程，更详细的说明请阅读 <code>SpringApplication</code> 和 <code>SpringApplicationRunListener</code> 的底层源码。</p></div><h3 id="事件触发时机"><a href="#事件触发时机" class="headerlink" title="事件触发时机"></a>事件触发时机</h3><h4 id="各种事件监听器"><a href="#各种事件监听器" class="headerlink" title="各种事件监听器"></a>各种事件监听器</h4><ul><li><code>BootstrapRegistryInitializer</code>：感知特定阶段（感知引导初始化）<ul><li><code>META-INF/spring.factories</code></li><li>创建引导上下文 <code>BootstrapContext</code> 的时候触发</li><li><code>application.addBootstrapRegistryInitializer()</code></li><li>使用场景：进行密钥校对授权</li></ul></li><li><code>ApplicationContextInitializer</code>：感知特定阶段（感知 IOC 容器初始化）<ul><li><code>META-INF/spring.factories</code></li><li><code>application.addInitializers()</code></li></ul></li><li><code>ApplicationListener</code>：感知全阶段，基于事件机制感知事件，一旦到了哪个阶段可以做别的事<ul><li><code>@Bean</code> 或 <code>@EventListener</code>：事件驱动</li><li><code>SpringApplication.addListeners(…)</code> 或 <code>SpringApplicationBuilder.listeners(…)</code></li><li><code>META-INF/spring.factories</code></li></ul></li><li><code>SpringApplicationRunListener</code>：感知全阶段生命周期，各种阶段都能自定义操作，功能更完善<ul><li><code>META-INF/spring.factories</code></li></ul></li><li><code>ApplicationRunner</code>: 感知特定阶段（感知应用就绪 - Ready）。如果应用卡死，就不会就绪<ul><li><code>@Bean</code></li></ul></li><li><code>CommandLineRunner</code>：感知特定阶段（感知应用就绪 - Ready）。如果应用卡死，就不会就绪<ul><li><code>@Bean</code></li></ul></li></ul><p><img data-src="../../../asset/2023/08/spring-boot3-study-22.png"></p><div class="admonition note"><p class="admonition-title">最佳实战</p><ul><li>如果想要在项目启动前做事：<code>BootstrapRegistryInitializer</code> 和 <code>ApplicationContextInitializer</code></li><li>如果想要在项目启动完成后做事：<code>ApplicationRunner</code> 和 <code>CommandLineRunner</code></li><li>如果要干涉整个生命周期做事：<code>SpringApplicationRunListener</code></li><li>如果想要利用事件机制做事：<code>ApplicationListener</code></li></ul></div><h4 id="完整事件触发流程"><a href="#完整事件触发流程" class="headerlink" title="完整事件触发流程"></a>完整事件触发流程</h4><ul><li>SpringBoot 9 大事件触发顺序与触发时机<ul><li><code>ApplicationStartingEvent</code>：应用启动但未做任何事情，除了注册 <code>listeners</code> 与 <code>initializers</code></li><li><code>ApplicationEnvironmentPreparedEvent</code>： Environment 准备好了，但 <code>ApplicationContext</code> 未创建</li><li><code>ApplicationContextInitializedEvent</code>: <code>ApplicationContext</code> 准备好了，<code>ApplicationContextInitializers</code> 被调用，但是任何 Bean 未加载</li><li><code>ApplicationPreparedEvent</code>：容器刷新之前，Bean 定义信息加载</li><li><code>ApplicationStartedEvent</code>：容器刷新完成，<code>runner</code> 未被调用</li><li><code>AvailabilityChangeEvent</code>：<code>LivenessState.CORRECT</code> 应用存活探针</li><li><code>ApplicationReadyEvent</code>: 任何 <code>runner</code> 被调用</li><li><code>AvailabilityChangeEvent</code>：<code>ReadinessState.ACCEPTING_TRAFFIC</code> 应用就绪探针，可以接收请求了</li><li><code>ApplicationFailedEvent</code>：应用启动出错</li></ul></li></ul><p><img data-src="../../../asset/2023/08/spring-boot3-study-23.png"></p><div class="admonition note"><p class="admonition-title">探针使用说明</p><ul><li><code>感知应用是否存活了</code>：应用可能处于植物状态，虽然活着，但是不能处理请求。</li><li><code>应用是否就绪了</code>：应用可以处理外部请求，说明确实活的比较好。</li><li><code>探针的使用场景</code>：若应用将来部署到 Kubernetes 等平台，则会大量被使用到。</li></ul></div><blockquote><p>更详细的 SpringBoot 事件触发顺序，请看<a href="../../../asset/2023/08/spring-boot3-study-24.png">这里</a>的图解。</p></blockquote><h4 id="SpringBoot-事件驱动开发"><a href="#SpringBoot-事件驱动开发" class="headerlink" title="SpringBoot 事件驱动开发"></a>SpringBoot 事件驱动开发</h4><p>SpringBoot 事件驱动开发，依赖应用启动过程生命周期事件感知（9 大事件）、应用运行中事件感知（无数种）。</p><ul><li>事件发布：实现 <code>ApplicationEventPublisherAware</code> 接口，或者注入 <code>ApplicationEventMulticaster</code></li><li>事件监听：实现 <code>ApplicationListener</code> 接口，或者使用 <code>@EventListener</code> 注解</li></ul><p><img data-src="../../../asset/2023/08/spring-boot3-study-25.png"></p><p><img data-src="../../../asset/2023/08/spring-boot3-study-26.png"></p><blockquote><p>SpringBoot 事件驱动开发的使用案例可以阅读 <a href="/posts/6bcf09.html#SpringBoot-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91">这里</a> 的教程。</p></blockquote><h2 id="Redis-整合"><a href="#Redis-整合" class="headerlink" title="Redis 整合"></a>Redis 整合</h2><h3 id="自动配置原理-2"><a href="#自动配置原理-2" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><ul><li><code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 中导入了 <code>RedisAutoConfiguration</code>、<code>RedisReactiveAutoConfiguration</code> 和 <code>RedisRepositoriesAutoConfiguration</code>，所有属性都绑定在 <code>RedisProperties</code> 中</li><li><code>RedisReactiveAutoConfiguration</code> 适用于响应式编程，<code>RedisRepositoriesAutoConfiguration</code> 适用于 JPA 操作</li><li><code>RedisAutoConfiguration</code> 配置了以下组件<ul><li><code>LettuceConnectionConfiguration</code>： 往容器中注入了连接工厂 <code>LettuceConnectionFactory</code> 和操作 Redis 的客户端 <code>DefaultClientResources</code></li><li><code>RedisTemplate&lt;Object, Object&gt;</code>： 可以往 Redis 存储任意对象，默认会使用 JDK 的序列化机制</li><li><code>StringRedisTemplate</code>： 可以往 Redis 存储字符串，如果需要存储对象，需要开发人员自己执行序列化操作，Key-Value 都是以字符串的形式进行操作</li></ul></li></ul><h2 id="MyBatis-整合"><a href="#MyBatis-整合" class="headerlink" title="MyBatis 整合"></a>MyBatis 整合</h2><h3 id="自动配置原理-3"><a href="#自动配置原理-3" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><h4 id="JDBC-场景的自动配置"><a href="#JDBC-场景的自动配置" class="headerlink" title="JDBC 场景的自动配置"></a>JDBC 场景的自动配置</h4><ul><li>JDBC 场景的自动配置<ul><li><code>mybatis-spring-boot-starter</code> 导入了 <code>spring-boot-starter-jdbc</code>，JDBC 用于操作数据库的场景</li><li> JDBC 场景的几个自动配置<ul><li><code>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</code><ul><li>支持数据源的自动配置</li><li>所有和数据源相关的配置都绑定在 <code>DataSourceProperties</code> 配置类</li><li>默认使用 <code>HikariDataSource</code> 数据源</li></ul></li><li><code>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</code><ul><li>往容器注册 <code>JdbcTemplate</code>，操作数据库</li></ul></li><li><code>org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration</code></li><li><code>org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration</code><ul><li>基于 XA 二阶提交协议的分布式事务数据源</li></ul></li><li><code>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</code><ul><li>支持事务的自动配置</li></ul></li></ul></li><li>拥有的底层能力：数据源、JdbcTemplate、事务处理</li></ul></li></ul><h4 id="MyBatisAutoConfiguration-分析"><a href="#MyBatisAutoConfiguration-分析" class="headerlink" title="MyBatisAutoConfiguration 分析"></a>MyBatisAutoConfiguration 分析</h4><ul><li><code>MyBatisAutoConfiguration</code> 配置了 MyBatis 的整合流程<ul><li><code>mybatis-spring-boot-starter</code> 导入 <code>mybatis-spring-boot-autoconfigure</code>（MyBatis 的自动配置包）</li><li>默认加载两个自动配置类<ul><li><code>org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration</code></li><li><code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code><ul><li>必须在数据源配置好之后才配置</li><li>往容器注册 <code>SqlSessionFactory</code> 组件，用于创建访问数据库的一次会话</li><li>往容器注册 <code>SqlSessionTemplate</code> 组件，用于操作数据库</li></ul></li></ul></li><li> MyBatis 的所有配置绑定在 <code>MybatisProperties</code></li><li>每个 <code>Mapper</code> 接口的代理对象是怎么创建并放到容器中，详见 <code>@MapperScan</code> 的底层源码<ul><li>利用 <code>@Import(MapperScannerRegistrar.class)</code> 批量往容器中注册组件。解析指定的包路径下的每一个类，为每一个 <code>Mapper</code> 接口类创建代理对象，并注册到容器中</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">如何分析哪个场景导入以后，开启了哪些自动配置类？</p><ul><li>在 <code>spring.boot.autoconfigure</code> 包里面找 <code>classpath:/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中配置的所有值，就是要开启的自动配置类；但是每个类可能有条件注解，基于条件注解判断哪个自动配置类会生效。</li><li>快速定位生效的自动配置，方法如下：</li></ul></div><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启调试模式，可以详细打印开启了哪些自动配置，Positive（生效的自动配置），Negative（不生效的自动配置）</span></span><br><span class="line"><span class="attr">debug</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a target="_blank" rel="external nofollow" href="https://docs.spring.io/spring-boot/docs/current/reference/html/">SpringBoot 3 官方英文文档</a></li><li><a target="_blank" rel="external nofollow" href="https://doc.qzxdp.cn/spring/spring-boot.html">SpringBoot 3 最新中文文档</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/1dfe3056.html" title="SpringBoot3 基础教程之九核心原理">https://www.techgrow.cn/posts/1dfe3056.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag"><i class="fa fa-tag"></i> 微服务</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/27928f6f.html" rel="prev" title="SpringBoot3 基础教程之八场景整合"><i class="fa fa-angle-left"></i> SpringBoot3 基础教程之八场景整合</a></div><div class="post-nav-item"> <a href="/posts/77624786.html" rel="next" title="聊聊 SOA 和微服务的关系">聊聊 SOA 和微服务的关系<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.8m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">27:39</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/1dfe3056.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>