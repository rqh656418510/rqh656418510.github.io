<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍在 Java 中如何使用线程池，包括正确关闭线程池、线程池处理异常等内容。"><meta property="og:type" content="article"><meta property="og:title" content="Java 之线程池使用详解"><meta property="og:url" content="https://www.techgrow.cn/posts/832c55b5.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍在 Java 中如何使用线程池，包括正确关闭线程池、线程池处理异常等内容。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/08/thread-pool-close-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/08/thread-pool-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/08/thread-pool-5.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/08/thread-pool-exception.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/08/thread-pool-close-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/08/thread-pool-completable.png"><meta property="article:published_time" content="2019-02-18T15:20:42.000Z"><meta property="article:modified_time" content="2024-08-15T14:34:42.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Java"><meta property="article:tag" content="并发编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2024/08/thread-pool-close-2.png"><link rel="canonical" href="https://www.techgrow.cn/posts/832c55b5.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/832c55b5.html","path":"posts/832c55b5.html","title":"Java 之线程池使用详解"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java 之线程池使用详解 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/app/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">线程池的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">线程池的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">线程池的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">线程池的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">线程池的核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-text">线程池的核心参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-text">线程池的拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">线程池的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="nav-text">线程池的核心类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-text">线程池的创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">线程池的使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="nav-text">使用案例一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="nav-text">使用案例二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%89"><span class="nav-text">使用案例三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD"><span class="nav-text">线程池如何正确关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%B3%E9%97%AD%E7%9A%84-API"><span class="nav-text">线程池关闭的 API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#shutdown-%E6%96%B9%E6%B3%95"><span class="nav-text">shutdown () 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shutdownNow-%E6%96%B9%E6%B3%95"><span class="nav-text">shutdownNow () 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#awaitTermination-%E6%96%B9%E6%B3%95"><span class="nav-text">awaitTermination () 方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%B3%E9%97%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">线程池关闭的最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="nav-text">JDK 官方文档</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%90%86%E8%AE%BA"><span class="nav-text">最佳实践理论</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%BB%A3%E7%A0%81"><span class="nav-text">最佳实践代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="nav-text">线程池如何处理异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">任务提交的三种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F"><span class="nav-text">第一种任务提交方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F"><span class="nav-text">第二种任务提交方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F"><span class="nav-text">第三种任务提交方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">异常处理的最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%90%86%E8%AE%BA-1"><span class="nav-text">最佳实践理论</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%BB%A3%E7%A0%81-1"><span class="nav-text">最佳实践代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-text">线程池如何合理配置参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">线程池的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">线程池的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%88%9A%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%B0%E4%BB%BB%E5%8A%A1"><span class="nav-text">如何处理刚提交的新任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98"><span class="nav-text">线程池的企业实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%89%B9%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span class="nav-text">大数据批处理任务工具类设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92%E5%92%8C%E5%B9%B6%E8%A1%8C%E4%BC%98%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">异步编排和并行优化的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Async-%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">@Async 与线程池的使用</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">590</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/832c55b5.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java 之线程池使用详解 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍在 Java 中如何使用线程池，包括正确关闭线程池、线程池处理异常等内容。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Java 之线程池使用详解</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-02-18 23:20:42" itemprop="dateCreated datePublished" datetime="2019-02-18T23:20:42+08:00">2019-02-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-08-15 22:34:42" itemprop="dateModified" datetime="2024-08-15T22:34:42+08:00">2024-08-15</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/832c55b5.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/832c55b5.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>9.4k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>9 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/832c55b5.html">Java 之线程池使用详解</a></li><li><a href="/posts/d208d196.html">Java 之 ScheduledThreadPoolExecutor 使用</a></li></ul><h2 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h2><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><ul><li>限定线程的个数，避免由于线程过多导致系统运行缓慢或崩溃。</li><li>线程池不需要每次都去创建或销毁线程，节约了资源。</li><li>线程池不需要每次都去创建线程，响应时间更快。</li></ul><h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><p>线程池是一种线程管理的机制，用于提高多线程任务处理的效率和性能。它由线程池管理器、工作队列和一组工作线程组成。</p><ul><li><strong>线程池管理器</strong>：负责创建、管理和调度线程池中的线程。它根据需要动态地创建或销毁线程，并分配任务给空闲的线程。</li><li><strong>工作队列</strong>：用于存储待执行的任务。线程池中的线程从工作队列中取出任务进行处理。当工作队列已满时，新提交的任务可能会被拒绝或者等待一段时间。</li><li><strong>工作线程</strong>：线程池中的实际执行单元。它们循环地从工作队列中取出任务执行，并在任务执行完毕后返回线程池等待下一次任务。</li></ul><span id="more"></span><h3 id="线程池的优缺点"><a href="#线程池的优缺点" class="headerlink" title="线程池的优缺点"></a>线程池的优缺点</h3><blockquote><p>线程池的优点</p></blockquote><ul><li><strong>降低资源消耗</strong>：减少了线程的创建和销毁频率，降低了系统开销。</li><li><strong>提高响应速度</strong>：线程池中的线程通常是预先创建好的，可以立即处理任务，避免了线程创建的延迟。</li><li><strong>提高系统稳定性</strong>：通过控制线程的数量，避免了系统资源被耗尽的风险，防止系统因过度并发而崩溃。</li><li><strong>提高可管理性</strong>：通过线程池管理器，可以方便地监控、调整线程池的大小和任务执行情况。</li></ul><p>线程池广泛应用于各种多线程任务处理的场景，如网络服务器、数据库连接池、图像处理等。</p><blockquote><p>线程池的缺点</p></blockquote><ul><li><strong>资源占用</strong>：线程池在运行过程中会占用一定的系统资源，包括内存和 CPU 资源。如果线程池的大小设置过大，可能会消耗过多的系统资源，影响其他程序的正常运行。</li><li><strong>调优难度</strong>：确定线程池的大小和配置参数需要一定的经验和调试，不同的应用场景可能需要不同的配置，而这种调优过程可能比较繁琐。</li><li><strong>任务拥堵</strong>：如果任务提交速度过快，超过了线程池的处理能力，会导致任务在工作队列中排队等待执行，可能造成任务响应时间延长或者任务被拒绝执行。</li><li><strong>任务依赖性</strong>：线程池中的线程都是独立的执行单元，无法直接控制线程间的依赖关系。如果有一些任务之间存在依赖关系，可能需要额外的同步机制来处理。</li><li><strong>线程泄漏</strong>：如果线程池中的线程没有适时地释放，可能会导致线程资源的泄漏，进而导致系统资源的浪费或者系统稳定性的下降。</li></ul><p>综上所述，虽然线程池可以提高多线程任务处理的效率和性能，但在使用时仍需注意合理配置线程池大小和参数，并且需要注意任务提交的速度，以免出现资源浪费或性能下降的情况。</p><h3 id="线程池的核心组件"><a href="#线程池的核心组件" class="headerlink" title="线程池的核心组件"></a>线程池的核心组件</h3><p>线程池主要由以下几个核心组件组成：</p><ul><li><strong>线程池管理器（ThreadPoolExecutor）</strong>：用于创建和管理线程池，包括创建线程、销毁线程和添加新任务。</li><li><strong>线程工厂（ThreadFactory）</strong>：用于创建新线程，用户可以通过自定义 ThreadFactory 来定义线程的属性（如是否是守护线程、线程的优先级等）。</li><li><strong>任务队列（BlockingQueue）</strong>：用于存放等待执行的任务，可以是有界或者无界的队列。</li><li><strong>任务拒绝策略（RejectedExecutionHandler）</strong>：当任务太多而无法处理时，线程池采取的处理策略。</li></ul><h3 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h3><p>线程池一共有 7 个核心参数，分别是：</p><ul><li><strong>corePoolSize</strong>：核心线程数，线程池中的常驻核心线程数<ul><li>在线程池创建后，池中的线程数通常等于 <code>corePoolSize</code>，当有请求任务过来，就会安排线程池中的线程去执行任务。</li><li>当线程池中的活动线程数量达到 <code>corePoolSize</code> 后，就会把到达的请求任务放到工作队列中等待。</li><li>在没有任务执行时，核心线程会一直存活在线程池中，即使是处于空闲状态，核心线程也不会被销毁。如果使用了无界队列，即使没有任务执行，核心线程也不会超时退出。</li></ul></li><li><strong>maximumPoolSize</strong>：最大线程数，线程池允许能够同时执行的最大线程数<ul><li>相当于扩容后的线程数，即这个线程池能容纳的最大线程数，此值必须大于等于 1。</li><li>当线程池中的活动线程数量达到 <code>corePoolSize</code>，且工作队列已满时，会为新任务创建新的线程，直到达到最大线程数，超过最大线程数的任务将会根据预先设定的拒绝策略来处理。</li></ul></li><li><strong>keepAliveTime</strong>：空闲线程的存活时间<ul><li>当线程池中的线程数量超过 <code>corePoolSize</code> 时，多余的空闲线程在被回收前等待新任务到来的最长时间。</li><li>当空闲时间超过 <code>keepAliveTime</code> 时，多余的空闲线程会被销毁，直到只剩下 <code>corePoolSize</code> 个线程为止。</li><li>在默认情况下，只有当线程池中的线程数量大于 <code>corePoolSize</code> 时，<code>keepAliveTime</code> 才会起作用。</li></ul></li><li><strong>unit</strong>：线程存活时间的单位<ul><li>指定 <code>keepAliveTime</code> 参数的时间单位，可以是秒、毫秒、分钟等。</li></ul></li><li><strong>workQueue</strong>：工作队列，存放被提交但未被执行的任务（待执行任务）<ul><li>线程池通过该队列来管理待执行的任务。</li><li>常见的实现类包括 ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue 等。</li></ul></li><li><strong>threadFactory</strong>：用于创建新线程的工厂<ul><li>生成线程池中工作线程的线程工厂，一般用默认的即可。</li><li>可以通过该参数自定义线程的创建方式，如设置线程的名称、优先级等。</li></ul></li><li><strong>handler</strong>：拒绝策略<ul><li>当任务无法被线程池执行，通常是由于线程池已经关闭，或者超过了最大线程数（maximumPoolSize），并且队列已满时，如何来拒绝执行任务的策略。</li></ul></li></ul><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><p>Java 线程池提供了 4 大拒绝策略，用于处理无法接受新任务的情况，四大拒绝策略都实现了 RejectedExecutionHandler 接口。</p><ul><li><strong>AbortPolicy</strong><ul><li> 这是默认拒绝策略，直接抛出 RejectedExcutionException 异常，以此通知调用者线程池无法接受新任务。</li></ul></li><li><strong>DiscardPolicy</strong><ul><li> 直接丢弃任务，不予任何处理也不抛出异常，如果允许任务丢失，这是一种较好的方案。</li></ul></li><li><strong>DiscardOldestPolicy</strong><ul><li> 丢弃工作队列中等待时间最长的任务（即最旧的任务），然后尝试再次提交这个新任务，将其加入到工作队列中。</li></ul></li><li><strong>CallerRunsPolicy</strong><ul><li> 既不会丢弃任务，也不会抛出异常，而是调用任务提交者的线程来执行这个新任务（即谁提交由谁来执行）。这样一来，提交任务的线程就会尝试去执行该任务，从而避免任务的丢失，并降低新任务的流量。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">CallerRunsPolicy 策略详解</p><ul><li>上述提到的 CallerRunsPolicy 拒绝策略，如果线程池中的线程数达到最大线程数，工作队列也已经满了，并且任务提交者的线程也很忙，没时间去执行被拒绝的任务，那么线程池会怎么处理呢？</li><li>如果采用 CallerRunsPolicy 拒绝策略，此时线程池中的线程数达到最大线程数，且工作队列也已经满了，这意味着没有空闲的线程来执行任务，并且工作队列也无法继续接收新的任务。在这种情况下，线程池会尝试调用任务提交者的线程来执行这个被拒绝的任务。然而，如果提交该任务的线程也忙于执行其他任务，没有空闲的时间去执行被拒绝的任务，那么线程池就会继续阻塞任务提交者，直到工作队列有空间或者有空闲线程可用来执行任务为止。</li></ul></div><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的核心类"><a href="#线程池的核心类" class="headerlink" title="线程池的核心类"></a>线程池的核心类</h3><p>JUC 包中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，ExecutorService、ThreadPoolExecutor、Executors（工具类）这几个核心类。</p><p><img data-src="../../../asset/2024/08/thread-pool-close-2.png"></p><h3 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h3><p>可以通过 Executors 提供的 5 个静态方法来创建不同的线程池，如下：</p><ul><li><strong>newFixedThreadPool</strong>：创建一个拥有固定线程数的线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li><strong>newCachedThreadPool</strong>：创建一个可扩容的线程池，如果线程池大小超过处理需要，可灵活回收空闲线程，若线程无可回收，则创建线程。</li><li><strong>newSingleThreadExecutor</strong>：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO、LIFO、优先级）执行。</li><li><strong>newScheduledThreadPool</strong>：创建一个拥有固定线程数的线程池，支持定时及周期性任务的执行。</li><li><strong>newWorkStealingPool</strong>：创建持有足够的线程的线程池来支持给定的并行级别，是 Java 8 新增的 API。</li></ul><div class="admonition warning"><p class="admonition-title">重点面试题</p><p>线程池常用的创建方式有三种：固定数量的、单一线程的、可扩容的，那么在实际开发中，应该使用哪种方式？</p></div><p>在生产环境中，三种方式都不使用，而是使用自己自定义的。那为什么不用 JDK 中 Executors 提供的呢？这里总结了一些不推荐使用默认 Executors 创建线程池的原因：</p><ul><li><strong>无界队列</strong>：默认情况下，Executors 工厂方法创建的线程池使用的是无界队列。这意味着如果任务提交的速度超过了线程池处理任务的速度，那么队列会不断增长，最终可能导致内存耗尽或者 OutOfMemoryError。因此，在某些情况下，使用有界队列更安全，当任务队列已满时，可以根据需要采取适当的拒绝策略。</li><li><strong>线程生命周期管理</strong>：使用默认的 Executors 创建的线程池，线程的生命周期（如线程的创建、销毁等）可能由线程池自动管理，而这种自动管理可能不适合所有的应用场景。例如，在某些情况下，可能需要对线程的创建和销毁进行更精细的控制，以避免资源泄露或者其他问题。</li><li><strong>线程池的大小</strong>：默认的 Executors 创建的线程池大小可能不符合实际需求。例如，如果任务量非常大，但是线程池的大小较小，那么可能会导致任务排队等待执行，从而影响系统的性能。因此，在实际应用中，通常需要根据实际情况来调整线程池的大小。</li></ul><h3 id="线程池的使用案例"><a href="#线程池的使用案例" class="headerlink" title="线程池的使用案例"></a>线程池的使用案例</h3><h4 id="使用案例一"><a href="#使用案例一" class="headerlink" title="使用案例一"></a>使用案例一</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个拥有固定线程数的线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                threadPool.execute(() -&gt; {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" execute job "</span> + index);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 execute job 1</span><br><span class="line">pool-1-thread-2 execute job 2</span><br><span class="line">pool-1-thread-3 execute job 3</span><br><span class="line">pool-1-thread-4 execute job 4</span><br><span class="line">pool-1-thread-5 execute job 5</span><br><span class="line">pool-1-thread-4 execute job 9</span><br><span class="line">pool-1-thread-3 execute job 8</span><br><span class="line">pool-1-thread-2 execute job 7</span><br><span class="line">pool-1-thread-1 execute job 6</span><br><span class="line">pool-1-thread-5 execute job 10</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例二"><a href="#使用案例二" class="headerlink" title="使用案例二"></a>使用案例二</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个只有 1 个线程的单线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                threadPool.execute(() -&gt; {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" execute job "</span> + index);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 execute job 1</span><br><span class="line">pool-1-thread-1 execute job 2</span><br><span class="line">pool-1-thread-1 execute job 3</span><br><span class="line">pool-1-thread-1 execute job 4</span><br><span class="line">pool-1-thread-1 execute job 5</span><br><span class="line">pool-1-thread-1 execute job 6</span><br><span class="line">pool-1-thread-1 execute job 7</span><br><span class="line">pool-1-thread-1 execute job 8</span><br><span class="line">pool-1-thread-1 execute job 9</span><br><span class="line">pool-1-thread-1 execute job 10</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例三"><a href="#使用案例三" class="headerlink" title="使用案例三"></a>使用案例三</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo3</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个可扩容的线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                threadPool.execute(() -&gt; {</span><br><span class="line">                    <span class="comment">// 模拟业务延迟</span></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">100</span>));</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" execute job "</span> + index);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-7 execute job 7</span><br><span class="line">pool-1-thread-6 execute job 6</span><br><span class="line">pool-1-thread-3 execute job 3</span><br><span class="line">pool-1-thread-9 execute job 9</span><br><span class="line">pool-1-thread-8 execute job 8</span><br><span class="line">pool-1-thread-1 execute job 1</span><br><span class="line">pool-1-thread-2 execute job 2</span><br><span class="line">pool-1-thread-4 execute job 4</span><br><span class="line">pool-1-thread-10 execute job 10</span><br><span class="line">pool-1-thread-5 execute job 5</span><br></pre></td></tr></tbody></table></figure><h3 id="线程池如何正确关闭"><a href="#线程池如何正确关闭" class="headerlink" title="线程池如何正确关闭"></a>线程池如何正确关闭</h3><h4 id="线程池关闭的-API"><a href="#线程池关闭的-API" class="headerlink" title="线程池关闭的 API"></a>线程池关闭的 API</h4><p>线程池关闭有两个 API：</p><ul><li><code>threadPool.shutdown()</code></li><li><code>threadPool.shutdownNow()</code></li></ul><p>执行 <code>shutdown()</code> 或者 <code>shutdownNow()</code> 方法之后，都将会影响任务的执行状态，比如：</p><ul><li>(1) 未提交的任务，此时任务可以被提交到线程池。</li><li>(2) 已提交未执行的任务，此时任务已在线程池的工作队列中，等待着执行。</li><li>(3) 执行中的任务，此时任务正在执行。</li><li>(4) 任务执行完毕</li></ul><h5 id="shutdown-方法"><a href="#shutdown-方法" class="headerlink" title="shutdown() 方法"></a>shutdown () 方法</h5><p>在 JDK 中，线程池的 <code>shutdown()</code> 方法的源码注释如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment"> * tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment"> * Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment"> * complete execution.  Use {<span class="doctag">@link</span> #awaitTermination awaitTermination}</span></span><br><span class="line"><span class="comment"> * to do that.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment"> *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment"> *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment"> *         because it does not hold {<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> *         java.lang.RuntimePermission}{<span class="doctag">@code</span> ("modifyThread")},</span></span><br><span class="line"><span class="comment"> *         or the security manager's {<span class="doctag">@code</span> checkAccess} method</span></span><br><span class="line"><span class="comment"> *         denies access.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>大概的意思是，调用 <code>shutdown()</code> 方法后，会将线程池状态置为 <code>SHUTDOWN</code>，并且会启动一个有序的关闭过程。在这个关闭过程中，线程池里等候待执行的任务和正在执行的任务都会继续执行，但不会再接受新的任务。如果系统已经关闭了，那么再次调用该方法将不会产生额外的效果。结合现实例子，比如银行下午 5 点关门，那么在下午 5 点 之前进去的顾客（Task），已经受理的可以办完业务才离开；下午 5 点之后，不再接受新顾客进来，只能明日请早。</p><ul><li><code>shutdown()</code> 方法的特性总结<ul><li>在方法调用后，不会再接受新的任务。</li><li>在方法调用后，等候待执行的任务和正在执行的任务都会继续执行。</li><li>如果线程池已关闭，再次调用方法不会产生任何影响。</li></ul></li></ul><blockquote><p>验证 <code>shutdown()</code> 方法的使用，代码如下：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        shutdownTest();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第 6 个任务开始及之后的任务都被拒绝了，1 ~ 5 号任务正常执行。</span></span><br><span class="line"><span class="comment">     * 所以 shutdown() 方法会将线程池状态设置为 SHUTDOWN，但是线程池并不会立即停止，要等正在执行和队列里等待的任务执行完才会停止。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdownTest</span><span class="params">()</span> </span>{</span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 提交 10 个任务，在第 5 个任务提交完，准备提交第 6 个的时候执行 shutdown</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"第 "</span> + i + <span class="string">" 次提交"</span>);</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Task(i));</span><br><span class="line">            <span class="comment">// i 等于 5 的时候 shutdown，意味着从第 6 次开始就不能提交新任务</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) {</span><br><span class="line">                threadPool.shutdown();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        String name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">            name = <span class="string">"task-"</span> + i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">"sleep completed, "</span> + getName());</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"interrupted, "</span> + getName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(getName() + <span class="string">" finished"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">第 1 次提交</span><br><span class="line">第 2 次提交</span><br><span class="line">第 3 次提交</span><br><span class="line">第 4 次提交</span><br><span class="line">第 5 次提交</span><br><span class="line">第 6 次提交</span><br><span class="line"></span><br><span class="line">Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task com.java.interview.pool.ThreadPoolDemo$Task@5e5792a0 rejected from java.util.concurrent.ThreadPoolExecutor@26653222[Shutting down, pool size = 1, active threads = 1, queued tasks = 4, completed tasks = 0]</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)</span><br><span class="line">	at java.base/java.util.concurrent.Executors$DelegatedExecutorService.execute(Executors.java:687)</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo.shutdownTest(ThreadPoolDemo.java:23)</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo.main(ThreadPoolDemo.java:15)</span><br><span class="line"></span><br><span class="line">sleep completed, task-1</span><br><span class="line">task-1 finished</span><br><span class="line"></span><br><span class="line">sleep completed, task-2</span><br><span class="line">task-2 finished</span><br><span class="line"></span><br><span class="line">sleep completed, task-3</span><br><span class="line">task-3 finished</span><br><span class="line"></span><br><span class="line">sleep completed, task-4</span><br><span class="line">task-4 finished</span><br><span class="line"></span><br><span class="line">sleep completed, task-5</span><br><span class="line">task-5 finished</span><br></pre></td></tr></tbody></table></figure><p>从上面的输出结果可以看到，当调用 <code>shutdown()</code> 方法后，线程池里等候待执行的任务和正在执行的任务都会继续执行，但不会再接受新的任务。</p><h5 id="shutdownNow-方法"><a href="#shutdownNow-方法" class="headerlink" title="shutdownNow() 方法"></a>shutdownNow () 方法</h5><p>在 JDK 中，线程池的 <code>shutdownNow()</code> 方法的源码注释如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment"> * processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment"> * that were awaiting execution.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment"> * terminate.  Use {<span class="doctag">@link</span> #awaitTermination awaitTermination} to</span></span><br><span class="line"><span class="comment"> * do that.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment"> * processing actively executing tasks.  For example, typical</span></span><br><span class="line"><span class="comment"> * implementations will cancel via {<span class="doctag">@link</span> Thread#interrupt}, so any</span></span><br><span class="line"><span class="comment"> * task that fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> list of tasks that never commenced execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment"> *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment"> *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment"> *         because it does not hold {<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> *         java.lang.RuntimePermission}{<span class="doctag">@code</span> ("modifyThread")},</span></span><br><span class="line"><span class="comment"> *         or the security manager's {<span class="doctag">@code</span> checkAccess} method</span></span><br><span class="line"><span class="comment"> *         denies access.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>大概的意思是，调用 <code>shutdownNow()</code> 方法后，线程池会尝试停止所有正在执行的任务（仅仅是做尝试，成功与否取决于任务是否响应 InterruptedException 异常，以及对其做出的反应），同时会中止处理等待执行的任务，并返回等待执行的任务列表。<code>shutdownNow()</code> 方法会将线程池状态置为 <code>STOP</code>，并试图让线程池立刻关闭，但不一定能保证立刻关闭。因为线程池是通过 <code>interrupt()</code> 方法去尝试停止正在执行的任务，所以无法响应 Interrupt 中断的任务可能不会被停止，要等所有正在执行的任务（不能被 Interrupt 中断的任务）执行完才能关闭线程池，也就是说该方法是无法保证一定能够停止正在执行的任务。</p><ul><li><code>shutdownNow()</code> 方法的特性总结<ul><li>在方法调用后，不会再接受新的任务。</li><li>在方法调用后，会尝试停止所有正在执行的任务。</li><li>在方法调用后，等待执行的任务会被取消，并返回等待任务的列表。</li><li>在方法返回时，等待执行的任务将从工作队列中移除。</li></ul></li></ul><blockquote><p>验证 <code>shutdownNow()</code> 方法的使用，代码如下：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        shutdownNowTest();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 shutdownNow() 方法后，在第一个任务正在睡眠的时候，触发了 Interrupt 中断。</span></span><br><span class="line"><span class="comment">     * 之前等待执行的任务 2 ~ 5 将从队列中移除并返回，之后的任务 6 ~ 10 被拒绝执行。</span></span><br><span class="line"><span class="comment">     * shutdounNow() 方法会将线程池状态置为 STOP，试图让线程池立刻关闭，但不一定能保证立即关闭，要等所有正在执行的任务（不能被 Interrupt 中断的任务）执行完才能关闭。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdownNowTest</span><span class="params">()</span> </span>{</span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交 10 个任务，在第 5 个任务提交完，准备提交第 6 个的时候执行 shutdown</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"第 "</span> + i + <span class="string">" 次提交"</span>);</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> Task(i));</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                System.out.println(<span class="string">"rejected, task = "</span> + i);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// i 等于 5 的时候 shutdown，意味着从第 6 次开始就不能提交新任务</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) {</span><br><span class="line">                List&lt;Runnable&gt; tasks = threadPool.shutdownNow();</span><br><span class="line">                <span class="keyword">for</span> (Runnable task : tasks) {</span><br><span class="line">                    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> Task) {</span><br><span class="line">                        System.out.println(<span class="string">"waiting task: "</span> + ((Task) task).getName());</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        String name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">            name = <span class="string">"task-"</span> + i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">"sleep completed, "</span> + getName());</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"interrupted, "</span> + getName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(getName() + <span class="string">" finished"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">第 1 次提交</span><br><span class="line">第 2 次提交</span><br><span class="line">第 3 次提交</span><br><span class="line">第 4 次提交</span><br><span class="line">第 5 次提交</span><br><span class="line"></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.base/java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at java.base/java.lang.Thread.sleep(Thread.java:339)</span><br><span class="line">	at java.base/java.util.concurrent.TimeUnit.sleep(TimeUnit.java:446)</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo$Task.run(ThreadPoolDemo.java:73)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br><span class="line"></span><br><span class="line">waiting task: task-2</span><br><span class="line">interrupted, task-1</span><br><span class="line">waiting task: task-3</span><br><span class="line">waiting task: task-4</span><br><span class="line">waiting task: task-5</span><br><span class="line">第 6 次提交</span><br><span class="line">rejected, task = 6</span><br><span class="line">第 7 次提交</span><br><span class="line">rejected, task = 7</span><br><span class="line">第 8 次提交</span><br><span class="line">rejected, task = 8</span><br><span class="line">第 9 次提交</span><br><span class="line">rejected, task = 9</span><br><span class="line">第 10 次提交</span><br><span class="line">rejected, task = 10</span><br></pre></td></tr></tbody></table></figure><p>从上面的输出结果可以看到，当调用 <code>shutdownNow()</code> 方法后，线程池会尝试停止所有正在执行的任务，同时会中止处理等待执行的任务，并返回等待执行的任务列表。</p><h5 id="awaitTermination-方法"><a href="#awaitTermination-方法" class="headerlink" title="awaitTermination() 方法"></a>awaitTermination () 方法</h5><p>在 JDK 中，线程池的 <code>awaitTermination()</code> 方法的源码注释如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Blocks until all tasks have completed execution after a shutdown</span></span><br><span class="line"><span class="comment"> * request, or the timeout occurs, or the current thread is</span></span><br><span class="line"><span class="comment"> * interrupted, whichever happens first.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this executor terminated and</span></span><br><span class="line"><span class="comment"> *         {<span class="doctag">@code</span> false} if the timeout elapsed before termination</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></tbody></table></figure><p>大概的意思是，在发出线程池关闭请求之后，会阻塞当前线程直到所有任务都执行完、或者发生超时、或者当前线程被中断，并且以这三者中先发生的情况为准。在关闭线程池时，如果需要等待任务执行完，请使用 <code>awaitTermination()</code> 方法。因为该方法带有超时参数，如果等待超时后，任务仍然未执行完毕，那么线程池就不会再等待。毕竟应用总归要停机重启的，不可能无限期地等待下去，因此超时机制是提供给用户的最后一道底线。</p><ul><li><code>awaitTermination()</code> 的特性总结<ul><li>在调用方法后，会阻塞当前线程，直到等待执行和正在执行的任务都执行完了，才解除当前线程的阻塞。</li><li>当等待超过设置的时间，会检查线程池是否已经关闭。</li><li>如果所有任务都执行完了，方法会返回 <code>true</code>。</li><li>如果在所有任务执行完之前等待超时了，方法会返回 <code>false</code>，并解除当前线程的阻塞。</li></ul></li></ul><blockquote><p>验证 shutdown () + awaitTermination () 方法的使用，代码如下：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        shutdownAndAwaitTermination();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdownAndAwaitTermination</span><span class="params">()</span> </span>{</span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交 10 个任务，在第 5 个任务提交完，准备提交第 6 个的时候执行 shutdown</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"第 "</span> + i + <span class="string">" 次提交"</span>);</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> Task(i));</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                System.out.println(<span class="string">"rejected, task = "</span> + i);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// i 等于 5 的时候 shutdown，意味着从第 6 次开始就不能提交新任务</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) {</span><br><span class="line">                threadPool.shutdown();</span><br><span class="line">                System.out.println();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 调用 awaitTermination() 方法后，当线程池里的任务没执行完成，且还没到设定的超时时间，则会阻塞当前线程，也就是不会执行最下面的两行打印代码。</span></span><br><span class="line"><span class="comment">             * 现在把等待时间设置为 4 秒，当达到设定的超时时间后，就不会再阻塞当前线程，直接打印最新下面的两行代码，并且返回了 false，表示线程池没有关闭。</span></span><br><span class="line"><span class="comment">             * 有时候需要主线程等所有子线程执行完成后再运行，在所有任务提交后，调用 shutdown() 方法触发 awaitTermination() 时，会阻塞主线程；当所有子线程执行完成后，才会解除阻塞。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">boolean</span> isStop = threadPool.awaitTermination(<span class="number">4</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="string">"is pool stoped: "</span> + isStop);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"all tests finished"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        String name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">            name = <span class="string">"task-"</span> + i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">"sleep completed, "</span> + getName());</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"interrupted, "</span> + getName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(getName() + <span class="string">" finished"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">第 1 次提交</span><br><span class="line">第 2 次提交</span><br><span class="line">第 3 次提交</span><br><span class="line">第 4 次提交</span><br><span class="line">第 5 次提交</span><br><span class="line"></span><br><span class="line">第 6 次提交</span><br><span class="line">rejected, task = 6</span><br><span class="line">第 7 次提交</span><br><span class="line">rejected, task = 7</span><br><span class="line">第 8 次提交</span><br><span class="line">rejected, task = 8</span><br><span class="line">第 9 次提交</span><br><span class="line">rejected, task = 9</span><br><span class="line">第 10 次提交</span><br><span class="line">rejected, task = 10</span><br><span class="line">sleep completed, task-1</span><br><span class="line">task-1 finished</span><br><span class="line"></span><br><span class="line">is pool stoped: false</span><br><span class="line">-----------------</span><br><span class="line">main	all tests finished</span><br><span class="line"></span><br><span class="line">sleep completed, task-2</span><br><span class="line">task-2 finished</span><br><span class="line"></span><br><span class="line">sleep completed, task-3</span><br><span class="line">task-3 finished</span><br><span class="line"></span><br><span class="line">sleep completed, task-4</span><br><span class="line">task-4 finished</span><br><span class="line"></span><br><span class="line">sleep completed, task-5</span><br><span class="line">task-5 finished</span><br></pre></td></tr></tbody></table></figure><p>从上面的输出结果可以看到，当调用 <code>shutdown()</code> 方法后，线程池里等候待执行的任务和正在执行的任务都会继续执行，但不会再接受新的任务。当调用 <code>awaitTermination()</code> 方法后，由于在所有任务执行完之前等待超时了，所以方法会返回 <code>false</code>，并解除当前线程的阻塞。</p><blockquote><p>验证 shutdownNow () + awaitTermination () 方法的使用，代码如下：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        shutdownNow_awaitTermination_Test();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdownNow_awaitTermination_Test</span><span class="params">()</span> </span>{</span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交 10 个任务，在第 5 个任务提交完，准备提交第 6 个的时候执行 shutdown</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> Task(i));</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                System.out.println(<span class="string">"rejected, task-"</span> + i);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i 等于 5 的时候 shutdown，意味着从第 6 次开始就不能提交新任务</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) {</span><br><span class="line">                List&lt;Runnable&gt; tasks = threadPool.shutdownNow();</span><br><span class="line">                <span class="keyword">for</span> (Runnable task : tasks) {</span><br><span class="line">                    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> Task) {</span><br><span class="line">                        System.out.println(<span class="string">"waiting task: "</span> + ((Task) task).getName());</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">boolean</span> isStop = threadPool.awaitTermination(<span class="number">4</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="string">"is pool stoped: "</span> + isStop);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"all tests finished"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        String name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">            name = <span class="string">"task-"</span> + i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">"sleep completed, "</span> + getName());</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"interrupted, "</span> + getName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(getName() + <span class="string">" finished"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">第 1 次提交</span><br><span class="line">第 2 次提交</span><br><span class="line">第 3 次提交</span><br><span class="line">第 4 次提交</span><br><span class="line">第 5 次提交</span><br><span class="line">waiting task: task-2</span><br><span class="line">interrupted, task-1</span><br><span class="line">waiting task: task-3</span><br><span class="line">waiting task: task-4</span><br><span class="line">waiting task: task-5</span><br><span class="line">第 6 次提交</span><br><span class="line">rejected, task-6</span><br><span class="line">第 7 次提交</span><br><span class="line">rejected, task-7</span><br><span class="line">第 8 次提交</span><br><span class="line">rejected, task-8</span><br><span class="line">第 9 次提交</span><br><span class="line">rejected, task-9</span><br><span class="line"></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.base/java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at java.base/java.lang.Thread.sleep(Thread.java:339)</span><br><span class="line">	at java.base/java.util.concurrent.TimeUnit.sleep(TimeUnit.java:446)</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo$Task.run(ThreadPoolDemo.java:146)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br><span class="line"></span><br><span class="line">第 10 次提交</span><br><span class="line">rejected, task-10</span><br><span class="line">is pool stoped: true</span><br><span class="line">-----------------</span><br><span class="line">main	all tests finished</span><br></pre></td></tr></tbody></table></figure><p>从上面的输出结果可以看到，当调用 <code>shutdownNow()</code> 方法后，线程池会尝试停止所有正在执行的任务，同时会中止处理等待执行的任务，并返回等待执行的任务列表。当调用 <code>awaitTermination()</code> 方法后，由于所有任务都执行完了（包括任务被中断而停止的情况），所以方法会返回 <code>true</code>，并解除当前线程的阻塞。</p><h4 id="线程池关闭的最佳实践"><a href="#线程池关闭的最佳实践" class="headerlink" title="线程池关闭的最佳实践"></a>线程池关闭的最佳实践</h4><h5 id="JDK-官方文档"><a href="#JDK-官方文档" class="headerlink" title="JDK 官方文档"></a>JDK 官方文档</h5><blockquote><p>在 <a target="_blank" rel="external nofollow" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ExecutorService.html">JDK 官方文档</a> 中，给出了线程池正确关闭的示例代码（如下所示）。以下方法分两个阶段关闭线程池，首先通过调用 <code>shutdown()</code> 方法，让线程池拒绝接受新的任务，然后在必要时调用 <code>shutdownNow()</code> 方法，以此停止所有正在执行的任务。</p></blockquote><p><img data-src="../../../asset/2024/08/thread-pool-3.png"></p><h5 id="最佳实践理论"><a href="#最佳实践理论" class="headerlink" title="最佳实践理论"></a>最佳实践理论</h5><p>线程池正确关闭的关键点在于使用 <code>shutdown()</code> + <code>awaitTermination()</code> 方法，或者使用 <code>shutdownNow()</code> + <code>awaitTermination()</code> 方法。</p><p><img data-src="../../../asset/2024/08/thread-pool-5.png"></p><h5 id="最佳实践代码"><a href="#最佳实践代码" class="headerlink" title="最佳实践代码"></a>最佳实践代码</h5><p>最终参考 JDK 官网的示例代码，正确（优雅）关闭线程池的写法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownAndAwaitTermination</span><span class="params">(ExecutorService threadPool)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (threadPool != <span class="keyword">null</span> &amp;&amp; !threadPool.isShutdown()) {</span><br><span class="line">        <span class="comment">// 平滑关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 阻塞当前线程 60 秒，等候待执行的任务和正在执行的任务执行完成</span></span><br><span class="line">            <span class="keyword">if</span> (!threadPool.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) {</span><br><span class="line">                <span class="comment">// 等待超时后，立刻关闭线程池</span></span><br><span class="line">                threadPool.shutdownNow();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 再次阻塞当前线程 60 秒，然后检查线程池是否已经关闭</span></span><br><span class="line">                <span class="keyword">if</span> (!threadPool.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) {</span><br><span class="line">                    System.out.println(<span class="string">"Thread pool did not terminate"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="comment">// 捕获到异常后，立刻关闭线程池</span></span><br><span class="line">            threadPool.shutdownNow();</span><br><span class="line">            <span class="comment">// 捕获到异常后，中断当前线程</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="线程池如何处理异常"><a href="#线程池如何处理异常" class="headerlink" title="线程池如何处理异常"></a>线程池如何处理异常</h3><div class="admonition warning"><p class="admonition-title">重点面试题</p><p>线程池中的线程抛出了异常，如何处理？</p></div><h4 id="任务提交的三种方式"><a href="#任务提交的三种方式" class="headerlink" title="任务提交的三种方式"></a>任务提交的三种方式</h4><p>往线程池提交任务时，有三种提交方式（如下图所示），这也导致了对异常的处理方式不一样。</p><p><img data-src="../../../asset/2024/08/thread-pool-exception.png"></p><h5 id="第一种任务提交方式"><a href="#第一种任务提交方式" class="headerlink" title="第一种任务提交方式"></a>第一种任务提交方式</h5><p>当调用 Executor 的 <code>execute()</code> 方法提交任务时，如果任务在执行期间出错，那么默认会抛出异常。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        execute();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 execute() 方法提交任务，默认会抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 调用 execute() 方法提交任务，会抛出异常</span></span><br><span class="line">            threadPool.execute(() -&gt; {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"进入 execute() 方法 ---start"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">3</span>) {</span><br><span class="line">                        <span class="keyword">int</span> age = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(<span class="string">"come in execute: "</span> + i);</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"进入 execute() 方法 ---end"</span>);</span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1	进入 execute() 方法 ---start</span><br><span class="line">come in execute: 1</span><br><span class="line">come in execute: 2</span><br><span class="line">Exception in thread "pool-1-thread-1" java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo.lambda$execute$0(ThreadPoolDemo.java:29)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></tbody></table></figure><h5 id="第二种任务提交方式"><a href="#第二种任务提交方式" class="headerlink" title="第二种任务提交方式"></a>第二种任务提交方式</h5><p>当调用 Executor 的 <code>submit()</code> 方法提交任务时，如果任务在执行期间出错，那么默认吞掉异常（即不会抛出异常）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        submit();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 submit() 方法提交任务，默认会吞掉异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>{</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 调用 submit() 方法提交任务，默认会吞掉异常</span></span><br><span class="line">            threadPool.submit(() -&gt; {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"进入 submit() 方法 ---start"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">3</span>) {</span><br><span class="line">                        <span class="keyword">int</span> age = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(<span class="string">"come in execute: "</span> + i);</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"进入 submit() 方法 ---end"</span>);</span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1	进入 submit() 方法 ---start</span><br><span class="line">come in execute: 1</span><br><span class="line">come in execute: 2</span><br></pre></td></tr></tbody></table></figure><h5 id="第三种任务提交方式"><a href="#第三种任务提交方式" class="headerlink" title="第三种任务提交方式"></a>第三种任务提交方式</h5><p>当调用 Executor 的 <code>submit()</code> 方法提交任务后，如果任务在执行期间出错了，并且通过调用 <code>Future.get()</code> 方法来获取任务的执行结果，则会抛出异常。特别注意，如果不调用 <code>Future.get()</code> 方法，异常默认会被吞掉。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        submitAndGet();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 submit() 方法提交任务后，如果通过调用 Future.get() 方法来获取任务的执行结果，那么会抛出异常；如果不调用 `Future.get()` 方法，异常默认会被吞掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">submitAndGet</span><span class="params">()</span> </span>{</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 执行 submit() 方法后，如果通过调用 Future.get() 方法来获取任务的执行结果，那么会抛出异常，否则异常会被吞掉</span></span><br><span class="line">            Future&lt;?&gt; result = threadPool.submit(() -&gt; {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"进入 submit() 方法 ---start"</span>);</span><br><span class="line">                <span class="keyword">int</span> age = <span class="number">20</span> / <span class="number">0</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"进入 submit() 方法 ---end"</span>);</span><br><span class="line">            });</span><br><span class="line">            <span class="comment">// 如果没有这一行代码，异常会被吞掉</span></span><br><span class="line">            result.get();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1	进入 submit() 方法 ---start</span><br><span class="line">java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">	at java.base/java.util.concurrent.FutureTask.report(FutureTask.java:122)</span><br><span class="line">	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:191)</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo.submitAndGet(ThreadPoolDemo.java:55)</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo.main(ThreadPoolDemo.java:14)</span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo.lambda$submitAndGet$1(ThreadPoolDemo.java:51)</span><br><span class="line">	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)</span><br><span class="line">	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></tbody></table></figure><h4 id="异常处理的最佳实践"><a href="#异常处理的最佳实践" class="headerlink" title="异常处理的最佳实践"></a>异常处理的最佳实践</h4><h5 id="最佳实践理论-1"><a href="#最佳实践理论-1" class="headerlink" title="最佳实践理论"></a>最佳实践理论</h5><p>由于线程池提交任务有多种方式，这也导致了对异常的处理方式不一样。<strong>为了统一处理线程池的异常，不能使用 Excutors 类来创建线程池，而是使用 ThreadPoolExecutor 类手动创建线程池，同时需要重写 ThreadPoolExecutor 类的 <code>afterExecute()</code> 方法来统一处理异常。</strong>在 JDK 中，<code>afterExecute()</code> 方法的源码注释如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method invoked upon completion of execution of the given Runnable.</span></span><br><span class="line"><span class="comment">     * This method is invoked by the thread that executed the task. If</span></span><br><span class="line"><span class="comment">     * non-null, the Throwable is the uncaught {<span class="doctag">@code</span> RuntimeException}</span></span><br><span class="line"><span class="comment">     * or {<span class="doctag">@code</span> Error} that caused execution to terminate abruptly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation does nothing, but may be customized in</span></span><br><span class="line"><span class="comment">     * subclasses. Note: To properly nest multiple overridings, subclasses</span></span><br><span class="line"><span class="comment">     * should generally invoke {<span class="doctag">@code</span> super.afterExecute} at the</span></span><br><span class="line"><span class="comment">     * beginning of this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; When actions are enclosed in tasks (such as</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> FutureTask}) either explicitly or via methods such as</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@code</span> submit}, these task objects catch and maintain</span></span><br><span class="line"><span class="comment">     * computational exceptions, and so they do not cause abrupt</span></span><br><span class="line"><span class="comment">     * termination, and the internal exceptions are &lt;em&gt;not&lt;/em&gt;</span></span><br><span class="line"><span class="comment">     * passed to this method. If you would like to trap both kinds of</span></span><br><span class="line"><span class="comment">     * failures in this method, you can further probe for such cases,</span></span><br><span class="line"><span class="comment">     * as in this sample subclass that prints either the direct cause</span></span><br><span class="line"><span class="comment">     * or the underlying exception if a task has been aborted:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt; {<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * class ExtendedExecutor extends ThreadPoolExecutor {</span></span><br><span class="line"><span class="comment">     *   // ...</span></span><br><span class="line"><span class="comment">     *   protected void afterExecute(Runnable r, Throwable t) {</span></span><br><span class="line"><span class="comment">     *     super.afterExecute(r, t);</span></span><br><span class="line"><span class="comment">     *     if (t == null</span></span><br><span class="line"><span class="comment">     *         &amp;&amp; r instanceof Future&lt;?&gt;</span></span><br><span class="line"><span class="comment">     *         &amp;&amp; ((Future&lt;?&gt;)r).isDone()) {</span></span><br><span class="line"><span class="comment">     *       try {</span></span><br><span class="line"><span class="comment">     *         Object result = ((Future&lt;?&gt;) r).get();</span></span><br><span class="line"><span class="comment">     *       } catch (CancellationException ce) {</span></span><br><span class="line"><span class="comment">     *         t = ce;</span></span><br><span class="line"><span class="comment">     *       } catch (ExecutionException ee) {</span></span><br><span class="line"><span class="comment">     *         t = ee.getCause();</span></span><br><span class="line"><span class="comment">     *       } catch (InterruptedException ie) {</span></span><br><span class="line"><span class="comment">     *         // ignore/reset</span></span><br><span class="line"><span class="comment">     *         Thread.currentThread().interrupt();</span></span><br><span class="line"><span class="comment">     *       }</span></span><br><span class="line"><span class="comment">     *     }</span></span><br><span class="line"><span class="comment">     *     if (t != null)</span></span><br><span class="line"><span class="comment">     *       System.out.println(t);</span></span><br><span class="line"><span class="comment">     *   }</span></span><br><span class="line"><span class="comment">     * }}&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable that has completed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the exception that caused termination, or null if</span></span><br><span class="line"><span class="comment">     * execution completed normally</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>{ }</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="最佳实践代码-1"><a href="#最佳实践代码-1" class="headerlink" title="最佳实践代码"></a>最佳实践代码</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExceptionDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动创建线程池，并统一处理异常的写法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">createThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 手动创建线程池</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            Runtime.getRuntime().availableProcessors(),</span><br><span class="line">            Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,</span><br><span class="line">            <span class="number">30L</span>,</span><br><span class="line">            TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>)) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 重写 afterExecute() 方法，实现统一异常处理</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable runnable, Throwable throwable)</span> </span>{</span><br><span class="line">                <span class="comment">// 判断是否调用 execute() 方法提交任务</span></span><br><span class="line">                <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) {</span><br><span class="line">                    log.error(throwable.getMessage(), throwable);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 判断是否调用 submit() 方法提交任务</span></span><br><span class="line">                <span class="keyword">if</span> (throwable == <span class="keyword">null</span> &amp;&amp; runnable <span class="keyword">instanceof</span> Future&lt;?&gt;) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Future&lt;?&gt; future = (Future&lt;?&gt;) runnable;</span><br><span class="line">                        <span class="keyword">if</span> (future.isDone()) {</span><br><span class="line">                            future.get();</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">catch</span> (CancellationException ce) {</span><br><span class="line">                        throwable = ce;</span><br><span class="line">                        log.error(ce.getMessage(), ce);</span><br><span class="line">                    } <span class="keyword">catch</span> (ExecutionException ee) {</span><br><span class="line">                        throwable = ee.getCause();</span><br><span class="line">                        log.error(ee.getMessage(), ee);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException ie) {</span><br><span class="line">                        log.error(ie.getMessage(), ie);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">return</span> threadPool;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>代码使用案例</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 手动创建线程池</span></span><br><span class="line">        ExecutorService threadPool = createThreadPool();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 调用 submit() 方法提交任务，默认会吞掉异常，改写后可以抛出异常了</span></span><br><span class="line">            threadPool.submit(() -&gt; {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"进入 submit() 方法 ---start"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">3</span>) {</span><br><span class="line">                        <span class="keyword">int</span> age = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(<span class="string">"come in execute: "</span> + i);</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"进入 submit() 方法 ---end"</span>);</span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1	进入 submit() 方法 ---start</span><br><span class="line">come in execute: 1</span><br><span class="line">come in execute: 2</span><br><span class="line">16:11:12.103 [pool-1-thread-1] ERROR com.java.interview.pool.ThreadPoolDemo - java.lang.ArithmeticException: / by zero</span><br><span class="line">java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">	at java.base/java.util.concurrent.FutureTask.report(FutureTask.java:122)</span><br><span class="line">	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:191)</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo$1.afterExecute(ThreadPoolDemo.java:113)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1129)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.java.interview.pool.ThreadPoolDemo.lambda$test02$1(ThreadPoolDemo.java:55)</span><br><span class="line">	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)</span><br><span class="line">	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)</span><br><span class="line">	... 2 common frames omitted</span><br></pre></td></tr></tbody></table></figure><h3 id="线程池如何合理配置参数"><a href="#线程池如何合理配置参数" class="headerlink" title="线程池如何合理配置参数"></a>线程池如何合理配置参数</h3><div class="admonition warning"><p class="admonition-title">重点面试题</p><p>生产环境中如何配置线程池的 corePoolSize 和 maximumPoolSize 参数？</p></div><p>首先需要弄清楚一点，业务系统是属于 CPU 密集型还是 I/O 密集型的。因为线程池的配置，是需要根据具体不同的业务来配置。</p><ul><li><p>CPU 密集型</p><ul><li>CPU 密集的意思是，该任务需要大量的运算，而且没有阻塞，CPU 一直全速运行</li><li> CPU 密集任务只有在真正的多核 CPU 上才可能得到加速执行（使用多线程），而在单核 CPU 上，无论启动几个模拟的多线程，该任务都不可能得到加速执行</li><li> CPU 密集型的任务，应该尽可能少的配置线程数量</li><li>一般配置公式：CPU 核心数 + 1 个线程数</li></ul></li><li><p> I/O 密集型</p><ul><li>IO 密集型的意思是，该任务需要大量的 I/O 操作（网络、磁盘等），大部分线程都会被阻塞</li><li>由于 I/O 密集型的任务线程并不是一直在执行任务，因此需要尽可能多配置线程数，如 CPU 核心数 * 2</li><li> 在单线程上执行 I/O 密集型的任务，会浪费大量的 CPU 运算能力，即花费大量时间在阻塞等待上；所以在 I/O 密集型任务中，使用多线程可以大大的加速程序的运行，这种加速主要就是利用了被浪费掉的阻塞时间</li><li>参考配置公式：CPU 核心数 / (1 - 阻塞系数)，阻塞系数在 0.8 ~ 0.9 左右</li></ul></li></ul><blockquote><p>如果希望更精准地估算 Java 线程池的大小与队列长度，可以参考 <a href="/posts/dc8f1477.html">这里</a> 的教程。</p></blockquote><div class="admonition note"><p class="admonition-title">Java 获取 CPU 核心数</p><p>在 Java 中，可以通过调用 <code>Runtime.getRuntime().availableProcessors()</code> 方法来获取 CPU 的核心数。</p></div><h2 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h2><h3 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h3><p><img data-src="../../../asset/2024/08/thread-pool-close-1.png"></p><p>线程池底层是通过阻塞队列 + 线程实现的，当往线程池添加新任务时：</p><ul><li>(1) 如果当前线程数小于核心线程数，会创建新线程来处理被添加的任务，即使线程池中的线程都处于空闲状态。</li><li>(2) 如果当前线程数大于等于核心线程数，并且工作队列未满，那么新任务会被放入工作队列中。</li><li>(3) 如果当前线程数大于等于核心线程数，工作队列已满，并且当前线程数小于最大线程数，那么会创建新线程来处理被添加的任务。</li><li>(4) 如果当前线程数大于等于核心线程数，工作队列已满，并且当前线程数等于最大线程数，那么会通过设定的任务拒绝策略来处理被添加的任务。</li><li>(5) 当前线程数大于核心线程数时，如果某个线程的空闲时间超过设定的线程存活时间（keepAliveTime），那么该线程将会被终止并从线程池中移除。</li></ul><h3 id="如何处理刚提交的新任务"><a href="#如何处理刚提交的新任务" class="headerlink" title="如何处理刚提交的新任务"></a>如何处理刚提交的新任务</h3><p>当提交新任务时，线程池会按照以下流程进行处理：</p><ol><li><strong>任务接收：</strong> 当有新的任务提交给线程池时，线程池会接收这个任务。</li><li><strong>核心线程处理：</strong> 首先，线程池会检查当前活动线程数量是否已达到核心线程数。如果未达到核心线程数，线程池会创建新的核心线程来处理这个任务。</li><li><strong>任务队列：</strong> 如果当前活动线程数量已经达到设定的核心线程数，但任务队列未满，线程池会将任务放入任务队列中，等待核心线程去处理。任务队列通常是一个阻塞队列，可以保证线程池安全地添加和获取任务。</li><li><strong>最大线程数判断：</strong> 如果任务队列已满，并且线程池中的线程数量未达到最大线程数，则线程池会创建新的非核心线程来处理任务。</li><li><strong>拒绝策略：</strong> 如果线程池中的任务队列已经满了，并且线程数量也已经达到最大线程数，线程池会根据预先设定的拒绝策略来处理新提交的任务。常见的拒绝策略包括抛出异常、丢弃任务或者调用任务提交者的线程执行任务。</li><li><strong>执行任务：</strong> 选中的线程（核心线程或新创建的线程）会执行任务。执行完成后，线程会返回线程池，可以被其他任务复用。</li><li><strong>线程池状态管理：</strong> 线程池会根据任务的执行情况来管理自身的状态，例如线程池的活动线程数量、已完成任务数量、空闲线程的销毁等。</li></ol><h2 id="线程池的企业实战"><a href="#线程池的企业实战" class="headerlink" title="线程池的企业实战"></a>线程池的企业实战</h2><h3 id="大数据批处理任务工具类设计"><a href="#大数据批处理任务工具类设计" class="headerlink" title="大数据批处理任务工具类设计"></a>大数据批处理任务工具类设计</h3><div class="admonition note"><p class="admonition-title">企业真实业务场景</p><p>在双十一购物节来临之前，基于线程池一次性下发 100 万优惠卷 / 短信 / 邮件给用户，并且需要兼顾线程池参数可配置。</p></div><ul><li>高并发多线程大数据批处理任务工具类的设计思路<ul><li> (1) 多个派发任务，使用单线程还是多线程？</li><li>(2) 多线程企业级使用，100% 会引入线程池，那问题来了，线程池应该怎么使用和配置？</li><li>(3) 如何保证不丢数据？怎么保证全部优惠卷都下发完成了？如何实现下发统计或者重试下发？</li><li>(4) 这次是下发优惠卷，下次是短信 / 邮件 / 验证码等，如何做到通用？</li></ul></li></ul><div class="admonition note"><p class="admonition-title">代码说明</p><p>这里将给出基于线程池实现批量发送优惠券的 SpringBoot 核心代码，完整的案例代码请从 <a target="_blank" rel="external nofollow" href="https://github.com/rqh656418510/spring-cloud-share/tree/main/juc/juc-study/juc-lesson-02">GitHub</a> 获取。</p></div><ul><li>线程池的配置参数，写在 <code>application.properties</code> 配置文件中</li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">thread.pool.corePoolSize</span>=<span class="string">16</span></span><br><span class="line"><span class="meta">thread.pool.maxPoolSize</span>=<span class="string">32</span></span><br><span class="line"><span class="meta">thread.pool.queueCapacity</span>=<span class="string">50</span></span><br><span class="line"><span class="meta">thread.pool.keepAliveSeconds</span>=<span class="string">2</span></span><br></pre></td></tr></tbody></table></figure><ul><li>线程池的参数类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = "thread.pool")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolProperties</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大可创建的线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作队列的最大长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池维护线程所允许的空闲时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>线程池的配置类，这里推荐使用 Spring 的 ThreadPoolTaskExecutor，而不是 JUC 的 ThreadPoolExecutor</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolProperties threadPoolProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">threadPoolTaskExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 这里使用 Spring 的 ThreadPoolTaskExecutor，而不是 JUC 的 ThreadPoolExecutor</span></span><br><span class="line">        ThreadPoolTaskExecutor threadPool = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 核心线程数</span></span><br><span class="line">        threadPool.setCorePoolSize(threadPoolProperties.getCorePoolSize());</span><br><span class="line">        <span class="comment">// 最大可创建的线程数</span></span><br><span class="line">        threadPool.setMaxPoolSize(threadPoolProperties.getMaxPoolSize());</span><br><span class="line">        <span class="comment">// 工作队列的最大长度</span></span><br><span class="line">        threadPool.setQueueCapacity(threadPoolProperties.getQueueCapacity());</span><br><span class="line">        <span class="comment">// 线程池维护线程所允许的空闲时间</span></span><br><span class="line">        threadPool.setKeepAliveSeconds(threadPoolProperties.getKeepAliveSeconds());</span><br><span class="line">        <span class="comment">// 异步方法内部线程的名称前缀</span></span><br><span class="line">        threadPool.setThreadNamePrefix(<span class="string">"Spring 自定义线程池 - "</span>);</span><br><span class="line">        <span class="comment">// 线程池对拒绝任务的处理策略</span></span><br><span class="line">        threadPool.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">// 任务都执行完成再关闭线程池</span></span><br><span class="line">        threadPool.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 任务初始化</span></span><br><span class="line">        threadPool.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> threadPool;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>业务接口类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CouponServcie</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchTaskAction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>业务实现类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponServiceImpl</span> <span class="keyword">implements</span> <span class="title">CouponServcie</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下发优惠卷数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer COUPON_NUMBER = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor threadPool;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchTaskAction</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 模拟要下发的优惠卷</span></span><br><span class="line">        List&lt;String&gt; coupons = getCoupons();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行批量发送任务</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TaskBatchSendUtils.send(coupons, threadPool, TaskBatchSendUtils::couponTask);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"任务处理完毕，总耗时: "</span> + (endTime - startTime) + <span class="string">" 毫秒"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟要下发的优惠卷</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getCoupons</span><span class="params">()</span> </span>{</span><br><span class="line">        List&lt;String&gt; coupons = <span class="keyword">new</span> ArrayList&lt;&gt;(COUPON_NUMBER);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= COUPON_NUMBER; i++) {</span><br><span class="line">            coupons.add(<span class="string">"优惠卷-"</span> + i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> coupons;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>批量处理任务的工具类，使用 Consumer 类来保证工具类的通用性</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskBatchSendUtils</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(List&lt;T&gt; taskList, Executor threadPool, Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">if</span> (taskList == <span class="keyword">null</span> || taskList.size() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(consumer)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(taskList.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (T task : taskList) {</span><br><span class="line">            threadPool.execute(() -&gt;</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    consumer.accept(task);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    log.error(e.getMessage());</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emailTask</span><span class="params">(String task)</span> </span>{</span><br><span class="line">        System.out.println(String.format(<span class="string">"【%s】下发邮件成功"</span>, task));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">textMessageTask</span><span class="params">(String task)</span> </span>{</span><br><span class="line">        System.out.println(String.format(<span class="string">"【%s】下发短信成功"</span>, task));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">couponTask</span><span class="params">(String task)</span> </span>{</span><br><span class="line">        System.out.println(String.format(<span class="string">"【%s】下发优惠卷成功"</span>, task));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchTaskTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CouponServcie couponServcie;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCoupons2</span><span class="params">()</span> </span>{</span><br><span class="line">        couponServcie.batchTaskAction();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【优惠卷-1】下发优惠卷成功</span><br><span class="line">【优惠卷-4】下发优惠卷成功</span><br><span class="line">【优惠卷-2】下发优惠卷成功</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">任务处理完毕，总耗时: 10 毫秒</span><br></pre></td></tr></tbody></table></figure><h3 id="异步编排和并行优化的使用"><a href="#异步编排和并行优化的使用" class="headerlink" title="异步编排和并行优化的使用"></a>异步编排和并行优化的使用</h3><div class="admonition note"><p class="admonition-title">企业真实业务场景</p><p>查询某个总接口，比如用户信息接口（<code>ConsumerInfo</code>），该接口又需要调用多个其他远程接口（比如关注、粉丝、订单信息、浏览记录），也就是说该接口聚合了多个其他远程接口的返回结果。如何才能让用户信息接口的请求响应时间最短呢？</p></div><ul><li>异步编排和并行优化的设计思路<ul><li> (1) 在用户信息接口内，串行调用多个其他远程接口，显然这种串行调用接口的方式性能很低，调用用户信息接口的总耗时为所有其他远程接口调用耗时之和。</li><li>(2) 在用户信息接口内，使用 CompletableFuture + 线程池来并发调用多个其他远程接口，这样调用用户信息接口的总耗时为耗时最长的那个远程接口调用。<ul><li>除了可以使用 CompletableFuture + 线程池来实现并发调用多个其他远程接口，还可以使用 Callable + FurtureTask + 线程池来实现，具体可以参考 <a href="../../../asset/2024/08/thread-pool-futuretask.png">这里</a> 的案例代码。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2024/08/thread-pool-completable.png"></p><div class="admonition note"><p class="admonition-title">代码说明</p><p>这里将给出基于 CompletableFuture + 线程池实现并发调用多个远程接口的 SpringBoot 核心代码，完整的案例代码请从 <a target="_blank" rel="external nofollow" href="https://github.com/rqh656418510/spring-cloud-share/tree/main/juc/juc-study/juc-lesson-03">GitHub</a> 获取。</p></div><ul><li>线程池的配置参数，写在 <code>application.properties</code> 配置文件中</li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">thread.pool.corePoolSize</span>=<span class="string">16</span></span><br><span class="line"><span class="meta">thread.pool.maxPoolSize</span>=<span class="string">32</span></span><br><span class="line"><span class="meta">thread.pool.queueCapacity</span>=<span class="string">50</span></span><br><span class="line"><span class="meta">thread.pool.keepAliveSeconds</span>=<span class="string">2</span></span><br></pre></td></tr></tbody></table></figure><ul><li>线程池的参数类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = "thread.pool")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolProperties</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大可创建的线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作队列的最大长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池维护线程所允许的空闲时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>线程池的配置类，这里推荐使用 Spring 的 ThreadPoolTaskExecutor，而不是 JUC 的 ThreadPoolExecutor</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolProperties threadPoolProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">threadPoolTaskExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 这里使用 Spring 的 ThreadPoolTaskExecutor，而不是 JUC 的 ThreadPoolExecutor</span></span><br><span class="line">        ThreadPoolTaskExecutor threadPool = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 核心线程数</span></span><br><span class="line">        threadPool.setCorePoolSize(threadPoolProperties.getCorePoolSize());</span><br><span class="line">        <span class="comment">// 最大可创建的线程数</span></span><br><span class="line">        threadPool.setMaxPoolSize(threadPoolProperties.getMaxPoolSize());</span><br><span class="line">        <span class="comment">// 工作队列的最大长度</span></span><br><span class="line">        threadPool.setQueueCapacity(threadPoolProperties.getQueueCapacity());</span><br><span class="line">        <span class="comment">// 线程池维护线程所允许的空闲时间</span></span><br><span class="line">        threadPool.setKeepAliveSeconds(threadPoolProperties.getKeepAliveSeconds());</span><br><span class="line">        <span class="comment">// 异步方法内部线程的名称前缀</span></span><br><span class="line">        threadPool.setThreadNamePrefix(<span class="string">"Spring 自定义线程池 - "</span>);</span><br><span class="line">        <span class="comment">// 线程池对拒绝任务的处理策略</span></span><br><span class="line">        threadPool.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">// 任务都执行完成再关闭线程池</span></span><br><span class="line">        threadPool.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 任务初始化</span></span><br><span class="line">        threadPool.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> threadPool;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>DTO 类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerMixInfo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Long score;</span><br><span class="line">    <span class="keyword">private</span> String orderInfo;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>业务接口类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function">CustomerMixInfo <span class="title">findCustomer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>业务实现类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span> <span class="keyword">implements</span> <span class="title">CustomerService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor threadPool;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomerMixInfo <span class="title">findCustomer</span><span class="params">()</span> </span>{</span><br><span class="line">        CustomerMixInfo customerMixInfo = <span class="keyword">new</span> CustomerMixInfo();</span><br><span class="line">        customerMixInfo.setId(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步调用用户远程接口</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; customerNameFuture = CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">            customerMixInfo.setName(<span class="keyword">this</span>.getCustomerName());</span><br><span class="line">        }, threadPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步调用积分远程接口</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; scoreFuture = CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">            customerMixInfo.setScore(<span class="keyword">this</span>.getScore());</span><br><span class="line">        }, threadPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步调用订单远程接口</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; orderInfoFuture = CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">            customerMixInfo.setOrderInfo(<span class="keyword">this</span>.getOrderInfo());</span><br><span class="line">        }, threadPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待所有任务完成，allOf() 方法的应用之一是在继续执行程序之前等待完成一组独立的 CompletableFuture</span></span><br><span class="line">        CompletableFuture.allOf(customerNameFuture, scoreFuture, orderInfoFuture).join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"总耗时："</span> + (endTime - startTime) + <span class="string">" 毫秒"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> customerMixInfo;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟调用用户远程接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCustomerName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            log.info(<span class="string">"==&gt; 调用用户远程接口"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"张三"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟调用积分远程接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getScore</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            log.info(<span class="string">"==&gt; 调用积分远程接口"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100L</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟调用订单远程接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderInfo</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            log.info(<span class="string">"==&gt; 调用订单远程接口"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"001 - 华为P70手机"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomerService customerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> </span>{</span><br><span class="line">        CustomerMixInfo customerMixInfo = customerService.findCustomer();</span><br><span class="line">        log.info(JSON.toJSONString(customerMixInfo));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Spring 自定义线程池 - 1] INFO  c.j.j.s.impl.CustomerServiceImpl - ==&gt; 调用用户远程接口</span><br><span class="line">[Spring 自定义线程池 - 3] INFO  c.j.j.s.impl.CustomerServiceImpl - ==&gt; 调用订单远程接口</span><br><span class="line">[Spring 自定义线程池 - 2] INFO  c.j.j.s.impl.CustomerServiceImpl - ==&gt; 调用积分远程接口</span><br><span class="line">总耗时：310 毫秒</span><br><span class="line">[main] INFO  com.java.juc.ThreadPoolTest - {"id":1,"name":"张三","orderInfo":"001 - 华为P70手机","score":100}</span><br></pre></td></tr></tbody></table></figure><h3 id="Async-与线程池的使用"><a href="#Async-与线程池的使用" class="headerlink" title="@Async 与线程池的使用"></a>@Async 与线程池的使用</h3><ul><li><a href="/posts/faebf827.html">Spring 之 @Async 与线程池的使用</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/832c55b5.html" title="Java 之线程池使用详解">https://www.techgrow.cn/posts/832c55b5.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 并发编程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/ec27dc79.html" rel="prev" title="Git 之九 - Docker 搭建 Gitlab 服务器"><i class="fa fa-angle-left"></i> Git 之九 - Docker 搭建 Gitlab 服务器</a></div><div class="post-nav-item"> <a href="/posts/c7372b8f.html" rel="next" title="Jenkins 入门教程之四 Jenkins 与 Git 持续集成实战">Jenkins 入门教程之四 Jenkins 与 Git 持续集成实战<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.4m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">20:37</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤 ICP 备 19024664 号</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035 号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/app/api/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/app/api/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/832c55b5.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>