<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Java 中的 CAS、ABA 问题、自旋锁、可重入锁、递归锁、读锁与写锁、互斥锁、公平锁与非公平锁等内容。"><meta property="og:type" content="article"><meta property="og:title" content="Java 多线程编程之四 CAS、ABA 问题、锁"><meta property="og:url" content="https://www.techgrow.cn/posts/3b82844a.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 Java 中的 CAS、ABA 问题、自旋锁、可重入锁、递归锁、读锁与写锁、互斥锁、公平锁与非公平锁等内容。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/cas-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/cas-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/cas-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/cas-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/cas-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/03/juc-spinlock-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/lock-support-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/lock-support-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/lock-support-1.png"><meta property="article:published_time" content="2022-07-23T14:34:42.000Z"><meta property="article:modified_time" content="2022-07-23T14:34:42.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Java"><meta property="article:tag" content="并发编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2024/03/cas-2.png"><link rel="canonical" href="https://www.techgrow.cn/posts/3b82844a.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/3b82844a.html","path":"posts/3b82844a.html","title":"Java 多线程编程之四 CAS、ABA 问题、锁"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java 多线程编程之四 CAS、ABA 问题、锁 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/app/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS"><span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">CAS 的介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">CAS 的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">CAS 的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ABA-%E9%97%AE%E9%A2%98"><span class="nav-text">ABA 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA-%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0"><span class="nav-text">ABA 问题概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA-%E9%97%AE%E9%A2%98%E4%BA%A7%E7%94%9F"><span class="nav-text">ABA 问题产生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="nav-text">ABA 问题解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81"><span class="nav-text">Java 常用的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-text">自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">自旋锁的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">自旋锁的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">手写一个自旋锁的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E9%80%92%E5%BD%92%E9%94%81%EF%BC%89"><span class="nav-text">可重入锁（递归锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">可重入锁的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-%E7%9A%84%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81"><span class="nav-text">Synchronized 的验证代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock-%E7%9A%84%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81"><span class="nav-text">ReentrantLock 的验证代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">Synchronized 的可重入的实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-text">公平锁和非公平锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">公平锁和非公平锁的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">公平锁和非公平锁的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E9%94%81-%E5%85%B1%E4%BA%AB%E9%94%81-%E3%80%81%E5%86%99%E9%94%81-%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="nav-text">读锁 (共享锁)、写锁 (独占锁)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E9%94%81%E5%92%8C%E5%86%99%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">读锁和写锁的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E9%94%81%E5%92%8C%E5%86%99%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">读锁和写锁的使用案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%90%8C%E6%AD%A5%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="nav-text">Java 同步辅助类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch-%E9%97%AD%E9%94%81"><span class="nav-text">CountDownLatch (闭锁)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">CountDownLatch 的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">CountDownLatch 的使用案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier-%E5%BE%AA%E7%8E%AF%E5%B1%8F%E9%9A%9C"><span class="nav-text">CyclicBarrier (循环屏障)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">CyclicBarrier 的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">CyclicBarrier 的使用案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">Semaphore (信号量)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">Semaphore 的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">Semaphore 的使用案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LockSupport-%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E"><span class="nav-text">LockSupport (线程阻塞)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LockSupport-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">LockSupport 的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LockSupport-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-text">LockSupport 的底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84-3-%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-text">线程等待和唤醒的 3 种方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LockSupport-%E7%9A%84%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">LockSupport 的高频面试题</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">556</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">50</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/3b82844a.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java 多线程编程之四 CAS、ABA 问题、锁 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 Java 中的 CAS、ABA 问题、自旋锁、可重入锁、递归锁、读锁与写锁、互斥锁、公平锁与非公平锁等内容。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Java 多线程编程之四 CAS、ABA 问题、锁</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-07-23 22:34:42" itemprop="dateCreated datePublished" datetime="2022-07-23T22:34:42+08:00">2022-07-23</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/3b82844a.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/3b82844a.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>12k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>11 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/5bbede3c.html">Java 多线程编程之一 Java 内存模型浅析</a></li><li><a href="/posts/f7ed7888.html">Java 多线程编程之二 synchronize 锁对象竞争</a></li><li><a href="/posts/ed2e098d.html">Java 多线程编程之三 volatile 与 JMM 内存模型</a></li><li><a href="/posts/3b82844a.html">Java 多线程编程之四 CAS、ABA 问题、锁</a></li><li><a href="/posts/d9aa9f1f.html">Java 多线程编程之五 AQS 底层源码深度剖析</a></li><li><a href="/posts/1f270e10.html">Java 多线程编程之六集合类的线程安全问题</a></li><li><a href="/posts/f7fd0987.html">Java 多线程编程之七队列、线程池、线程通信</a></li><li><a href="/posts/4a0f41c0.html">Java 多线程编程之八 Fork/Join 框架使用</a></li><li><a href="/posts/d016a303.html">Java 多线程编程之九 ThreadLocal 使用</a></li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="CAS-的介绍"><a href="#CAS-的介绍" class="headerlink" title="CAS 的介绍"></a>CAS 的介绍</h3><p><strong>CAS 的全称是 Compare-And-Swap（比较并交换），它是 CPU 并发原语，用于比较当前内存中的值与预期值是否相等，如果相等则进行更新操作，整个操作是原子性的，可用于解决多线程并发访问共享变量时的数据一致性问题。</strong>CAS 并发原语体现在 Java 语言中就是 <code>sun.misc.Unsafe</code> 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会帮开发者实现出 CAS 汇编指令，这是一种完全依赖于硬件平台的功能，通过它可以实现原子操作。再次强调，由于 CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成的，用于完成某项功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断（打断、加塞）。简而言之，CAS 是一系列 CPU 的原子指令，不会造成所谓的数据不一致问题，也就是说 CAS 是线程安全的。</p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的更新值 B。</li><li>CAS 会比较当前线程工作内存中的值和主内存中的值，如果两者相等，则执行规定操作，否则不执行任何操作。</li></ul></div><span id="more"></span><div class="admonition note"><p class="admonition-title">Java 中的 CAS 实现</p><ul><li>在 Java 中，CAS 是一种无锁的同步方式，常用于实现原子操作和乐观锁，适用于并发竞争不激烈的业务场景，可以提高并发性能。</li><li>在 Java 中，CAS 是使用 <code>java.util.concurrent.atomic</code> 包中提供的原子类实现的，常用的原子类包括 AtomicInteger、AtomicReference 等，而原子类的底层是依靠 Unsafe 类实现原子性。</li></ul></div><h3 id="CAS-的原理"><a href="#CAS-的原理" class="headerlink" title="CAS 的原理"></a>CAS 的原理</h3><blockquote><p>AtomicInteger 类</p></blockquote><p>首先看看 <code>AtomicInteger.getAndIncrement()</code> 方法的源码，可以发现底层调用了一个 Unsafe 类的 <code>getAndAddInt()</code> 方法。</p><p><img data-src="../../../asset/2024/03/cas-2.png"></p><p><img data-src="../../../asset/2024/03/cas-1.png"></p><blockquote><p>Unsafe 类</p></blockquote><p><strong>在 Java 中，CAS 操作的执行都依赖于 Unsafe 类的方法。</strong>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层操作系统，需要通过本地（Native）方法来访问。Unsafe 相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe 类存在 于 <code>sun.misc</code> 包中，其内部方法可以像 C 语言的指针一样直接操作内存。特别注意，Unsafe 类的所有方法都是 <code>native</code> 修饰的，也就是说 Unsafe 类中的方法都直接调用操作系统底层资源执行相应的任务。<strong>Atomic 修饰的包装类（如 AtomicInteger）之所以能够保证原子性，依靠的就是底层的 Unsafe 类。</strong></p><blockquote><p>valueOffset 变量</p></blockquote><p><code>valueOffset</code> 是 AtomicInteger 类中变量 value 的内存地址偏移量，因为 Unsafe 类就是根据内存地址偏移量来获取数据的。从下面的源码能够看到，通过 <code>this</code> 指针和 <code>valueOffset</code> 得知变量 value 的完整内存地址后，就可以获取到变量 value 的值，然后执行加 1 的操作。</p><p><img data-src="../../../asset/2024/03/cas-1.png"></p><blockquote><p>保证多线程之间的内存可见性</p></blockquote><p><img data-src="../../../asset/2024/03/cas-1.png"></p><p><img data-src="../../../asset/2024/03/cas-3.png"></p><p>变量 v 是线程将变量 value 从主内存中拷贝到工作内存中的副本。也就是说，线程每次都要从主内存拿到最新的值，并拷贝一份副本到自己的工作内存，然后再执行 <code>weakCompareAndSetInt()</code> 方法跟主内存的值进行比较。线程不可以越过高速缓存直接操作主内存。在执行加 1 操作之前，需要比较工作内存和主内存中的变量值是否一致，假设执行 <code>weakCompareAndSetInt()</code> 方法返回 false，那么就会一直执行 do while 循环，直到期望的值（工作内存中的值）和当前值（主内存中的值）一致。这里没有用 synchronized，而是用 CAS，这样既可以提高并发性能，又可以够保证数据一致性。因为每个线程进来后，都会进入的 do while 循环，然后不断地获取主内存中的变量值，并判断工作内存中的变量值是否为最新值，然后再将更改后的变量值写回主内存。由于 AtomicInteger 中的 value 变量被 volatile 修饰，当某个线程将更改后的变量值写回主内存后，会立刻通知其他线程，这样其他线程就可以立刻感知到最新的变量值。<strong>值得一提的是，CAS 思想 + Unsafe 类 = 自旋（自我旋转）。</strong></p><ul><li>假设线程 A 和线程 B 同时执行 <code>getAndAddInt()</code> 方法（两者分别跑在不同的 CPU 上）<ul><li>AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据 JMM 模型，线程 A 和线程 B 各自持有一份值为 3 的副本，分别存储在各自的工作内存</li><li>线程 A 通过 <code>getIntVolatile()</code> 方法拿到的 value 值为 3，此时刚好线程 A 被挂起（该线程失去 CPU 执行权）</li><li>线程 B 通过 <code>getIntVolatile()</code> 方法拿到的 value 值也是 3，此时刚好线程 B 没有被挂起，并执行了 <code>weakCompareAndSetInt()</code> 方法，比较值时主内存中的值也是 3，线程 B 成功修改主内存中的值为 4</li><li> 线程 A 恢复运行，执行 <code>weakCompareAndSetInt()</code> 方法进行比较，发现自己工作内存中的值 3 和主内存中的值 4 不一致，说明该值已经被其它线程修改过了，那么线程 A 本次修改失败，只能够重新读取主内存中的值，也就是再执行一次 do while 循环</li><li>线程 A 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总能够立刻感知到最新值，线程 A 继续执行 <code>weakCompareAndSetInt()</code> 方法进行比较和交换，直到成功执行写入操作为止</li></ul></li></ul><blockquote><p>底层汇编代码</p></blockquote><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Unsafe 类中的 <code>weakCompareAndSetInt()</code> 是一个本地（Native）方法，该方法的实现位于 <code>unsafe.cpp</code> 中。</li><li>更多关于 Unsafe 类的介绍，请阅读 <a target="_blank" rel="external nofollow" href="https://segmentfault.com/a/1190000023381653">《Unsafe 介绍及 CAS 原理解析》</a>。</li></ul></div><p>在下述的 C++ 代码中，会调用 <code>Atomic::cmpxchg(x, addr, e)</code> 函数实现比较和交换，其中参数 x 是即将更新的值，参数 e 是原内存的值</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></tbody></table></figure><p>在下述的 Linux x86 实现中，<code>Atomic::cmpxchg()</code> 函数直接内嵌调用了 <code>cmpxchgl</code> 汇编指令</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span><span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint *dest, jint compare_value)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP( % <span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">"=a"</span>(exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">"r"</span>(exchange_value), <span class="string">"a"</span>(compare_value), <span class="string">"r"</span>(dest), <span class="string">"r"</span>(mp)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> exchange_value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="CAS-的优缺点"><a href="#CAS-的优缺点" class="headerlink" title="CAS 的优缺点"></a>CAS 的优缺点</h3><ul><li><p>优点</p><ul><li><code>无锁</code>：CAS 是一种基于硬件原子操作的无锁算法，避免了传统锁机制带来的性能损耗。</li><li><code>高效</code>：由于 CAS 是在硬件层面实现的原子操作，比使用锁的方式执行速度更快。</li><li><code>避免死锁</code>：CAS 操作不会导致线程死锁，因为它不需要获取锁来完成操作，而是基于原子性来完成操作。</li><li><code>可实现乐观并发控制</code>：CAS 实现了乐观锁，当多个线程尝试更新同一内存位置时，只有一个线程能够成功，其他线程可以根据失败重试或者执行其他操作。</li></ul></li><li><p>缺点</p><ul><li><code>自旋重试</code>：CAS 操作在并发量大的情况下，可能会导致自旋重试次数过多，消耗 CPU 资源。</li><li><code>ABA 问题</code>：CAS 操作可能会出现 ABA 问题，即在进行比较时，内存位置值已经被改变两次，导致原子操作无法正确判断值是否被修改。</li><li><code>不能保证多个操作的原子性</code>：CAS 只能保证单个操作的原子性，不能保证多个操作的原子性，这在复杂的业务场景下可能会带来一些问题。</li></ul></li></ul><p>总的来说，CAS 是一种高效的无锁机制，适合在并发度不高、竞争不激烈的业务场景下使用，但需要小心处理 CAS 可能带来的 ABA 问题和自旋重试次数过多的情况。</p><div class="admonition warning"><p class="admonition-title">注意事项</p><ul><li>在多线程环境下，对一个共享变量执行写操作时，可以通过循环 CAS 的方式来保证操作的原子性。对于多个共享变量的写操作，循环 CAS 就无法保证操作的原子性，这个时候只能用锁来保证原子性。</li><li>CAS 有可能需要多次比较，导致循环时间长，CPU 资源开销大。因为执行的是 do while 循环，如果比较不成功会一直在循环。最极端的情况，就是某个线程一直取到的值（预期值）和内存中的值不一样，这样就会无限循环。</li></ul></div><h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><div class="admonition note"><p class="admonition-title">面试连环套路</p><p>面试官往往会通过 AtomicInteger 引出一系列问题，环环相扣，如 CAS -&gt; Unsafe 类 -&gt; CAS 底层实现 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避 ABA 问题。</p></div><h3 id="ABA-问题概述"><a href="#ABA-问题概述" class="headerlink" title="ABA 问题概述"></a>ABA 问题概述</h3><p>假设现在有两个线程，分别是 T1 和 T2，然后 T1 执行某个操作的时间为 10 秒，T2 执行某个时间的操作是 2 秒。刚开始两个线程分别从主内存中获取 A 值，但是因为 T2 线程的执行速度更快，它先把主内存的值改成 B，然后再将主内存的值修改成 A，然后 T2 线程执行完毕。T1 线程在 10 秒后，执行完毕，判断主内存中的值为 A，并且和自己预期的值一样，它就简单认为主内存中的值没有被改动过，就直接将主内存中的值修改成 B；但是实际上主内存中的值在这期间可能经历了 ABCDEFA 一系列变化，也就是在这期间主内存中的值经历了 “狸猫换太子”。<strong>简而言之，ABA 问题就是，在某个线程获取主内存值后，该内存值在更改并写入主内存的时候，已经被其他线程修改了 N 次，只是最终又被改成原来的值，导致该线程误认为主内存的值没有被其他线程更改过。</strong>这种问题可能会影响到一些使用比较操作来判断数据状态的情况，如 CAS 操作。为了解决 ABA 问题，通常需要使用一些方法，比如使用版本号、引入额外的数据等手段来避免数据发生 ABA 问题。</p><blockquote><p>CAS 导致的 ABA 问题</p></blockquote><p>CAS 算法实现的一个重要前提是需要取出内存中某一时刻的数据，并在当下时刻比较并交换，那么在这个时间差内数据可能会发生变化。比如，一个线程 T1 从内存位置 V 中取出 A 值，这时候另外一个线程 T2 也从内存位置 V 中取出 A 值，并且线程 T2 执行了一些操作将内存位置 V 的值改成了 B，然后线程 T2 又将内存位置 V 的值改成 A，这时候线程 T1 进行 CAS 操作时发现内存中的值仍然是 A，然后线程 T1 成功写入。尽管线程 T1 的 CAS 操作执行成功，但是不代表这个过程就是没有问题的。<strong>简而言之，CAS 最大的问题是只管开头和结尾的值，也就是头和尾的值是一样的，那就修改成功，中间的这个过程，可能会被修改过。</strong></p><h3 id="ABA-问题产生"><a href="#ABA-问题产生" class="headerlink" title="ABA 问题产生"></a>ABA 问题产生</h3><p>原子包装类（如 AtomicInteger）或者原子引用类（如 AtomicReference）会产生 ABA 问题，示例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生 ABA 问题的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;Integer&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 暂定两秒t2线程，保证上面的t1线程完成了一次ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">102</span>);</span><br><span class="line">            System.out.println(result + <span class="string">" "</span> + atomicReference.get());</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true 102</span><br></pre></td></tr></tbody></table></figure><h3 id="ABA-问题解决"><a href="#ABA-问题解决" class="headerlink" title="ABA 问题解决"></a>ABA 问题解决</h3><p>可以使用 JDK 中的 AtomicStampedReference 时间戳原子引用类（版本号原子引用类）解决 ABA 问题，示例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决 ABA 问题的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"初始版本号: "</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 暂定一秒t1线程，保证下面的t2线程拿到的初始版本号与t1的初始版本号一致</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"第一次修改后的版本号: "</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"第二次修改后的版本号: "</span> + atomicStampedReference.getStamp());</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"初始版本号: "</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 暂定两秒t2线程，保证上面的t1线程完成了一次ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">102</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"是否修改成功："</span> + result + <span class="string">"，当前实际最新的版本号为： "</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(<span class="string">"当前实际最新值为："</span> + atomicStampedReference.getReference());</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1初始版本号: 1</span><br><span class="line">t2初始版本号: 1</span><br><span class="line">t1第一次修改后的版本号: 2</span><br><span class="line">t1第二次修改后的版本号: 3</span><br><span class="line">t2是否修改成功：false，当前实际最新的版本号为： 3</span><br><span class="line">当前实际最新值为：100</span><br></pre></td></tr></tbody></table></figure><p>观察程序的运行结果可以发现，线程 t1，在进行 ABA 操作后，版本号变更成了 3；而线程 t2 在进行操作的时候，就会出现操作失败，因为版本号和当初拿到的不一样，这就可以避免 ABA 问题的产生。</p><div class="admonition note"><p class="admonition-title">ABA 问题总结</p><p>利用原子引用 + 版本号（类似时间戳）机制可以解决 ABA 问题，比如可以直接使用 JDK 提供的时间戳原子引用类 <code>AtomicStampedReference</code>。</p></div><h2 id="Java-常用的锁"><a href="#Java-常用的锁" class="headerlink" title="Java 常用的锁"></a>Java 常用的锁</h2><p>在 Java 中，常用的锁有以下几种：</p><ul><li><p>自旋锁</p><ul><li>在 Java 中，CAS (Compare-And-Swap) 是一种自旋锁。</li></ul></li><li><p>读锁与写锁</p><ul><li>ReentrantReadWriteLock 是一种读 / 写锁</li></ul></li><li><p>悲观锁与乐观锁</p><ul><li>synchronized 是典型的悲观锁</li><li>基于抽象队列同步器（AQS）实现的锁是乐观锁，如 ReentrantLock 等</li></ul></li><li><p>公平锁与非公平锁</p><ul><li>ReentrantLock 默认是非公平锁</li><li> ReentrantLock 在构造方法中传入 <code>true</code> 可以创建公平锁</li></ul></li><li><p>独占锁和共享锁</p><ul><li>synchronized、ReentrantLock 都是典型的独占锁</li></ul></li><li><p>可重入锁与不可重入锁</p><ul><li>可重入锁也叫 “递归锁”</li><li>synchronized、ReentrantLock 都是典型的可重入锁</li></ul></li><li><p>可中断锁与不可中断锁</p><ul><li>synchronized 是一种不可中断锁</li><li> ReentrantLock 是一种可中断锁</li></ul></li></ul><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="自旋锁的介绍"><a href="#自旋锁的介绍" class="headerlink" title="自旋锁的介绍"></a>自旋锁的介绍</h4><p><strong>自旋锁（SpinLock）是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式不断尝试获取锁。</strong>这样的优点是减少线程上下文切换的消耗，缺点是循环获取锁的操作会消耗 CPU 资源。上面提到的 CAS（比较并交换），底层使用的就是自旋。自旋的本质就是多次尝试，多次访问，不会阻塞的状态就是自旋。在 CAS 中，Unsafe 类使用自旋锁的代码如下图所示：</p><p><img data-src="../../../asset/2021/03/juc-spinlock-1.png" alt="juc-spinlock-1"></p><h4 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h4><p>自旋锁是一种用于多线程编程中实现互斥访问的同步机制。它的优缺点如下：</p><ul><li>优点<ul><li><code>效率相对较高</code>：自旋锁适用于对共享资源的竞争短暂且频繁的情况，相较于其他同步机制（如互斥锁），它的开销更小，因为当获取锁失败时，线程会进入忙等待状态（自旋），不会进入阻塞状态，减少了线程上下文切换的开销。</li><li><code>预期等待时间短</code>：由于自旋锁不会将请求资源的线程挂起，当持有锁的线程释放锁后，其他线程能够更快地获取锁，减少了等待时间。</li></ul></li><li>缺点<ul><li><code>占用 CPU 资源</code>：自旋锁会导致线程在获取锁之前处于忙等状态，消耗 CPU 资源，尤其是在高并发的情况下，如果自旋时间过长，会增加系统的负担，降低 CPU 利用率。</li><li><code>优先级反转</code>：当一个低优先级线程持有锁，而高优先级线程在自旋等待时，可能会导致高优先级线程长时间得不到执行（即优先级反转问题）。</li><li><code>存在死锁风险</code>：自旋锁使用不当可能会导致死锁情况的发生，比如在多个线程之间相互等待对方释放锁。</li></ul></li></ul><h4 id="手写一个自旋锁的实现"><a href="#手写一个自旋锁的实现" class="headerlink" title="手写一个自旋锁的实现"></a>手写一个自旋锁的实现</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子引用线程</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 当前线程</span></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">" come in"</span>);</span><br><span class="line">        <span class="comment">// 自旋锁实现，如果期望值是 null，则更新为当前线程，否者一直自旋</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 当前线程</span></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 释放自旋锁</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">" unlock"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待 5 秒，模拟业务执行</span></span><br><span class="line">            <span class="keyword">try</span> { TimeUnit.SECONDS.sleep(<span class="number">5</span>); } <span class="keyword">catch</span> (InterruptedException e) { }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  让 main 线程暂停 1 秒，保证 t1 线程比 t2 线程先执行</span></span><br><span class="line">        <span class="keyword">try</span> { TimeUnit.SECONDS.sleep(<span class="number">1</span>); } <span class="keyword">catch</span> (InterruptedException e) { }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待 1 秒，模拟业务执行</span></span><br><span class="line">            <span class="keyword">try</span> { TimeUnit.SECONDS.sleep(<span class="number">1</span>); } <span class="keyword">catch</span> (InterruptedException e) { }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 come in</span><br><span class="line">t2 come in</span><br><span class="line">t1 unlock</span><br><span class="line">t2 unlock</span><br></pre></td></tr></tbody></table></figure><h3 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h3><h4 id="可重入锁的介绍"><a href="#可重入锁的介绍" class="headerlink" title="可重入锁的介绍"></a>可重入锁的介绍</h4><p><strong>可重入锁又叫 “递归锁”，指的是同一个线程在外层函数获得锁之后，在内层递归函数仍然能够获取到该锁，也就是同一个线程在外层方法获取到锁的时候，在进入内层方法会自动获取到锁（代码如下）。</strong>简而言之，可重入锁保证了线程可以进入任何一个它已经拥有锁的所有同步代码块。<code>ReentrantLock</code>、<code>Synchronized</code> 都是典型的可重入锁。可重入锁最大的作用是可以避免死锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只要线程进入 method1 方法后，那么它也能直接进入 method2 方法，因为它们所拥有的锁是同一把锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>{</span><br><span class="line">		  method2();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Synchronized-的验证代码"><a href="#Synchronized-的验证代码" class="headerlink" title="Synchronized 的验证代码"></a>Synchronized 的验证代码</h4><p>首先编写了一个资源类 Phone，拥有两个加了 synchronized 的同步方法，分别是 <code>sendSMS()</code> 和 <code>sendEmail()</code>。另外，在 <code>sendSMS()</code> 方法中，调用了 <code>sendEmail()</code> 方法。最后在主线程中，开启了两个线程进行测试。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证 Synchronized 是可重入锁 (递归锁)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" invoked sendSMS()"</span>);</span><br><span class="line">        <span class="comment">// 在同步方法中，调用另外一个同步方法</span></span><br><span class="line">        sendEmail();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" invoked sendEmail()"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程一</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程二</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()</span><br><span class="line">t1 invoked sendEmail()</span><br><span class="line">t2 invoked sendSMS()</span><br><span class="line">t2 invoked sendEmail()</span><br></pre></td></tr></tbody></table></figure><p>从上述运行结果可以发现，当 t1 线程进入 <code>sendSMS()</code> 方法的时候，拥有了一把锁，同时 t2 线程无法进入，直到 t1 线程拿着锁，执行完 <code>sendEmail()</code> 方法后，才释放锁，这样 t2 才能够执行 <code>sendSMS()</code> 方法。</p><h4 id="ReentrantLock-的验证代码"><a href="#ReentrantLock-的验证代码" class="headerlink" title="ReentrantLock 的验证代码"></a>ReentrantLock 的验证代码</h4><p>首先资源类 Phone 实现了 Runnable 接口，重写了 <code>run()</code> 方法，并在里面调用 <code>getLock()</code> 方法。另外，在进入 <code>getLock()</code> 方法的时候就加了锁，而且在方法里面又调用另外一个加了锁的 <code>setLock()</code> 方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证 ReentrantLock 是可重入锁 (递归锁)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock locker = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>{</span><br><span class="line">        locker.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">            setLock();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            locker.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">()</span> </span>{</span><br><span class="line">        locker.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" set Lock"</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            locker.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        getLock();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(phone, <span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(phone, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 get Lock</span><br><span class="line">t1 set Lock</span><br><span class="line">t2 get Lock</span><br><span class="line">t2 set Lock</span><br></pre></td></tr></tbody></table></figure><p>可以发现运行结果跟加 <code>synchronized</code> 修饰的方法是一致的，都是线程在外层的方法获取到锁之后，线程就能够直接执行内层的同步代码。</p><blockquote><p>大厂面试题之一，在上述的 <code>getLock()</code> 方法中，如果加两把锁会是什么情况呢？</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>{</span><br><span class="line">    ReentrantLock.lock();</span><br><span class="line">    ReentrantLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">        setLock();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后得到的结果也是一样的，因为无论 <code>getLock()</code> 方法里面有多少把锁，其实它们都是同一把锁，也就是说用同一把钥匙就能够打开多把锁。</p><blockquote><p>大厂面试题之二，在上述的 <code>getLock()</code> 方法中，如果加了两把锁，但是只解开一把锁，会出现什么情况呢？</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>{</span><br><span class="line">    ReentrantLock.lock();</span><br><span class="line">    ReentrantLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">        setLock();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>会出现死锁现象，也就是 t1 线程执行完成后，没有完全释放锁，导致 t2 线程一直在等待获取锁。<strong>简而言之，申请了几次锁，最后就需要释放几次锁。</strong></p><blockquote><p>大厂面试题之三，在上述的 <code>getLock()</code> 方法中，如果只加一把锁，但是后面解锁两次，又会出现什么情况呢？</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>{</span><br><span class="line">    ReentrantLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">            setLock();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这种情况下，程序运行会直接抛出异常：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t1 get Lock</span><br><span class="line">t1 set Lock</span><br><span class="line">t2 get Lock</span><br><span class="line">t2 set Lock</span><br><span class="line">Exception in thread "t1" Exception in thread "t2" java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.base/java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:149)</span><br><span class="line">	at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1302)</span><br><span class="line">	at java.base/java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:439)</span><br><span class="line">	at com.java.interview.test.Phone.getLock(ReentrantLockTest.java:17)</span><br><span class="line">	at com.java.interview.test.Phone.run(ReentrantLockTest.java:32)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.base/java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:149)</span><br><span class="line">	at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1302)</span><br><span class="line">	at java.base/java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:439)</span><br><span class="line">	at com.java.interview.test.Phone.getLock(ReentrantLockTest.java:17)</span><br><span class="line">	at com.java.interview.test.Phone.run(ReentrantLockTest.java:32)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></tbody></table></figure><h4 id="Synchronized-的可重入的实现原理"><a href="#Synchronized-的可重入的实现原理" class="headerlink" title="Synchronized 的可重入的实现原理"></a>Synchronized 的可重入的实现原理</h4><p>这里将介绍 synchronized 是如何实现可重入锁的，首先阅读下面的 Java 代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSyncDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">            System.out.println(<span class="string">"synchronized code block 1"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                System.out.println(<span class="string">"synchronized code block 2"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        LockSyncDemo syncDemo = <span class="keyword">new</span> LockSyncDemo();</span><br><span class="line">        syncDemo.m1();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>javap -c LockSyncDemo.class</code> 命令，可以看到上述 Java 代码编译后的字节码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void m1();</span><br><span class="line">Code:</span><br><span class="line">    0: aload_0</span><br><span class="line">    1: getfield      #3                  // Field lock:Ljava/lang/Object;</span><br><span class="line">    4: dup</span><br><span class="line">    5: astore_1</span><br><span class="line">    6: monitorenter</span><br><span class="line">    7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    10: ldc           #5                  // String synchronized code block</span><br><span class="line">    12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    15: aload_0</span><br><span class="line">    16: getfield      #3                  // Field lock:Ljava/lang/Object;</span><br><span class="line">    19: dup</span><br><span class="line">    20: astore_2</span><br><span class="line">    21: monitorenter</span><br><span class="line">    22: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    25: ldc           #5                  // String synchronized code block</span><br><span class="line">    27: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    30: aload_2</span><br><span class="line">    31: monitorexit</span><br><span class="line">    32: goto          40</span><br><span class="line">    35: astore_3</span><br><span class="line">    36: aload_2</span><br><span class="line">    37: monitorexit</span><br><span class="line">    38: aload_3</span><br><span class="line">    39: athrow</span><br><span class="line">    40: aload_1</span><br><span class="line">    41: monitorexit</span><br><span class="line">    42: goto          52</span><br><span class="line">    45: astore        4</span><br><span class="line">    47: aload_1</span><br><span class="line">    48: monitorexit</span><br><span class="line">    49: aload         4</span><br><span class="line">    51: athrow</span><br><span class="line">    52: return</span><br></pre></td></tr></tbody></table></figure><p>在上面的字节码中，<code>monitorenter</code> 与 <code>monitorexit</code> 是一一配对出现的，之所以多出两个 <code>monitorexit</code>，是为了保证在每个配对中出现异常的时候，可以彻底释放锁。</p><ul><li><code>synchronized</code> 的可重入的实现原理<ul><li>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</li><li>当执行 <code>monitorenter</code> 时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java 虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加 1。</li><li>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加 1，否则需要等待，直至持有线程释放该锁。</li><li>当执行 <code>monitorexit</code> 时，Java 虚拟机则需将锁对象的计数器减 1，计数器为 0 代表锁已被释放。</li></ul></li></ul><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><h4 id="公平锁和非公平锁的介绍"><a href="#公平锁和非公平锁的介绍" class="headerlink" title="公平锁和非公平锁的介绍"></a>公平锁和非公平锁的介绍</h4><ul><li><code>公平锁</code>：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先到先得。</li><li><code>非公平锁</code>：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。在高并发的情况下，有可能会造成优先级反转，或者饥饿现象（即某个线程一直获取得不到锁）。</li><li>在 JUC 包中，公平锁和非公平锁用的都是 <code>ReentrantLock</code>，而 <code>ReentrantLock</code> 默认是非公平锁。</li></ul><h4 id="公平锁和非公平锁的区别"><a href="#公平锁和非公平锁的区别" class="headerlink" title="公平锁和非公平锁的区别"></a>公平锁和非公平锁的区别</h4><ul><li><code>公平锁</code>：公平锁就是很公平，在并发情况下，每个线程在获取锁时会查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照 FIFO 规则从队列中取到自己。</li><li><code>非公平锁</code>：非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采取类似公平锁那种方式（等待队列）处理。</li><li>在 JUC 包中，<code>ReentrantLock</code> 可以通过构造方法指定该锁是否公平（代码如下），默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<strong>对于 <code>synchronized</code> 而言，也是一种非公平锁。</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);    <span class="comment">// 创建一个可重入锁，true 表示公平锁，false 表示非公平锁，默认是非公平锁</span></span><br></pre></td></tr></tbody></table></figure><h3 id="读锁-共享锁-、写锁-独占锁"><a href="#读锁-共享锁-、写锁-独占锁" class="headerlink" title="读锁 (共享锁)、写锁 (独占锁)"></a>读锁 (共享锁)、写锁 (独占锁)</h3><h4 id="读锁和写锁的介绍"><a href="#读锁和写锁的介绍" class="headerlink" title="读锁和写锁的介绍"></a>读锁和写锁的介绍</h4><ul><li><code>读锁（共享锁）</code>：指该锁可被多个线程所持有，对于 <code>ReentrantReadWriteLock</code> 来讲，其读锁是共享锁，其写锁是独占锁。</li><li><code>写锁（独占锁）</code>：指该锁一次只能被一个线程所持有，对于 <code>ReentrantLock</code> 和 <code>Synchronized</code> 而言都是写锁（独占锁）。</li></ul><div class="admonition note"><p class="admonition-title">为什么会有写锁和读锁？</p><p>原来使用 ReentrantLock 创建锁的时候，那是独占锁，也就是说同一时刻只能有一个线程访问。但是有一个读写分离的场景，读的时候希望同时进行，那么原来写锁（独占锁）的并发性能就没这么好了，因为读锁并不会造成数据不一致的问题，因此多个线程同时读一个资源没有任何问题。所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，那就不应该再有其它线程可以对该资源进行读或写操作。读锁可保证并发读是非常高效的，其中读写、写读、写写的过程是互斥的，而读读是可以共存的。</p></div><h4 id="读锁和写锁的使用案例"><a href="#读锁和写锁的使用案例" class="headerlink" title="读锁和写锁的使用案例"></a>读锁和写锁的使用案例</h4><p>这里模拟实现一个读写缓存（如 MyBatis 的缓存实现），假设刚开始没有加锁的时候，会出现什么情况呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 volatile 修饰，必须保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在写入："</span> + key);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 模拟网络拥堵，延迟 0.2 秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 写入完成"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在读取："</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 模拟网络拥堵，延迟 0.3 秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        Object value = cache.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 读取完成："</span> + value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 5 个线程并发写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                myCache.put(tempInt + <span class="string">""</span>, tempInt + <span class="string">""</span>);</span><br><span class="line">            }, <span class="string">"write-"</span> + i).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 5 个线程并发读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="comment">// lambda 表达式内部必须是 final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                myCache.get(tempInt + <span class="string">""</span>);</span><br><span class="line">            }, <span class="string">"read-"</span> + i).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">write-0 正在写入：0</span><br><span class="line">write-1 正在写入：1</span><br><span class="line">write-3 正在写入：3</span><br><span class="line">write-4 正在写入：4</span><br><span class="line">write-2 正在写入：2</span><br><span class="line">read-2 正在读取：</span><br><span class="line">read-4 正在读取：</span><br><span class="line">read-3 正在读取：</span><br><span class="line">read-0 正在读取：</span><br><span class="line">read-1 正在读取：</span><br><span class="line">write-4 写入完成</span><br><span class="line">read-1 读取完成：null</span><br><span class="line">read-2 读取完成：null</span><br><span class="line">write-2 写入完成</span><br><span class="line">write-0 写入完成</span><br><span class="line">read-3 读取完成：null</span><br><span class="line">write-3 写入完成</span><br><span class="line">write-1 写入完成</span><br><span class="line">read-4 读取完成：4</span><br><span class="line">read-0 读取完成：0</span><br></pre></td></tr></tbody></table></figure><p>从上述运行结果可以发现，在并发写入的时候，写操作都被其它线程打断了，也就是写操作不具备原子性，这就造成了某个线程还没写完，其它线程又开始写，最终导致数据不一致。</p><hr><p>上面的代码是没有加锁的，这样就会造成线程在执行写操作的时候，被其它线程频繁打断，也就是写操作不具备原子性，这个时候就需要用到读写锁来解决原子性问题。这里的读锁和写锁的区别在于，写锁允许同一时刻只有一个线程持有，可以独占式地执行写操作，而读锁允许同一时刻有多个线程同时持有，可以并发式地执行读操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个读写锁，它是一个读写锁融为一体的锁，在使用的时候，需要手动转换</span></span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写锁，当执行写操作的时候，需要转换成写锁</span></span><br><span class="line">rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放写锁</span></span><br><span class="line">rwLock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁，当执行读操作的时候，需要转换成读锁</span></span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放读锁</span></span><br><span class="line">rwLock.readLock().unlock();</span><br></pre></td></tr></tbody></table></figure><p>使用读写锁改造后的完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 验证读写锁，简单模拟 MyBatis 的缓存实现</span></span><br><span class="line"><span class="comment">* 读操作：多个线程可以同时读同一个资源，并不会造成数据不一致的问题</span></span><br><span class="line"><span class="comment">* 写操作：原子 + 独占，整个过程必须是一个完整的统一体，中间不许被分割和被打断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 volatile 修饰，必须保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在写入："</span> + key);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 模拟网络拥堵，延迟 0.2 秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 写入完成"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 释放写锁</span></span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line">        <span class="comment">// 获取读锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在读取："</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 模拟网络拥堵，延迟 0.3 秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            Object result = cache.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 读取完成："</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 释放读锁</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 5 个线程并发写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                myCache.put(tempInt + <span class="string">""</span>, tempInt + <span class="string">""</span>);</span><br><span class="line">            }, <span class="string">"write-"</span> + i).start();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动 5 个线程并发读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="comment">// lambda 表达式内部必须是 final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                myCache.get(tempInt + <span class="string">""</span>);</span><br><span class="line">            }, <span class="string">"read-"</span> + i).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">write-1 正在写入：1</span><br><span class="line">write-1 写入完成</span><br><span class="line">write-4 正在写入：4</span><br><span class="line">write-4 写入完成</span><br><span class="line">write-0 正在写入：0</span><br><span class="line">write-0 写入完成</span><br><span class="line">write-2 正在写入：2</span><br><span class="line">write-2 写入完成</span><br><span class="line">read-0 正在读取：</span><br><span class="line">read-2 正在读取：</span><br><span class="line">read-4 正在读取：</span><br><span class="line">read-0 读取完成：0</span><br><span class="line">read-2 读取完成：2</span><br><span class="line">read-4 读取完成：4</span><br><span class="line">write-3 正在写入：3</span><br><span class="line">write-3 写入完成</span><br><span class="line">read-3 正在读取：</span><br><span class="line">read-1 正在读取：</span><br><span class="line">read-3 读取完成：3</span><br><span class="line">read-1 读取完成：1</span><br></pre></td></tr></tbody></table></figure><p>从上述运行结果可以发现，写入操作是一个一个线程执行的，并且在每个线程执行写操作期间都不会被打断，即不存在原子性问题；而执行读操作的时候，是多个线程并发执行读操作。</p><h2 id="Java-同步辅助类"><a href="#Java-同步辅助类" class="headerlink" title="Java 同步辅助类"></a>Java 同步辅助类</h2><h3 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch (闭锁)"></a>CountDownLatch (闭锁)</h3><p><strong>在 Java 中，CountDownLatch 的作用是允许一个或多个线程等待其他线程完成操作。</strong>它是通过一个计数器来实现，该计数器初始化为一个正整数，每当一个线程完成了自己的任务时，计数器的值就会减 1。当计数器达到零时，所有等待的线程就会被唤醒。CountDownLatch 广泛用于多线程编程中，特别是在一些需要等待其他线程执行完毕再继续执行的场景中，比如实现线程间协作、并行计算等。常见的应用场景包括多线程计算任务划分、线程池任务等待完成、主线程等待子线程完成等。</p><h4 id="CountDownLatch-的介绍"><a href="#CountDownLatch-的介绍" class="headerlink" title="CountDownLatch 的介绍"></a>CountDownLatch 的介绍</h4><p>CountDownLatch（闭锁）是一个同步辅助类，也叫 “倒计时门栓”，在多线程环境中用来协调多个线程之间的执行顺序。它主要有两个常用的方法，分别是 <code>await()</code> 方法和 <code>countDown()</code> 方法。当一个或多个线程调用 <code>await()</code> 方法时，调用线程就会被阻塞。其它线程调用 <code>countDown()</code> 方法时会将计数器减 1，而调用 <code>countDown()</code> 方法的线程则不会被阻塞。当计数器的值变成零时，因调用 <code>await()</code> 方法被阻塞的线程会被唤醒，然后恢复执行。</p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>闭锁可以延迟线程的进度直到其到达终止状态，也就是说可以用来确保某些活动直到其他活动都完成才继续执行，比如以下场景：</li><li>(1) 确保某个计算在其需要的所有资源都被初始化之后才继续执行。</li><li>(2) 确保某个服务在其依赖的所有其他服务都已经启动之后才启动。</li><li>(3) 等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul></div><h4 id="CountDownLatch-的使用案例"><a href="#CountDownLatch-的使用案例" class="headerlink" title="CountDownLatch 的使用案例"></a>CountDownLatch 的使用案例</h4><p>现在有这样一个场景，假设一个自习室里有 7 个人，其中有一个是班长，班长的主要职责就是在其它 6 个同学走了后，关灯并锁上教室门，最后自己离开。因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的呢？这个时候，就比较适合使用 CountDownLatch 来解决类似的问题。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 上完自习，离开教室"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 班长关灯离开教室"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br><span class="line">1 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">main 班长关灯离开教室</span><br></pre></td></tr></tbody></table></figure><h3 id="CyclicBarrier-循环屏障"><a href="#CyclicBarrier-循环屏障" class="headerlink" title="CyclicBarrier (循环屏障)"></a>CyclicBarrier (循环屏障)</h3><p><strong>CyclicBarrier 的字面意思是可循环（Cyclic）使用的屏障（Barrier），简称 “循环屏障”。它是一个同步辅助类，允许一组线程相互等待，直到它们都到达一个共同的屏障点（也叫同步点）。一旦所有线程都到达该屏障点，屏障将打开并且所有线程可以继续执行。</strong>CyclicBarrier 在多线程编程中通常用于线程间协作、并行计算等，例如要求一组线程在达到某个状态后同时执行下一阶段的任务，或者拆分一个大任务为多个子任务并行执行，最后合并执行结果。举一个现实中的例子，公司的员工全都到齐了，才可以开始开会。</p><h4 id="CyclicBarrier-的介绍"><a href="#CyclicBarrier-的介绍" class="headerlink" title="CyclicBarrier 的介绍"></a>CyclicBarrier 的介绍</h4><p><strong>CyclicBarrier 跟 CountDownLatch 刚好相反，也就是 CyclicBarrier 做的是加法，开始值是 0，加到某个值的时候就执行特定的任务。</strong>CyclicBarrier 可以让一组线程到达一个屏障点时被阻塞，直到最后一个线程到达屏障点时，屏障才会开门，所有被屏障拦截的线程才会继续执行。线程到达屏障点是通过调用 CyclicBarrier 的 <code>await()</code> 方法来实现。CyclicBarrier 类有一个核心的构造方法，它接受一个 <code>int</code> 类型的 <code>parties</code> 参数，用于指定在屏障打开之前必须调用 <code>await()</code> 方法的参与者数量。此外，构造方法还可以接受一个可选的 <code>Runnable</code> 参数，该参数定义了当屏障打开时要执行的操作。值得一提的是，<strong>CyclicBarrier 是可重用的，一旦所有等待线程都到达屏障点，屏障将重置并可以再次使用。</strong></p><h4 id="CyclicBarrier-的使用案例"><a href="#CyclicBarrier-的使用案例" class="headerlink" title="CyclicBarrier 的使用案例"></a>CyclicBarrier 的使用案例</h4><p>这里将使用 CyclicBarrier，模拟集齐了 7 个龙珠，才可以召唤神龙，示例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个循环屏障，参数一是需要累加的值，参数二是需要执行的任务</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"开始召唤神龙"</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 7 个线程，进行龙珠收集，当一个线程收集到的时候，需要让它执行 await 方法，等待 7 个线程全部收集完成后，才执行原先定义好任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                System.out.println(<span class="string">"收集到第 "</span> + index + <span class="string">" 颗龙珠"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 先到的被阻塞，等待全部线程执行完成</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">收集到第 1 颗龙珠</span><br><span class="line">收集到第 3 颗龙珠</span><br><span class="line">收集到第 2 颗龙珠</span><br><span class="line">收集到第 7 颗龙珠</span><br><span class="line">收集到第 5 颗龙珠</span><br><span class="line">收集到第 6 颗龙珠</span><br><span class="line">收集到第 4 颗龙珠</span><br><span class="line">开始召唤神龙</span><br></pre></td></tr></tbody></table></figure><h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore (信号量)"></a>Semaphore (信号量)</h3><p>Semaphore (信号量) 是一种常用的同步工具，用于控制对共享资源的并发访问。<strong>在多线程编程中，Semaphore 可以用来限制并发访问某个共享资源的线程数量</strong>，避免资源竞争和提高系统性能，比如用于电商秒杀、停车场停车等业务场景。</p><h4 id="Semaphore-的介绍"><a href="#Semaphore-的介绍" class="headerlink" title="Semaphore 的介绍"></a>Semaphore 的介绍</h4><p><strong>Semaphore 内部维护了一个计数器，该计数器会随着线程的获取许可证和释放许可证而增减。</strong>它提供了两个核心方法，<code>acquire()</code> 和 <code>release()</code>，其中 <code>acquire()</code> 方法会尝试获取许可，如果当前许可计数器大于 0，则直接减 1，否则阻塞当前线程；而 <code>release()</code> 方法会释放许可证，也就是将许可计数器直接加 1，并依次唤醒等待队列中的第一个线程，直到没有可用的许可。Semaphore 可以指定初始许可证数量，这决定了同时允许多少个线程并发访问共享资源。当许可证数量为 1 时，Semaphore 可以用作互斥锁（Mutex）；当许可证数量大于 1 时，Semaphore 可以用作限流器（RateLimiter）。Semaphore 的常见应用场景如下：</p><ul><li><code>资源池管理</code>：Semaphore 可以限制对有限资源的并发访问，例如数据库连接池或线程池中的资源管理。</li><li><code>控制并发线程数</code>：Semaphore 可以控制同时执行的线程数量，例如限制同时访问某个接口的请求数量。</li><li><code>控制任务流量</code>：Semaphore 可以限制任务的执行速率，例如限制某个任务在单位时间内的执行次数。</li><li><code>实现互斥锁</code>：Semaphore 可以用于实现互斥锁的功能，通过设置 <code>permits</code> 为 1，保证同一时间只有一个线程可以访问共享资源。</li></ul><h4 id="Semaphore-的使用案例"><a href="#Semaphore-的使用案例" class="headerlink" title="Semaphore 的使用案例"></a>Semaphore 的使用案例</h4><p>这里将使用 Semaphore，模拟 7 辆车抢占 3 个停车位，示例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化一个信号量，参数一是 3（模拟 3 个停车位），参数二是 false（即非公平锁）</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 7 个线程，模拟 7 台车抢占车位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 抢占停车位，代表有一辆车已经抢占到了车位</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 抢到车位"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每辆车停车 3 秒</span></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);    </span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 停车 3 秒后离开车位"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 释放停车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                }</span><br><span class="line">            }, <span class="string">"t-"</span> + i).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t-2 抢到车位</span><br><span class="line">t-3 抢到车位</span><br><span class="line">t-1 抢到车位</span><br><span class="line">t-1 停车 3 秒后离开车位</span><br><span class="line">t-2 停车 3 秒后离开车位</span><br><span class="line">t-3 停车 3 秒后离开车位</span><br><span class="line">t-6 抢到车位</span><br><span class="line">t-4 抢到车位</span><br><span class="line">t-7 抢到车位</span><br><span class="line">t-6 停车 3 秒后离开车位</span><br><span class="line">t-7 停车 3 秒后离开车位</span><br><span class="line">t-5 抢到车位</span><br><span class="line">t-4 停车 3 秒后离开车位</span><br><span class="line">t-5 停车 3 秒后离开车位</span><br></pre></td></tr></tbody></table></figure><h3 id="LockSupport-线程阻塞"><a href="#LockSupport-线程阻塞" class="headerlink" title="LockSupport (线程阻塞)"></a>LockSupport (线程阻塞)</h3><h4 id="LockSupport-的介绍"><a href="#LockSupport-的介绍" class="headerlink" title="LockSupport 的介绍"></a>LockSupport 的介绍</h4><p><strong>LockSupport 是用来创建锁和其他同步类的基本线程阻塞原语</strong>。LockSupport 的 <code>park()</code> 与 <code>unpark()</code> 的作用分别是阻塞线程和解除阻塞线程。<strong>简而言之，LockSupport 是线程等待唤醒机制（wait /notify）的改良加强版。</strong>LockSupport 使用了一种名为许可（<code>permit</code>）的概念来实现阻塞和唤醒线程的功能，每个线程都有一个许可，而且 <code>permit</code> 只有 0 和 1 这两个值，默认值是 0。这里可以将许可看成是一种信号量（Semaphore），不同的是，许可的累加上限是 1。</p><h4 id="LockSupport-的底层实现"><a href="#LockSupport-的底层实现" class="headerlink" title="LockSupport 的底层实现"></a>LockSupport 的底层实现</h4><p>LockSupport 是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意地方阻塞，阻塞之后也有对应的唤醒方法。LockSupport 底层是基于 Unsafe 类中的 Native 代码实现的，如下图所示。LockSupport 和每个使用它的线程都有一个许可（<code>permit</code>）关联，而且最多只有一个 <code>permit</code>。因为 <code>permit</code> 的默认值是 0，所以一开始调用 <code>park()</code> 方法时，当前线程就会被阻塞，直到其他线程调用 <code>unpark()</code> 方法，将当前线程的 <code>permit</code> 设置为 1 时，<code>park()</code> 方法会被唤醒（即当前线程被唤醒），然后将 <code>permit</code> 再次设置为 0 并返回。值得一提的是，重复调用 <code>unpark()</code> 方法并不会累加 <code>permit</code> 多次，更详细的介绍请<a href="../../../asset/2024/03/lock-support-4.png">点击</a> 这里。</p><p><img data-src="../../../asset/2024/03/lock-support-2.png"></p><p><img data-src="../../../asset/2024/03/lock-support-3.png"></p><blockquote><p>形象地理解</p></blockquote><p>在使用 LockSupport 的时候，线程阻塞需要消耗许可（<code>permit</code>），这个 <code>permit</code> 最多只有 1 个。</p><ul><li><p>当调用 <code>park()</code> 方法时</p><ul><li>如果有许可，则会直接消耗掉这个许可，然后正常执行并返回；</li><li>如果无许可，就必须阻塞等待，直到有许可为止，然后正常执行并返回；</li></ul></li><li><p>当调用 <code>unpark()</code> 方法时</p><ul><li>会添加一个许可，而且许可最多只能有 1 个，即累加无效；</li></ul></li></ul><h4 id="线程等待和唤醒的-3-种方法"><a href="#线程等待和唤醒的-3-种方法" class="headerlink" title="线程等待和唤醒的 3 种方法"></a>线程等待和唤醒的 3 种方法</h4><p><img data-src="../../../asset/2024/03/lock-support-1.png"></p><ul><li>方法一：使用 Object 类中的 <code>wait()</code> 和 <code>notify()</code> 方法实现线程等待和唤醒</li><li>方法二：使用 JUC 包中的 Condition 接口中的 <code>await()</code> 和 <code>signal()</code> 方法实现线程等待和唤醒</li><li>方法三：使用 LockSupport 类中的 <code>park()</code> 和 <code>unpark()</code> 实现线程等待和唤醒</li></ul><blockquote><p>使用方法一实现线程等待和唤醒</p></blockquote><ul><li>使用限制说明<ul><li>基于 <code>synchronized</code> + <code>wait()</code> + <code>notify()</code> 实现。</li><li>如果 <code>notify()</code> 在 <code>wait()</code> 前面先执行，那么等待被唤醒的线程会阻塞执行（一直等待），导致无法唤醒。</li><li><code>wait()</code> 和 <code>notify()</code> 必须在同步方法或者同步代码块中执行，即必须使用 <code>synchronized</code> 关键字，否则会抛出 <code>IllegalMonitorStateException</code> 异常。</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAwaitNotifyDemo1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" come in"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock.wait();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 被唤醒"</span>);</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 1 秒，保证 t1 线程比 t2 线程先执行</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 开始通知"</span>);</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 come in</span><br><span class="line">t2 开始通知</span><br><span class="line">t1 被唤醒</span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用方法二实现线程等待和唤醒</p></blockquote><ul><li><p>使用限制说明</p><ul><li>基于 <code>Lock</code> + <code>Condition</code> + <code>await()</code> + <code>signal()</code> 实现。</li><li>如果 <code>signal()</code> 在 <code>await()</code> 前面先执行，那么等待被唤醒的线程会阻塞执行（一直等待），导致无法唤醒。</li><li><code>await()</code> 和 <code>signal()</code> 必须在锁代码块（Lock）中执行，否则会抛出 <code>IllegalMonitorStateException</code> 异常。</li></ul></li><li><p>Condition 接口介绍</p><ul><li>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 <code>Object.wait()</code> 访问的隐式监视器类似，但提供了更强大的功能。</li><li>特别注意，单个 Lock 可以和多个 Condition 实例关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</li><li>在 Condition 实例中，await、signal、signalAll 方法对应的分别是 Object 中的 wait、notify、notifyAll 方法。</li><li>Condition 实例实质上被绑定到一个锁上。要从特定的 Lock 实例获得 Condition 实例，可以使用其 <code>newCondition()</code> 方法。</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAwaitNotifyDemo2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock locker = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition condition = locker.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            locker.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" come in"</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 被唤醒"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                locker.unlock();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 1 秒，保证 t1 线程比 t2 线程先执行</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            locker.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 开始通知"</span>);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                locker.unlock();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 come in</span><br><span class="line">t2 开始通知</span><br><span class="line">t1 被唤醒</span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用方法三实现线程等待和唤醒</p></blockquote><ul><li>使用限制说明<ul><li>基于 <code>LockSupport</code> + <code>unpark()</code> + <code>park()</code> 实现。</li><li><code>unpark()</code> 可以在 <code>park()</code> 前面先执行。</li><li><code>unpark()</code> 和 <code>park()</code> 不要求在锁代码块（Lock）中执行。</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAwaitNotifyDemo3</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" come in"</span>);</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 被唤醒"</span>);</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"t1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 1 秒，保证 t1 线程比 t2 线程先执行</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="comment">// 唤醒指定的线程</span></span><br><span class="line">            LockSupport.unpark(thread1);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 开始通知"</span>);</span><br><span class="line">        }, <span class="string">"t2"</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 come in</span><br><span class="line">t2 开始通知</span><br><span class="line">t1 被唤醒</span><br></pre></td></tr></tbody></table></figure><h4 id="LockSupport-的高频面试题"><a href="#LockSupport-的高频面试题" class="headerlink" title="LockSupport 的高频面试题"></a>LockSupport 的高频面试题</h4><blockquote><p>为什么可以先唤醒线程后阻塞线程？</p></blockquote><p>因为调用 <code>unpark()</code> 方法可以获得一个许可，之后再调用 <code>park()</code> 方法时，就可以名正言顺地凭许可进行消费，所以不会阻塞线程。</p><blockquote><p>为什么唤醒两次后阻塞两次，但最终结果还是会阻塞线程？</p></blockquote><p>因为许可（<code>permit</code>）的数量最多为 1，连续调用两次 <code>unpark()</code> 和调用一次 <code>unpark()</code> 的效果是一样的，都只会增加一个许可。而调用两次 <code>park()</code> 却需要消费两个许可，由于许可的数量不够用，因此还是会阻塞线程。</p><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/3b82844a.html" title="Java 多线程编程之四 CAS、ABA 问题、锁">https://www.techgrow.cn/posts/3b82844a.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 并发编程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/8b87f2be.html" rel="prev" title="C++ 进阶基础之八"><i class="fa fa-angle-left"></i> C++ 进阶基础之八</a></div><div class="post-nav-item"> <a href="/posts/360c74ef.html" rel="next" title="C++ 进阶基础之九">C++ 进阶基础之九<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.3m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">19:08</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤 ICP 备 19024664 号</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035 号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/app/api/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/app/api/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/3b82844a.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>