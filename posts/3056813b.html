<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Java 虚拟机的 JVM 参数调优。"><meta property="og:type" content="article"><meta property="og:title" content="Java 虚拟机入门教程之三 JVM 参数调优"><meta property="og:url" content="https://www.techgrow.cn/posts/3056813b.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 Java 虚拟机的 JVM 参数调优。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-minor-gc.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-oom-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-oom-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-oom-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-oom-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-error-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/jvm-gc-oom-5.png"><meta property="article:published_time" content="2019-05-19T12:13:43.000Z"><meta property="article:modified_time" content="2023-04-02T12:13:43.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM 虚拟机"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2024/03/jvm-minor-gc.png"><link rel="canonical" href="https://www.techgrow.cn/posts/3056813b.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/3056813b.html","path":"posts/3056813b.html","title":"Java 虚拟机入门教程之三 JVM 参数调优"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java 虚拟机入门教程之三 JVM 参数调优 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">JVM 的参数类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E9%85%8D%E6%8C%87%E4%BB%A4"><span class="nav-text">标配指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%A0%87%E5%87%86%E6%8C%87%E4%BB%A4"><span class="nav-text">非标准指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E7%A8%B3%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="nav-text">不稳定参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-JVM-%E5%8F%82%E6%95%B0"><span class="nav-text">查看 JVM 参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89-JVM-%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">查看所有 JVM 参数的默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89-JVM-%E5%8F%82%E6%95%B0%E7%9A%84%E6%9C%80%E7%BB%88%E5%80%BC"><span class="nav-text">查看所有 JVM 参数的最终值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-JVM-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0"><span class="nav-text">查看 JVM 的默认初始化参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="nav-text">JVM 常用的调优参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E9%AB%98%E7%BA%A7%E7%9A%84%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="nav-text">JVM 高级的调优参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="nav-text">堆内存知识回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%92%E5%88%86"><span class="nav-text">堆内存结构的划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">Minor GC 的执行过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XX-NewRatio"><span class="nav-text">-XX:NewRatio</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XX-SurvivorRatio"><span class="nav-text">-XX:SurvivorRatio</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XX-MaxTenuringThreshold"><span class="nav-text">-XX:MaxTenuringThreshold</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="nav-text">其他不常用的高级调优参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">JVM 参数调优的最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-Java-%E8%BF%9B%E7%A8%8B%E7%9A%84-JVM-%E5%8F%82%E6%95%B0"><span class="nav-text">如何查看 Java 进程的 JVM 参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E-Java-%E8%BF%9B%E7%A8%8B%E6%9C%AA%E8%BF%90%E8%A1%8C"><span class="nav-text">方法一，适用于 Java 进程未运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E-Java-%E8%BF%9B%E7%A8%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C"><span class="nav-text">方法二，适用于 Java 进程正在运行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F-JVM-%E5%8F%91%E7%94%9F-OOM-%E7%8E%B0%E8%B1%A1"><span class="nav-text">模拟 JVM 发生 OOM 现象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF"><span class="nav-text">Java 内存溢出错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-%E7%BB%8F%E5%85%B8%E9%94%99%E8%AF%AF%E5%88%86%E7%B1%BB"><span class="nav-text">JVM 经典错误分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StackoverFlowError"><span class="nav-text">StackoverFlowError</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%A6%82%E8%BF%B0"><span class="nav-text">错误概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E9%87%8D%E7%8E%B0"><span class="nav-text">错误重现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OutOfMemoryError"><span class="nav-text">OutOfMemoryError</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-heap-space"><span class="nav-text">Java heap space</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%A6%82%E8%BF%B0-1"><span class="nav-text">错误概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E9%87%8D%E7%8E%B0-1"><span class="nav-text">错误重现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC-overhead-limit-exceeded"><span class="nav-text">GC overhead limit exceeded</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%A6%82%E8%BF%B0-2"><span class="nav-text">错误概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E9%87%8D%E7%8E%B0-2"><span class="nav-text">错误重现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Direct-buffer-memory"><span class="nav-text">Direct buffer memory</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%A6%82%E8%BF%B0-3"><span class="nav-text">错误概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E9%87%8D%E7%8E%B0-3"><span class="nav-text">错误重现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unable-to-create-new-native-thread"><span class="nav-text">Unable to create new native thread</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%A6%82%E8%BF%B0-4"><span class="nav-text">错误概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E9%87%8D%E7%8E%B0-4"><span class="nav-text">错误重现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Metaspace"><span class="nav-text">Metaspace</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Metaspace-%E9%94%99%E8%AF%AF%E6%A6%82%E8%BF%B0"><span class="nav-text">Metaspace 错误概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Metaspace-%E9%94%99%E8%AF%AF%E9%87%8D%E7%8E%B0"><span class="nav-text">Metaspace 错误重现</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">725</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/3056813b.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java 虚拟机入门教程之三 JVM 参数调优 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 Java 虚拟机的 JVM 参数调优。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Java 虚拟机入门教程之三 JVM 参数调优</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-05-19 20:13:43" itemprop="dateCreated datePublished" datetime="2019-05-19T20:13:43+08:00">2019-05-19</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-04-02 20:13:43" itemprop="dateModified" datetime="2023-04-02T20:13:43+08:00">2023-04-02</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/3056813b.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/3056813b.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>8.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>8 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/f9740ba6.html">Java 虚拟机入门教程之一 JVM 内存结构</a></li><li><a href="/posts/ddd77972.html">Java 虚拟机入门教程之二 JVM 垃圾收集</a></li><li><a href="/posts/3056813b.html">Java 虚拟机入门教程之三 JVM 参数调优</a></li><li><a href="/posts/f524f467.html">Java 虚拟机入门教程之四 JVM 四种引用</a></li><li><a href="/posts/62936140.html">Java 虚拟机入门教程之五 JVM 性能优化</a></li><li><a href="/posts/d5b19bd1.html">Java 虚拟机入门教程之六 JVM 类加载机制</a></li></ul><h2 id="JVM-的参数类型"><a href="#JVM-的参数类型" class="headerlink" title="JVM 的参数类型"></a>JVM 的参数类型</h2><h3 id="标配指令"><a href="#标配指令" class="headerlink" title="标配指令"></a>标配指令</h3><p>标配指令都以 <code>-</code> 开头，这些参数是不同版本的 HotSpot 虚拟机都支持的。</p><table><thead><tr><th>参数</th><th>参数说明</th><th>使用例子</th></tr></thead><tbody><tr><td> -version</td><td> 查看版本号</td><td> java -version</td></tr><tr><td>-help</td><td> 查看命令帮助手册</td><td> java -help</td></tr><tr><td>-showversion</td><td> 查看版本信息</td><td> java -showversion</td></tr></tbody></table><span id="more"></span><h3 id="非标准指令"><a href="#非标准指令" class="headerlink" title="非标准指令"></a>非标准指令</h3><p>非标准指令都以 <code>-X</code> 开头，这些参数通常跟特定版本的 HotSpot 虚拟机对应，但差别不是特别大。</p><table><thead><tr><th>参数</th><th>参数说明</th><th>使用例子</th></tr></thead><tbody><tr><td> -Xint</td><td> 解释执行</td><td> java -Xint -version</td></tr><tr><td>-Xcomp</td><td> 第一次使用就编译成本地代码</td><td> java -Xcomp -version</td></tr><tr><td>-Xmixed</td><td> 混合模式</td><td> java -Xmixed -version</td></tr></tbody></table><h3 id="不稳定参数"><a href="#不稳定参数" class="headerlink" title="不稳定参数"></a>不稳定参数</h3><p>不稳定参数都以 <code>-XX:</code> 开头，这些参数通常跟特定版本的 HotSpot 虚拟机对应。特别注意，在不同版本的 HotSpot 虚拟机中，这一类参数的区别（变化）非常大，详细的文档资料也相对较少。</p><ul><li><p>Boolean 类型参数</p><ul><li>参数格式：-XX:<code>+</code> 或者 <code>-</code> 某个属性，<code>+</code> 表示开启，<code>-</code> 表示关闭</li><li>使用例子：<code>-XX:-PrintGCDetails</code>，关闭 GC 详情输出的功能</li></ul></li><li><p> Key-Value 类型参数</p><ul><li>参数格式：-XX:Key=Value</li><li> 使用例子：<code>-XX:MetaspaceSize=256m</code>，设置元空间的大小</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>-Xss</code>、<code>-Xms</code> 与 <code>-Xmx</code> 还是属于 XX 参数，只是都取了别名而已。</li><li><code>-Xss</code> 等价于 <code>-XX:ThreadStackSize</code>，用于设置单个线程的栈空间大小，一般默认为 512k ~ 1024k。</li><li><code>-Xms</code> 等价于 <code>-XX:InitialHeapSize</code>，用于设置初始堆空间的大小，默认只会使用到最大物理内存的 1/64。</li><li><code>-Xmx</code> 等价于 <code>-XX:MaxHeapSize</code>，用于设置堆空间的最大值，默认只会使用到最大物理内存的 1/4。</li></ul></div><h2 id="查看-JVM-参数"><a href="#查看-JVM-参数" class="headerlink" title="查看 JVM 参数"></a>查看 JVM 参数</h2><h3 id="查看所有-JVM-参数的默认值"><a href="#查看所有-JVM-参数的默认值" class="headerlink" title="查看所有 JVM 参数的默认值"></a>查看所有 JVM 参数的默认值</h3><table><thead><tr><th>参数</th><th>参数说明</th><th>使用例子</th></tr></thead><tbody><tr><td> -XX:+PrintFlagsInitial</td><td> 打印所有 JVM 参数的默认值</td><td> (1) java -XX:+PrintFlagsInitial -version<br> (2) java -XX:+PrintFlagsInitial Test，其中 Test 是类名</td></tr></tbody></table><p>执行 <code>java -XX:+PrintFlagsInitial -version</code> 命令后，输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">      int ActiveProcessorCount                     = -1                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor         = 4                                         {product} {default}</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale        = 10                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin   = 50                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps      = 20                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval         = 0                                         {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                 = 10                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizeThroughPutPolicy             = 0                                         {product} {default}</span><br><span class="line">    uintx AdaptiveTimeWeight                       = 25                                        {product} {default}</span><br><span class="line">     bool AggressiveHeap                           = false                                     {product} {default}</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure><h3 id="查看所有-JVM-参数的最终值"><a href="#查看所有-JVM-参数的最终值" class="headerlink" title="查看所有 JVM 参数的最终值"></a>查看所有 JVM 参数的最终值</h3><table><thead><tr><th>参数</th><th>参数说明</th><th>使用例子</th></tr></thead><tbody><tr><td> -XX:+PrintFlagsFinal</td><td> 打印所有 JVM 参数修改后的最终值</td><td> (1) java -XX:+PrintFlagsFinal -version<br> (2) java -XX:+PrintFlagsFinal -XX:MaxHeapSize=128m Test，其中 Test 是类名</td></tr></tbody></table><p>执行 <code>java -XX:+PrintFlagsFinal -version</code> 命令后，输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">      int ActiveProcessorCount                     = -1                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor         = 4                                         {product} {default}</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale        = 10                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin   = 50                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps      = 20                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval         = 0                                         {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                 = 10                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizeThroughPutPolicy             = 0                                         {product} {default}</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure><p>如果输出结果中有 <code>:=</code> 或者 <code>{command line}</code>，则表示该 JVM 参数的值被修改过了，而 <code>=</code> 或者 <code>{default}</code> 则表示该 JVM 参数的值没有被修改过（即使用的是默认值）。</p><h3 id="查看-JVM-的默认初始化参数"><a href="#查看-JVM-的默认初始化参数" class="headerlink" title="查看 JVM 的默认初始化参数"></a>查看 JVM 的默认初始化参数</h3><table><thead><tr><th>参数</th><th>参数说明</th><th>使用例子</th></tr></thead><tbody><tr><td> -XX:+PrintCommandLineFlags</td><td> 打印 JVM 默认的简单初始化参数</td><td> java -XX:+PrintCommandLineFlags -version</td></tr></tbody></table><p>执行 <code>java -XX:+PrintCommandLineFlags -version</code> 命令后，输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:G1ConcRefinementThreads=48 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=522493504 -XX:MaxHeapSize=8359896064 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC </span><br><span class="line">java version "11.0.9" 2020-10-20 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.9+7-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.9+7-LTS, mixed mode)</span><br></pre></td></tr></tbody></table></figure><h2 id="JVM-常用的调优参数"><a href="#JVM-常用的调优参数" class="headerlink" title="JVM 常用的调优参数"></a>JVM 常用的调优参数</h2><table><thead><tr><th>参数</th><th>参数说明</th><th>默认值</th></tr></thead><tbody><tr><td> -Xms</td><td> 初始堆空间的大小</td><td>默认为物理内存的 1/64，等价于 -XX:initialHeapSize</td></tr><tr><td>-Xmx</td><td> 堆空间大小的最大值</td><td>默认为物理内存的 1/4，等价于 - XX:MaxHeapSize</td></tr><tr><td>-Xss</td><td> 单个线程的栈空间大小</td><td>默认为 512k ~ 1024k，等价于 -XX:ThreadStackSize</td></tr><tr><td>-Xmn</td><td> 新生代的大小</td><td>新生代默认占堆空间的 1/3，而老年代默认占堆空间的 2/3</td></tr><tr><td>-XX:MetaspaceSize</td><td> 元空间的大小</td><td>默认的元空间大小只有 20 兆 (M)</td></tr><tr><td>-XX:+PrintGCDetails</td><td> 输出详细 GC 收集日志信息</td><td></td></tr></tbody></table><blockquote><p>JVM 参数调优案例： -Xms1024m -Xmx1024m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal -XX:+PrintGCDetails</p></blockquote><div class="admonition note"><p class="admonition-title">提示</p><ul><li>最好将 <code>-Xms</code> 和 <code>-Xmx</code> 调整成一致，防止 JVM 频繁执行垃圾收集（GC）。</li><li>使用 <code>jinfo -flag ThreadStackSize PID</code> 查看 JVM 参数时，会发现 <code>-XX:ThreadStackSize = 0</code>，这是因为该值的大小取决于平台，Linux (64-bit)、OS X (64-bit)、Oracle Solaris (64-bit) 平台上的值为 1024KB，而 Windows 取决于虚拟内存的大小。</li><li>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现，不过元空间与永久代之间最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。因此，默认情况下元空间的大小仅受本地内存（物理内存）限制。由于默认的元空间大小只有 20 多兆 (M)，为了防止在频繁地实例化对象时，导致元空间出现 OOM 现象，因此可以将元空间的大小设置大一些。</li></ul></div><h2 id="JVM-高级的调优参数"><a href="#JVM-高级的调优参数" class="headerlink" title="JVM 高级的调优参数"></a>JVM 高级的调优参数</h2><h3 id="堆内存知识回顾"><a href="#堆内存知识回顾" class="headerlink" title="堆内存知识回顾"></a>堆内存知识回顾</h3><h4 id="堆内存结构的划分"><a href="#堆内存结构的划分" class="headerlink" title="堆内存结构的划分"></a>堆内存结构的划分</h4><p>JVM 的堆内存从 GC 的角度可以细分为：新生代（包括 Eden 区、SurvivorFrom 区和 SurvivorTo 区）和老年代，如下图所示：</p><p><img data-src="../../../asset/2024/03/jvm-minor-gc.png"></p><h4 id="Minor-GC-的执行过程"><a href="#Minor-GC-的执行过程" class="headerlink" title="Minor GC 的执行过程"></a>Minor GC 的执行过程</h4><p>Java 中 GC 分为两种：Minor GC（发生在新生代），Full GC（发生在新生代 + 老年代 + 元空间），其中 Minor GC 的执行过程如下：</p><blockquote><p>第一步：Eden、From Survivor 复制到 To Survivor，且将对象的年龄加一</p></blockquote><p>首先，当 Eden 区满的时候会触发第一次 GC ，将还活着的对象拷贝到 From Survivor 区。当 Eden 区再次触发 GC 的时候，会扫描 Eden 区和 From Survivor 区，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接拷贝到 To Survivor 区域（如果有对象的年龄已经达到了老年的标准，则拷贝到老年代区），同时将这些对象的年龄加一。</p><blockquote><p>第二步：清空 Eden、From Survivor</p></blockquote><p>然后，清空 Eden 和 From Survivor 中的对象，而且在拷贝操作执行完成之后 From Survivor 区和 To Survivor 区会交换角色，谁空谁就是 To Survivor 区。</p><blockquote><p>第三步：From Survivor 和 To Survivor 交换</p></blockquote><p>最后，From Survivor 区和 To Survivor 区交换角色，原 To Survivor 成为下一次 GC 时的 From Survivor 区。部分对象会在 From Survivor 区和 To Survivor 区中复制来复制去，如此交换 15 次（由 JVM 参数 <code>-XX:MaxTenuringThreshold</code> 决定，这个参数值默认是 15）后，最终如果还是存活，就晋升到老年代区中。</p><h3 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h3><table><thead><tr><th>参数</th><th>参数说明</th><th>默认值</th></tr></thead><tbody><tr><td> -XX:NewRatio</td><td> 配置新生代和老年代在堆内存中的占比</td><td>默认为 -XX:NewRatio=2，即新生代占 1，老年代 占 2，即新生代占整个堆内存的 1/3</td></tr></tbody></table><p>比如设置成 <code>-XX:NewRatio=4</code>，则表示新生代占 1，老年代占 4，即新生代占整个堆内存的 1/5。也就是说，NewRadio 值就是设置老年代的占比，剩下的 1 是新生代的占比。值得一提的是，如果新生代的内存空间特别小，会造成 JVM 频繁地进行 GC 操作。</p><h3 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h3><table><thead><tr><th>参数</th><th>参数说明</th><th>默认值</th></tr></thead><tbody><tr><td> -XX:SurvivorRatio</td><td> 配置新生代中 Eden 和 SurvivorFrom、SurvivorTo 的内存空间比例</td><td>默认为 -XX:SuriviorRatio=8，即 Eden:SurvivorFrom:SurvivorTo = 8:1:1</td></tr></tbody></table><p>比如设置成 <code>-XX:SurvivorRatio=4</code>，则表示 Eden:SurvivorFrom:SurvivorTo = 4:1:1。也就是说，SurvivorRatio 值就是设置 Eden 区的比例占多少，SurvivorFrom 和 SurvivorTo 的比例相同。</p><h3 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h3><table><thead><tr><th>参数</th><th>参数说明</th><th>默认值</th></tr></thead><tbody><tr><td> -XX:MaxTenuringThreshold</td><td> 用于设置对象经过多少次垃圾收集后，仍然存活而晋升到老年代</td><td>默认值是 15，并且设置的值必须在 0 ~ 15 之间</td></tr></tbody></table><p>SurvivorFrom 区和 SurvivorTo 区交换后，原 SurvivorTo 成为下一次 GC 时的 SurvivorFrom 区。部分对象会在 SurvivorFrom 区和 SurvivorTo 区中复制来复制去，如此交换 15 次（由 JVM 参数 <code>MaxTenuringThreshold</code> 决定，这个参数值默认是 15）后，最终如果还是存活，就存入到老年代区中。<code>-XX:MaxTenuringThreshold</code> 这个阈值可以帮助 JVM 调优，尤其是对那些生命周期较长的对象来说。通过调节这个参数，可以控制对象在新生代和老年代之间的晋升频率，从而影响垃圾收集的性能。更高的值意味着对象更不容易晋升到老年代，而更低的值则可能增加老年代的压力。值得一提的是，如果 <code>MaxTenuringThreshold</code> 的值设置为 0 的话，则年轻对象不会经过 Survivor 区，直接进入老年代。</p><h3 id="其他不常用的高级调优参数"><a href="#其他不常用的高级调优参数" class="headerlink" title="其他不常用的高级调优参数"></a>其他不常用的高级调优参数</h3><p><img data-src="../../../asset/2024/03/jvm-gc-oom-4.png"></p><h2 id="JVM-参数调优的最佳实践"><a href="#JVM-参数调优的最佳实践" class="headerlink" title="JVM 参数调优的最佳实践"></a>JVM 参数调优的最佳实践</h2><h3 id="如何查看-Java-进程的-JVM-参数"><a href="#如何查看-Java-进程的-JVM-参数" class="headerlink" title="如何查看 Java 进程的 JVM 参数"></a>如何查看 Java 进程的 JVM 参数</h3><div class="admonition note"><p class="admonition-title">面试题</p><p>如何查看一个 Java 应用程序，它的某个 JVM 参数是否开启，或者某个 JVM 参数的值是多少？</p></div><h4 id="方法一，适用于-Java-进程未运行"><a href="#方法一，适用于-Java-进程未运行" class="headerlink" title="方法一，适用于 Java 进程未运行"></a>方法一，适用于 Java 进程未运行</h4><ul><li>在 Java 应用程序启动之前，添加以下任意一个 JVM 启动参数。当应用程序启动后，可以将相应的 JVM 参数全部打印出来。</li></ul><table><thead><tr><th>参数</th><th>参数说明</th><th>使用案例</th></tr></thead><tbody><tr><td> -XX:+PrintFlagsInitial</td><td> 打印所有 JVM 参数的默认值</td><td><code>java -XX:+PrintFlagsInitial -version</code></td></tr><tr><td>-XX:+PrintFlagsFinal</td><td> 打印所有 JVM 参数修改后的最终值</td><td><code>java -XX:+PrintFlagsFinal -version</code></td></tr><tr><td>-XX:+PrintCommandLineFlags</td><td> 打印 JVM 默认的简单初始化参数</td><td><code>java -XX:+PrintCommandLineFlags -version</code></td></tr></tbody></table><ul><li>比如，执行 <code>java -XX:+PrintFlagsFinal -version</code> 命令后，JVM 参数的打印结果如下：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">      int ActiveProcessorCount                     = -1                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor         = 4                                         {product} {default}</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale        = 10                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin   = 50                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps      = 20                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval         = 0                                         {product} {default}</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                 = 10                                        {product} {default}</span><br><span class="line">    uintx AdaptiveSizeThroughPutPolicy             = 0                                         {product} {default}</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure><h4 id="方法二，适用于-Java-进程正在运行"><a href="#方法二，适用于-Java-进程正在运行" class="headerlink" title="方法二，适用于 Java 进程正在运行"></a>方法二，适用于 Java 进程正在运行</h4><ul><li>首先使用 <code>jps</code> 命令查看 Java 应用程序的进程 ID (PID)，比如是 30886</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>jinfo</code> 命令查看 Java 进程的某个 JVM 参数是否开启</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag PrintGCDetails 30886  </span><br></pre></td></tr></tbody></table></figure><ul><li>命令行的输出结果如下，其中 <code>+</code> 号表示开启，<code>-</code> 号表示关闭</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>jinfo</code> 命令查看 Java 进程的某个 JVM 参数的值是多少</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag MetaspaceSize 30886</span><br></pre></td></tr></tbody></table></figure><ul><li>命令行的输出结果如下</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=21807104</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>jinfo</code> 命令查看 Java 进程的所有 JVM 参数</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flags 30886</span><br></pre></td></tr></tbody></table></figure><ul><li>命令行的输出结果如下</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=18 -XX:ConcGCThreads=12 -XX:ErrorFile=/root/java_error_in_idea_%p.log -XX:G1ConcRefinementThreads=48 -XX:G1HeapRegionSize=1048576 -XX:GCDrainStackTargetSize=64 -XX:HeapDumpPath=/root/java_error_in_idea_.hprof -XX:InitialHeapSize=524288000 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=2576351232 -XX:MinHeapDeltaBytes=1048576 -XX:NonNMethodCodeHeapSize=8769992 -XX:NonProfiledCodeHeapSize=121444124 -XX:ProfiledCodeHeapSize=121444124 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseG1GC </span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">jinfo 命令的使用总结</p><ul><li>jinfo 命令的使用方式一：<code>jinfo -flag 配置项 进程ID</code>，可查看 Java 应用程序的某个 JVM 参数。比如，<code>jinfo -flag MetaspaceSize 30886</code>，查看 Java 应用程序的元空间大小。</li><li>jinfo 命令的使用方式二：<code>jinfo -flags 进程ID</code>，可查看 Java 应用程序的所有 JVM 参数。比如，<code>jinfo -flags 30886</code>。</li></ul></div><h3 id="模拟-JVM-发生-OOM-现象"><a href="#模拟-JVM-发生-OOM-现象" class="headerlink" title="模拟 JVM 发生 OOM 现象"></a>模拟 JVM 发生 OOM 现象</h3><ul><li>首先编写下述的一段代码，创建一个大对象，触发 JVM 执行垃圾收集。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个占用大内存空间的字节数组 (50M 大小)</span></span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>然后设置 Java 应用程序启动的 JVM 参数，比如设置初始堆内存大小为 10m，最大堆内存大小为 10m，并输出详细 GC 收集日志信息。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></tbody></table></figure><ul><li>在 Java 应用程序启动后，发现会出现以下的错误，同时还打印出 JVM 执行 GC 垃圾收集时的详细信息。这就是 OOM（Java 堆内存溢出），也就是堆内存空间不足。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1972K-&gt;504K(2560K)] 1972K-&gt;740K(9728K), 0.0156109 secs] [Times: user=0.00 sys=0.00, real=0.03 secs]</span><br><span class="line">......</span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 648K-&gt;630K(7168K)] 648K-&gt;630K(9728K)， [Metaspace: 3467K-&gt;3467K(1056768K)]， 0.0058502 secs] [Times: user=0.00 sys=0.00， real=0.01 secs]</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.java.interview.gc.HelloGC.main(HelloGC.java:9)</span><br></pre></td></tr></tbody></table></figure><ul><li>这因为通过 <code>-Xms10m</code> 和 <code>-Xmx10m</code> 只给 JVM 堆内存设置了 10M 的大小，但在 Java 代码中又创建了一个 50M 的数组对象，所以就会出现堆内存不足的现象，而且在 JVM 执行垃圾收集的时候，触发了两种 GC 类型：GC 和 Full GC。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1972K-&gt;504K(2560K)] 1972K-&gt;740K(9728K), 0.0156109 secs] [Times: user=0.00 sys=0.00, real=0.03 secs]</span><br></pre></td></tr></tbody></table></figure><ul><li>GC (Allocation Failure) 表示对象的内存空间分配失败，那么就需要触发新生代的垃圾收集，各个参数对应的示意图如下：</li></ul><p><img data-src="../../../asset/2024/03/jvm-gc-oom-1.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 648K-&gt;630K(7168K)] 648K-&gt;630K(9728K)， [Metaspace: 3467K-&gt;3467K(1056768K)]， 0.0058502 secs] [Times: user=0.00 sys=0.00， real=0.01 secs]</span><br></pre></td></tr></tbody></table></figure><ul><li>Full GC 大部分发生在老年代，当老年代的内存空间不足时，就会出现 OOM 异常，各个参数对应的示意图如下：</li></ul><p><img data-src="../../../asset/2024/03/jvm-gc-oom-2.png"></p><ul><li>从 JVM 输出的详细 GC 收集日志信息，可以发现如下规律：</li></ul><p><img data-src="../../../asset/2024/03/jvm-gc-oom-3.png"></p><h2 id="Java-内存溢出错误"><a href="#Java-内存溢出错误" class="headerlink" title="Java 内存溢出错误"></a>Java 内存溢出错误</h2><h3 id="JVM-经典错误分类"><a href="#JVM-经典错误分类" class="headerlink" title="JVM 经典错误分类"></a>JVM 经典错误分类</h3><p>JVM 中常见的两个错误：</p><ul><li><code>栈溢出</code>：StackoverFlowError</li><li><code>堆溢出</code>：OutofMemoryError</li></ul><p>除此之外，详细的错误信息如下：</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><p>特别注意 StackOverflowError 和 OutOfMemoryError 都是属于 Error，而不是属于 Exception：</p><p><img data-src="../../../asset/2024/03/jvm-error-1.png"></p><h3 id="StackoverFlowError"><a href="#StackoverFlowError" class="headerlink" title="StackoverFlowError"></a>StackoverFlowError</h3><h4 id="错误概述"><a href="#错误概述" class="headerlink" title="错误概述"></a>错误概述</h4><p><code>java.lang.StackOverflowError</code> 是栈溢出错误。最简单的一个递归调用，就会造成栈溢出，也就是深度的方法调用。栈的大小一般是 512K，不断地递归调用，直到栈被撑破为止，就会造成栈溢出的错误。</p><h4 id="错误重现"><a href="#错误重现" class="headerlink" title="错误重现"></a>错误重现</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflowErrorDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        stackOverFlowError();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stackOverFlowError</span><span class="params">()</span> </span>{</span><br><span class="line">        stackOverFlowError();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.StackOverflowError</span><br><span class="line">	at com.java.interview.oom.StackOverflowErrorDemo.stackOverFlowError(StackOverflowErrorDemo.java:10)</span><br></pre></td></tr></tbody></table></figure><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><h4 id="Java-heap-space"><a href="#Java-heap-space" class="headerlink" title="Java heap space"></a>Java heap space</h4><h5 id="错误概述-1"><a href="#错误概述-1" class="headerlink" title="错误概述"></a>错误概述</h5><p><code>java.lang.OutOfMemoryError：java heap space</code> 是堆内存不足错误。这是由于 Java 应用在运行期间，创建了大对象或者很多对象，导致 JVM 堆空间没有足够的内存进行存储。</p><h5 id="错误重现-1"><a href="#错误重现-1" class="headerlink" title="错误重现"></a>错误重现</h5><p>为了更快地让代码达到模拟效果，首先需要设置应用的 JVM 启动参数为 <code>-Xms5m -Xmx5m</code>。重现这个错误的步骤就是不断地反复拼接字符串，即创建多个 String 对象，直到启动 GC 回收堆内存。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaHeapSpaceDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置JVM启动参数：-Xms5m -Xmx5m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            str = str + <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">2000</span>);</span><br><span class="line">            str.intern();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.base/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1271)</span><br></pre></td></tr></tbody></table></figure><h4 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h4><h5 id="错误概述-2"><a href="#错误概述-2" class="headerlink" title="错误概述"></a>错误概述</h5><p><code>java.lang.OutOfMemoryError：GC overhead limit exceeeded</code> 错误是指 GC 操作执行时间过长，这里时间过长的定义是，超过了 98% 的时间用来执行 GC 操作，并且回收了不到 2% 的堆内存（如下图所示）。这一般是连续多次 GC 都只回收了不到 2% 堆内存的极端情况下，才会抛出该错误。假设不抛出 GC overhead limit 错误会造成什么情况呢？那结果就是 GC 回收的这点堆内存很快会被再次填满，迫使 GC 再次执行，这样就形成了恶性循环，CPU 的使用率一直都是 100%，而 GC 却没有任何效果。</p><p><img data-src="../../../asset/2024/03/jvm-gc-oom-5.png"></p><h5 id="错误重现-2"><a href="#错误重现-2" class="headerlink" title="错误重现"></a>错误重现</h5><p>为了更快地让代码达到模拟效果，首先需要设置应用的 JVM 启动参数为 <code>-Xms5m -Xmx5m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code>。重现这个错误的步骤就是不断地向 List 中插入新的 String 对象，直到启动 GC 回收堆内存。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GC 操作执行时间过长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcOverheadLimitErrorDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置JVM启动参数： -Xms5m -Xmx5m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                list.add(String.valueOf(i++).intern());</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">    at java.lang.Integer.toString(Integer.java:403)</span><br><span class="line">    at java.lang.String.valueOf(String.java:3099)</span><br></pre></td></tr></tbody></table></figure><h4 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h4><h5 id="错误概述-3"><a href="#错误概述-3" class="headerlink" title="错误概述"></a>错误概述</h5><p><code>java.lang.OutOfMemoryError：Direct buffer memory</code> 这个错误一般是由 NIO 引起的，比如使用 Netty 网络框架等。<strong>简而言之，堆内存充足，但本地内存（堆外内存）不足的时候，就会出现该错误。</strong>编写 NIO 程序的时候，会经常使用 ByteBuffer 来读取或写入数据，这是一种基于通道 (Channel) 与 缓冲区 (Buffer) 的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块堆外内存的引用进行操作。这样能在一些业务场景中显著地提高性能，因为避免了在 Java 堆和 Native 堆中频繁来回复制数据。</p><ul><li><code>ByteBuffer.allocate(capability)</code>：第一种方式是分配 JVM 堆内存，属于 GC 管辖范畴，由于需要拷贝内存数据，所以执行速度相对较慢</li><li><code>ByteBuffer.allocteDirect(capability)</code>：第二种方式是分配 OS 本地内存（堆外内存），不属于 GC 管辖范畴，由于不需要拷贝内存数据，所以执行速度相对较快</li></ul><p>如果不断地分配本地内存，而堆内存又很少使用，那么 JVM 就不需要执行 GC，同时 DirectByteBuffer 对象就不会被回收，这时候虽然堆内存充足，但本地内存可能已经用光（撑爆）了，当再次尝试分配本地内存就会出现 OutOfMemoryError 错误，程序也随之崩溃。在 Java 中，可以使用以下代码获取最大本地内存（直接内存）大小。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDirectMemoryUtil</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最大直接内存大小（兼容 JDK 8 及以下版本）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMaxDirectMemory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> maxDirectMemory = sun.misc.VM.maxDirectMemory();</span><br><span class="line">        System.out.println(<span class="string">"Max direct memory (JDK 8-): "</span> + maxDirectMemory + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="keyword">return</span> maxDirectMemory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最大直接内存大小（兼容 JDK 9 及以上版本）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMaxDirectMemoryNew</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 这个值可能包括了堆内存的部分，所以如果需要获取真正的直接内存大小，建议将其值除以 2</span></span><br><span class="line">        <span class="keyword">long</span> maxDirectMemoryNew = ManagementFactory.getPlatformMXBean(com.sun.management.OperatingSystemMXBean.class).getTotalPhysicalMemorySize();</span><br><span class="line">        System.out.println(<span class="string">"Max direct memory (JDK 9+): "</span> + maxDirectMemoryNew / <span class="number">2</span> + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="keyword">return</span> maxDirectMemoryNew / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> maxDirectMemory = getMaxDirectMemoryNew();</span><br><span class="line">        String result = maxDirectMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"GB"</span>;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="错误重现-3"><a href="#错误重现-3" class="headerlink" title="错误重现"></a>错误重现</h5><p>为了更快地让代码达到模拟效果，首先需要设置应用的 JVM 启动参数为 <code>-Xms5m -Xmx5m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code>，主要是使用 <code>-XX:MaxDirectMemorySize=5m</code> 设置能使用的本地内存（堆外内存）大小为 5M。重现这个错误的步骤就是通过 ByteBuffer 直接分配 6M 的本地内存空间。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地内存（直接内存）不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectBufferMemoryErrorDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 分配 6M 的本地内存空间</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">	at java.base/java.nio.Bits.reserveMemory(Bits.java:175)</span><br><span class="line">	at java.base/java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:118)</span><br></pre></td></tr></tbody></table></figure><h4 id="Unable-to-create-new-native-thread"><a href="#Unable-to-create-new-native-thread" class="headerlink" title="Unable to create new native thread"></a>Unable to create new native thread</h4><h5 id="错误概述-4"><a href="#错误概述-4" class="headerlink" title="错误概述"></a>错误概述</h5><p><code>java.lang.OutOfMemoryError：unable to create new native thread</code> 错误表示无法创建更多的新线程，也就是说创建线程的上限达到了。在高并发场景下，经常会出现该错误，准确来说该错误与对应的平台有关。</p><ul><li><p>错误原因</p><ul><li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限</li><li>服务器并不允许应用程序创建这么多线程，Linux 系统默认允许单个进程可以创建的线程数为 1024 个，如果超过这个数量就会报错上述错误</li></ul></li><li><p>解决方法</p><ul><li>想办法降低应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，更改代码将线程数降到最低</li><li>对于部分应用，确实需要创建很多线程，且远超过 Linux 系统默认 1024 个线程的限制，可以通过修改 Linux 服务器配置，扩大 Linux 默认的线程数限制</li></ul></li></ul><h5 id="错误重现-4"><a href="#错误重现-4" class="headerlink" title="错误重现"></a>错误重现</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无法创建更多的新线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnableCreateNewThreadDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            index++;</span><br><span class="line">            System.out.println(<span class="string">"************** index = "</span> + index);</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }, String.valueOf(index)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: unable to ceratenew native thread</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">更改 Linux 系统最大线程数的限制</p><ul><li><a href="/posts/88a10b.html">《Centos7 更改最大打开文件描述符数》</a></li></ul></div><h4 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h4><h5 id="Metaspace-错误概述"><a href="#Metaspace-错误概述" class="headerlink" title="Metaspace 错误概述"></a>Metaspace 错误概述</h5><p><code>java.lang.OutOfMemoryError：Metaspace</code> 是元空间内存不足错误。Matespace 元空间使用的是本地内存，<code>-XX:MetaspaceSize</code> 指定的元空间初始化大小是 20M。元空间就是方法区，存放的是类信息、静态变量、常量池等内容。对于 Hotspot 虚拟机而言，为了与 Java 堆区分开来，方法区还有一个别名 Non-Heap （非堆）。值得一提的是，在 JDK 7 及以前，方法区的名称叫 “永久代”，在 JDK 8 及以后，方法区的名称叫 “元空间”。<strong>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。</strong>永久代、元空间二者并不只是名字变了，内部结构也调整了，详细介绍可以看 <a href="/posts/f9740ba6.html#JVM-%E7%9A%84%E6%96%B9%E6%B3%95%E5%8C%BA">这里</a>。</p><div class="admonition note"><p class="admonition-title">JDK 1.7 及以前的方法区内存不足错误</p><p>在 JDK 1.7 及以前，方法区又叫永久代，因此它的内存不足错误是 <code>java.lang.OutOfMemoryError: PermGen space</code>。</p></div><h5 id="Metaspace-错误重现"><a href="#Metaspace-错误重现" class="headerlink" title="Metaspace 错误重现"></a>Metaspace 错误重现</h5><p>为了更快地让代码达到模拟效果，首先需要设置应用的 JVM 启动参数为 <code>-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m -XX:+PrintGCDetails</code>。重现这个错误的步骤就是不断往元空间创建类，直到类占据的空间超过 Metaspace 指定的空间大小为止。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaspaceOutOfMemoryDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 使用 Cglib 的动态字节码技术创建新类</span></span><br><span class="line">                Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">                enhancer.setSuperclass(OOMTest.class);</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">                enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">                        <span class="keyword">return</span> methodProxy.invokeSuper(<span class="number">0</span>, args);</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.out.println(<span class="string">"创建多少次类后发生异常: "</span> + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建多少次类后发生异常: 201</span><br><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: Metaspace</span><br></pre></td></tr></tbody></table></figure><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/3056813b.html" title="Java 虚拟机入门教程之三 JVM 参数调优">https://www.techgrow.cn/posts/3056813b.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag"><i class="fa fa-tag"></i> JVM 虚拟机</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/10809f39.html" rel="prev" title="手写 JDK 的 LinkedList 实现"><i class="fa fa-angle-left"></i> 手写 JDK 的 LinkedList 实现</a></div><div class="post-nav-item"> <a href="/posts/fc09f9be.html" rel="next" title="计算机教学视频资源整理">计算机教学视频资源整理<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">29:58</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/3056813b.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>