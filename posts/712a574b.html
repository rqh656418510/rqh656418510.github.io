<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 SGI STL 内存池的底层源码。"><meta property="og:type" content="article"><meta property="og:title" content="SGI STL 内存池源码剖析"><meta property="og:url" content="https://www.techgrow.cn/posts/712a574b.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 SGI STL 内存池的底层源码。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-7.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-8.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-9.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-6.png"><meta property="article:published_time" content="2025-04-18T13:55:33.000Z"><meta property="article:modified_time" content="2025-04-18T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta property="article:tag" content="源码剖析"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-2.png"><link rel="canonical" href="https://www.techgrow.cn/posts/712a574b.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/712a574b.html","path":"posts/712a574b.html","title":"SGI STL 内存池源码剖析"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>SGI STL 内存池源码剖析 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD"><span class="nav-text">源码下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90"><span class="nav-text">书籍推荐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL"><span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="nav-text">多种实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SGI-STL"><span class="nav-text">SGI STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">概念介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SGI-STL-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">SGI STL 是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SGI-STL-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-text">SGI STL 的主要特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SGI-STL-%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BD%9C%E7%94%A8"><span class="nav-text">SGI STL 的历史作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SGI-STL-%E4%B8%8E-C-STL-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">SGI STL 与 C++ STL 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8"><span class="nav-text">自由链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">自由链表是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">自由链表的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9D%97%E7%B2%92%E5%BA%A6%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-text">内存块粒度与分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84"><span class="nav-text">自由链表节点结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">自由链表的存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-text">内存分配策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-text">内存回收策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-text">源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89"><span class="nav-text">空间配置器的相关定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">重要类型和变量的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E8%BE%85%E5%8A%A9%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-text">重要的辅助接口函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="nav-text">内存池管理核心函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93%E8%AF%B4%E6%98%8E"><span class="nav-text">内存池管理总结说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E7%A7%BB%E6%A4%8D"><span class="nav-text">源码移植</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81"><span class="nav-text">核心源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">测试代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">695</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/712a574b.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="SGI STL 内存池源码剖析 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 SGI STL 内存池的底层源码。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> SGI STL 内存池源码剖析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-04-18 21:55:33" itemprop="dateCreated datePublished" datetime="2025-04-18T21:55:33+08:00">2025-04-18</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/712a574b.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/712a574b.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>6k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>5 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/5bc5018f.html">Nginx 内存池源码剖析</a></li><li><a href="/posts/712a574b.html">SGI STL 内存池源码剖析</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将剖析 SGI STL 二级空间配置器中的内存池源码，并介绍内存池的底层设计和工作原理，最后移植 SGI STL 内存池的核心源码。</p><div class="admonition note"><p class="admonition-title">C++ 常见的池</p><p>在 C++ 中有五大池，包括内存池、连接池、协程池、线程池、进程池。</p></div><span id="more"></span><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><ul><li><a href="../../../downloads/2025/05/sgi-stl.zip">SGI STL 源码下载</a></li></ul><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><ul><li><a href="#">《STL 源码剖析》 第二章 - 空间配置器（Allocator）</a></li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>C++ 中的 STL（Standard Template Library）是标准模板库，提供了一组通用的数据结构和算法，如向量（<code>vector</code>）、链表（<code>list</code>）、集合（<code>set</code>）、映射（<code>map</code>）、排序、查找等；基于模板实现，支持泛型编程，代码复用性高、效率也好。</p><h3 id="多种实现"><a href="#多种实现" class="headerlink" title="多种实现"></a>多种实现</h3><p>除了 C++ 自身提供的 STL 之外，常见的第三方 STL（标准模板库）实现有以下几种：</p><ul><li><p><strong>RW STL（Rogue Wave STL）</strong></p><ul><li>开发者：<ul><li>Rogue Wave Software 公司（后被 Perforce 收购）</li></ul></li><li>性质：<ul><li>商业版本的 C++ 标准模板库实现</li></ul></li><li>代表产品：<ul><li>作为 SourcePro C++ 产品的一部分提供（包含 STL、线程库、网络库、数据库访问库等）</li></ul></li><li>产品特点：<ul><li>遵循 ISO C++ 标准</li><li>跨平台，适配多种操作系统和编译器</li><li>提供高级调试、异常安全、多线程支持</li><li>可配置性强，适用于嵌入式和大型系统</li></ul></li><li>应用场景：<ul><li>金融系统、通信系统、嵌入式开发、航空航天、政府项目等对可靠性要求高的场景</li></ul></li></ul></li><li><p> <strong>PJ STL（Dinkumware STL）</strong></p><ul><li>开发者：<ul><li>P. J. Plauger（C++ 标准委员会成员），其自己公司 Dinkumware 提供支持</li></ul></li><li>性质：<ul><li>商业版本的 C++ 标准模板库实现</li></ul></li><li>代表使用者：<ul><li>Microsoft Visual C++（尤其是 VC++ 6 及后续版本）默认使用 PJ STL</li></ul></li><li> 特点：<ul><li>遵循 ISO C++ 标准</li><li>接口稳定、实现清晰，强调工程实用性</li><li>提供 STL、C 标准库（如 <code>&lt;cmath&gt;</code>，<code>&lt;cstdlib&gt;</code>）、TR1 和部分 C++ 11 / 14 特性</li></ul></li><li>优势：<ul><li>商业支持</li><li>与微软编译器深度集成</li><li>重视可移植性和性能</li></ul></li><li>局限：<ul><li>并非开源，文档和源代码可见性有限</li></ul></li></ul></li><li><p> <strong>HP STL（Hewlett-Packard STL）</strong></p><ul><li>开发者：<ul><li>Hewlett-Packard 公司（惠普实验室），由 Alexander Stepanov 及其团队在 HP（惠普）初步实现</li></ul></li><li>性质：<ul><li>STL 的原始实现，是 SGI STL 的前身</li></ul></li><li>历史意义：<ul><li>1994 年 Stepanov 在 HP Labs（惠普实验室）首次实现 STL，随后向 C++ 标准委员会提交</li><li>后由 SGI 改进并推广形成 SGI STL，逐渐成为业界学习模板编程的典范</li></ul></li><li>特点：<ul><li>结构清晰，贴近标准草案</li><li>强调通用算法和迭代器的分离设计</li><li>奠定了 STL 的基础架构，如容器、迭代器、算法的三大支柱</li></ul></li><li>应用与影响：<ul><li>虽然未被广泛部署于实际商业编译器中，但在学术界和标准委员会中具有开创性意义</li><li>是理解 STL 起源与设计哲学的关键资料</li></ul></li><li>现状：<ul><li>已不再维护，但源码与设计理念在 SGI STL 中得以继承和发扬</li></ul></li></ul></li><li><p> <strong>SGI STL（Silicon Graphics STL）</strong></p><ul><li>开发者：<ul><li>Alexander Stepanov（STL 之父）、Meng Lee 等人在 SGI（Silicon Graphics Inc.）公司开发</li></ul></li><li>性质：<ul><li>最早公开发布的 STL 实现之一，并作为学习范例广泛传播</li></ul></li><li>特点：<ul><li>完全开源，源码可读性和学习性极强</li><li>强调泛型编程、模板技巧和性能优化</li><li>提供了 <code>allocator</code>、<code>traits</code>、<code>function object</code>、<code>iterator</code> 等先进设计</li></ul></li><li>贡献：<ul><li>为后来的标准库实现（如 GCC 的 libstdc++）提供了基础</li><li>推动了 STL 的工业化、模块化和标准化</li></ul></li><li>现状：<ul><li>虽然已经不再更新，但作为教学和研究材料仍具重要历史价值</li></ul></li></ul></li></ul><blockquote><p>第三方 STL 实现的总结对比表</p></blockquote><table><thead><tr><th>名称</th><th>开发者</th><th>是否开源</th><th>典型应用</th><th>特点描述</th></tr></thead><tbody><tr><td> RW STL</td><td>Rogue Wave Software</td><td>❌ 商业版</td><td>金融、嵌入式、政府、工业系统</td><td>工程化程度高，稳定性强，附带调试与多线程支持，属于 SourcePro C++ 一部分</td></tr><tr><td> PJ STL</td><td>P. J. Plauger / Dinkumware</td><td>❌ 商业版</td><td> Visual C++、商业工具链</td><td>工程稳健，兼容性好，被微软 Visual Studio 多版本采用</td></tr><tr><td> HP STL</td><td>Alexander Stepanov / HP</td><td>✅ 开源</td><td>教育、历史研究、标准演化</td><td> STL 的最早实现版本，设计哲学完整，影响了 SGI STL 和后续标准化进程</td></tr><tr><td> SGI STL</td><td>Alexander Stepanov / SGI</td><td>✅ 开源</td><td>教育、研究、GCC libstdc++ 原型</td><td>泛型编程示范，模板设计前沿，影响广泛</td></tr></tbody></table><h2 id="SGI-STL"><a href="#SGI-STL" class="headerlink" title="SGI STL"></a>SGI STL</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><h4 id="SGI-STL-是什么"><a href="#SGI-STL-是什么" class="headerlink" title="SGI STL 是什么"></a>SGI STL 是什么</h4><p>SGI STL 是由 Alexander Stepanov 和 Meng Lee 等人在 SGI（Silicon Graphics Inc.）公司开发的 C++ 标准模板库实现，最早出现在 1990 年代。这个库实现了 STL 的核心思想：泛型编程与容器 - 算法 - 迭代器模型。<strong>SGI STL 包含了一级空间配置器和二级空间配置器，其中一级空间配置器 <code>allocator</code> 采用 <code>malloc()</code> 和 <code>free()</code> 来管理内存，和 C++ 标准模板库（STL）中提供的 <code>allocator</code> 是一样的，但其二级空间配置器 <code>allocator</code> 采用了基于自由链表（Free List）原理的内存池机制来实现内存管理。具体来说，当申请的内存块超过 <code>128</code> 字节时，视之为 “足够大”，会调用一级空间配置器；当申请的内存块小于 <code>128</code> 字节时，视之为 “过小”，会调用二级空间配置器，采用复杂的内存池管理方式，这样可以避免小内存频繁申请和释放导致的内存碎片问题，同时提高效率。</strong></p><div class="admonition warning"><p class="admonition-title">STL 空间配置器的作用</p><ul><li>在 C++ STL 中，空间配置器（<code>allocator</code>）的作用主要有两种：</li><li>(1) 分离了对象的内存开辟（<code>allocate()</code>）和对象的构造（<code>construct()</code>）。</li><li>(2) 分离了对象的析构（<code>destroy()</code>）和对象的内存释放（<code>deallocate()</code>）。</li></ul></div><h4 id="SGI-STL-的主要特性"><a href="#SGI-STL-的主要特性" class="headerlink" title="SGI STL 的主要特性"></a>SGI STL 的主要特性</h4><ul><li>提供了 STL 的主要组件：<code>vector</code>、<code>list</code>、<code>map</code>、<code>set</code>、<code>algorithm</code>、<code>iterator</code> 等。</li><li>包含一些非标准扩展，例如：<ul><li><code>slist</code>（单向链表）</li><li><code>hash_map</code> / <code>hash_set</code>（后来的 <code>unordered_map</code> / <code>unordered_set</code> 的前身）</li></ul></li><li>代码高度模板化、效率高、注释详尽。</li><li>源码开放，很多 C++ 开发者都用它来学习 STL 的底层实现。</li></ul><h4 id="SGI-STL-的历史作用"><a href="#SGI-STL-的历史作用" class="headerlink" title="SGI STL 的历史作用"></a>SGI STL 的历史作用</h4><p>SGI STL 是 现代 C++ STL 的原型，其思想和实现对 C++ 98 标准 STL 的设计有极大影响。许多早期编译器，如 GCC、MSVC、Intel C++，都在某个时期采用过 SGI STL 或其变种（比如 STLport）。</p><div class="admonition note"><p class="admonition-title">今天还需要使用 SGI STL 吗</p><ul><li>通常不需要使用 SGI STL，因为现代 C++ 编译器都自带符合标准的 STL 实现，比如 GCC：libstdc++、Clang：libc++、MSVC：Dinkumware。</li><li>如果是为了学习 STL 的内部实现机制（底层原理），SGI STL 是一个非常好的教学资源；但在生产环境中，应该使用现代 C++ STL（标准模板库）。</li></ul></div><h4 id="SGI-STL-与-C-STL-的区别"><a href="#SGI-STL-与-C-STL-的区别" class="headerlink" title="SGI STL 与 C++ STL 的区别"></a>SGI STL 与 C++ STL 的区别</h4><table><thead><tr><th>项目</th><th> SGI STL</th><th>C++ STL（标准模板库）</th></tr></thead><tbody><tr><td>作者 / 出处</td><td> SGI 公司（如 STLport）</td><td>C++ 标准委员会</td></tr><tr><td>标准性</td><td>非正式实现，非标准的一些扩展</td><td>从 C++ 98 开始，成为标准 C++ 的一部分</td></tr><tr><td>扩展内容</td><td><code>hash_map</code>、<code>slist</code>、<code>rope</code> 等非标准组件</td><td>标准化容器如 <code>vector</code>、<code>deque</code>、<code>map</code>、<code>set</code> 等</td></tr><tr><td>可移植性</td><td>与平台、编译器耦合程度较高</td><td>作为标准模板库，各主流编译器都支持</td></tr><tr><td>现代兼容性</td><td>不支持 C++ 11 及以后的特性</td><td>现代 STL 持续演进（如 <code>move semantics</code>, <code>unordered_map</code>, <code>ranges</code> 等）</td></tr><tr><td>教育价值</td><td>非常适合学习 STL 实现机制</td><td>通常以黑箱方式使用</td></tr></tbody></table><h3 id="自由链表"><a href="#自由链表" class="headerlink" title="自由链表"></a>自由链表</h3><p>这里将介绍 SGI STL 二级空间配置器中自由链表的底层实现。</p><h4 id="自由链表是什么"><a href="#自由链表是什么" class="headerlink" title="自由链表是什么"></a>自由链表是什么</h4><p>自由链表是一种用于管理空闲内存块的链表结构。每个链表节点指向一个未被使用的内存块，便于快速分配和回收。在 SGI STL 的二级空间配置器中，自由链表有以下特点：</p><ul><li>每种固定大小的内存块（如 8 字节、16 字节、24 字节 …）都有一个对应的自由链表。</li><li>小对象内存块的复用：当用户释放内存时，并不会直接 <code>free()</code>，而是将内存放回对应的自由链表中，供后续复用。</li><li>分配内存时，优先从自由链表中取；只有自由链表为空时，才会从系统堆（Heap）分配一大块内存进行切分。</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>数量</td><td> 16 个自由链表（按 8 ~ 128 字节分为 16 类）</td></tr><tr><td>数据结构</td><td><code>union obj</code> 实现链表节点</td></tr><tr><td>分配策略</td><td>优先从自由链表取，否则从堆中批量 <code>refill()</code></td></tr><tr><td>回收策略</td><td>小块内存回收到对应的自由链表，大块内存直接释放</td></tr><tr><td>性能优势</td><td>避免频繁 <code>malloc</code> / <code>free</code>，显著减少内存碎片和内存开辟 / 释放的开销</td></tr></tbody></table><h4 id="自由链表的结构"><a href="#自由链表的结构" class="headerlink" title="自由链表的结构"></a>自由链表的结构</h4><p><img data-src="../../../asset/2025/04/sgi-stl-2.png"></p><h5 id="内存块粒度与分类"><a href="#内存块粒度与分类" class="headerlink" title="内存块粒度与分类"></a>内存块粒度与分类</h5><ul><li>内存块的粒度信息</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (__SUNPRO_CC) || defined (__GNUC__)</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_ALIGN = <span class="number">8</span>};            <span class="comment">// 小块内存的对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_MAX_BYTES = <span class="number">128</span>};      <span class="comment">// 二级空间配置器最大管理范围（128 字节）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_NFREELISTS = <span class="number">16</span>};      <span class="comment">// 自由链表的数量，计算方式：_MAX_BYTES / _ALIGN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>一共维护 16 个自由链表，每个自由链表负责管理一种字节大小的内存块：</li></ul><table><thead><tr><th>自由链表的下标</th><th>内存块的大小</th></tr></thead><tbody><tr><td> 0</td><td>8 字节</td></tr><tr><td> 1</td><td>16 字节</td></tr><tr><td> 2</td><td>24 字节</td></tr><tr><td>…</td><td>…</td></tr><tr><td>15</td><td>128 字节</td></tr></tbody></table><h5 id="自由链表节点结构"><a href="#自由链表节点结构" class="headerlink" title="自由链表节点结构"></a>自由链表节点结构</h5><ul><li>每个空闲内存块都可以看作是一个 <code>_Obj</code>，其中 <code>_M_free_list_link</code> 用来链接空闲内存块（最终形成自由链表）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span>    <span class="comment">// 下一个内存 chunk 块的地址</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data [<span class="number">1</span>];          <span class="comment">// 实际分配给用户的内存起始位置</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="自由链表的存储结构"><a href="#自由链表的存储结构" class="headerlink" title="自由链表的存储结构"></a>自由链表的存储结构</h5><ul><li>这个数组保存了每种块大小的链表头指针</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list [_NFREELISTS];  <span class="comment">// 16 个自由链表</span></span><br></pre></td></tr></tbody></table></figure><h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><ul><li>当调用 <code>allocate(n)</code>：<ul><li>如果 <code>n &gt; 128</code>，则交由一级空间配置器处理（直接调用 <code>malloc()</code> 分配内存）。</li><li>否则：<ul><li>(1) 将 <code>n</code> 向上对齐到 8 的倍数（实现内存对齐）。</li><li>(2) 找到对应的自由链表索引。</li><li>(3) 如果该链表非空，从中取一个满足大小的空闲内存块返回。</li><li>(4) 如果链表为空，调用 <code>refill()</code> 从堆上批量分配一大块内存（默认分配 2 x 20 个块），挂到自由链表上。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2025/04/sgi-stl-7.png"></p><h5 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h5><ul><li>当调用 <code>deallocate(p, n)</code>：<ul><li>如果 <code>n &gt; 128</code>，则交由一级空间配置器处理（直接调用 <code>free()</code> 释放内存）。</li><li>否则：<ul><li>(1) 将 <code>n</code> 向上对齐到 8 的倍数（实现内存对齐）。</li><li>(2) 找到对应的自由链表索引。</li><li>(3) 把块头强制转换为 <code>obj*</code>，插入到自由链表的头部（头插法）。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2025/04/sgi-stl-8.png"></p><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><p>在剖析 SGI STL 的内存池源码时，建议以 <code>vector</code> 容器的源码作为切入点，然后一步步分析一级和二级空间配置器的底层实现，如下图所示：</p><p><img data-src="../../../asset/2025/04/sgi-stl-3.png"></p><h4 id="空间配置器的相关定义"><a href="#空间配置器的相关定义" class="headerlink" title="空间配置器的相关定义"></a>空间配置器的相关定义</h4><ul><li><code>vector</code> 容器的定义</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> __STL_DEFAULT_ALLOCATOR (_Tp) &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> :</span> <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt; { }</span><br></pre></td></tr></tbody></table></figure><ul><li><code>vector</code> 容器的默认空间配置器是 <code>__STL_DEFAULT_ALLOCATOR ( _Tp)</code>，它是一个宏定义，如下：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR (T) allocator<span class="meta-string">&lt; T &gt;</span>   <span class="comment">// 使用标准 STL allocator（一级空间配置器）</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR (T) alloc            <span class="comment">// 使用 SGI alloc（二级空间配置器）</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>从上面可以看到 <code>__STL_DEFAULT_ALLOCATOR</code> 通过宏控制有两种空间配置器实现，一种是 <code>allocator&lt;T&gt;</code>，另一种是 <code>alloc</code>，这两种分别就是 SGI STL 的一级空间配置器和二级空间配置器的实现</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span>           // 一级空间配置器内存管理类（底层通过 <span class="title">malloc</span> 和 <span class="title">free</span> 管理内存）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> {</span> }      <span class="comment">// 二级空间配置器内存管理类（底层通过自定义内存池实现内存管理）</span></span><br></pre></td></tr></tbody></table></figure><ul><li>SGI STL 的一级和二级空间配置器对比</li></ul><table><thead><tr><th>类型</th><th>实现类</th><th>内存管理机制</th><th>用途</th><th>源码位置</th></tr></thead><tbody><tr><td>一级空间配置器</td><td><code>__malloc_alloc_template</code></td><td><code>malloc() / free()</code></td><td>分配大块内存</td><td>定义在 <code>stl_alloc.h</code> 头文件，<a href="../../../asset/2025/04/sgi-stl-4.png">如图所示</a></td></tr><tr><td>二级空间配置器</td><td><code>__default_alloc_template</code></td><td>内存池机制</td><td>分配小块内存，其核心机制就是使用一组自由链表（Free List）来管理内存块，提高小对象（小于等于 128 字节）的内存分配效率，底层也是使用 <code>malloc() / free()</code> 分配和释放内存</td><td>定义在 <code>stl_alloc.h</code> 头文件，<a href="../../../asset/2025/04/sgi-stl-5.png">如图所示</a></td></tr></tbody></table><div class="admonition note"><p class="admonition-title">SGI STL 默认的空间配置器</p><p>从上面的 <code>vector</code> 容器源码可以发现，SGI STL 的每一个容器都已经指定其缺省的空间配置器为 <code>alloc</code>，即默认使用的是二级空间配置器 <code>__default_alloc_template</code>。</p></div><h4 id="重要类型和变量的定义"><a href="#重要类型和变量的定义" class="headerlink" title="重要类型和变量的定义"></a>重要类型和变量的定义</h4><p>在 SGI STL 的二级空间配置器（<code>__default_alloc_template</code>）中，有以下重要类型和变量定义，其底层的自由链表节点结构如下图所示：</p><p><img data-src="../../../asset/2025/04/sgi-stl-1.png"></p><ul><li>内存池的粒度信息</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (__SUNPRO_CC) || defined (__GNUC__)</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_ALIGN = <span class="number">8</span>};            <span class="comment">// 小块内存的对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_MAX_BYTES = <span class="number">128</span>};      <span class="comment">// 小块内存的最大字节数（128 字节）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_NFREELISTS = <span class="number">16</span>};      <span class="comment">// 自由链表的数量，计算方式：_MAX_BYTES / _ALIGN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>每一个内存 chunk 块的头信息</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span>     <span class="comment">// 下一个内存 chunk 块的地址</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data [<span class="number">1</span>];           <span class="comment">// 实际分配给用户的内存起始位置</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>组织所有自由链表的数组，数组的每一个元素的类型都是 <code>_Obj*</code>，全部初始化为 <code>0</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list [_NFREELISTS]; </span><br></pre></td></tr></tbody></table></figure><ul><li>记录内存 chunk 块的分配情况</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk allocation state.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="重要的辅助接口函数"><a href="#重要的辅助接口函数" class="headerlink" title="重要的辅助接口函数"></a>重要的辅助接口函数</h4><ul><li>将 <code>__bytes</code> 上调至最邻近的 8 的倍数（实现内存对齐）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up (<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>返回 <code>__bytes</code> 大小的 chunk 块位于自由链表数组中的索引</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index (<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理核心函数"><a href="#内存池管理核心函数" class="headerlink" title="内存池管理核心函数"></a>内存池管理核心函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配内存的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span> <span class="params">(<span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配新的 chunk 块，并将分配好的 chunk 块进行连接，添加到自由链表当中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* _S_refill (<span class="keyword">size_t</span> __n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配相应内存字节大小的 chunk 块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc (<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 chunk 块归还到内存池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span> <span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池扩容/缩容函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span> <span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理总结说明"><a href="#内存池管理总结说明" class="headerlink" title="内存池管理总结说明"></a>内存池管理总结说明</h4><blockquote><p>SGI STL 对内存分配和内存释放的设计哲学</p></blockquote><ul><li>向 System Heap 要内存空间。</li><li>考虑多线程（Multi Threads）状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多 “小型区块内存” 可能造成的内存碎片（Fragment）问题</li></ul><blockquote><p>SGI STL 二级空间配置器中内存池的优点</p></blockquote><ul><li><p><strong>内存分配具有预留机制</strong></p><ul><li>对于每种特定字节大小的 chunk（内存块）分配，内存池并不会仅分配刚好所需的内存，而是会一次性申请较大一块内存，并将其划分为多个 chunk（比如 40 个）。其中一部分（20 个 chunk）立即用于分配，另一部分（20 个 chunk）作为备用，供后续相同字节大小的分配请求使用。更重要的是，如果其他字节大小的 chunk 分配失败，这部分备用内存也有可能被重新划分后用于其他字节大小的 chunk 分配请求，从而提升内存使用的灵活性与效率。</li></ul></li><li><p><strong>最大化利用碎片内存</strong></p><ul><li>在将一大块备用内存划分为若干 chunk 后，可能会剩下一小部分无法完整划分的内存碎片。SGI STL 会在后续分配中尽可能再次利用这些内存碎片，避免资源浪费，确保备用内存池被 “用得干干净净”。</li></ul></li><li><p><strong>具有健壮的回退机制</strong></p><ul><li>当某一特定字节大小的内存块分配失败时，二级空间配置器会遍历所有字节大小的自由链表，查找是否有可用的空闲 chunk 块可暂时 “借用”。如果发现其他链表中有满足需求的空闲 chunk 块，就会将其临时分配出去，以缓解当前内存分配压力。如果其他链表中没有满足需求的空闲 chunk 块可以借用，就会直接调用 <code>malloc()</code> 继续分配内存空间。</li></ul></li><li><p><strong>支持 OOM 回调机制</strong></p><ul><li>如果其他自由链表中没有空闲的 chunk 块可以借用，且调用 <code>malloc()</code> 分配内存失败，那么二级空间配置器将尝试调用用户预设的 <code>oom_handler</code> 回调函数（可以用于释放用户自定义的内存资源），以应对 <code>malloc()</code> 执行失败的情况（在死循环中处理）。若用户未设置 <code>oom_handler</code> 回调函数，则直接抛出 OOM（Out Of Memory）异常，提示内存分配失败，确保程序行为的可控性和安全性。</li></ul></li></ul><blockquote><p>SGI STL 一级和二级空间配置器的关系</p></blockquote><p><img data-src="../../../asset/2025/04/sgi-stl-9.png"></p><blockquote><p>SGI STL 内存池的的核心源码文件</p></blockquote><p><img data-src="../../../asset/2025/04/sgi-stl-6.png"></p><h3 id="源码移植"><a href="#源码移植" class="headerlink" title="源码移植"></a>源码移植</h3><p>这里将移植 SGI STL 二级空间配置器中的内存池代码，即单独抽出内存池的代码以复用，其中移植的代码主要位于 SGI STL 的 <code>stl_alloc.h</code> 头文件中。</p><h4 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h4><ul><li><code>allocator.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一级空间配置器，按字节分配大块内存</span></span><br><span class="line"><span class="comment">// 封装 malloc() 和 free() 来实现内存管理，可以设置发生 OOM 时释放内存的回调函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __result) {</span><br><span class="line">            <span class="comment">// 调用OOM处理流程</span></span><br><span class="line">            __result = _S_oom_malloc(__n);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(__p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存空间重分配</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __result) {</span><br><span class="line">            <span class="comment">// 调用OOM处理流程</span></span><br><span class="line">            __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的OOM处理函数，返回旧的处理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in"><span class="keyword">void</span></span> (*__old)() = __malloc_alloc_oom_handler;</span><br><span class="line">        __malloc_alloc_oom_handler = __f;</span><br><span class="line">        <span class="keyword">return</span> (__old);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存空间开辟时的OOM处理流程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> *_S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存空间重分配时的OOM处理流程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> *_S_oom_realloc(<span class="keyword">void</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OOM回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="params">(*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)</span><span class="params">()</span> </span>= <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__malloc_alloc_template&lt;inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n) {</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *__result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环，不断尝试释放、申请、再释放、再申请...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) { <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); }</span><br><span class="line">        <span class="comment">// 调用OOM回调函数</span></span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        <span class="comment">// 再次尝试申请内存</span></span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__malloc_alloc_template&lt;inst&gt;::_S_oom_realloc(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> __n) {</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *__result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环，不断尝试释放、重分配、再释放、再重分配...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) { <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); }</span><br><span class="line">        <span class="comment">// 调用OOM回调函数</span></span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        <span class="comment">// 再次尝试内存重分配</span></span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定义类型</span></span><br><span class="line"><span class="keyword">using</span> malloc_alloc = __malloc_alloc_template&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级空间配置器，按字节分配小块内存</span></span><br><span class="line"><span class="comment">// 基于自由链表原理的内存池机制来实现内存管理</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__ret = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配大块内存（当字节数大于 128）</span></span><br><span class="line">        <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) {</span><br><span class="line">            <span class="comment">// 调用一级空间配置器分配大内存</span></span><br><span class="line">            __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 分配小块内存</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表的互斥锁</span></span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; __lock_instance(_S_free_list_mtx[_S_freelist_index(__n)]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取自由链表的头节点</span></span><br><span class="line">            _Obj *__result = *__my_free_list;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果头节点为空（即没有空闲的内存 chunk 块），则分配新的内存 chunk 块</span></span><br><span class="line">            <span class="keyword">if</span> (__result == <span class="literal">nullptr</span>) {</span><br><span class="line">                __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果有空闲的内存 chunk 块，则将其取出来，并维护自由链表的结构</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 将自由链表的头节点指向下一个内存 chunk 块</span></span><br><span class="line">                *__my_free_list = __result-&gt;_M_free_list_link;</span><br><span class="line">                __ret = __result;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> __ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> __n)</span> </span>{</span><br><span class="line">        <span class="comment">// 大块内存（当字节数大于 128）直接交由一级空间配置器释放掉</span></span><br><span class="line">        <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) {</span><br><span class="line">            malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 小块内存回收到自由链表</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">            _Obj *__q = (_Obj *) __p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表的互斥锁</span></span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; __lock_instance(_S_free_list_mtx[_S_freelist_index(__n)]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回收内存，将释放的小块内存插入到自由链表的头部（头插法）</span></span><br><span class="line">            __q-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = __q;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存池扩容 / 缩容</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *__p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span> </span>{</span><br><span class="line">        <span class="keyword">void</span> *__result;</span><br><span class="line">        <span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种情况：当新旧大小均超过最大内存池处理阈值是，直接调用系统的 realloc()</span></span><br><span class="line">        <span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) {</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">realloc</span>(__p, __new_sz));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种情况：当新旧内存块在内存池中的对齐后大小相等，则直接复用旧内存块</span></span><br><span class="line">        <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) {</span><br><span class="line">            <span class="keyword">return</span> (__p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三种情况：需要执行内存重分配</span></span><br><span class="line">        __result = <span class="built_in">allocate</span>(__new_sz);    <span class="comment">// 申请新内存块（根据内存池策略）</span></span><br><span class="line">        __copy_sz = __new_sz &gt; __old_sz ? __old_sz : __new_sz;   <span class="comment">// 安全拷贝大小（取较小值）</span></span><br><span class="line">        <span class="built_in">memcpy</span>(__result, __p, __copy_sz);    <span class="comment">// 数据拷贝（仅拷贝有效内容）</span></span><br><span class="line">        <span class="built_in">deallocate</span>(__p, __old_sz);     <span class="comment">// 释放旧内存块（根据旧内存块的大小进行回收）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> {</span> _ALIGN = <span class="number">8</span> };            <span class="comment">// 小块内存的对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> {</span> _MAX_BYTES = <span class="number">128</span> };      <span class="comment">// 小块内存的最大字节数（128 字节）</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> {</span> _NFREELISTS = <span class="number">16</span> };      <span class="comment">// 自由链表的数量，计算方式：_MAX_BYTES / _ALIGN</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个内存 chunk 块的头信息</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> *_<span class="title">M_free_list_link</span>;</span>        <span class="comment">// 下一个内存 chunk 块的地址</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];                <span class="comment">// 实际分配给用户的内存起始位置</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录内存 chunk 块的分配情况</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *_S_start_free;     <span class="comment">// 整个内存池的起始位置，只在 _S_chunk_alloc() 中发生变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *_S_end_free;       <span class="comment">// 整个内存池的结束位置，只在 _S_chunk_alloc() 中发生变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组织所有自由链表的数组，数组的每一个元素的类型都是 _Obj*</span></span><br><span class="line">    <span class="keyword">static</span> _Obj *<span class="keyword">volatile</span> _S_free_list[_NFREELISTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有自由链表的互斥锁的数组（内存池基于自由链表实现，需要考虑线程安全问题，为每个自由链表添加一个互斥锁，降低锁的粒度）</span></span><br><span class="line">    <span class="keyword">static</span> std::mutex _S_free_list_mtx[_NFREELISTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 __bytes 上调至最邻近的 8 的倍数（实现内存对齐）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 __bytes 大小的 chunk 块位于自由链表数组中的索引</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的内存 chunk 块，并将分配好的 chunk 块进行连接，添加到自由链表当中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> *_S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配相应字节大小的内存 chunk 块</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span> &amp;__nobjs);</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员变量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;inst&gt;::_S_start_free = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;inst&gt;::_S_end_free = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line">std::mutex __default_alloc_template&lt;inst&gt;::_S_free_list_mtx[_NFREELISTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;inst&gt;::_Obj *<span class="keyword">volatile</span> __default_alloc_template&lt;inst&gt;::_S_free_list[_NFREELISTS] = {<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">                                                                                                                     <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__default_alloc_template&lt;inst&gt;::_S_refill(<span class="keyword">size_t</span> __n) {</span><br><span class="line">    <span class="comment">// 一次性分配 20 个内存 chunk 块，但万一内存空间不足，获得的块数可能小于 20</span></span><br><span class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配多个指定大小的内存 chunk 块，参数 __nobjs 使用引用传递</span></span><br><span class="line">    <span class="keyword">char</span> *__chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line"></span><br><span class="line">    _Obj *<span class="keyword">volatile</span> *__my_free_list;</span><br><span class="line">    _Obj *__result;</span><br><span class="line">    _Obj *__current_obj;</span><br><span class="line">    _Obj *__next_obj;</span><br><span class="line">    <span class="keyword">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只获得一个内存 chunk 块，就直接分配给调用者使用，自由链表不会添加新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) {</span><br><span class="line">        <span class="keyword">return</span> (__chunk);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分配到的多个内存 chunk 块添加到对应的自由链表中（即将各个 chunk 块串联起来）</span></span><br><span class="line">    __result = (_Obj *) __chunk;    <span class="comment">// 这个内存 chunk 返回给调用者</span></span><br><span class="line">    *__my_free_list = __next_obj = (_Obj *) (__chunk + __n);</span><br><span class="line">    <span class="keyword">for</span> (__i = <span class="number">1</span>;; __i++) {     <span class="comment">// 从 1 开始，因为第 0 个返回给调用者</span></span><br><span class="line">        __current_obj = __next_obj;</span><br><span class="line">        __next_obj = (_Obj *) ((<span class="keyword">char</span> *) __next_obj + __n);</span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) {</span><br><span class="line">            __current_obj-&gt;_M_free_list_link = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            __current_obj-&gt;_M_free_list_link = __next_obj;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (__result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span> &amp;__nobjs) {</span><br><span class="line">    <span class="keyword">char</span> *__result;</span><br><span class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;    <span class="comment">// 计算需要分配的总字节数</span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;    <span class="comment">// 获取整个内存池剩余空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种情况：整个内存池的剩余空间完全可以满足需求</span></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) {</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 第二种情况：整个内存池的剩余空间不能满足全部需求，但至少能分配一个以上的内存 chunk 块</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) {</span><br><span class="line">        <span class="comment">// 更改为实际能够供应的内存 chunk 数</span></span><br><span class="line">        __nobjs = (<span class="keyword">int</span>) (__bytes_left / __size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span> (__result);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 第三种情况：整个内存池的剩余空间不足一个内存 chunk 块大小</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 计算需要申请的内存总量：2倍需求 + 附加量（堆大小的1/16并向上对齐）</span></span><br><span class="line">        <span class="keyword">size_t</span> __bytes_to_get = <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试回收利用内存池的剩余碎片</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list = _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line">            <span class="comment">// 将剩余碎片插入到自由链表的头部（头插法）</span></span><br><span class="line">            ((_Obj *) _S_start_free)-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj *) _S_start_free;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请新的内存块并添加到内存池中</span></span><br><span class="line">        _S_start_free = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(__bytes_to_get);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  新的内存块申请失败处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == _S_start_free) {</span><br><span class="line">            <span class="keyword">size_t</span> __i;</span><br><span class="line">            _Obj *<span class="keyword">volatile</span> *__my_free_list;</span><br><span class="line">            _Obj *__p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试从其他字节数更大的自由链表中查找可用内存块</span></span><br><span class="line">            <span class="comment">// 注意：不尝试从字节数更小的自由链表中查找，因为在多处理器环境中容易出现问题</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size; __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES; __i += (<span class="keyword">size_t</span>) _ALIGN) {</span><br><span class="line">                <span class="comment">// 获取对应大小的自由链表</span></span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="comment">// 找到可用内存块</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">nullptr</span> != __p) {</span><br><span class="line">                    <span class="comment">// 调整自由链表以获取未使用的内存块</span></span><br><span class="line">                    *__my_free_list = __p-&gt;_M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="keyword">char</span> *) __p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="comment">// 递归调用自身，为了修正 __nobjs</span></span><br><span class="line">                    <span class="keyword">return</span> (_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// 注意：任何剩余碎片最终都会被加入到合适的自由链表中备用</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 所有自由链表都无可用内存时的最后处理手段</span></span><br><span class="line">            _S_end_free = <span class="literal">nullptr</span>;    <span class="comment">// 异常安全处理</span></span><br><span class="line">            _S_start_free = (<span class="keyword">char</span> *) malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);    <span class="comment">// 调用一级空间配置器分配内存（可能会抛出OOM异常）</span></span><br><span class="line">            <span class="comment">// 此处假设分配操作总会成功（要么抛出异常，要么解决问题）</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新内存池管理参数</span></span><br><span class="line">        _S_heap_size += __bytes_to_get;    <span class="comment">// 累计分配的内存总量</span></span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get;    <span class="comment">// 设置新的内存池结束位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用自身，为了修正 __nobjs（此时内存池已有新申请的内存块）</span></span><br><span class="line">        <span class="keyword">return</span> (_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定义类型</span></span><br><span class="line"><span class="keyword">using</span> default_alloc = __default_alloc_template&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间配置器的接口，符合 STL 规范，按元素的大小分配内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simple_alloc</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定义类型</span></span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">simple_alloc</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">simple_alloc</span><span class="params">(<span class="keyword">const</span> simple_alloc &amp;)</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _U, class _Other&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="title">simple_alloc</span><span class="params">(<span class="keyword">const</span> simple_alloc&lt;_U, _Other&gt; &amp;)</span> <span class="keyword">noexcept</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="literal">nullptr</span> : (T *) Alloc::<span class="built_in">allocate</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) Alloc::<span class="built_in">allocate</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) {</span><br><span class="line">            Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（利用可变参数模板 + 引用折叠 + 完美转发）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *__p, Args &amp;&amp;... args)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(__p) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *__p)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存析构对象</span></span><br><span class="line">        __p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><ul><li><code>main.cpp</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"allocator.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deepCopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (source) {</span><br><span class="line">            name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(source) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name, source);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            name = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> age) : <span class="built_in">age</span>(age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person(name, age)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">deepCopy</span>(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;other) : <span class="built_in">age</span>(other.age) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person(const Person&amp;)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">deepCopy</span>(other.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符</span></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Person &amp;other) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Person&amp; operator=(const Person&amp;)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) {</span><br><span class="line">            <span class="comment">// 先释放原有内存</span></span><br><span class="line">            <span class="keyword">delete</span>[] name;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拷贝新数据</span></span><br><span class="line">            age = other.age;</span><br><span class="line">            <span class="built_in">deepCopy</span>(other.name);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; (name ? name : <span class="string">"[Unnamed]"</span>) &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试基础类型的内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 SGI STL 二级空间配置器</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>, simple_alloc&lt;<span class="keyword">int</span>, default_alloc&gt;&gt; vec1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        vec1.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;item : vec1) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试自定义类型的内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用 SGI STL 二级空间配置器</span></span><br><span class="line">    vector&lt;Person, simple_alloc&lt;Person, default_alloc&gt;&gt; vec2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不想频繁触发容器扩容，可以强制指定容器的预留容量</span></span><br><span class="line">    <span class="comment">// vec2.reserve(5);</span></span><br><span class="line"></span><br><span class="line">    vec2.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">"Jim"</span>, <span class="number">18</span>));</span><br><span class="line">    vec2.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">"Peter"</span>, <span class="number">23</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec2.<span class="built_in">begin</span>(); it != vec2.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        it-&gt;<span class="built_in">display</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试代码运行的输出结果</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3 4 1 8 8 5 10 1 8 8 </span><br><span class="line">Person(name, age)           // 构造临时对象 Jim</span><br><span class="line">Person(const Person&amp;)       // push_back 时拷贝临时对象 Jim 进容器</span><br><span class="line">~Person()                   // 析构临时对象 Jim</span><br><span class="line">Person(name, age)           // 构造临时对象 Peter</span><br><span class="line">Person(const Person&amp;)       // push_back 时触发容器扩容后，拷贝容器已有元素 Jim 到新容器中</span><br><span class="line">Person(const Person&amp;)       // push_back 时触发容器扩容后，拷贝临时对象 Peter 到新容器中</span><br><span class="line">~Person()                   // 析构旧容器中的对象 Jim</span><br><span class="line">~Person()                   // 析构临时对象 Peter</span><br><span class="line">Name: Jim, Age: 18</span><br><span class="line">Name: Peter, Age: 23</span><br><span class="line">~Person()                   // 析构新容器中的对象 Jim</span><br><span class="line">~Person()                   // 析构新容器中的对象 Peter</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a target="_blank" rel="external nofollow" href="https://blog.51cto.com/u_16099355/10572558">容器内存分析 STL 容器内存分配</a></li><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/wofeishenling/articles/17702398.html">SGI STL 二级空间配置器内存池源码</a></li><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/fortunely/p/16219743.html">SGI STL 空间配置器 allocator /alloc</a></li><li><a target="_blank" rel="external nofollow" href="https://blog.csdn.net/mmshixing/article/details/51672434">SGI STL 空间配置器 - 第二级空间配置器</a></li><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/712899055">高效利用内存资源：掌握内存池设计与实现</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/712a574b.html" title="SGI STL 内存池源码剖析">https://www.techgrow.cn/posts/712a574b.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a><a href="/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> 源码剖析</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/73b8af5d.html" rel="prev" title="C++ 算法入门教程之一"><i class="fa fa-angle-left"></i> C++ 算法入门教程之一</a></div><div class="post-nav-item"> <a href="/posts/585aa296.html" rel="next" title="基于 C++ 手写线程池">基于 C++ 手写线程池<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.8m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">27:17</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/712a574b.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>