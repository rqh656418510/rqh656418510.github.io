<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 SGI STL 内存池的底层源码。"><meta property="og:type" content="article"><meta property="og:title" content="SGI STL 内存池源码浅析"><meta property="og:url" content="https://www.techgrow.cn/posts/712a574b.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 SGI STL 内存池的底层源码。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-1.png"><meta property="article:published_time" content="2025-04-18T13:55:33.000Z"><meta property="article:modified_time" content="2025-04-18T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta property="article:tag" content="源码剖析"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/04/sgi-stl-2.png"><link rel="canonical" href="https://www.techgrow.cn/posts/712a574b.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/712a574b.html","path":"posts/712a574b.html","title":"SGI STL 内存池源码浅析"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>SGI STL 内存池源码浅析 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD"><span class="nav-text">源码下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90"><span class="nav-text">书籍推荐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SGI-STL"><span class="nav-text">SGI STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-text">概念介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#STL-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">STL 的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SGI-STL-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">SGI STL 是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SGI-STL-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-text">SGI STL 的主要特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SGI-STL-%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BD%9C%E7%94%A8"><span class="nav-text">SGI STL 的历史作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SGI-STL-%E4%B8%8E-C-STL-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">SGI STL 与 C++ STL 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8"><span class="nav-text">自由链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">自由链表是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">自由链表的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9D%97%E7%B2%92%E5%BA%A6%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-text">内存块粒度与分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84"><span class="nav-text">自由链表节点结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">自由链表的存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-text">内存分配策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-text">内存回收策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-text">源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89"><span class="nav-text">空间配置器的相关定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">重要类型和变量的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E8%BE%85%E5%8A%A9%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-text">重要的辅助接口函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="nav-text">内存池管理核心函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93%E8%AF%B4%E6%98%8E"><span class="nav-text">内存池管理总结说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">691</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/712a574b.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="SGI STL 内存池源码浅析 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 SGI STL 内存池的底层源码。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> SGI STL 内存池源码浅析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-04-18 21:55:33" itemprop="dateCreated datePublished" datetime="2025-04-18T21:55:33+08:00">2025-04-18</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/712a574b.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/712a574b.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.6k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>4 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/5bc5018f.html">Nginx 内存池源码浅析</a></li><li><a href="/posts/712a574b.html">SGI STL 内存池源码浅析</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 SGI STL 二级空间配置器中的内存池实现，并解析其底层原理。</p><div class="admonition note"><p class="admonition-title">C++ 常见的池</p><p>在 C++ 中，常见的池有四种，包括内存池、连接池、线程池、进程池。</p></div><span id="more"></span><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><ul><li><a href="../../../downloads/2025/05/sgi-stl.zip">SGI STL 源码下载</a></li></ul><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><ul><li><a href="#">《STL 源码剖析》 第二章 - 空间配置器（allocator）</a></li></ul><h2 id="SGI-STL"><a href="#SGI-STL" class="headerlink" title="SGI STL"></a>SGI STL</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><h4 id="STL-的实现"><a href="#STL-的实现" class="headerlink" title="STL 的实现"></a>STL 的实现</h4><p>除了 C++ STL 之外，常见的第三方 STL（标准模板库）实现有以下几种：</p><ul><li><p><strong>RW STL（Rogue Wave STL）</strong></p><ul><li>开发者：<ul><li>Rogue Wave Software 公司（后被 Perforce 收购）</li></ul></li><li>性质：<ul><li>商业版本的 C++ 标准模板库实现</li></ul></li><li>代表产品：<ul><li>作为 SourcePro C++ 产品的一部分提供（包含 STL、线程库、网络库、数据库访问库等）</li></ul></li><li>产品特点：<ul><li>遵循 ISO C++ 标准</li><li>跨平台，适配多种操作系统和编译器</li><li>提供高级调试、异常安全、多线程支持</li><li>可配置性强，适用于嵌入式和大型系统</li></ul></li><li>应用场景：<ul><li>金融系统、通信系统、嵌入式开发、航空航天、政府项目等对可靠性要求高的场景</li></ul></li></ul></li><li><p> <strong>PJ STL（Dinkumware STL）</strong></p><ul><li>开发者：<ul><li>P. J. Plauger（C++ 标准委员会成员），其自己公司 Dinkumware 提供支持</li></ul></li><li>性质：<ul><li>商业版本的 C++ 标准模板库实现</li></ul></li><li>代表使用者：<ul><li>Microsoft Visual C++（尤其是 VC++ 6 及后续版本）默认使用 PJ STL</li></ul></li><li> 特点：<ul><li>遵循 ISO C++ 标准</li><li>接口稳定、实现清晰，强调工程实用性</li><li>提供 STL、C 标准库（如 <code>&lt;cmath&gt;</code>，<code>&lt;cstdlib&gt;</code>）、TR1 和部分 C++ 11 / 14 特性</li></ul></li><li>优势：<ul><li>商业支持</li><li>与微软编译器深度集成</li><li>重视可移植性和性能</li></ul></li><li>局限：<ul><li>并非开源，文档和源代码可见性有限</li></ul></li></ul></li><li><p> <strong>SGI STL（Silicon Graphics STL）</strong></p><ul><li>开发者：<ul><li>Alexander Stepanov（STL 之父）、Meng Lee 等人在 SGI（Silicon Graphics Inc.）公司开发</li></ul></li><li>性质：<ul><li>最早公开发布的 STL 实现之一，并作为学习范例广泛传播</li></ul></li><li>特点：<ul><li>完全开源，源码可读性和学习性极强</li><li>强调泛型编程、模板技巧和性能优化</li><li>提供了 <code>allocator</code>、<code>traits</code>、<code>function object</code>、<code>iterator</code> 等先进设计</li></ul></li><li>贡献：<ul><li>为后来的标准库实现（如 GCC 的 libstdc++）提供了基础</li><li>推动了 STL 的工业化、模块化和标准化</li></ul></li><li>现状：<ul><li>虽然已经不再更新，但作为教学和研究材料仍具重要历史价值</li></ul></li></ul></li></ul><blockquote><p>STL 实现的总结对比表</p></blockquote><table><thead><tr><th>名称</th><th>开发者</th><th>是否开源</th><th>典型应用</th><th>特点描述</th></tr></thead><tbody><tr><td> RW STL</td><td>Rogue Wave Software</td><td>❌ 商业版</td><td>金融、嵌入式、政府、工业系统</td><td>工程化程度高，稳定性强，附带调试与多线程支持，属于 SourcePro C++ 一部分</td></tr><tr><td> PJ STL</td><td>P. J. Plauger / Dinkumware</td><td>❌ 商业版</td><td> Visual C++、商业工具链</td><td>工程稳健，兼容性好，被微软 Visual Studio 多版本采用</td></tr><tr><td> SGI STL</td><td>Alexander Stepanov / SGI</td><td>✅ 开源</td><td>教育、研究、GCC libstdc++ 原型</td><td>泛型编程示范，模板设计前沿，影响广泛</td></tr></tbody></table><h4 id="SGI-STL-是什么"><a href="#SGI-STL-是什么" class="headerlink" title="SGI STL 是什么"></a>SGI STL 是什么</h4><p>SGI STL 是由 Alexander Stepanov 和 Meng Lee 等人在 SGI（Silicon Graphics Inc.）公司开发的 C++ 标准模板库实现，最早出现在 1990 年代。这个库实现了 STL 的核心思想：泛型编程与容器 - 算法 - 迭代器模型。<strong>SGI STL 包含了一级空间配置器和二级空间配置器，其中一级空间配置器 <code>allocator</code> 采用 <code>malloc()</code> 和 <code>free()</code> 来管理内存，和 C++ 标准模板库（STL）中提供的 <code>allocator</code> 是一样的，但其二级空间配置器 <code>allocator</code> 采用了基于自由链表（Free List）原理的内存池机制来实现内存管理，可以避免小内存频繁申请和释放导致的内存碎片问题。</strong></p><div class="admonition warning"><p class="admonition-title">STL 空间配置器的作用</p><ul><li>在 C++ STL 中，空间配置器（<code>allocator</code>）的作用主要有两种：</li><li>(1) 分离了对象的内存开辟和对象的构造。</li><li>(2) 分离了对象的析构和对象的内存释放。</li></ul></div><h4 id="SGI-STL-的主要特性"><a href="#SGI-STL-的主要特性" class="headerlink" title="SGI STL 的主要特性"></a>SGI STL 的主要特性</h4><ul><li>提供了 STL 的主要组件：<code>vector</code>、<code>list</code>、<code>map</code>、<code>set</code>、<code>algorithm</code>、<code>iterator</code> 等。</li><li>包含一些非标准扩展，例如：<ul><li><code>slist</code>（单向链表）</li><li><code>hash_map</code> / <code>hash_set</code>（后来的 <code>unordered_map</code> / <code>unordered_set</code> 的前身）</li></ul></li><li>代码高度模板化、效率高、注释详尽。</li><li>源码开放，很多 C++ 开发者都用它来学习 STL 的底层实现。</li></ul><h4 id="SGI-STL-的历史作用"><a href="#SGI-STL-的历史作用" class="headerlink" title="SGI STL 的历史作用"></a>SGI STL 的历史作用</h4><p>SGI STL 是 现代 C++ STL 的原型，其思想和实现对 C++ 98 标准 STL 的设计有极大影响。许多早期编译器，如 GCC、MSVC、Intel C++，都在某个时期采用过 SGI STL 或其变种（比如 STLport）。</p><div class="admonition note"><p class="admonition-title">今天还需要使用 SGI STL 吗</p><ul><li>通常不需要使用 SGI STL，因为现代 C++ 编译器都自带符合标准的 STL 实现，比如 GCC：libstdc++、Clang：libc++、MSVC：Dinkumware。</li><li>如果是为了学习 STL 的内部实现机制（底层原理），SGI STL 是一个非常好的教学资源；但在生产环境中，应该使用现代 C++ STL（标准模板库）。</li></ul></div><h4 id="SGI-STL-与-C-STL-的区别"><a href="#SGI-STL-与-C-STL-的区别" class="headerlink" title="SGI STL 与 C++ STL 的区别"></a>SGI STL 与 C++ STL 的区别</h4><table><thead><tr><th>项目</th><th> SGI STL</th><th>C++ STL（标准模板库）</th></tr></thead><tbody><tr><td>作者 / 出处</td><td> SGI 公司（如 STLport）</td><td>C++ 标准委员会</td></tr><tr><td>标准性</td><td>非正式实现，非标准的一些扩展</td><td>从 C++ 98 开始，成为标准 C++ 的一部分</td></tr><tr><td>扩展内容</td><td><code>hash_map</code>、<code>slist</code>、<code>rope</code> 等非标准组件</td><td>标准化容器如 <code>vector</code>、<code>deque</code>、<code>map</code>、<code>set</code> 等</td></tr><tr><td>可移植性</td><td>与平台、编译器耦合程度较高</td><td>作为标准模板库，各主流编译器都支持</td></tr><tr><td>现代兼容性</td><td>不支持 C++ 11 及以后的特性</td><td>现代 STL 持续演进（如 <code>move semantics</code>, <code>unordered_map</code>, <code>ranges</code> 等）</td></tr><tr><td>教育价值</td><td>非常适合学习 STL 实现机制</td><td>通常以黑箱方式使用</td></tr></tbody></table><h3 id="自由链表"><a href="#自由链表" class="headerlink" title="自由链表"></a>自由链表</h3><p>这里将介绍 SGI STL 二级空间配置器中自由链表的底层实现。</p><h4 id="自由链表是什么"><a href="#自由链表是什么" class="headerlink" title="自由链表是什么"></a>自由链表是什么</h4><p>自由链表是一种用于管理空闲内存块的链表结构。每个链表节点指向一个未被使用的内存块，便于快速分配和回收。在 SGI STL 的二级空间配置器中，自由链表有以下特点：</p><ul><li>每种固定大小的内存块（如 8 字节、16 字节、24 字节 …）都有一个对应的自由链表。</li><li>小对象内存块的复用：当用户释放内存时，并不会直接 <code>free()</code>，而是将内存放回对应的自由链表中，供后续复用。</li><li>分配内存时，优先从自由链表中取；只有自由链表为空时，才会从系统堆（Heap）分配一大块内存进行切分。</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>数量</td><td> 16 个自由链表（按 8 ~ 128 字节分为 16 类）</td></tr><tr><td>数据结构</td><td><code>union obj</code> 实现链表节点</td></tr><tr><td>分配策略</td><td>优先从自由链表取，否则从堆中批量 <code>refill()</code></td></tr><tr><td>回收策略</td><td>小块内存回收到对应的自由链表，大块内存直接释放</td></tr><tr><td>性能优势</td><td>避免频繁 <code>malloc</code> / <code>free</code>，显著减少内存碎片和内存开辟 / 释放的开销</td></tr></tbody></table><h4 id="自由链表的实现"><a href="#自由链表的实现" class="headerlink" title="自由链表的实现"></a>自由链表的实现</h4><p><img data-src="../../../asset/2025/04/sgi-stl-2.png"></p><h5 id="内存块粒度与分类"><a href="#内存块粒度与分类" class="headerlink" title="内存块粒度与分类"></a>内存块粒度与分类</h5><ul><li>内存块的粒度信息</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__)</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_ALIGN = <span class="number">8</span>};            <span class="comment">// 内存对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_MAX_BYTES = <span class="number">128</span>};      <span class="comment">// 二级空间配置器最大管理范围（128 字节）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_NFREELISTS = <span class="number">16</span>};      <span class="comment">// _MAX_BYTES/_ALIGN，自由链表的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>一共维护 16 个自由链表，每个自由链表负责管理一种字节大小的内存块：</li></ul><table><thead><tr><th>自由链表的下标</th><th>内存块的大小</th></tr></thead><tbody><tr><td> 0</td><td>8 字节</td></tr><tr><td> 1</td><td>16 字节</td></tr><tr><td> 2</td><td>24 字节</td></tr><tr><td>…</td><td>…</td></tr><tr><td>15</td><td>128 字节</td></tr></tbody></table><h5 id="自由链表节点结构"><a href="#自由链表节点结构" class="headerlink" title="自由链表节点结构"></a>自由链表节点结构</h5><ul><li>每个空闲内存块都可以看作是一个 <code>_Obj</code>，其中 <code>_M_free_list_link</code> 用来链接空闲内存块（最终形成自由链表）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];     <span class="comment">// 实际分配给用户的数据起始位置</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="自由链表的存储结构"><a href="#自由链表的存储结构" class="headerlink" title="自由链表的存储结构"></a>自由链表的存储结构</h5><ul><li>这个数组保存了每种块大小的链表头指针</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS];  <span class="comment">// 16 个自由链表</span></span><br></pre></td></tr></tbody></table></figure><h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><ul><li>当调用 <code>allocate(n)</code>：<ul><li>如果 <code>n &gt; 128</code>，则交由一级空间配置器（直接调用 <code>malloc()</code> 分配内存）。</li><li>否则：<ul><li>(1) 将 <code>n</code> 向上对齐到 8 的倍数。</li><li>(2) 找到对应的自由链表索引。</li><li>(3) 如果该链表非空，从中取一个空闲块返回。</li><li>(4) 如果链表为空，调用 <code>refill()</code> 从堆上批量分配一大块内存（默认分配 20 个块），挂到自由链表上。</li></ul></li></ul></li></ul><h5 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h5><ul><li>当调用 <code>deallocate(p, n)</code>：<ul><li>如果 <code>n &gt; 128</code>，直接调用 <code>free(p)</code> 释放内存。</li><li>否则：<ul><li>(1) 将 <code>n</code> 向上对齐。</li><li>(2) 找到对应自由链表。</li><li>(3) 把块头强制转换为 <code>obj*</code>，插入到自由链表头部。</li></ul></li></ul></li></ul><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><h4 id="空间配置器的相关定义"><a href="#空间配置器的相关定义" class="headerlink" title="空间配置器的相关定义"></a>空间配置器的相关定义</h4><ul><li><code>vector</code> 容器类的定义</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> :</span> <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt; { }</span><br></pre></td></tr></tbody></table></figure><ul><li><code>vector</code> 容器的默认空间配置器是 <code>__STL_DEFAULT_ALLOCATOR( _Tp)</code>，它是一个宏定义，如下：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) allocator<span class="meta-string">&lt; T &gt;</span>   <span class="comment">// 使用标准 STL allocator（一级空间配置器）</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) alloc            <span class="comment">// 使用 SGI alloc（二级空间配置器）</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>从上面可以看到 <code>__STL_DEFAULT_ALLOCATOR</code> 通过宏控制有两种空间配置器实现，一种是 <code>allocator&lt;T&gt;</code>，另一种是 <code>alloc</code>，这两种分别就是 SGI STL 的一级空间配置器和二级空间配置器的实现</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span>           // 一级空间配置器内存管理类（底层通过 <span class="title">malloc</span> 和 <span class="title">free</span> 管理内存）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> {</span> }      <span class="comment">// 二级空间配置器内存管理类（底层通过自定义内存池实现内存管理）</span></span><br></pre></td></tr></tbody></table></figure><ul><li>SGI STL 的一级和二级空间配置器对比</li></ul><table><thead><tr><th>类型</th><th>实现类</th><th>机制</th><th>用途</th></tr></thead><tbody><tr><td>一级空间配置器</td><td><code>__malloc_alloc_template</code></td><td><code>malloc / free</code></td><td>大块内存分配</td></tr><tr><td>二级配置器</td><td><code>__default_alloc_template</code></td><td>内存池机制</td><td>小块内存高效分配，其核心机制就是使用一组自由链表（Free List）来管理内存块，提高小对象（小于等于 128 字节）的内存分配效率</td></tr></tbody></table><h4 id="重要类型和变量的定义"><a href="#重要类型和变量的定义" class="headerlink" title="重要类型和变量的定义"></a>重要类型和变量的定义</h4><p>在 SGI STL 的二级空间配置器（<code>__default_alloc_template</code>）中，有以下重要类型和变量定义，其底层的自由链表节点结构如下图所示：</p><p><img data-src="../../../asset/2025/04/sgi-stl-1.png"></p><ul><li>内存池的粒度信息</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__)</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_ALIGN = <span class="number">8</span>};            <span class="comment">// 内存对齐粒度（每次分配 8 字节的倍数）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_MAX_BYTES = <span class="number">128</span>};      <span class="comment">// 二级分配器最大管理范围（128 字节）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> {</span>_NFREELISTS = <span class="number">16</span>};      <span class="comment">// _MAX_BYTES/_ALIGN，自由链表的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>每一个内存 chunk 块的头信息</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>组织所有自由链表的数组，数组的每一个元素的类型都是 <code>_Obj*</code>，全部初始化为 <code>0</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br></pre></td></tr></tbody></table></figure><ul><li>记录内存 chunk 块的分配情况</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk allocation state.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="重要的辅助接口函数"><a href="#重要的辅助接口函数" class="headerlink" title="重要的辅助接口函数"></a>重要的辅助接口函数</h4><ul><li>将 <code>__bytes</code> 上调至最邻近的 8 的倍数</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>返回 <code>__bytes</code> 大小的 chunk 块位于 <code>free-list</code> 中的编号</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) {</span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理核心函数"><a href="#内存池管理核心函数" class="headerlink" title="内存池管理核心函数"></a>内存池管理核心函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配内存的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责把分配好的chunk块进行连接，添加到自由链表当中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配相应内存字节大小的chunk块，并且给下面三个成员变量初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把chunk块归还到内存池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池扩容函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理总结说明"><a href="#内存池管理总结说明" class="headerlink" title="内存池管理总结说明"></a>内存池管理总结说明</h4><p>SGI STL 二级空间配置器中内存池的实现优点如下：</p><ul><li><p><strong>内存分配具有预留机制</strong></p><ul><li>对于每种特定字节大小的 chunk（内存块）分配，内存池并不会仅分配刚好所需的内存，而是会一次性申请较大一块内存，并将其划分为多个 chunk。其中一部分立即用于分配，另一部分作为备用，供后续相同字节大小的分配请求使用。更重要的是，如果其他字节大小的 chunk 分配失败，这部分备用内存也有可能被重新划分后用于其他字节大小的 chunk 分配请求，从而提升内存使用的灵活性与效率。</li></ul></li><li><p><strong>最大化利用碎片内存</strong></p><ul><li>在将一大块备用内存划分为若干 chunk 后，可能会剩下一小部分无法完整划分的内存碎片。SGI STL 会在后续分配中尽可能再次利用这些内存碎片，避免资源浪费，确保备用内存池被 “用得干干净净”。</li></ul></li><li><p><strong>具有健壮的回退机制</strong></p><ul><li>当某一特定字节大小的内存块分配失败时，二级空间配置器会遍历所有字节大小的自由链表，查找是否有可用的空闲 chunk 块可暂时 “借用”。如果发现其他链表中有空闲的 chunk 块，就会将其临时分配出去，以缓解当前内存分配压力。如果其他链表中没有空闲的 chunk 块可以借用，就会直接调用 <code>malloc()</code> 继续分配内存空间。</li></ul></li><li><p><strong>支持 OOM 回调机制</strong></p><ul><li>如果其他自由链表中没有空闲的 chunk 块可以借，且调用 <code>malloc()</code> 分配内存失败，二级空间配置器将尝试调用用户预设的 <code>oom_handler</code> 回调函数（可以用于释放用户自定义的内存资源），以应对 <code>malloc()</code> 执行失败的情况（在死循环中处理）。若用户未设置 <code>oom_handler</code> 回调函数，则直接抛出 OOM（Out Of Memory）异常，提示内存分配失败，确保程序行为的可控性和安全性。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a target="_blank" rel="external nofollow" href="https://blog.51cto.com/u_16099355/10572558">容器内存分析 STL 容器内存分配</a></li><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/wofeishenling/articles/17702398.html">SGI STL 二级空间配置器内存池源码</a></li><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/fortunely/p/16219743.html">SGI STL 空间配置器 allocator /alloc</a></li><li><a target="_blank" rel="external nofollow" href="https://blog.csdn.net/mmshixing/article/details/51672434">SGI STL 空间配置器 - 第二级空间配置器</a></li><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/712899055">高效利用内存资源：掌握内存池设计与实现</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/712a574b.html" title="SGI STL 内存池源码浅析">https://www.techgrow.cn/posts/712a574b.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a><a href="/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> 源码剖析</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/73b8af5d.html" rel="prev" title="C++ 算法入门教程之一"><i class="fa fa-angle-left"></i> C++ 算法入门教程之一</a></div><div class="post-nav-item"> <a href="/posts/5bc5018f.html" rel="next" title="Nginx 内存池源码浅析">Nginx 内存池源码浅析<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.8m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">27:06</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/712a574b.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>