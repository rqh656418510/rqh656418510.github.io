<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Java 中的 AQS，包括 AQS 的介绍与源码深度剖析。"><meta property="og:type" content="article"><meta property="og:title" content="Java 多线程编程之五 AQS 底层源码深度剖析"><meta property="og:url" content="https://www.techgrow.cn/posts/d9aa9f1f.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 Java 中的 AQS，包括 AQS 的介绍与源码深度剖析。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-6.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-7.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-8.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-5.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-9.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-10.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-11.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-12.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-13.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-14.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-15.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-16.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-20.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-17.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-18.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-19.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-21.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-22.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-23.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-25.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-26.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-27.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-28.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-29.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-30.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-31.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-32.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-33.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-34.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-35.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-36.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-37.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-38.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-41.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-39.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-40.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-43.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-42.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-44.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-45.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-46.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-47.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-48.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-49.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-50.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-51.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-52.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-53.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-54.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-56.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-55.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-57.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-58.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-59.png"><meta property="article:published_time" content="2022-08-03T14:34:42.000Z"><meta property="article:modified_time" content="2022-08-03T14:34:42.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Java"><meta property="article:tag" content="并发编程"><meta property="article:tag" content="源码剖析"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2024/03/juc-aqs-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/d9aa9f1f.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/d9aa9f1f.html","path":"posts/d9aa9f1f.html","title":"Java 多线程编程之五 AQS 底层源码深度剖析"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java 多线程编程之五 AQS 底层源码深度剖析 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-text">AQS 的概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">AQS 的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="nav-text">AQS 的核心类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-%E7%9A%84%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90"><span class="nav-text">AQS 的源码浅析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-%E7%9A%84%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90"><span class="nav-text">AQS 的源码深度剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E-ReentrantLock-%E5%89%96%E6%9E%90-AQS"><span class="nav-text">从 ReentrantLock 剖析 AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90-AQS-%E7%9A%84%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81"><span class="nav-text">深度剖析 AQS 的底层源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lock"><span class="nav-text">lock()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acquire"><span class="nav-text">acquire()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tryAcquire"><span class="nav-text">tryAcquire()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addWaiter"><span class="nav-text">addWaiter()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acquireQueued"><span class="nav-text">acquireQueued()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unlock"><span class="nav-text">unlock()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">AQS 高频面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80"><span class="nav-text">高频面试题一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C"><span class="nav-text">高频面试题二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">AQS 源码解读流程图</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">690</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/d9aa9f1f.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java 多线程编程之五 AQS 底层源码深度剖析 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 Java 中的 AQS，包括 AQS 的介绍与源码深度剖析。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Java 多线程编程之五 AQS 底层源码深度剖析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-08-03 22:34:42" itemprop="dateCreated datePublished" datetime="2022-08-03T22:34:42+08:00">2022-08-03</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/d9aa9f1f.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/d9aa9f1f.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>8.1k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>7 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/5bbede3c.html">Java 多线程编程之一 Java 内存模型浅析</a></li><li><a href="/posts/f7ed7888.html">Java 多线程编程之二 synchronize 锁对象竞争</a></li><li><a href="/posts/ed2e098d.html">Java 多线程编程之三 volatile 与 JMM 内存模型</a></li><li><a href="/posts/3b82844a.html">Java 多线程编程之四 CAS、ABA 问题、锁</a></li><li><a href="/posts/d9aa9f1f.html">Java 多线程编程之五 AQS 底层源码深度剖析</a></li><li><a href="/posts/1f270e10.html">Java 多线程编程之六集合类的线程安全问题</a></li><li><a href="/posts/f7fd0987.html">Java 多线程编程之七队列、线程池、线程通信</a></li><li><a href="/posts/4a0f41c0.html">Java 多线程编程之八 Fork/Join 框架使用</a></li><li><a href="/posts/d016a303.html">Java 多线程编程之九 ThreadLocal 使用</a></li></ul><h2 id="AQS-的概述"><a href="#AQS-的概述" class="headerlink" title="AQS 的概述"></a>AQS 的概述</h2><p>AQS (AbstractQueuedSynchronizer) 的字面意思是 “抽象队列同步器”。在一般情况下，AQS 指的是 <code>java.util.concurrent.locks</code> 包下的 <code>AbstractQueuedSynchronizer</code> 类，但其实还有另外两种抽象队列同步器：<code>AbstractOwnableSynchronizer</code>、<code>AbstractQueuedLongSynchronizer</code>。AQS 是用来构建锁或者其他同步器组件的重量级基础框架及整个 JUC 体系的基石，通过内置的 FIFO 队列来完成资源获取线程的排队工作（如下图所示），并通过单个原子 <code>int</code> 类型变量表示持有锁的状态。<strong>简而言之，AQS = state 变量 + CLH 队列。</strong></p><span id="more"></span><p><img data-src="../../../asset/2024/03/juc-aqs-1.png"></p><h2 id="AQS-的作用"><a href="#AQS-的作用" class="headerlink" title="AQS 的作用"></a>AQS 的作用</h2><p>加锁就会导致线程阻塞，有阻塞就需要排队，实现排队必然需要有某种形式的队列来管理。简而言之，抢到资源的线程直接执行业务逻辑，抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程继续去等候（类似银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候），但等候线程仍然保留获取锁的可能且获取锁流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？<strong>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证分配。这个机制主要用的是 CLH 队列的变体实现，将暂时获取不到锁的线程加入到队列中，这个队列就是 AQS 的抽象表现。</strong>AQS 使用一个 <code>volatile</code> 的 <code>int</code> 类型的成员变量 <code>state</code> 来表示同步状态，通过内置的 FIFO 队列来完成资源获取的排队工作，将每个要去抢占资源的线程封装成队列的结点（Node）来实现锁的分配，通过 CAS、自旋以及 <code>LockSupport.park()</code> 的方式维护 <code>state</code> 变量的状态，使并发达到同步的控制效果。AQS 的整体工作流程如下图所示：</p><p><img data-src="../../../asset/2024/03/juc-aqs-3.png"></p><h2 id="AQS-的核心类"><a href="#AQS-的核心类" class="headerlink" title="AQS 的核心类"></a>AQS 的核心类</h2><ul><li><p>AQS 的核心类</p><ul><li>java.util.concurrent.locks.AbstractOwnableSynchronizer</li><li>java.util.concurrent.locks.AbstractQueuedLongSynchronizer</li><li>java.util.concurrent.locks.AbstractQueuedSynchronizer，简称 AQS</li></ul></li><li><p> 跟 AQS 相关的锁</p><ul><li>Semaphore (信号量锁)</li><li>CountDownLatch（闭锁）</li><li>CyclicBarrier（循环屏障锁）</li><li>ReentrantLock（可重入锁）</li><li>ReentrantReadWriteLock（读写锁）</li><li>……</li></ul></li><li><p> 锁和同步器的关系</p><ul><li>锁：面向锁的使用者，定义了程序员和锁交互的调用层 API，隐藏了实现细节，直接调用即可。</li><li>同步器：面向锁的实现者（设计者），比如 Java 并发大神 Douglee，提出统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知 / 唤醒机制等。</li></ul></li></ul><p><img data-src="../../../asset/2024/03/juc-aqs-4.png"></p><div class="admonition note"><p class="admonition-title">更多跟 AQS 相关的内容</p><ul><li>更多关于 AQS 与锁相关的内容请点击 <a href="../../../asset/2024/03/juc-aqs-2.png">这里</a> 查看。</li></ul></div><h2 id="AQS-的源码浅析"><a href="#AQS-的源码浅析" class="headerlink" title="AQS 的源码浅析"></a>AQS 的源码浅析</h2><blockquote><p>AbstractQueuedSynchronizer 类的源码注释</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-6.png"></p><p><img data-src="../../../asset/2024/03/juc-aqs-7.png"></p><blockquote><p>AbstractQueuedSynchronizer 类的源码剖析</p></blockquote><p>AQS 使用一个 <code>volatile</code> 的 <code>int</code> 类型的成员变量 <code>state</code> 来表示同步状态，通过内置的 FIFO 队列来完成资源获取的排队工作，将每个要去抢占资源的线程封装成队列的结点（Node）来实现锁的分配，通过 CAS、自旋以及 <code>LockSupport.park()</code> 的方式维护 <code>state</code> 变量的状态，使并发达到同步的控制效果。AQS 中的 Node 节点是什么呢？它类似 HashMap 的 Node 节点，JDK 用 <code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {}</code> 来封装传入的键值对。这里也是一样的道理，JDK 使用 Node 来封装（管理）Thread，可以将 Node 和 Thread 类比为候客区的椅子和等待办理业务的顾客。</p><p><img data-src="../../../asset/2024/03/juc-aqs-8.png"></p><blockquote><p>AQS 的内部体系架构图</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-5.png"></p><blockquote><p>AQS 的 CLH 队列</p></blockquote><p>CLH 队列是一种自旋锁队列，由 John Mellor-Crummey、Michael L. Scott 和 Thomas E. Anderson 三人在 1991 年提出。CLH 队列使用了一种无锁队列算法，被设计用来在多线程环境下管理共享资源的访问。与传统的自旋锁相比，CLH 队列提供了更好的性能和可伸缩性。它的实现原理是使用单向链表结构管理等待访问共享资源的线程，这些线程按照先来后到的顺序排队，等待释放锁。<strong>AQS 中的 CLH 队列是原 CLH 队列的一个变体，也就是 CLH 变体的虚拟双向队列 FIFO。</strong>简单来说，AQS 中的 CLH 队列由以下几个要素组成：</p><ul><li><strong>节点（Node）</strong>：每个等待锁的线程都会创建一个节点，用于表示其在队列中的位置。节点通常包含了线程状态等信息，以及指向前一个节点的引用。</li><li><strong>虚拟前驱（Dummy Head）</strong>：CLH 队列会使用一个虚拟的头节点来简化代码逻辑，使得每个节点都有一个前驱节点，避免了在队列为空时的特殊处理。</li><li><strong>自旋（Spin）</strong>：等待锁的线程会通过自旋的方式尝试获取锁，而不是进入睡眠状态，这样可以减少线程切换的开销。</li><li><strong>CAS 操作</strong>：CLH 队列通常使用 CAS（Compare and Swap）操作来实现节点的状态更新，以确保并发安全性。</li></ul><p><img data-src="../../../asset/2024/03/juc-aqs-9.png"></p><h2 id="AQS-的源码深度剖析"><a href="#AQS-的源码深度剖析" class="headerlink" title="AQS 的源码深度剖析"></a>AQS 的源码深度剖析</h2><h3 id="从-ReentrantLock-剖析-AQS"><a href="#从-ReentrantLock-剖析-AQS" class="headerlink" title="从 ReentrantLock 剖析 AQS"></a>从 ReentrantLock 剖析 AQS</h3><blockquote><p>Lock 接口的实现类，基本都是通过聚合了一个抽象队列同步器的子类来完成线程访问控制的。比如，ReentrantLock 实现了 Lock 接口，在 ReentrantLock 的内部聚合了一个 AbstractQueuedSynchronizer 的子类 Sync。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-10.png"></p><blockquote><p>ReentrantLock 在内部定义了多个静态内部类，其中有 NoFairSync（非公平锁）和 FairSync（公平锁）。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-11.png"></p><blockquote><p>ReentrantLock 的构造方法不传参数时，表示默认创建非公平锁；当参数为 <code>true</code>，表示创建公平锁；当参数为 <code>false</code> 表示创建非公平锁。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-12.png"></p><blockquote><p>在 ReentrantLock 内部，NoFairSync 和 FairSync 中 <code>tryAcquire()</code> 方法的区别如下，可以明显看出两者的唯一区别就在于公平锁在获取同步状态时多了一个限制条件 <code>!hasQueuedPredecessors()</code>。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-13.png"></p><blockquote><p>ReentrantLock 的 <code>hasQueuedPredecessors()</code> 方法，用于在公平锁获取锁时，判断等待队列中是否存在有效节点，也就是判断是否需要排队。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-14.png"></p><blockquote><p>由于公平锁在获取锁时比非公平锁多了一个判断 <code>!hasQueuedPredecessors()</code>，即判断是否需要排队，这导致公平锁和非公平锁的差异如下。</p></blockquote><ul><li>公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有其他线程在等待，那么当前线程就会进入等待队列中。</li><li>非公平锁：不管是否有等待队列，如果可以获取锁，则立刻抢占锁对象。也就是说，队列的第一个排队线程在 <code>unpark()</code>，之后还是需要竞争锁 (存在线程竞争的情况下)。</li></ul><blockquote><p>在创建完公平锁或者非公平锁后，执行 <code>lock()</code> 方法会进行加锁，最终都会执行到 <code>acquire()</code> 方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-15.png"></p><blockquote><p>最后 <code>acquire()</code> 方法会执行 <code>tryAcquire()</code> 方法，而在 NonfairSync 和 FairSync 中均重写了其父 AbstractQueuedSynchronizer 中的 <code>tryAcquire()</code> 方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-16.png"></p><h3 id="深度剖析-AQS-的底层源码"><a href="#深度剖析-AQS-的底层源码" class="headerlink" title="深度剖析 AQS 的底层源码"></a>深度剖析 AQS 的底层源码</h3><blockquote><p>这里举个例子，假设 A、B、C 三个人都要去银行窗口办理业务，但是银行窗口只有一个，下面使用 <code>ReentrantLock.lock()</code> 方法模拟这种业务场景。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过一个银行办理业务的案例来模拟 AQS 是如何进行线程管理和实现通知唤醒机制的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AQSDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3 个线程模拟 3 个顾客来银行网点的受理窗口办理业务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A 顾客就是第一个顾客，此时受理窗口没有任何人，A 可以直接去办理业务</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            ReentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"-----A thread come in"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.MINUTES.sleep(<span class="number">20</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个顾客，第二个线程 ---&gt; 由于受理业务的窗口只有一个 (只能有一个线程持有锁)，此时 B 只能进入候客区等待</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            ReentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"-----B thread come in"</span>);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三个顾客，第三个线程 ---&gt; 由于受理业务的窗口只有一个 (只能有一个线程持有锁)，此时 C 只能进入候客区等待</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            ReentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"-----C thread come in"</span>);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"C"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><blockquote><p>在执行 ReentrantLock 的构造方法时，没有传递参数，因此默认创建的是非公平锁，而且执行 <code>ReentrantLock.lock()</code> 方法最终都会执行 NonfairSync 重写后的 <code>lock()</code> 方法。第一次执行 <code>lock()</code> 方法时，<code>state</code> 变量的值等于 0，表示锁没有被占用。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-20.png"></p><blockquote><p>然后 <code>lock()</code> 方法会执行 <code>compareAndSetState(0, 1)</code> 方法进行 CAS 判断，可得 <code>state == expected == 0</code>，因此 CAS 操作执行成功，将 <code>state</code> 变量的值修改为 1。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-17.png"></p><blockquote><p>整个 CAS 修改过程会通过 Unsafe 提供的 <code>compareAndSwapInt()</code> 方法来保证修改操作的原子性。如果变量的值等于期望值，则修改变量的值为新值，并返回 <code>true</code>；若不相等，则直接返回 <code>false</code>。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-18.png"></p><blockquote><p>再来看看 <code>setExclusiveOwnerThread()</code> 方法，它负责将拥有锁的线程设置为当前线程（线程 A）。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-19.png"></p><p><img data-src="../../../asset/2024/03/juc-aqs-21.png"></p><blockquote><p>第二次执行 <code>lock()</code> 方法时，<code>state</code> 变量的值等于 1，表示锁已经被占用，此时执行 <code>compareAndSetState(0, 1)</code> 方法进行 CAS 判断，可得 <code>state != expected</code>，因此 CAS 操作执行失败，进入 <code>acquire()</code> 方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-22.png"></p><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h4><blockquote><p>在 <code>acquire()</code> 方法中，主要包含以下几个方法，下面会详细介绍每一个方法</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-23.png"></p><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h4><blockquote><p>在 <code>tryAcquire()</code> 方法中，为什么只抛了一个异常呢？这是 AbstractQueuedSynchronizer 抽象队列同步器中定义的方法，既然抛出了异常，就说明父类强制要求子类实现该方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-25.png"></p><blockquote><p>找到 <code>tryAcquire()</code> 方法在 AbstractQueuedSynchronizer 子类中的实现。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-26.png"></p><blockquote><p>这里以子类 NonfairSync 非公平锁为例，在 <code>tryAcquire()</code> 方法中执行了 <code>nonfairTryAcquire()</code> 方法，传入的参数是 1。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-27.png"></p><blockquote><p>在 <code>nonfairTryAcquire()</code> 方法中，大多数情况都是这样的执行流程：线程 B 执行 <code>int c = getState()</code> 时，获取到 <code>state</code> 变量的值为 1，表示锁正在被占用，于是执行 <code>c == 0</code> 发现条件不成立；接着执行下一个判断条件 <code>current == getExclusiveOwnerThread()</code>，current 线程为线程 B，而 <code>getExclusiveOwnerThread()</code> 方法返回的是正在占用锁的线程 A，因此 <code>tryAcquire()</code> 方法最后会返回 <code>false</code>，表示并没有抢占到锁。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-28.png"></p><blockquote><p>上面的 <code>getExclusiveOwnerThread()</code> 方法，返回的是正在占用锁的线程（Exclusive - 排他锁）。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-29.png"></p><blockquote><p><code>nonfairTryAcquire()</code> 方法有两种比较特殊的执行流程。第一种情况是，执行 <code>int c = getState()</code> 语句时，此时线程 A 恰好执行完成，释放出了锁，那么 <code>state</code> 变量的值为 0，当然发生这种情况的概率很小。那么线程 B 执行 CAS 操作成功后，将占用锁的线程修改为自己，然后返回 <code>true</code>，表示抢占锁成功。其实这里还有一种情况，需要留到 <code>unlock()</code> 方法执行时才能解释清楚。第二种情况为可重入锁的表现，假设 A 线程又再次抢占到锁（当然上述案例代码里面并没有体现出来），这时 <code>current == getExclusiveOwnerThread()</code> 条件成立，将 <code>state</code> 变量的值加上 <code>acquire</code>，这种情况也应该返回 <code>true</code>，表示线程 A 正在占用锁。因此，<code>state</code> 变量的值是可以大于 1 的。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-30.png"></p><blockquote><p>在 <code>tryAcquire()</code> 方法返回 <code>false</code> 之后，执行 <code>!</code> 操作后为 <code>true</code>，那么就会继续执行 <code>addWaiter()</code> 方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-31.png"></p><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h4><blockquote><p>这里的 <code>addWaiter()</code> 方法会先判断 <code>tail</code> 尾指针是否为空，如果为空，则执行 <code>enq(node)</code> 方法，将封装了线程 B 的 Node 节点加入到队列中。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-32.png"></p><blockquote><p>上面的 <code>end(node)</code> 方法，用于构建双端同步队列。在双端同步队列中，第一个节点为虚节点（也叫哨兵节点），它其实并不存储任何信息，只是占个位置。真正的第一个有数据的节点，是从第二个节点开始的。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-33.png"></p><blockquote><p>在 <code>end(node)</code> 方法中，第一次执行 <code>for</code> 循环：当线程 B 进来时，双端同步队列为空。由于 <code>tail == null</code>，先通过 <code>new Node()</code> 创建一个哨兵节点，然后将头指针指向哨兵节点。此时队列中只有一个节点，尾节点即是头节点，因此尾指针也指向该哨兵节点。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-34.png"></p><blockquote><p>在 <code>end(node)</code> 方法中，第二次执行 <code>for</code> 循环：将封装着线程 B 的节点放入双端同步队列中，此时 <code>tail</code> 尾指针指向了哨兵节点并不等于 <code>null</code>，以尾插法的方式，先将 <code>node</code>（装着线程 B 的节点）的 <code>prev</code> 指向之前的 <code>tail</code>，再通过 <code>compareAndSetTail(t, node)</code> 方法将 <code>node</code> 设置为尾节点，最后将 <code>t.next</code> 指向 <code>node</code>，最后执行 <code>return t</code> 结束 <code>for</code> 循环。注意，最后哨兵节点和 NodeB 节点的 <code>waitStatus</code> 都为 0，表示在等待队列中。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-35.png"></p><blockquote><p>最后看看线程 C（顾客 C）的执行流程，线程 C 和线程 B 的执行流程很类似，都是执行 <code>acquire()</code> 中的方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-36.png"></p><blockquote><p>但是在 <code>addWaiter()</code> 方法中，线程 C 的执行流程有些区别。由于 <code>tail != null</code>，因此在 <code>addWaiter()</code> 方法中就已经将 C 节点添加至队尾了。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-37.png"></p><blockquote><p>在执行 <code>addWaiter()</code> 方法时，会将节点 C 添加到双端同步队列的队尾，而且不需要再执行 <code>enq(node)</code> 方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-38.png"></p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h4><blockquote><p>当线程 B 执行完 <code>addWaiter()</code> 方法后，就会进入 <code>acquireQueued()</code> 方法中，此时传入的参数为封装了线程 B 的 NodeB 节点。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-41.png"></p><blockquote><p>在 <code>acquireQueued()</code> 方法中，两个 <code>if</code> 判断中的代码都是放在 <code>for( ; ; )</code> 中执行，这样可以实现自旋的操作。NodeB 节点的前驱结点为哨兵节点，因此 <code>final Node p = node.predecessor()</code> 执行完后，<code>p</code> 将指向哨兵节点。哨兵节点满足 <code>p == head</code> 条件，如果此时线程 B 执行 <code>tryAcquire(arg)</code> 方法尝试抢占锁还是失败了，那么就会执行后面 <code>if</code> 判断中的 <code>shouldParkAfterFailedAcquire()</code> 方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-39.png"></p><blockquote><p>在 <code>shouldParkAfterFailedAcquire()</code> 方法中，由于哨兵节点的 <code>waitStatus</code> 为 0，所以会通过 <code>compareAndSetWaitStatus()</code> 方法执行 CAS 操作，将哨兵节点的 <code>waitStatus</code> 修改为 <code>Node.SIGNAL</code>，即使将 <code>waitStatus</code> 修改为 -1。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-40.png"></p><blockquote><p>注意，<code>compareAndSetWaitStatus()</code> 方法会调用 UnSafe 类的 <code>compareAndSwapInt()</code> 来保证修改操作的原子性，虽然 <code>compareAndSwapInt()</code> 方法内无自旋操作，但是在 <code>acquireQueued()</code> 方法中的 <code>for( ; ; )</code> 能保证实现自旋的操作。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-43.png"></p><blockquote><p>执行完上述操作后，哨兵节点的 <code>waitStatus</code> 会被修改为 -1。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-42.png"></p><blockquote><p>执行完上述操作后，将退出 <code>if</code> 判断，又会重新进入 <code>for( ; ; )</code> 循环，此时第二次执行 <code>shouldParkAfterFailedAcquire()</code> 方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-44.png"></p><blockquote><p>由于哨兵节点的 <code>waitStatus</code> 已经被修改为 -1，因此在线程 B 第二次执行 <code>shouldParkAfterFailedAcquire()</code> 方法时会返回 <code>true</code>，导致会接着执行 <code>parkAndCheckInterrupt()</code> 方法；然后线程 B 调用 <code>park()</code> 方法后被阻塞，也就是不会继续往下执行，一直排队等待。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-45.png"></p><blockquote><p>线程 C 的执行流程：因为线程 C 最终也会执行 <code>LockSupport.park()</code> 方法，所以线程 C 最后也会被阻塞，进入等候区排队等待。</p></blockquote><div class="admonition note"><p class="admonition-title">总结</p><p>如果前驱节点的 <code>waitstatus</code> 是 SIGNAL (-1) 状态，那么 <code>shouldParkAfterFailedAcquire()</code> 方法会返回 <code>true</code>，当前线程会继续往下执行 <code>parkAndCheckInterrupt()</code> 方法，然后再执行 <code>park()</code> 方法将当前线程挂起。根据 <code>park()</code> 方法 API 描述，当前线程在两种情况下会恢复执行，第一种情况是被 <code>unpark</code>，第二种情况是被中断（interrupt）。如果是发生第二种情况（被中断），那么 <code>parkAndCheckInterrupt()</code> 方法会返回当前线程的中断状态。</p></div><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h4><blockquote><p>线程 A 调用 <code>ReentrantLock.unlock()</code> 方法，释放手上持有的锁。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-46.png"></p><blockquote><p>在 <code>ReentrantLock.unlock()</code> 方法中，调用了 <code>sync.release()</code> 方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-47.png"></p><blockquote><p>在 <code>sync.release()</code> 方法中，由于线程 A 即将释放锁，因此执行 <code>tryRelease()</code> 方法后会返回 <code>true</code>，表示锁释放成功。<code>head</code> 指针指向哨兵节点，并且满足 <code>if</code> 条件，可以继续执行 <code>unparkSuccessor()</code> 方法。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-48.png"></p><blockquote><p>在 <code>tryRelease()</code> 方法中，又是抛出了一个异常，继续查看 AbstractQueuedSynchronizer 子类的 <code>tryRelease()</code> 方法实现。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-49.png"></p><p><img data-src="../../../asset/2024/03/juc-aqs-50.png"></p><blockquote><p>由于线程 A 只加过一次锁，因此 <code>state</code> 的值为 1，传进来的参数 <code>release</code> 的值也为 1；满足 <code>c == 0</code> 条件，将 <code>free</code> 标志位设置为 <code>true</code>，表示当前锁已被释放；再将排他锁关联的线程设置为 <code>null</code>，表示当前没有任何线程占用锁。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-51.png"></p><blockquote><p>由于 <code>release()</code> 方法中获取到的头结点 <code>h</code> 为哨兵节点，而且哨兵节点的 <code>waitStatus</code> 为 -1，因此在 <code>unparkSuccessor()</code> 方法中可以通过 <code>compareAndSetWaitStatus()</code> 方法执行 CAS 操作，将哨兵节点的 <code>waitStatus</code> 设置为 0，并将哨兵节点的下一个节点 NodeB 获取出来，然后唤醒 NodeB 节点中封装的线程 B。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-52.png"></p><blockquote><p>执行完上述操作后，当前没有线程占用锁，哨兵节点的 <code>waitStatus</code> 被设置为 0，而且 <code>state</code> 的值也为 0（表示当前没有任何线程占用锁）。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-53.png"></p><hr><blockquote><p>杀个回马枪，继续看看线程 B 被唤醒之后的执行流程。首先返回到 <code>lock()</code> 方法的执行流程中来，线程 B 被 <code>unpark()</code> 之后将不再阻塞，继续往下执行。由于 线程 B 是被正常唤醒的，因此 <code>Thread.interrupted()</code> 方法的返回值为 <code>false</code>，表示线程 B 未被中断。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-54.png"></p><blockquote><p>然后返回到 <code>parkAndCheckInterrupt()</code> 方法的上一层 <code>acquireQueued()</code> 方法中来，此时锁未被占用，线程 B 再次执行 <code>tryAcquire()</code> 方法能够抢占到锁，并且将 <code>state</code> 变量的值设置为 1，表示该锁已经被占用。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-56.png"></p><blockquote><p>接着继续看看 <code>acquireQueued()</code> 方法中的 <code>setHead(node)</code> 方法。传入的节点为 NodeB，将头指针指向 NodeB 节点；将 NodeB 节点中封装的线程置为 <code>null</code>（因为线程 B 已经获取到锁）；NodeB 不再指向其前驱节点（哨兵节点）。这一切操作都是为了将 NodeB 节点作为新的哨兵节点。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-55.png"></p><blockquote><p>执行完 <code>setHead()</code> 方法后，整体状态如下图所示</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-57.png"></p><blockquote><p>最后将原来的哨兵节点的后驱节点设置为 <code>null</code>，之后原来的哨兵节点就会变成一个完全孤立的节点（会被 GC 回收），此时 NodeB 节点可以正式作为新的哨兵节点了。</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-58.png"></p><blockquote><p>执行完上述步骤后，整体状态如下图所示</p></blockquote><p><img data-src="../../../asset/2024/03/juc-aqs-59.png"></p><blockquote><p>线程 C 被唤醒之后，执行的也是类似的唤醒流程。</p></blockquote><h2 id="AQS-高频面试题"><a href="#AQS-高频面试题" class="headerlink" title="AQS 高频面试题"></a>AQS 高频面试题</h2><h3 id="高频面试题一"><a href="#高频面试题一" class="headerlink" title="高频面试题一"></a>高频面试题一</h3><blockquote><p>我相信你应该看过源码了，那么 AQS 里面有个变量叫 <code>state</code>，它的值有几种状态？</p></blockquote><ul><li><code>state</code> 变量有 3 种状态<ul><li><code>0</code>：表示锁没被占用</li><li><code>1</code>：表示锁被占用了</li><li><code>大于 1</code>：表示是可重入锁，比如 ReentrantLock 才有这状态</li></ul></li></ul><h3 id="高频面试题二"><a href="#高频面试题二" class="headerlink" title="高频面试题二"></a>高频面试题二</h3><blockquote><p>如果锁正在被占用，A、B 两个线程进来了以后，请问队列中总共有多少个 Node 节点？</p></blockquote><p>3 个节点，分别是哨兵节点、NodeA、NodeB。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="AQS-源码解读流程图"><a href="#AQS-源码解读流程图" class="headerlink" title="AQS 源码解读流程图"></a>AQS 源码解读流程图</h3><ul><li><a target="_blank" rel="external nofollow" href="https://www.processon.com/view/link/61a887c70e3e746f85f790d0">AQS 源码解读流程图</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/d9aa9f1f.html" title="Java 多线程编程之五 AQS 底层源码深度剖析">https://www.techgrow.cn/posts/d9aa9f1f.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 并发编程</a><a href="/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> 源码剖析</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/28df7196.html" rel="prev" title="Java 自动生成数据库文档"><i class="fa fa-angle-left"></i> Java 自动生成数据库文档</a></div><div class="post-nav-item"> <a href="/posts/ba04f364.html" rel="next" title="Java 微信支付开发入门教程">Java 微信支付开发入门教程<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.8m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">27:01</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/d9aa9f1f.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>