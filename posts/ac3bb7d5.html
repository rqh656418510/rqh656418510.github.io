<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 RabbitMQ 的使用教程。"><meta property="og:type" content="article"><meta property="og:title" content="RabbitMQ 入门教程之十一"><meta property="og:url" content="https://www.techgrow.cn/posts/ac3bb7d5.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 RabbitMQ 的使用教程。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-67.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-68.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-69.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-70.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-71.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-78.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-72.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-73.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-75.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-76.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-77.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-82.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-79.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-80.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-81.png"><meta property="article:published_time" content="2021-07-02T14:13:45.000Z"><meta property="article:modified_time" content="2021-07-02T14:13:45.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="微服务"><meta property="article:tag" content="消息队列"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/04/rabbitmq-67.png"><link rel="canonical" href="https://www.techgrow.cn/posts/ac3bb7d5.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/ac3bb7d5.html","path":"posts/ac3bb7d5.html","title":"RabbitMQ 入门教程之十一"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>RabbitMQ 入门教程之十一 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90"><span class="nav-text">学习资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E8%83%8C%E6%99%AF"><span class="nav-text">业务背景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ-Federated-%E6%8F%92%E4%BB%B6"><span class="nav-text">RabbitMQ Federated 插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD"><span class="nav-text">专业术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6"><span class="nav-text">安装插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-text">使用说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Federated-Exchagne"><span class="nav-text">Federated Exchagne</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="nav-text">版本说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-text">节点说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Exchange"><span class="nav-text">创建 Exchange</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0-Upstream"><span class="nav-text">添加 Upstream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E7%AD%96%E7%95%A5%EF%BC%88Policy%EF%BC%89"><span class="nav-text">添加策略（Policy）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%81%94%E9%82%A6%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-text">查看联邦交换机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%81%94%E9%82%A6%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-text">测试联邦交换机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Federated-Queue"><span class="nav-text">Federated Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-2"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-1"><span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E-1"><span class="nav-text">版本说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E8%AF%B4%E6%98%8E-1"><span class="nav-text">节点说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Queue"><span class="nav-text">创建 Queue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0-Upstream-1"><span class="nav-text">添加 Upstream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E7%AD%96%E7%95%A5%EF%BC%88Policy%EF%BC%89-1"><span class="nav-text">添加策略（Policy）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%81%94%E9%82%A6%E9%98%9F%E5%88%97"><span class="nav-text">查看联邦队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%81%94%E9%82%A6%E9%98%9F%E5%88%97"><span class="nav-text">测试联邦队列</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ-Shovel-%E6%8F%92%E4%BB%B6"><span class="nav-text">RabbitMQ Shovel 插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0%E4%BB%8B%E7%BB%8D"><span class="nav-text">概述介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6-1"><span class="nav-text">安装插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-2"><span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E-2"><span class="nav-text">版本说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E8%AF%B4%E6%98%8E-2"><span class="nav-text">节点说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-text">创建队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0-Shovel"><span class="nav-text">添加 Shovel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-Shovel"><span class="nav-text">查看 Shovel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-Shovel"><span class="nav-text">测试 Shovel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E8%AF%B4%E6%98%8E"><span class="nav-text">使用总结说明</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">736</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/ac3bb7d5.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="RabbitMQ 入门教程之十一 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 RabbitMQ 的使用教程。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> RabbitMQ 入门教程之十一</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-07-02 22:13:45" itemprop="dateCreated datePublished" datetime="2021-07-02T22:13:45+08:00">2021-07-02</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/ac3bb7d5.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/ac3bb7d5.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>13k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>12 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/ec623f8b.html">RabbitMQ 入门教程之一</a>、<a href="/posts/39a63bd3.html">RabbitMQ 入门教程之二</a>、<a href="/posts/ae3ea986.html">RabbitMQ 入门教程之三</a></li><li><a href="/posts/b2ecc598.html">RabbitMQ 入门教程之四</a>、<a href="/posts/ff0ea7dd.html">RabbitMQ 入门教程之五</a>、<a href="/posts/f9176fde.html">RabbitMQ 入门教程之六</a></li><li><a href="/posts/4eeb4098.html">RabbitMQ 入门教程之七</a>、<a href="/posts/1074caeb.html">RabbitMQ 入门教程之八</a>、<a href="/posts/adff4cba.html">RabbitMQ 入门教程之九</a></li><li><a href="/posts/3168935.html">RabbitMQ 入门教程之十</a>、<a href="/posts/ac3bb7d5.html">RabbitMQ 入门教程之十一</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a target="_blank" rel="external nofollow" href="https://github.com/rabbitmq/rabbitmq-server">RabbitMQ GitHub 开源项目</a></li><li><a target="_blank" rel="external nofollow" href="https://www.rabbitmq.com/docs">RabbitMQ 官方文档（英文）</a></li><li><a target="_blank" rel="external nofollow" href="https://rabbitmq.cn/docs">RabbitMQ 官方文档（中文）</a></li></ul><span id="more"></span><h3 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h3><p>在一个典型的分布式系统中，存在地理上分布较远的多个节点，例如部署在北京的 RabbitMQ 节点（Broker 北京）和部署在深圳的 RabbitMQ 节点（Broker 深圳）。由于两地之间网络延迟较大，跨地域通信时延是必须面对的问题。假设有一个部署在北京的数据生产方（Client 北京），需要连接到本地的 Broker 北京，并向其中的交换机 exchangeA 发送消息。由于网络延迟极小，即便启用了发布确认机制或事务机制，Client 北京也能迅速地将消息发送至 exchangeA，并及时收到确认响应，整体通信效率较高。然而，当另一个部署在深圳的业务系统（Client 深圳）也需要向 exchangeA 发送消息时，就面临了显著的延迟问题。由于 Client 深圳需跨地域连接到 Broker 北京，消息的发送及等待确认过程会受到网络延迟的影响，尤其在启用发布确认机制或事务机制时，延迟变得更加明显。这不仅会导致消息发送线程响应变慢，降低吞吐性能，严重时甚至可能造成线程阻塞，影响整体业务的稳定性。一种看似可行的方案是将 Client 深圳迁移部署到北京的机房，从而缩短其与 Broker 北京之间的通信延迟。然而，这种做法往往会引发新的问题。例如，Client 深圳可能还依赖部署在深圳的其他服务，迁移到北京后又会增加访问这些服务的网络延迟。此外，完全将所有业务系统集中部署在同一个机房，不仅违背了分布式部署和负载均衡的初衷，也严重影响了系统的容灾能力与灵活性。<strong>为了解决跨地域通信延迟带来的问题，RabbitMQ 提供了 Federation 插件和 Shovel 插件。</strong>通过 Shovel 插件，可以在 Broker 北京和 Broker 深圳之间建立推送通道，使得 Client 深圳可以就近连接到本地的 Broker 深圳，并将消息通过 Shovel 插件自动转发至 Broker 北京的 exchangeA。这样既避免了直接跨地域通信造成的高延迟，又保留了系统架构的灵活性与容灾能力，是一种高效且实用的方案。</p><h2 id="RabbitMQ-Federated-插件"><a href="#RabbitMQ-Federated-插件" class="headerlink" title="RabbitMQ Federated 插件"></a>RabbitMQ Federated 插件</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>Federated Plugin（联邦插件）是 RabbitMQ 官方提供的一种跨节点或者跨集群消息桥接机制，主要用于在不同 RabbitMQ 节点或集群之间转发消息，而不需要将它们合并成一个集群（如下图所示）。</p><p><img data-src="../../../asset/2025/04/rabbitmq-67.png"></p><ul><li><p><strong>Federated 插件的桥接方式</strong></p><ul><li><strong><code>Federation Exchange</code>：联邦交换机，将远程交换机中的消息拉取（Pull）并复制到本地交换机。</strong></li><li><strong><code>Federation Queue</code>：联邦队列，将远程队列中的消息拉取（Pull）并复制到本地队列。</strong></li></ul></li><li><p><strong>Federated 插件的核心作用</strong></p><ul><li>在多个 RabbitMQ 节点（或者集群）之间建立松耦合的消息流通通道。</li><li>实现消息从一个集群的交换机或队列自动桥接到另一个集群。</li><li>不要求各个集群之间网络完全互通或者节点角色一致。</li><li>适用于地理分布式部署、跨数据中心传输、云混合架构等场景。</li></ul></li><li><p><strong>Federated 插件的核心特性</strong></p><ul><li>松耦合架构：各集群独立运行，互不依赖。</li><li>灵活配置：按需定义哪些交换机或队列联邦同步。</li><li>适应网络限制：可通过 NAT、防火墙、VPN 等中介连接。</li><li>按需消息传输：只有在本地有消费者订阅时才开始拉取消息（避免浪费）。</li></ul></li><li><p><strong>Federated 插件的使用场景</strong></p><ul><li>跨数据中心消息传递：比如有两个数据中心，各自有独立的 RabbitMQ 集群，通过 Federation 插件可以把消息从一个数据中心传给另一个数据中心。</li><li>跨组织通信：不同组织、子公司、服务系统之间 RabbitMQ 独立部署的场景下互联互通。</li><li>可控的数据同步：Federation 插件是基于拉取（Pull）的方式，不会对远程 RabbitMQ 造成压力，也能做流量控制。</li><li>异地灾备：如果一个 RabbitMQ 出问题，可以将消息同步到另一个 RabbitMQ 做备份处理（不是实时高可用，但可以保证消息冗余）。</li></ul></li><li><p><strong>Federated 插件与集群的区别</strong></p></li></ul><table><thead><tr><th>Federated 插件</th><th> RabbitMQ 集群</th></tr></thead><tbody><tr><td>节点彼此独立</td><td>节点组成统一集群</td></tr><tr><td>松耦合</td><td>强耦合（共享元数据）</td></tr><tr><td>可跨网络、跨数据中心</td><td>需低延迟、稳定内网</td></tr><tr><td>消息通过桥接拉取（Pull）</td><td>消息自动路由同步</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>使用 Federated 插件（包括联邦交换机、联邦队列）时，消息都是下游（Downstream）通过拉取方式获取的，而不是上游（Upstream）主动推送消息，所以消息获取方式都是拉模式（Pull-Based）。</li></ul></div><h3 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h3><p>在 RabbitMQ 的 Federated Plugin（联邦插件）中，Federated Link 是从 Downstream（本地）连接到 Upstream（远程）：</p><ul><li><code>Upstream（上游）</code>：被订阅的远程 RabbitMQ 节点（即数据源）。</li><li><code>Downstream（下游）</code>：发起连接、接收或转发消息的本地 RabbitMQ 节点。</li><li><code>Federation Link</code>：这是 Downstream（下游）主动拉取消息的桥梁。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>在 Federated Exchange（联邦交换机）中，下游从上游的交换机中拉取消息，并重新发布到本地交换机，供本地消费者消费。</li><li>在 Federated Queue（联邦队列）中，当本地有消费者订阅时，下游从上游的队列中拉取消息，并重新传递到本地队列，供本地消费者消费。</li></ul></div><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><ul><li>由于 RabbitMQ 默认自带了 Federated 插件，包括 <code>rabbitmq_federation</code> 和 <code>rabbitmq_federation_management</code>，因此只需要在所需的 RabbitMQ 节点上分别启用 Federated 插件即可，如下所示：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用 rabbitmq_federation 插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 rabbitmq_federation_management 插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation_management</span><br></pre></td></tr></tbody></table></figure><ul><li>当 Federated 插件成功启用后，在 RabbitMQ 节点的控制台页面中，可以看到以下内容：</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-68.png"></p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>Federated 插件的使用步骤：</p><ul><li>(1) 启用 <code>rabbitmq_federation</code> 和 <code>rabbitmq_federation_management</code> 插件</li><li> (2) 配置远程服务器（Upstream）</li><li>(3) 创建 Federated Exchange 或 Federated Queue（通过管理界面或者命令行创建策略）</li><li>(4) 消费者连接本地队列即可间接消费远程消息</li></ul><h3 id="Federated-Exchagne"><a href="#Federated-Exchagne" class="headerlink" title="Federated Exchagne"></a>Federated Exchagne</h3><h4 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h4><p>Federated Exchange（联邦交换机）是 Federation 插件提供的一种机制，用于在不同 RabbitMQ 节点（或者集群）之间联通交换机，使消息可以从一个交换机自动路由到另一个交换机中。值得一提的是，<strong>联邦交换机可以让消息在多个 RabbitMQ 节点（或者集群）中实现交换机级别的广播复制。</strong></p><ul><li><p><strong>Federated Exchange 的工作原理</strong></p><ul><li>在两个或多个 RabbitMQ 节点（或者集群）中，<strong>各自定义一个名称相同的交换机</strong>。</li><li>本地交换机（Downstream）通过 <code>federation upstream</code> 指定远程交换机（Upstream）。</li><li>当有消息发布到远程交换机（Upstream）时，本地交换机（Downstream）会通过联邦链接从远程交换机（Upstream）将消息拉取（Pull）到本地，消息就会像正常发布到本地交换机那样进行路由，最后分发到本地绑定的队列中。</li></ul></li><li><p><strong>Federated Exchange 的核心特性</strong></p><ul><li>主动拉取：本地交换机（Downstream）主动连接远程交换机（Upstream），从远程拉取发布的消息。</li><li>拓扑独立：不需要队列之间互联，只需交换机保持同步，适用于解耦多个站点。</li><li>灵活匹配：联邦可应用于任意交换机类型，比如支持 <code>fanout</code>、<code>direct</code>、<code>topic</code>、<code>headers</code> 等类型的交换机。</li><li>消息原样保留：被拉取的消息会重新发布到本地交换机，保留原始的 RoutingKey、Headers 等属性。</li></ul></li><li><p><strong>Federated Exchange 的注意事项</strong></p><ul><li>消息是拉取式同步：下游节点通过 AMQP Consumer 从上游获取消息，若连接断开则消息不会缓存，断开期间消息会丢失（除非 Upstream 队列持久化）。</li><li>存在重复消息可能：若配置多个 Federated Upstream，可能导致消息重复，需要业务层实现幂等消费。</li><li>不具备消费 ACK 保证机制：消息仅转发一次，不能确认是否被成功消费，不具备像 Queue 那样的可靠性保障。</li><li>本地需持久化：联邦交换机不存储消息，需要配合绑定本地持久化队列实现落盘。</li></ul></li><li><p><strong>Federated Exchange 的适用场景</strong></p><ul><li>多数据中心同步广播消息（如总部通知分部）。</li><li>多区域事件发布（如多地游戏服务器的事件联播）。</li><li>跨网络隔离系统同步数据（比如生产网到测试网）。</li></ul></li><li><p><strong>Federated Exchange 与其他机制对比</strong></p></li></ul><table><thead><tr><th>特性</th><th> Federated Exchange</th><th>Federated Queue</th><th>Shovel 插件</th></tr></thead><tbody><tr><td>传输模式</td><td>拉取（Pull）</td><td>拉取（Pull）</td><td>拉取（Pull）</td></tr><tr><td>联通对象</td><td>交换机 → 交换机</td><td>队列 → 队列</td><td>队列 → 交换机 / 队列</td></tr><tr><td>典型场景</td><td>发布 / 订阅场景下的消息广播同步</td><td>拉取型任务聚合（如分布式任务）</td><td>精准的数据迁移与桥接</td></tr></tbody></table><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>本节将演示如何使用 Federation 插件中的 Federation Exchange（联邦交换机），整体工作流程如下图所示：</p><p><img data-src="../../../asset/2025/04/rabbitmq-69.png"></p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>在上面的工作流程图中，使用了 Federation Exchange（联邦交换机），当发送消息到独立节点一（<code>node1 upstream</code>）的交换机 <code>fed_exchange</code> 时，RabbitMQ 会将消息发送给独立节点一中的本地队列 <code>node1_queue</code>。同时，联邦交换机还会从独立节点一的交换机拉取（Pull）消息，并发送给独立节点二（<code>node2 upstream</code>）的交换机 <code>fed_exchange</code>，然后独立节点二的交换机 <code>fed_exchange</code> 再将消息发送到本地队列 <code>node2_queue</code>。这相当于独立节点二可以消费到跟独立节点一相同的消息，从而让消息可以在多个 RabbitMQ 节点（或者集群）中实现交换机级别的广播复制。</li></ul></div><h5 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h5><p>本案例使用的各软件版本如下表所示：</p><table><thead><tr><th>组件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> RabbitMQ Server</td><td><code>3.8.26</code></td><td></td></tr><tr><td>RabbitMQ Client</td><td><code>5.10.0</code></td><td></td></tr><tr><td>Erlang</td><td><code>24.2</code></td><td></td></tr><tr><td>Java</td><td><code>11</code></td><td></td></tr></tbody></table><h5 id="节点说明"><a href="#节点说明" class="headerlink" title="节点说明"></a>节点说明</h5><p><strong>这里简单使用两个独立的 RabbitMQ 节点（非同一个集群），并且都已经启用 Federated 插件</strong>，如下表所示：</p><table><thead><tr><th>节点的名称</th><th>节点的 IP</th><th> 节点暴露的端口</th><th>节点的主机名称</th><th>节点的控制台访问地址</th><th>说明</th></tr></thead><tbody><tr><td>独立节点一</td><td> 192.168.2.143</td><td><code>5673</code>、<code>15673</code></td><td>rabbitmq-node1</td><td><code>http://192.168.2.143:15673</code></td><td>作为 Upstream（上游）</td></tr><tr><td>独立节点二</td><td> 192.168.2.144</td><td><code>5674</code>、<code>15674</code></td><td>rabbitmq-node2</td><td><code>http://192.168.2.144:15674</code></td><td>作为 Downstream（下游）</td></tr></tbody></table><h5 id="创建-Exchange"><a href="#创建-Exchange" class="headerlink" title="创建 Exchange"></a>创建 Exchange</h5><ul><li>在 RabbitMQ 独立节点一（<code>rabbitmq-node1</code>）中，创建对应的交换机和队列，并建立绑定关系，可以通过 Web 控制台或者 Java 代码进行创建，同时让消费者订阅队列中的消息。<strong>特别注意，在 RabbitMQ 两个独立节点中，交换机的名称必须完全一致。</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ 独立节点一（Upstream）的消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConsumerNode1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"fed_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"node1_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的路由键（绑定键）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ROUTING_KEY = <span class="string">"routekey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.2.143"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5673</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// type – 交换机类型</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久交换机，则为 true（交换机将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 交换机，则为 true（当最后一个绑定队列解除绑定后，自动删除该交换机）</span></span><br><span class="line">        <span class="comment">// arguments – 交换的其他属性（构造参数）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久队列，则为 true（队列将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// exclusive – 如果需要声明一个独占队列（仅限于此连接使用，连接关闭后队列自动删除），则为 true。</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 队列，则为 true（服务器将在最后一个消费者断开连接以后，自动删除该队列）</span></span><br><span class="line">        <span class="comment">// arguments – 队列的其他属性（构造参数）</span></span><br><span class="line">        <span class="comment">// 特别注意：如果确定队列已存在，消费者可以不声明队列。但是，强烈建议无论生产者还是消费者，都应该声明队列，确保参数可控</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定交换机和队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// routingKey – 用于绑定的 RoutingKey（如果不使用 Routingkey，可填空字符串）</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, QUEUE_ROUTING_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">"Successed to consume message : "</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动确认消息</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// deliveryTag – 消息的标记</span></span><br><span class="line">            <span class="comment">// multiple – true 表示确认所有消息，包括提供的送达标签为止的所有消息；false 仅确认提供的投放标记</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消费时的回调（比如，在消费的时候队列已被删除掉）</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Failed to consume message : "</span> + consumerTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"消费者开始消费消息..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭自动确认机制</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// autoAck – 如果需要服务器在消息投递后自动确认消息，则为 true；如果需要客户端手动确认消息，则为 false</span></span><br><span class="line">        <span class="comment">// deliverCallback – 消费消息时的回调</span></span><br><span class="line">        <span class="comment">// cancelCallback – 取消消费时的回调</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让消费者持续运行</span></span><br><span class="line">        System.out.println(<span class="string">"按回车键退出程序："</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭信道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在 RabbitMQ 独立节点二（<code>rabbitmq-node2</code>）中，创建对应的交换机和队列，并建立绑定关系，可以通过 Web 控制台或者 Java 代码进行创建，同时让消费者订阅队列中的消息。<strong>特别注意，在 RabbitMQ 两个独立节点中，交换机的名称必须完全一致。</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ 独立节点二（Downstream）的消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConsumerNode2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"fed_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"node2_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的路由键（绑定键）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ROUTING_KEY = <span class="string">"routekey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.2.144"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5674</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// type – 交换机类型</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久交换机，则为 true（交换机将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 交换机，则为 true（当最后一个绑定队列解除绑定后，自动删除该交换机）</span></span><br><span class="line">        <span class="comment">// arguments – 交换的其他属性（构造参数）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久队列，则为 true（队列将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// exclusive – 如果需要声明一个独占队列（仅限于此连接使用，连接关闭后队列自动删除），则为 true。</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 队列，则为 true（服务器将在最后一个消费者断开连接以后，自动删除该队列）</span></span><br><span class="line">        <span class="comment">// arguments – 队列的其他属性（构造参数）</span></span><br><span class="line">        <span class="comment">// 特别注意：如果确定队列已存在，消费者可以不声明队列。但是，强烈建议无论生产者还是消费者，都应该声明队列，确保参数可控</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定交换机和队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// routingKey – 用于绑定的 RoutingKey（如果不使用 Routingkey，可填空字符串）</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, QUEUE_ROUTING_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">"Successed to consume message : "</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动确认消息</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// deliveryTag – 消息的标记</span></span><br><span class="line">            <span class="comment">// multiple – true 表示确认所有消息，包括提供的送达标签为止的所有消息；false 仅确认提供的投放标记</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消费时的回调（比如，在消费的时候队列已被删除掉）</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Failed to consume message : "</span> + consumerTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"消费者开始消费消息..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭自动确认机制</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// autoAck – 如果需要服务器在消息投递后自动确认消息，则为 true；如果需要客户端手动确认消息，则为 false</span></span><br><span class="line">        <span class="comment">// deliverCallback – 消费消息时的回调</span></span><br><span class="line">        <span class="comment">// cancelCallback – 取消消费时的回调</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让消费者持续运行</span></span><br><span class="line">        System.out.println(<span class="string">"按回车键退出程序："</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭信道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="添加-Upstream"><a href="#添加-Upstream" class="headerlink" title="添加 Upstream"></a>添加 Upstream</h5><ul><li>在 RabbitMQ 独立节点二（<code>rabbitmq-node2</code>）的 Web 控制台中，添加节点一（<code>rabbitmq-node1</code>）作为 Upstream。</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-70.png"></p><blockquote><p>参数说明：<br><code>Name</code>：Upstream 的名称<br><code>URI</code>：Upstream 的 URI 地址，其中 <code>amqp://</code> 是协议前缀，<code>admin:admin</code> 用户名和密码，<code>@rabbitmq-node1</code> 是主机名称。<br><code>Acknowledgement Mode</code>：下游从上游拉取消息后，何时向上游确认（ACK）这条消息已被 “接收” 了。它控制的是 Federation Exchange 与上游的消息拉取确认行为，而不是消费者消费消息的 ACK 行为。</p></blockquote><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Acknowledgement Mode 不是指消费者的 ACK 机制，也不等同于 RabbitMQ Queue 中的消息消费确认机制，只是针对 Federation Exchange 拉取消息的内部行为。Acknowledgement Mode 的三种取值含义如下表所示。</p></div><table><thead><tr><th>确认模式</th><th>是否等待下游 Confirm</th><th> 是否等待消费者处理</th><th>具体含义</th><th>风险 / 特点</th></tr></thead><tbody><tr><td><code>on-confirm</code></td><td>✅ 等待 confirm</td><td>❌ 不管</td><td>默认值，Federation Exchange 拉取到消息后，等下游的 Exchange 成功接收（RabbitMQ 层面 Confirm）后才向上游 ACK</td><td> 最安全，可靠性最高，推荐用于关键业务</td></tr><tr><td><code>on-publish</code></td><td>❌ 不等待</td><td>❌ 不管</td><td>拉取到消息并成功发布（指投递动作没有抛出错误，如交换机不存在、连接中断等）到下游的 Exchange 后立即 ACK，不等待 Confirm</td><td> 性能优于 <code>on-confirm</code>，风险略高</td></tr><tr><td><code>no-ack</code></td><td>❌ 不等待</td><td>❌ 不管</td><td>拉取到消息立即 ACK，不管下游的 Exchange 是否成功接收消息</td><td>风险最大，易丢消息（断线、未投递成功等）</td></tr></tbody></table><h5 id="添加策略（Policy）"><a href="#添加策略（Policy）" class="headerlink" title="添加策略（Policy）"></a>添加策略（Policy）</h5><ul><li>在 RabbitMQ 独立节点二（<code>rabbitmq-node2</code>）的 Web 控制台中，添加策略（Policy），让名称为 <code>node1-as-upstream</code> 的 Upstream 应用在所有以 <code>fed_</code> 开头的交换机。</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-71.png"></p><h5 id="查看联邦交换机"><a href="#查看联邦交换机" class="headerlink" title="查看联邦交换机"></a>查看联邦交换机</h5><ul><li>当 Upstream 和策略（Policy）都添加完成，并且交换机也创建完成后，如果一切正常运行，那么在独立节点二（<code>rabbitmq-node2</code>）的 Web 控制台中，可以在交换机列表中看到联邦交换机。</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-78.png"></p><ul><li>当 Upstream 和策略（Policy）都添加完成，并且交换机也创建完成后，如果一切正常运行，那么在独立节点二（<code>rabbitmq-node2</code>）的 Web 控制台中可以看到联邦状态显示正常。</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-72.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>只有独立节点二（<code>rabbitmq-node2</code>）中的交换机已经创建好，RabbitMQ 的 Web 控制台才会正常显示对应的联邦交换机和联邦状态。</p></div><h5 id="测试联邦交换机"><a href="#测试联邦交换机" class="headerlink" title="测试联邦交换机"></a>测试联邦交换机</h5><ul><li>创建一个生产者，发送消息到独立节点一（<code>rabbitmq-node1</code>）中的交换机</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ 独立节点一（Upstream）的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQProducerNode1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"fed_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的路由键（绑定键）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ROUTING_KEY = <span class="string">"routekey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.2.143"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5673</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 try-with-resources 自动关闭连接和通道，确保资源释放</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 创建连接</span></span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            <span class="comment">// 创建信道</span></span><br><span class="line">            Channel channel = connection.createChannel()</span><br><span class="line">        ) {</span><br><span class="line">            <span class="comment">// 声明交换机</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">            <span class="comment">// type – 交换机类型</span></span><br><span class="line">            <span class="comment">// durable – 如果需要声明一个持久交换机，则为 true（交换机将在服务器重启后继续存在）</span></span><br><span class="line">            <span class="comment">// autoDelete – 如果需要声明 autoDelete 交换机，则为 true（当最后一个绑定队列解除绑定后，自动删除该交换机）</span></span><br><span class="line">            <span class="comment">// arguments – 交换的其他属性（构造参数）</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// exchange – 要将消息发布到的交换机，空字符串表示默认交换机</span></span><br><span class="line">            <span class="comment">// routingKey – 路由 Key</span></span><br><span class="line">            <span class="comment">// props – 消息的其他属性，比如：使用 MessageProperties.PERSISTENT_TEXT_PLAIN 属性确保消息持久化，配合持久化队列可避免服务器重启导致消息丢失</span></span><br><span class="line">            <span class="comment">// body – 消息内容</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, QUEUE_ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"hello"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码测试结果：启动所有生产者和消费者应用，由于在独立节点二（<code>rabbitmq-node2</code>）中配置了 Federation Exchange（联邦交换机），当发送消息到 RabbitMQ 独立节点一（<code>rabbitmq-node1</code>）中的交换机时，除了独立节点一（<code>rabbitmq-node1</code>）中的消费者可以接收到消息，独立节点二（<code>rabbitmq-node2</code>）中的消费者也可以接收到消息；<strong>即对于同一条消息，会被两个独立节点中的消费者同时消费。这就说明使用 Federation Exchange（联邦交换机）后，消息可以在多个 RabbitMQ 节点（或者集群）中实现交换机级别的广播复制。</strong></li></ul><h3 id="Federated-Queue"><a href="#Federated-Queue" class="headerlink" title="Federated Queue"></a>Federated Queue</h3><h4 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h4><p>Federated Queue（联邦队列）是 Federation 插件提供的一种机制，用于在一个队列与另一个远程队列之间建立连接，将远程队列的消息拉取（Pull）到本地队列中 的一种机制。它不会复制队列的元数据（如绑定、消费者等），只是将消息从远程传输到本地，消费者只需要订阅本地队列即可消费远程消息。一个联邦队列可以连接一个或者多个上游队列（Upstream Queue）， 并从这些上游队列中获取消息以满足本地消费者消费消息的需求。值得一提的是，<strong>Federated Queue 可以让多个 RabbitMQ 节点（或者集群）共享消费同一个逻辑队列的数据，即可以在跨节点的多个消费者之间轮询分发消息（效果类似 RabbitMQ 的工作队列模式）。</strong></p><ul><li><p><strong>Federated Queue 的工作原理</strong></p><ul><li>联邦队列通过 HTTP API 从远程 RabbitMQ 节点拉取（Pull）目标队列的消息。</li><li>使用一个 “后台工作者”（Federation Link）定期拉取新消息。</li><li>拉取的消息会缓存在本地队列，供本地消费者消费。</li><li>联邦队列是基于拉模式（Pull-Based），而非主动推送。</li></ul></li><li><p><strong>Federated Queue 的核心特性</strong></p><ul><li>解耦：远程与本地队列解耦，连接断开时可自动恢复。</li><li>灵活性：支持配置哪些消息被拉取（如使用 RoutingKey 或 Headers）。</li><li>异地容错：适合跨区域部署（如一个数据中心消费另一个数据中心的数据）。</li><li>只拉不推：Federated Queue 是拉取（Pull）消息，然后供消费者消费。</li></ul></li><li><p><strong>Federated Queue 的注意事项</strong></p><ul><li>联邦队列不适用于要求高实时性、低延迟的场景。</li><li>如果远程队列消息量太大，本地可能会堆积消息。</li><li>发生网络异常时，消息同步会暂停，可能造成消费延迟。</li></ul></li><li><p><strong>Federated Queue 与普通 Queue 对比</strong></p></li></ul><table><thead><tr><th>特性</th><th> Federated Queue</th><th> 普通 Queue</th></tr></thead><tbody><tr><td> 消息方向</td><td>拉取（Pull）</td><td>本地消息处理</td></tr><tr><td>消息中继</td><td>是</td><td>否</td></tr><tr><td>延迟控制</td><td>有延迟（受网络和速率影响）</td><td>本地处理较快</td></tr><tr><td>使用场景</td><td>跨地区数据聚合</td><td>常规消息传递</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><p>一个联邦队列可以连接一个或者多个上游队列（Upstream Queue），并从这些上游队列中获取消息，以满足本地消费者消费消息的需求。</p></div><h4 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h4><p>本节将演示如何使用 Federation 插件中的 Federation Queue（联邦队列），整体工作流程如下图所示：</p><p><img data-src="../../../asset/2025/04/rabbitmq-73.png"></p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>在上面的工作流程图中，使用了 Federation Queue（联邦队列），当发送消息到独立节点一（<code>node1 upstream</code>）的队列时，RabbitMQ 会轮询分发消息给独立节点一（<code>node1 upstream</code>）和独立节点二（<code>node2 upstream</code>）的消费者。</li><li>举个例子，当发送消息 A 和消息 B 到独立节点一的队列时，独立节点一的消费者会接收到消息 A，而独立节点二的消费者会接收到消息 B，消息不会被重复消费。</li></ul></div><h5 id="版本说明-1"><a href="#版本说明-1" class="headerlink" title="版本说明"></a>版本说明</h5><p>本案例使用的各软件版本如下表所示：</p><table><thead><tr><th>组件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> RabbitMQ Server</td><td><code>3.8.26</code></td><td></td></tr><tr><td>RabbitMQ Client</td><td><code>5.10.0</code></td><td></td></tr><tr><td>Erlang</td><td><code>24.2</code></td><td></td></tr><tr><td>Java</td><td><code>11</code></td><td></td></tr></tbody></table><h5 id="节点说明-1"><a href="#节点说明-1" class="headerlink" title="节点说明"></a>节点说明</h5><p><strong>这里简单使用两个独立的 RabbitMQ 节点（非同一个集群），并且都已经启用 Federated 插件</strong>，如下表所示：</p><table><thead><tr><th>节点的名称</th><th>节点的 IP</th><th> 节点暴露的端口</th><th>节点的主机名称</th><th>节点的控制台访问地址</th><th>说明</th></tr></thead><tbody><tr><td>独立节点一</td><td> 192.168.2.143</td><td><code>5673</code>、<code>15673</code></td><td>rabbitmq-node1</td><td><code>http://192.168.2.143:15673</code></td><td>作为 Upstream（上游）</td></tr><tr><td>独立节点二</td><td> 192.168.2.144</td><td><code>5674</code>、<code>15674</code></td><td>rabbitmq-node2</td><td><code>http://192.168.2.144:15674</code></td><td>作为 Downstream（下游）</td></tr></tbody></table><h5 id="创建-Queue"><a href="#创建-Queue" class="headerlink" title="创建 Queue"></a>创建 Queue</h5><ul><li>在 RabbitMQ 独立节点一（<code>rabbitmq-node1</code>）中，创建对应的交换机和队列，并建立绑定关系，可以通过 Web 控制台或者 Java 代码进行创建，同时让消费者订阅队列中的消息。<strong>特别注意，在 RabbitMQ 两个独立节点中，队列的名称必须完全一致。</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ 独立节点一（Upstream）的消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConsumerNode1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"node1_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"fed.queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的路由键（绑定键）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ROUTING_KEY = <span class="string">"routekey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.2.148"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5673</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// type – 交换机类型</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久交换机，则为 true（交换机将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 交换机，则为 true（当最后一个绑定队列解除绑定后，自动删除该交换机）</span></span><br><span class="line">        <span class="comment">// arguments – 交换的其他属性（构造参数）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久队列，则为 true（队列将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// exclusive – 如果需要声明一个独占队列（仅限于此连接使用，连接关闭后队列自动删除），则为 true。</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 队列，则为 true（服务器将在最后一个消费者断开连接以后，自动删除该队列）</span></span><br><span class="line">        <span class="comment">// arguments – 队列的其他属性（构造参数）</span></span><br><span class="line">        <span class="comment">// 特别注意：如果确定队列已存在，消费者可以不声明队列。但是，强烈建议无论生产者还是消费者，都应该声明队列，确保参数可控</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定交换机和队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// routingKey – 用于绑定的 RoutingKey（如果不使用 Routingkey，可填空字符串）</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, QUEUE_ROUTING_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">"Successed to consume message : "</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动确认消息</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// deliveryTag – 消息的标记</span></span><br><span class="line">            <span class="comment">// multiple – true 表示确认所有消息，包括提供的送达标签为止的所有消息；false 仅确认提供的投放标记</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消费时的回调（比如，在消费的时候队列已被删除掉）</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Failed to consume message : "</span> + consumerTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"消费者开始消费消息..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭自动确认机制</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// autoAck – 如果需要服务器在消息投递后自动确认消息，则为 true；如果需要客户端手动确认消息，则为 false</span></span><br><span class="line">        <span class="comment">// deliverCallback – 消费消息时的回调</span></span><br><span class="line">        <span class="comment">// cancelCallback – 取消消费时的回调</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让消费者持续运行</span></span><br><span class="line">        System.out.println(<span class="string">"按回车键退出程序："</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭信道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在 RabbitMQ 独立节点二（<code>rabbitmq-node2</code>）中，创建对应的交换机和队列，并建立绑定关系，可以通过 Web 控制台或者 Java 代码进行创建，同时让消费者订阅队列中的消息。<strong>特别注意，在 RabbitMQ 两个独立节点中，队列的名称必须完全一致。</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ 独立节点二（Downstream）的消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConsumerNode2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"node2_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"fed.queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的路由键（绑定键）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ROUTING_KEY = <span class="string">"routekey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.2.148"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5674</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// type – 交换机类型</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久交换机，则为 true（交换机将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 交换机，则为 true（当最后一个绑定队列解除绑定后，自动删除该交换机）</span></span><br><span class="line">        <span class="comment">// arguments – 交换的其他属性（构造参数）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久队列，则为 true（队列将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// exclusive – 如果需要声明一个独占队列（仅限于此连接使用，连接关闭后队列自动删除），则为 true。</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 队列，则为 true（服务器将在最后一个消费者断开连接以后，自动删除该队列）</span></span><br><span class="line">        <span class="comment">// arguments – 队列的其他属性（构造参数）</span></span><br><span class="line">        <span class="comment">// 特别注意：如果确定队列已存在，消费者可以不声明队列。但是，强烈建议无论生产者还是消费者，都应该声明队列，确保参数可控</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定交换机和队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// routingKey – 用于绑定的 RoutingKey（如果不使用 Routingkey，可填空字符串）</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, QUEUE_ROUTING_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">"Successed to consume message : "</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动确认消息</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// deliveryTag – 消息的标记</span></span><br><span class="line">            <span class="comment">// multiple – true 表示确认所有消息，包括提供的送达标签为止的所有消息；false 仅确认提供的投放标记</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消费时的回调（比如，在消费的时候队列已被删除掉）</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Failed to consume message : "</span> + consumerTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"消费者开始消费消息..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭自动确认机制</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// autoAck – 如果需要服务器在消息投递后自动确认消息，则为 true；如果需要客户端手动确认消息，则为 false</span></span><br><span class="line">        <span class="comment">// deliverCallback – 消费消息时的回调</span></span><br><span class="line">        <span class="comment">// cancelCallback – 取消消费时的回调</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让消费者持续运行</span></span><br><span class="line">        System.out.println(<span class="string">"按回车键退出程序："</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭信道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="添加-Upstream-1"><a href="#添加-Upstream-1" class="headerlink" title="添加 Upstream"></a>添加 Upstream</h5><ul><li>在 RabbitMQ 独立节点二（<code>rabbitmq-node2</code>）的 Web 控制台中，添加节点一（<code>rabbitmq-node1</code>）作为 Upstream。</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-75.png"></p><blockquote><p>参数说明：<br><code>Name</code>：Upstream 的名称<br><code>URI</code>：Upstream 的 URI 地址，其中 <code>amqp://</code> 是协议前缀，<code>admin:admin</code> 用户名和密码，<code>@rabbitmq-node1</code> 是主机名称。<br><code>Acknowledgement Mode</code>：下游从上游拉取消息后，何时向上游确认（ACK）这条消息已被 “接收” 了。它控制的是 Federation Queue 与上游的消息拉取确认行为，而不是消费者消费消息的 ACK 行为。</p></blockquote><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Acknowledgement Mode 不是指消费者的 ACK 机制，也不等同于 RabbitMQ Queue 中的消息消费确认机制，只是针对 Federation Queue 拉取消息的内部行为。Acknowledgement Mode 的三种取值含义如下表所示。</p></div><table><thead><tr><th>确认模式</th><th>是否等待下游 Confirm</th><th> 是否等待消费者处理</th><th>具体含义</th><th>风险 / 特点</th></tr></thead><tbody><tr><td><code>on-confirm</code></td><td>✅ 等待 confirm</td><td>❌ 不管</td><td>默认值，Federation Queue 拉取到消息后，等下游的 Queue 成功接收（指消息已经被 RabbitMQ 成功、安全地写入下游队列的存储结构中，包括内存或磁盘）后才向上游 ACK</td><td> 最安全，可靠性最高，推荐用于关键业务</td></tr><tr><td><code>on-publish</code></td><td>❌ 不等待</td><td>❌ 不管</td><td>拉取到消息并成功发布（指投递动作没有抛出错误，如队列不存在、连接中断等）到下游的 Queue 后立即 ACK，不等待 Confirm</td><td> 性能优于 <code>on-confirm</code>，风险略高</td></tr><tr><td><code>no-ack</code></td><td>❌ 不等待</td><td>❌ 不管</td><td>拉取到消息立即 ACK，不管下游的 Queue 是否成功接收消息</td><td>风险最大，易丢消息（断线、未投递成功等）</td></tr></tbody></table><h5 id="添加策略（Policy）-1"><a href="#添加策略（Policy）-1" class="headerlink" title="添加策略（Policy）"></a>添加策略（Policy）</h5><ul><li>在 RabbitMQ 独立节点二（<code>rabbitmq-node2</code>）的 Web 控制台中，添加策略（Policy），让名称为 <code>node1-as-upstream</code> 的 Upstream 应用在所有以 <code>fed.</code> 开头的队列。</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-76.png"></p><h5 id="查看联邦队列"><a href="#查看联邦队列" class="headerlink" title="查看联邦队列"></a>查看联邦队列</h5><ul><li>当 Upstream 和策略（Policy）都添加完成，并且队列也创建完成后，如果一切正常运行，那么在独立节点二（<code>rabbitmq-node2</code>）的 Web 控制台中可以看到联邦状态显示正常。</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-77.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>只有独立节点二（<code>rabbitmq-node2</code>）中的队列已经创建好，RabbitMQ 的 Web 控制台才会正常显示对应的联邦状态。</p></div><h5 id="测试联邦队列"><a href="#测试联邦队列" class="headerlink" title="测试联邦队列"></a>测试联邦队列</h5><ul><li>创建一个生产者，发送消息到独立节点一（<code>rabbitmq-node1</code>）中的队列</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ 独立节点一（Upstream）的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQProducerNode1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"node1_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的路由键（绑定键）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ROUTING_KEY = <span class="string">"routekey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.2.148"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5673</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 try-with-resources 自动关闭连接和通道，确保资源释放</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 创建连接</span></span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            <span class="comment">// 创建信道</span></span><br><span class="line">            Channel channel = connection.createChannel()</span><br><span class="line">        ) {</span><br><span class="line">            <span class="comment">// 声明交换机</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">            <span class="comment">// type – 交换机类型</span></span><br><span class="line">            <span class="comment">// durable – 如果需要声明一个持久交换机，则为 true（交换机将在服务器重启后继续存在）</span></span><br><span class="line">            <span class="comment">// autoDelete – 如果需要声明 autoDelete 交换机，则为 true（当最后一个绑定队列解除绑定后，自动删除该交换机）</span></span><br><span class="line">            <span class="comment">// arguments – 交换的其他属性（构造参数）</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// exchange – 要将消息发布到的交换机，空字符串表示默认交换机</span></span><br><span class="line">            <span class="comment">// routingKey – 路由 Key</span></span><br><span class="line">            <span class="comment">// props – 消息的其他属性，比如：使用 MessageProperties.PERSISTENT_TEXT_PLAIN 属性确保消息持久化，配合持久化队列可避免服务器重启导致消息丢失</span></span><br><span class="line">            <span class="comment">// body – 消息内容</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, QUEUE_ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"hello"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码测试结果：启动所有生产者和消费者应用，由于在独立节点二（<code>rabbitmq-node2</code>）中配置了 Federation Queue（联邦队列），当发送消息到 RabbitMQ 独立节点一（<code>rabbitmq-node1</code>）的队列时，RabbitMQ 会轮询分发消息给独立节点一（<code>rabbitmq-node1</code>）和独立节点二（<code>rabbitmq-node2</code>）的消费者。举个例子，当发送消息 A 和消息 B 到独立节点一的队列时，独立节点一的消费者会接收到消息 A，而独立节点二的消费者会接收到消息 B，消息不会被重复消费。<strong>这就说明使用 Federation Queue（联邦队列）后，可以在多个 RabbitMQ 节点（或者集群）之间为单个队列提供均衡负载的功能，即在跨节点的多个消费者之间轮询分发消息（效果类似 RabbitMQ 的工作队列模式）。</strong></li></ul><h2 id="RabbitMQ-Shovel-插件"><a href="#RabbitMQ-Shovel-插件" class="headerlink" title="RabbitMQ Shovel 插件"></a>RabbitMQ Shovel 插件</h2><h3 id="概述介绍"><a href="#概述介绍" class="headerlink" title="概述介绍"></a>概述介绍</h3><p>RabbitMQ 的 Shovel 插件用于实现不同 RabbitMQ 服务器或虚拟主机（Vhost）之间的消息转发，其核心作用是 “铲子” 式地将消息从一个队列 “铲” 到另一个位置。Shovel 插件能够从一个 Broker 中的队列（作为源端，即 Source）中拉取（Pull）消息，并将其转发至另一个 Broker 中的交换机 / 队列（作为目标端，即 Destination）。源端的队列和目标端的交换机 / 队列既可以分别位于不同的 Broker，也可以位于同一个 Broker 中。这种机制使得 Shovel 插件特别适用于跨数据中心消息传输、系统迁移、灾备同步等场景，确保消息可靠地在 RabbitMQ 实例间流动。<strong>简而言之，Shovel 是一个 “拉取消息再发送出去” 的搬运工，即基于拉取（Pull）模式从源端的队列获取消息，再推送（Push）消息到目标端的交换机 / 队列。</strong></p><ul><li><p><strong>Shovel 插件的工作原理</strong></p><ul><li>Shovel 连接到源服务器（Source）并拉取指定队列。</li><li>拉取到消息后，将消息转发到目标服务器（Destination）。</li><li>确保目标端写入成功后，才确认（ACK）消费源端消息（保证消息不丢）。</li><li>若出现连接中断，会自动重试连接并继续搬运。</li></ul></li><li><p><strong>Shovel 插件的核心特性</strong></p><ul><li>跨实例传输：支持在不同 RabbitMQ 实例间转发消息</li><li>持续运行：它是一种持续运行的转发机制（非一次性）</li><li>可靠性：支持自动重连、持久化、确认机制</li><li>可配置性：支持静态配置（Static Shovel）和动态配置（Dynamic Shovel）</li><li>支持 AMQP <code>0.9.1</code>：兼容 RabbitMQ 默认协议</li></ul></li><li><p> <strong>Shovel 插件的注意事项</strong></p><ul><li>大量 Shovel 实例会消耗较多连接资源、通道和内存，建议限制并发 Shovel 数量。</li><li>消息顺序不能百分百保证，特别在连接中断重连、存在多个 Shovel 的情况下。</li><li>若业务对消息顺序、消息重复敏感，则需要在消费端做幂等性处理或顺序校验。</li><li>可通过 RabbitMQ 管理控制台或 HTTP API 监控 Shovel 状态，推荐集成监控系统报警异常。</li></ul></li><li><p><strong>Shovel 插件的使用场景</strong></p><ul><li>跨数据中心的消息转发</li><li>消息系统迁移</li><li>多活集群的消息同步</li><li>灾备系统的消息复制</li></ul></li><li><p> <strong>Shovel 插件的配置说明</strong></p><ul><li>源端和目标端都应设置合理的权限控制，避免越权访问。</li><li>参数 <code>ack-mode</code> 建议设置为 <code>on-confirm</code> 或 <code>on-publish</code>，以保证消息成功写入目标端后再确认源端消费，避免消息丢失。</li><li>可以设置 <code>prefetch-count</code>（预取数量）来控制一次拉取的消息数量，避免消息积压。</li><li>连接异常时，Shovel 会自动尝试重连，使用 <code>reconnect-delay</code> 参数设置重连间隔，比如 <code>reconnect-delay: 5</code>。</li><li>静态配置（Static Shovel）：通过 <code>rabbitmq.conf</code> 文件或环境变量配置，适合在服务启动前就确定连接和队列信息的场景。</li><li>动态配置（Dynamic Shovel）：使用 RabbitMQ Management UI 或 HTTP API 动态创建和管理 Shovel，适合运行时灵活调整。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><ul><li>Shovel 插件是基于消费机制实现的，它从队列中 "消费" 消息（就像一个消费者一样），所以<strong>消息源（源端 - Source）必须是一个队列，消息目标（目标端 - Destination）则通常是交换机，间接也支持目标端为队列。</strong></li><li><strong>在 RabbitMQ 控制台的配置页面中，虽然 Shovel 的源端（Source）可以选择是交换机，但本质上它依然是通过中间队列消费消息。Shovel 插件不能作为 "监听交换机" 的工具，而是从现有队列中读取消息进行再发布。</strong></li></ul></div><blockquote><p>Shovel 插件与 Federated 插件的对比</p></blockquote><table><thead><tr><th>特性 / 机制</th><th> Shovel 插件</th><th> Federated Exchange（联邦交换机）</th><th>Federated Queue（联邦队列）</th></tr></thead><tbody><tr><td>连接发起方</td><td>目标端主动连接源端</td><td>目标端主动连接源端</td><td>目标端主动连接源端</td></tr><tr><td>消息获取模式</td><td>从源队列拉取（Pull）</td><td>从源交换机拉取（Pull）</td><td>从源队列拉取并消费</td></tr><tr><td>源端行为</td><td>类似普通 Broker，无特殊行为</td><td>类似普通 Broker，无特殊行为</td><td>类似普通 Broker，无特殊行为</td></tr><tr><td>目标端行为</td><td>拉取消息 → 发布到目标交换机 / 队列</td><td>拉取消息 → 再次路由到本地交换机</td><td>拉取消息 → 直接投递到本地队列</td></tr><tr><td>支持方向</td><td>支持队列到交换机、队列到队列</td><td>仅支持交换机级别联邦</td><td>仅支持队列级别联邦</td></tr><tr><td>拉取粒度</td><td>手动配置：逐条、批量、确认等</td><td>自动控制，类似 AMQP 消费者</td><td>自动控制，类似 AMQP 消费者</td></tr><tr><td>使用方式</td><td>插件 + 显式配置（静态 / 动态）</td><td>插件 + 通过策略自动应用</td><td>插件 + 通过策略自动应用</td></tr><tr><td>适用场景</td><td>精细控制、混合部署、定制路由</td><td>多站点广播、发布同步</td><td>多个节点共享消费同一个逻辑队列的数据（即轮询分发消息给多个消费者）</td></tr><tr><td>消息可靠性控制</td><td>高（支持 ACK、持久化等）</td><td>中等（依赖 AMQP 投递机制）</td><td>中等（依赖消费确认机制）</td></tr></tbody></table><h3 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h3><ul><li>由于 RabbitMQ 默认自带了 Shovel 插件，包括 <code>rabbitmq_shovel</code> 和 <code>rabbitmq_shovel_management</code>，因此只需要在所需的 RabbitMQ 节点上分别启用 Shovel 插件即可，如下所示：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用 rabbitmq_shovel 插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_shovel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 rabbitmq_shovel_management 插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_shovel_management</span><br></pre></td></tr></tbody></table></figure><ul><li>当 Shovel 插件成功启用后，在 RabbitMQ 节点的控制台页面中，可以看到以下内容：</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-82.png"></p><h3 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h3><p>本节将演示如何使用 Shovel 插件，整体工作流程如下图所示：</p><p><img data-src="../../../asset/2025/04/rabbitmq-79.png"></p><h4 id="版本说明-2"><a href="#版本说明-2" class="headerlink" title="版本说明"></a>版本说明</h4><p>本案例使用的各软件版本如下表所示：</p><table><thead><tr><th>组件</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> RabbitMQ Server</td><td><code>3.8.26</code></td><td></td></tr><tr><td>RabbitMQ Client</td><td><code>5.10.0</code></td><td></td></tr><tr><td>Erlang</td><td><code>24.2</code></td><td></td></tr><tr><td>Java</td><td><code>11</code></td><td></td></tr></tbody></table><h4 id="节点说明-2"><a href="#节点说明-2" class="headerlink" title="节点说明"></a>节点说明</h4><p><strong>这里简单使用两个独立的 RabbitMQ 节点（非同一个集群），并且都已经启用 Shovel 插件</strong>，如下表所示：</p><table><thead><tr><th>节点的名称</th><th>节点的 IP</th><th> 节点暴露的端口</th><th>节点的主机名称</th><th>节点的控制台访问地址</th><th>说明</th></tr></thead><tbody><tr><td>独立节点一</td><td> 192.168.2.143</td><td><code>5673</code>、<code>15673</code></td><td>rabbitmq-node1</td><td><code>http://192.168.2.143:15673</code></td><td>作为源端（Source）</td></tr><tr><td>独立节点二</td><td> 192.168.2.144</td><td><code>5674</code>、<code>15674</code></td><td>rabbitmq-node2</td><td><code>http://192.168.2.144:15674</code></td><td>作为目标端（Destination）</td></tr></tbody></table><h4 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h4><ul><li>在 RabbitMQ 独立节点一（<code>rabbitmq-node1</code>）中，创建对应的交换机和队列，并建立绑定关系，可以通过 Web 控制台或者 Java 代码进行创建，同时让消费者订阅队列中的消息。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ 独立节点一（Source）的消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConsumerNode1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"shovel1_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"Q1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的路由键（绑定键）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ROUTING_KEY = <span class="string">"routekey.q1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.2.148"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5673</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// type – 交换机类型</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久交换机，则为 true（交换机将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 交换机，则为 true（当最后一个绑定队列解除绑定后，自动删除该交换机）</span></span><br><span class="line">        <span class="comment">// arguments – 交换的其他属性（构造参数）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久队列，则为 true（队列将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// exclusive – 如果需要声明一个独占队列（仅限于此连接使用，连接关闭后队列自动删除），则为 true。</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 队列，则为 true（服务器将在最后一个消费者断开连接以后，自动删除该队列）</span></span><br><span class="line">        <span class="comment">// arguments – 队列的其他属性（构造参数）</span></span><br><span class="line">        <span class="comment">// 特别注意：如果确定队列已存在，消费者可以不声明队列。但是，强烈建议无论生产者还是消费者，都应该声明队列，确保参数可控</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定交换机和队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// routingKey – 用于绑定的 RoutingKey（如果不使用 Routingkey，可填空字符串）</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, QUEUE_ROUTING_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">"Successed to consume message : "</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动确认消息</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// deliveryTag – 消息的标记</span></span><br><span class="line">            <span class="comment">// multiple – true 表示确认所有消息，包括提供的送达标签为止的所有消息；false 仅确认提供的投放标记</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消费时的回调（比如，在消费的时候队列已被删除掉）</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Failed to consume message : "</span> + consumerTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"消费者开始消费消息..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭自动确认机制</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// autoAck – 如果需要服务器在消息投递后自动确认消息，则为 true；如果需要客户端手动确认消息，则为 false</span></span><br><span class="line">        <span class="comment">// deliverCallback – 消费消息时的回调</span></span><br><span class="line">        <span class="comment">// cancelCallback – 取消消费时的回调</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让消费者持续运行</span></span><br><span class="line">        System.out.println(<span class="string">"按回车键退出程序："</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭信道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在 RabbitMQ 独立节点二（<code>rabbitmq-node2</code>）中，创建对应的交换机和队列，并建立绑定关系，可以通过 Web 控制台或者 Java 代码进行创建，同时让消费者订阅队列中的消息。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ 独立节点二（Destination）的消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConsumerNode2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"shovel2_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"Q2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的路由键（绑定键）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ROUTING_KEY = <span class="string">"routekey.q2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.2.148"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5674</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// type – 交换机类型</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久交换机，则为 true（交换机将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 交换机，则为 true（当最后一个绑定队列解除绑定后，自动删除该交换机）</span></span><br><span class="line">        <span class="comment">// arguments – 交换的其他属性（构造参数）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// durable – 如果需要声明一个持久队列，则为 true（队列将在服务器重启后继续存在）</span></span><br><span class="line">        <span class="comment">// exclusive – 如果需要声明一个独占队列（仅限于此连接使用，连接关闭后队列自动删除），则为 true。</span></span><br><span class="line">        <span class="comment">// autoDelete – 如果需要声明 autoDelete 队列，则为 true（服务器将在最后一个消费者断开连接以后，自动删除该队列）</span></span><br><span class="line">        <span class="comment">// arguments – 队列的其他属性（构造参数）</span></span><br><span class="line">        <span class="comment">// 特别注意：如果确定队列已存在，消费者可以不声明队列。但是，强烈建议无论生产者还是消费者，都应该声明队列，确保参数可控</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定交换机和队列</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">        <span class="comment">// routingKey – 用于绑定的 RoutingKey（如果不使用 Routingkey，可填空字符串）</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, QUEUE_ROUTING_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">"Successed to consume message : "</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动确认消息</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// deliveryTag – 消息的标记</span></span><br><span class="line">            <span class="comment">// multiple – true 表示确认所有消息，包括提供的送达标签为止的所有消息；false 仅确认提供的投放标记</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消费时的回调（比如，在消费的时候队列已被删除掉）</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Failed to consume message : "</span> + consumerTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"消费者开始消费消息..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭自动确认机制</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// queue – 队列的名称</span></span><br><span class="line">        <span class="comment">// autoAck – 如果需要服务器在消息投递后自动确认消息，则为 true；如果需要客户端手动确认消息，则为 false</span></span><br><span class="line">        <span class="comment">// deliverCallback – 消费消息时的回调</span></span><br><span class="line">        <span class="comment">// cancelCallback – 取消消费时的回调</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让消费者持续运行</span></span><br><span class="line">        System.out.println(<span class="string">"按回车键退出程序："</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭信道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="添加-Shovel"><a href="#添加-Shovel" class="headerlink" title="添加 Shovel"></a>添加 Shovel</h4><ul><li>在 RabbitMQ 控制台的配置页面中，添加 Shovel 时可以将源端（Source）和目标端（Destination）设置为交换机或者队列，其中 RabbitMQ 的默认行为如下：</li></ul><table><thead><tr><th>源端的选择</th><th>默认行为</th></tr></thead><tbody><tr><td>如果源端（Source）选择的是 Queue</td><td>RabbitMQ 会在创建 Shovel 之前，预先自动创建该队列（如果队列不存在就自动创建）</td></tr><tr><td>如果源端（Source）选择的是 Exchange</td><td>RabbitMQ 不会预先自动创建该交换机，但如果源端（Source）是 Exchange，会自动创建一个内部队列，并绑定到这个 Exchange，以便从 Exchange 拉取消息</td></tr></tbody></table><ul><li>在 RabbitMQ 独立节点二（<code>rabbitmq-node2</code>）的 Web 控制台中，添加 Shovel，如下图所示：</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-80.png"></p><blockquote><p>参数说明：<br>Name：Shovel 的名称<br>URI：节点 的 URI 地址，其中 <code>amqp://</code> 是协议前缀，<code>admin:admin</code> 用户名和密码，<code>@rabbitmq-node1</code> 是主机名称。</p></blockquote><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Shovel 是 "谁配置，谁搬运"，一般推荐将 Shovel 添加在目标端（Destination）节点上，也可以添加在中立第三方节点。这样目标端可以主动拉取消息，更安全可控，易于统一监控与运维。</p></div><h4 id="查看-Shovel"><a href="#查看-Shovel" class="headerlink" title="查看 Shovel"></a>查看 Shovel</h4><ul><li>当 Shovel 添加完成后，并且交换机 / 队列也创建完成后，如果一切正常运行，那么在独立节点二（<code>rabbitmq-node2</code>）的 Web 控制台中可以看到 Shovel 状态显示正常。</li></ul><p><img data-src="../../../asset/2025/04/rabbitmq-81.png"></p><h4 id="测试-Shovel"><a href="#测试-Shovel" class="headerlink" title="测试 Shovel"></a>测试 Shovel</h4><ul><li>创建一个生产者，发送消息到独立节点一（<code>rabbitmq-node1</code>）中的队列</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQ 独立节点一（Source）的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQProducerNode1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"shovel1_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的路由键（绑定键）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ROUTING_KEY = <span class="string">"routekey.q1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.2.148"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5673</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 try-with-resources 自动关闭连接和通道，确保资源释放</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 创建连接</span></span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            <span class="comment">// 创建信道</span></span><br><span class="line">            Channel channel = connection.createChannel()</span><br><span class="line">        ) {</span><br><span class="line">            <span class="comment">// 声明交换机</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// exchange – 交换机的名称</span></span><br><span class="line">            <span class="comment">// type – 交换机类型</span></span><br><span class="line">            <span class="comment">// durable – 如果需要声明一个持久交换机，则为 true（交换机将在服务器重启后继续存在）</span></span><br><span class="line">            <span class="comment">// autoDelete – 如果需要声明 autoDelete 交换机，则为 true（当最后一个绑定队列解除绑定后，自动删除该交换机）</span></span><br><span class="line">            <span class="comment">// arguments – 交换的其他属性（构造参数）</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="comment">// 参数说明：</span></span><br><span class="line">            <span class="comment">// exchange – 要将消息发布到的交换机，空字符串表示默认交换机</span></span><br><span class="line">            <span class="comment">// routingKey – 路由 Key</span></span><br><span class="line">            <span class="comment">// props – 消息的其他属性，比如：使用 MessageProperties.PERSISTENT_TEXT_PLAIN 属性确保消息持久化，配合持久化队列可避免服务器重启导致消息丢失</span></span><br><span class="line">            <span class="comment">// body – 消息内容</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, QUEUE_ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"hello"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码测试结果：启动所有生产者和消费者应用，由于在独立节点二（<code>rabbitmq-node2</code>）中配置了 Shovel，且源端（Source）和目标端（Destination）选择的都是队列，当发送消息到 RabbitMQ 独立节点一（<code>rabbitmq-node1</code>）的队列时，RabbitMQ 会轮询分发消息给独立节点一（<code>rabbitmq-node1</code>）和独立节点二（<code>rabbitmq-node2</code>）的消费者。举个例子，当发送消息 A 和消息 B 到独立节点一的队列时，独立节点一的消费者会接收到消息 A，而独立节点二的消费者会接收到消息 B，消息不会被重复消费。</li></ul><h4 id="使用总结说明"><a href="#使用总结说明" class="headerlink" title="使用总结说明"></a>使用总结说明</h4><p>在 RabbitMQ 的 Web 控制台中，对于 Shovel 的源端（Source）和目标端（Destination）的不同配置，有着不同的运行效果：</p><table><thead><tr><th>源端选择</th><th>目标端选择</th><th>实际运行效果</th><th>运行效果类比</th></tr></thead><tbody><tr><td>队列</td><td>队列</td><td>从源队列消费消息，重新发布到目标队列（目标队列可在不同实例），实现真正的 “消息搬运”</td><td> 运行效果类似 Federated Queue（联邦队列），可以让多个 RabbitMQ 节点（或者集群）共享消费同一个逻辑队列的数据，即可以在跨节点的多个消费者之间轮询分发消息</td></tr><tr><td>交换机</td><td>交换机</td><td>自动绑定一个临时队列到源交换机 → 从该队列消费消息 → 发布到目标交换机</td><td>运行效果类似 Federated Exchange（联邦交换机），可实现广播复制效果</td></tr><tr><td>队列</td><td>交换机</td><td>从源队列消费消息，重新发布到目标交换机，再由目标交换机路由到绑定的队列</td><td>最常见用法，灵活可靠</td></tr><tr><td>交换机</td><td>队列</td><td>自动绑定一个临时队列到源交换机 → 从该队列消费消息 → 直接投递到目标队列</td><td>支持，但配置上需要确保匹配路由键</td></tr></tbody></table><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/ac3bb7d5.html" title="RabbitMQ 入门教程之十一">https://www.techgrow.cn/posts/ac3bb7d5.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag"><i class="fa fa-tag"></i> 微服务</a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> 消息队列</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/5a68992a.html" rel="prev" title="ZooKeeper 入门教程之三"><i class="fa fa-angle-left"></i> ZooKeeper 入门教程之三</a></div><div class="post-nav-item"> <a href="/posts/16baf534.html" rel="next" title="ZooKeeper 入门教程之四">ZooKeeper 入门教程之四<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">30:49</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/ac3bb7d5.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>