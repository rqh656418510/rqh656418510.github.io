<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍如何基于 C++ 手写一个线程池，并提供 C++ 11 和 C++ 17 两种版本的实现代码。"><meta property="og:type" content="article"><meta property="og:title" content="基于 C++ 手写线程池"><meta property="og:url" content="https://www.techgrow.cn/posts/585aa296.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍如何基于 C++ 手写一个线程池，并提供 C++ 11 和 C++ 17 两种版本的实现代码。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/05/cxx-thread-pool-1.png"><meta property="article:published_time" content="2025-05-13T13:55:33.000Z"><meta property="article:modified_time" content="2025-05-13T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Linux系统编程"><meta property="article:tag" content="并发编程"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/05/cxx-thread-pool-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/585aa296.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/585aa296.html","path":"posts/585aa296.html","title":"基于 C++ 手写线程池"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>基于 C++ 手写线程池 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E8%83%8C%E6%99%AF"><span class="nav-text">知识背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="nav-text">开发工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-text">版本特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E5%B9%B3%E5%8F%B0"><span class="nav-text">兼容平台</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">多线程的适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-text">多线程的协作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-text">线程互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">线程同步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A2%9D%E5%A4%96%E5%BC%80%E9%94%80"><span class="nav-text">多线程的额外开销</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">线程池的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8A%BF"><span class="nav-text">线程池的使用优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="nav-text">线程池的两种模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">线程池的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="nav-text">整体设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E6%8F%8F%E8%BF%B0"><span class="nav-text">功能描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11-%E7%89%88%E6%9C%AC"><span class="nav-text">C++ 11 版本</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="nav-text">核心代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">测试代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="nav-text">动态链接库</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#GCC-%E7%BC%96%E8%AF%91"><span class="nav-text">GCC 编译</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CMake-%E7%BC%96%E8%AF%91"><span class="nav-text">CMake 编译</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-17-%E7%89%88%E6%9C%AC"><span class="nav-text">C++ 17 版本</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81-1"><span class="nav-text">核心代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-1"><span class="nav-text">测试代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F"><span class="nav-text">特别注意</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D"><span class="nav-text">问题定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="nav-text">问题解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93"><span class="nav-text">项目输出总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%88%B0%E4%BC%81%E4%B8%9A%E9%A1%B9%E7%9B%AE%E4%B8%AD"><span class="nav-text">应用到企业项目中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E5%88%B0%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86%E4%B8%8A"><span class="nav-text">输出到求职简历上</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">711</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/585aa296.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="基于 C++ 手写线程池 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍如何基于 C++ 手写一个线程池，并提供 C++ 11 和 C++ 17 两种版本的实现代码。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 基于 C++ 手写线程池</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-05-13 21:55:33" itemprop="dateCreated datePublished" datetime="2025-05-13T21:55:33+08:00">2025-05-13</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/585aa296.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/585aa296.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>7.1k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>6 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将基于 C++ 手写一个线程池，并分别提供 C++ 11 和 C++ 17 两种版本的线程池实现。线程池作为五大池之一（内存池、连接池、协程池、线程池、进程池），应用非常广泛，不管是客户端程序，还是后台服务程序，都是提高业务处理能力的必备模块。有很多开源的线程池实现，虽然各自接口在使用上稍有区别，但是其核心实现原理都是基本相同的。</p><h3 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h3><p>在基于 C++ 手写线程池之前，应该熟悉并掌握以下技术内容：</p><ul><li>熟练基于 C++ 11 的面向对象编程</li><li>熟悉组合和继承、继承多态、STL 容器、智能指针、函数对象、绑定器、<code>lambda</code> 表达式、可变参数模板编程等。</li><li>熟悉 C++ 11 多线程编程，比如线程互斥、线程同步、原子操作、CAS 等。</li><li>熟悉 <code>thread</code>、<code>mutex</code>、<code>unique_lock</code>、<code>condition_variable</code>、<code>atomic</code> 等。</li><li>熟悉 C++ 17 和 C++ 20 的新特性，比如 C++ 17 的 <code>any</code> 类型和 C++ 20 的 <code>counting_semaphore</code> 信号量类型等。</li></ul><span id="more"></span><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>本文使用以下工具来开发 C++ 线程池项目：</p><ul><li>C++ 11 / C++ 17</li><li>Visual Studio 2019</li><li>CMake 构建编译环境</li><li> GDB 调试分析定位线程死锁问题</li><li> Linux 编译项目生成动态链接库（<code>.so</code>）</li></ul><h3 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h3><p>C++ 各版本支持的特性如下：</p><table><thead><tr><th>特性名称</th><th>对应头文件</th><th>最低支持的 C++ 标准版本</th><th>说明</th></tr></thead><tbody><tr><td><code>std::make_unique</code></td><td><code>&lt;memory&gt;</code></td><td>C++ 14</td><td>C++ 14 引入，用于简洁安全地创建 <code>unique_ptr</code> 智能指针。</td></tr><tr><td><code>std::any</code></td><td><code>&lt;any&gt;</code></td><td>C++ 17</td><td> 提供类型安全的类型擦除容器。</td></tr><tr><td><code>std::counting_semaphore</code></td><td><code>&lt;semaphore&gt;</code></td><td>C++ 20</td><td>C++ 20 引入的信号量机制。</td></tr><tr><td><code>std::packaged_task</code></td><td><code>&lt;future&gt;</code></td><td>C++ 11</td><td> 将可调用对象封装起来，并用于异步执行。</td></tr><tr><td><code>std::future</code></td><td><code>&lt;future&gt;</code></td><td>C++ 11</td><td> 异步操作的结果获取机制，可以与 <code>std::async</code>、<code>std::promise</code> 搭配使用。</td></tr><tr><td>可变参数模板</td><td>语言特性</td><td> C++ 11</td><td> 支持模板中参数数量可变，用于构建灵活函数模板，如递归参数展开等。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><p>如果使用的是 GCC、Clang 或 MSVC 编译器，需确保编译器版本也支持相应的 C++ 标准。若需进一步查询编译器支持的标准或特性情况，可以参考 <a target="_blank" rel="external nofollow" href="https://zh.cppreference.com">C/C++ 参考手册</a>。</p></div><h3 id="兼容平台"><a href="#兼容平台" class="headerlink" title="兼容平台"></a>兼容平台</h3><p>本文提供的所有 C++ 线程池代码都可以兼容 Windows 和 Linux 平台，并分别提供 C++ 11 和 C++ 17 两种版本的线程池实现。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li><p><strong>并发（Concurrency）</strong></p><ul><li>在单核处理器上，多个线程之间通过操作系统的调度机制交替执行，每个线程轮流占用 CPU 的时间片（例如每 10 毫秒切换一次）。由于每个线程执行的时间片非常短，人们在宏观上感受到这些线程像是 “同时” 在执行一样，虽然它们在物理层面上是串行执行的。这种 “看起来同时执行” 的场景被称为并发。</li></ul></li><li><p><strong>并行（Parallelism）</strong></p><ul><li>在多核处理器或多 CPU 系统中，多个线程可以被分配到不同的核心上同时执行，彼此之间互不抢占 CPU 时间资源，是真正意义上的 “同时执行”。这种多个任务在物理层面并行的执行方式称为并行。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>简而言之，并发是 "逻辑上的同时发生"，并行是 "物理上的同时进行"。</p></div><h3 id="多线程的适用场景"><a href="#多线程的适用场景" class="headerlink" title="多线程的适用场景"></a>多线程的适用场景</h3><p>多线程程序的性能就一定好吗？不一定，要看具体的应用场景：</p><ul><li><p><strong>I/O 密集型场景</strong></p><ul><li>对于涉及大量 I/O 操作（如磁盘读写、网络通信、数据库访问等）的程序，这些操作通常会导致线程阻塞，从而释放 CPU 时间片。此时，通过多线程并发处理，可以有效利用 CPU 的空闲时间，提高程序的吞吐量和响应速度。因此，无论是 CPU 单核、CPU 多核、多 CPU，多线程通常都能带来较好的性能提升，因此适合运行多线程程序。</li></ul></li><li><p><strong>CPU 密集型场景</strong></p><ul><li>CPU 单核<ul><li>在 CPU 单核中，多个线程无法真正并行执行，只能通过 CPU 时间片轮转实现 “伪并发”。多线程会导致频繁的线程上下文切换，增加 CPU 调度开销，甚至可能因为线程数量过多而拖慢整体性能。<strong>在这种情况下，使用单线程可能反而更高效，因此不适合运行多线程程序</strong>。</li></ul></li><li>CPU 多核、多 CPU<ul><li> 多个线程可以被调度到多个核心上并行运行，从而充分利用计算资源，提高程序的运行效率。对于 CPU 密集型任务（如图像处理、大规模计算等），多线程可以显著提升性能，尤其是在合理控制线程数量、避免过度竞争的前提下，因此适合运行多线程程序。</li></ul></li></ul></li></ul><h3 id="多线程的协作机制"><a href="#多线程的协作机制" class="headerlink" title="多线程的协作机制"></a>多线程的协作机制</h3><p>在 C++ 中，为了实现多线程之间的正确协作与安全访问共享资源，通常需要使用线程互斥与线程同步机制。</p><h4 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h4><p>线程互斥用于防止多个线程同时访问共享资源，从而避免数据竞争和数据不一致的问题。常用机制包括：</p><ul><li><p><code>mutex</code> 互斥锁</p><ul><li>提供基本的加锁与解锁操作（<code>lock()</code> / <code>unlock()</code> 或 <code>lock_guard</code> / <code>unique_lock</code> 自动管理），确保同一时间只有一个线程能够访问临界区（共享资源）。</li></ul></li><li><p><code>recursive_mutex</code> 递归互斥锁</p><ul><li>支持同一个线程多次对同一个互斥锁加锁，适用于递归函数调用场景。</li></ul></li><li><p><code>atomic</code> 原子类型</p><ul><li>提供无锁的并发访问机制，支持原子操作，如自增、比较交换等，适用于简单共享变量的并发访问，性能较高。</li></ul></li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>线程同步用于协调多个线程之间的执行顺序，例如一个线程等待另一个线程完成某项任务后再继续执行。常用机制包括：</p><ul><li><p><code>condition_variable</code> 条件变量</p><ul><li>配合互斥锁（<code>mutex</code>）使用，允许线程在满足某个条件之前进入等待状态，并在条件满足后被唤醒。适合用于生产者 - 消费者模型等场景。</li></ul></li><li><p><code>semaphore</code> 信号量（C++ 20 引入）</p><ul><li>用于控制对某个资源的并发访问数量，即限制同一时刻最多有 N 个线程访问某个共享资源（可用作限流器），适用于如电商秒杀、停车场停车等业务场景。</li></ul></li><li><p><code>barrier</code> / <code>latch</code>（C++ 20 引入）</p><ul><li>用于多线程之间的阶段性同步。例如，所有线程都执行到某一步后再一起进入下一阶段。</li></ul></li></ul><h3 id="多线程的额外开销"><a href="#多线程的额外开销" class="headerlink" title="多线程的额外开销"></a>多线程的额外开销</h3><p>为了完成任务，创建很多的线程可以吗？线程真的是越多越好吗？答案是否定的。</p><ul><li>线程的创建和销毁都是非常 “重” 的操作（涉及用户空间和内核空间的切换）；</li><li>线程栈（通常为 8MB）本身占用大量内存空间；</li><li>线程的上下文切换需要占用大量时间；</li><li>大量线程同时唤醒，会导致操作系统经常出现锯齿状负载或者瞬间负载量很大，造成系统宕机。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Linux 平台下，通过 <code>pthread</code> 库默认最多可以创建约 <code>380</code> 个线程。若希望创建更多的线程，可以降低线程栈的大小（比如 8KB），还可以增大 Linux 系统的最大可打开文件描述符数（<code>ulimit -n</code>），或者最大可创建的用户进程数 / 线程数（<code>ulimit -u</code>）。</p></div><h2 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h2><h3 id="线程池的使用优势"><a href="#线程池的使用优势" class="headerlink" title="线程池的使用优势"></a>线程池的使用优势</h3><p>在操作系统中，线程的创建和销毁都是较为 “昂贵” 的操作，不仅耗时，而且会消耗较多的系统资源。如果在服务运行过程中，每当有任务到来就动态创建线程来执行，任务完成后又立即销毁线程，那么在高并发或大流量场景下，频繁的线程创建与销毁会显著降低系统的实时响应能力，增加 CPU 开销，从而影响整体业务的处理效率。线程池的出现正是为了解决这一问题。在线程池机制中，服务进程在启动阶段就会预先创建好一组可复用的线程（即线程池），这些线程会在后台处于等待状态。当业务任务到来时，系统无需重新创建线程，而是直接从线程池中取出一个空闲线程来执行任务（Task）。任务执行完毕后，该线程不会被销毁，而是归还给线程池，等待下一次任务（Task）的分配。</p><ul><li>线程池带来了多种优势：<ul><li>减少线程创建和销毁的开销，提高系统性能；</li><li>避免线程资源耗尽，通过线程池大小限制线程总数，控制系统并发量；</li><li>提升响应速度，线程可立即复用，减少任务启动延迟；</li><li>便于线程管理和监控，统一由线程池控制线程生命周期和运行状态。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>线程池是一种非常重要的并发编程工具，特别适用于高并发、高吞吐、对实时性有要求的业务场景。</p></div><h3 id="线程池的两种模式"><a href="#线程池的两种模式" class="headerlink" title="线程池的两种模式"></a>线程池的两种模式</h3><ul><li><p><strong>Fixed 模式线程池（固定大小线程池）</strong></p><ul><li>在这种模式下，线程池中的线程数量在创建时就被固定，且在整个线程池的生命周期内保持不变。一般在初始化线程池时，会根据当前机器的 CPU 核心数量或业务需求设定一个合理的线程数。</li><li>当有任务到来时，如果线程池中有空闲线程，则立即分配执行；如果线程都处于忙碌状态，则任务会被放入等待队列中，排队等待有空闲的线程。</li><li>Fixed 模式适合任务量较为稳定、对系统资源可控性要求较高的场景，有助于防止线程数量膨胀导致系统负载过高。</li></ul></li><li><p><strong>Cached 模式线程池（缓存线程池）</strong></p><ul><li>在这种模式下，线程池的线程数量不是固定的，而是可以根据实际任务量动态增长。当有新的任务到来时，如果线程池中没有空闲线程，会临时创建新的线程来处理任务，并在任务完成后将其归还到线程池中。</li><li>为了防止线程无限增长，通常会设置一个线程最大数量的阀值。此外，如果某个线程在空闲超过指定时间（如 60 秒）后仍无新任务可执行，它将被自动销毁，从而释放资源。线程池会始终保留初始的核心线程数，用于处理正常业务流量。</li><li>Cached 模式适用于任务处理量波动较大、流量突发性强的场景，可以在短时间内快速扩展线程池以应对高并发流量，但需要注意合理设置线程上限以避免资源耗尽。</li></ul></li></ul><h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><p><img data-src="../../../asset/2025/05/cxx-thread-pool-1.png"></p><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><ul><li>(1) 基于 C++ 可变参数模板编程和引用折叠原理，实现线程池 <code>submitTask</code> 接口，支持任意任务函数和任意参数的传递</li><li> (2) 使用 <code>future</code> 类型定制 <code>submitTask</code> 接口提交任务的返回值</li><li> (3) 使用 <code>map</code> 和 <code>queue</code> 容器管理线程对象和任务</li><li> (4) 基于条件变量 <code>condition_variable</code> 和互斥锁 <code>mutex</code> 实现任务提交线程和任务执行线程间的同步通信机制</li><li> (5) 支持 <code>fixed</code> 模式和 <code>cached</code> 模式的线程池定制</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="C-11-版本"><a href="#C-11-版本" class="headerlink" title="C++ 11 版本"></a>C++ 11 版本</h4><p>这里基于 C++ 11 手写一个线程池，并自行实现 <code>make_unique()</code>、<code>any</code> 类型、信号量类型。</p><div class="admonition note"><p class="admonition-title">代码下载</p><p>C++ 11 实现线程池的完整案例代码可以从 <a target="_blank" rel="external nofollow" href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-thread-pool/c%2B%2B-11-thread-pool">这里</a> 下载得到，所有案例代码都兼容 Windows 和 Linux 平台。</p></div><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><ul><li><code>extend.h</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// make_unique() /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> extend {</span><br><span class="line">    <span class="comment">// 创建非数组类型对象</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;!std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt;&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">make_unique</span><span class="params">(Args &amp;&amp;... args)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建未知大小的数组（例如 make_unique&lt;T[]&gt;(n)）</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_array&lt;T&gt;::value &amp;&amp; std::extent&lt;T&gt;::value == <span class="number">0</span>, std::unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">    <span class="built_in">make_unique</span>(std::<span class="keyword">size_t</span> size) {</span><br><span class="line">        <span class="keyword">using</span> ElementType = <span class="keyword">typename</span> std::remove_extent&lt;T&gt;::type;</span><br><span class="line">        <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> ElementType[size]());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止使用定长数组（例如 make_unique&lt;int[10]&gt; 是不合法的）</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;(std::extent&lt;T&gt;::value != <span class="number">0</span>), <span class="keyword">void</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">make_unique</span><span class="params">(Args &amp;&amp;...)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// Any 类型 /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 类型（可以接收任意数据类型）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Any</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用带左值的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Any</span>(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用带左值的赋值运算符</span></span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值的拷贝构造函数（移动拷贝构造）</span></span><br><span class="line">    <span class="built_in">Any</span>(Any&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值的赋值运算符（移动赋值运算符）</span></span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(Any &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用构造函数（让 Any 类型可以接收任意数据类型）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T&amp;&amp; data)</span> : base_(extend::make_unique&lt;Derive&lt;typename std::decay&lt;T&gt;::type&gt;&gt;(std::forward&lt;T&gt;(data))) {</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换（将 Any 类型存储的数据类型提取出来）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">cast</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (base_ == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"Any is empty"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将基类指针转换为派生类指针（类型向下转换）</span></span><br><span class="line">        Derive &lt;T&gt; *p = <span class="keyword">dynamic_cast</span>&lt;Derive &lt;T&gt; *&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"type is unmatch!"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回真实的数据类型</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;<span class="built_in">getData</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 基类类型</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 虚析构函数</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类类型</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 通用构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">        <span class="title">Derive</span><span class="params">(U &amp;&amp;data)</span> : data_(std::forward&lt;U&gt;(data)) {</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">Derive</span>() {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> data_;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T data_;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;    <span class="comment">// 基类指针</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////// Semaphore 信号量 /////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量类（用于线程通信）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="keyword">int</span> limit = <span class="number">0</span>) : <span class="built_in">limit_</span>(limit), <span class="built_in">isDestroyed</span>(<span class="literal">false</span>) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Semaphore</span>() {</span><br><span class="line">        <span class="comment">// 标记当前对象已经被析构</span></span><br><span class="line">        isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个信号量资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isDestroyed) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待信号量资源</span></span><br><span class="line">            cond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> limit_ &gt; <span class="number">0</span>; });</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更改资源计数</span></span><br><span class="line">            limit_--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个信号量资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isDestroyed) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更改资源计数</span></span><br><span class="line">            limit_++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知其他线程获取信号量资源</span></span><br><span class="line">            <span class="comment">// 特别注意，在默认情况下，Linux 平台中 condition_variable 的析构函数什么也没做，会导致这里状态已经失效；一旦外部使用它的对象（比如 Result）提前析构，就会无故阻塞线程，造成线程死锁</span></span><br><span class="line">            cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> limit_;                     <span class="comment">// 资源计数</span></span><br><span class="line">    std::mutex mtx_;                <span class="comment">// 互斥锁</span></span><br><span class="line">    std::condition_variable cond_;  <span class="comment">// 条件变量</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isDestroyed;   <span class="comment">// 是否已经被析构（用于解决Linux平台的兼容问题）</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EXTEND_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>thread_pool.h</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"extend.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池核心参数 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的线程数量（默认是CPU的核心数）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INIT_THREAD_SIZE = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TASK_MAX_THRESHHOLD = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_SIZE_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程允许的最大空闲时间（单位秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">PoolMode</span> {</span></span><br><span class="line">    MODE_FIXED,    <span class="comment">// 固定大小线程池</span></span><br><span class="line">    MODE_CACHED    <span class="comment">// 缓存线程池</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务抽象类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行结果类的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Task</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数，实现用户自定义的任务处理逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Result *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Result *result_;    <span class="comment">// 任务执行结果（使用裸指针，避免智能指针循环引用问题）</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务结果类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="keyword">bool</span> isValid = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Result</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    <span class="function">Any <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(Any data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断任务执行结果是否有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断关联的任务是否已完成</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFinished</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Any data_;                        <span class="comment">// 存储任务执行的结果</span></span><br><span class="line">    Semaphore sem_;                   <span class="comment">// 线程通信的信号量</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isValid_;        <span class="comment">// 任务执行结果是否有效</span></span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;      <span class="comment">// 关联的任务</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isFinished_;     <span class="comment">// 关联的任务是否已执行完成</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数对象的类型</span></span><br><span class="line">    <span class="keyword">using</span> ThreadHandler = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程构造</span></span><br><span class="line">    <span class="built_in">Thread</span>(ThreadHandler handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程析构</span></span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> threadId_;                    <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> generateId_;           <span class="comment">// 用于辅助生成全局唯一的线程ID</span></span><br><span class="line">    ThreadHandler threadHandler_;     <span class="comment">// 线程处理函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池析构</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initThreadSize = INIT_THREAD_SIZE)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务给线程池</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Result&gt; <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池的运行状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理已完成的任务执行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanTaskResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;        <span class="comment">// 线程集合</span></span><br><span class="line">    PoolMode poolMode_;                                               <span class="comment">// 线程池的模式</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isPoolRuning_;                                   <span class="comment">// 表示线程池是否正在运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> initThreadSize_;                                           <span class="comment">// 初始的线程数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> idleThreadSize_;                                  <span class="comment">// 空闲线程的数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> curThreadSize_;                                   <span class="comment">// 当前线程池的线程数量</span></span><br><span class="line">    <span class="keyword">int</span> threadSizeMaxThreshHold_;                                     <span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"></span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;Task&gt;&gt; taskQueue_;                     <span class="comment">// 任务队列</span></span><br><span class="line">    std::<span class="keyword">atomic_uint</span> taskSize_;                                       <span class="comment">// 当前任务队列的任务数量</span></span><br><span class="line">    <span class="keyword">size_t</span> taskQueMaxThreshHold_;                                     <span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;                                           <span class="comment">// 任务队列操作的互斥锁</span></span><br><span class="line">    std::condition_variable notFull_;                                 <span class="comment">// 表示任务队列不满，用于通知用户线程提交任务</span></span><br><span class="line">    std::condition_variable notEmpty_;                                <span class="comment">// 表示任务队列不空，用于通知线程池中的线程执行任务</span></span><br><span class="line">    std::condition_variable allExit_;                                 <span class="comment">// 表示等待线程池回收所有线程</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Result&gt;&gt; taskResults_;                <span class="comment">// 任务执行结果列表，用于避免任务执行结果比任务早被析构</span></span><br><span class="line">    std::mutex taskResultsMtx_;                                       <span class="comment">// 任务执行结果的互斥锁</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// THREAD_POOL_H</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>thread_pool.cpp</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务抽象类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Task::<span class="built_in">Task</span>() : <span class="built_in">result_</span>(<span class="literal">nullptr</span>) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task::exec</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 执行任务处理逻辑（发生多态调用）</span></span><br><span class="line">    Any data = <span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务执行结果</span></span><br><span class="line">    <span class="keyword">if</span> (result_ != <span class="literal">nullptr</span>) {</span><br><span class="line">        result_-&gt;<span class="built_in">setVal</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task::setResult</span><span class="params">(Result *p)</span> </span>{</span><br><span class="line">    result_ = p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 任务结果类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="keyword">bool</span> isValid) : <span class="built_in">task_</span>(task), <span class="built_in">isValid_</span>(isValid), <span class="built_in">isFinished_</span>(<span class="literal">false</span>) {</span><br><span class="line">    <span class="comment">// 关联任务和任务执行结果</span></span><br><span class="line">    task-&gt;<span class="built_in">setResult</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取任务执行结果</span></span><br><span class="line"><span class="function">Any <span class="title">Result::get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果任务执行结果无效，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isValid_) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待获取一个信号量资源（即让当前线程等待任务执行完成）</span></span><br><span class="line">    sem_.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回任务执行完成的结果</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(data_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Result::setVal</span><span class="params">(Any data)</span> </span>{</span><br><span class="line">    <span class="comment">// 存储任务执行结果</span></span><br><span class="line">    data_ = std::<span class="built_in">move</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联的任务已执行完成</span></span><br><span class="line">    isFinished_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个信号量资源（即通知其他线程获取任务执行结果）</span></span><br><span class="line">    sem_.<span class="built_in">post</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断任务执行结果是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Result::isValid</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isValid_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断关联的任务是否已完成</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Result::isFinished</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isFinished_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程构造</span></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadHandler handler) : <span class="built_in">threadHandler_</span>(handler), <span class="built_in">threadId_</span>(generateId_++) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程析构</span></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个线程，并执行线程处理函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadHandler_, threadId_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子线程设置为分离线程</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread::getId</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> threadId_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于辅助生成全局唯一的线程ID</span></span><br><span class="line"><span class="keyword">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 ////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池构造</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>() {</span><br><span class="line">    idleThreadSize_ = <span class="number">0</span>;</span><br><span class="line">    curThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">    initThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">    threadSizeMaxThreshHold_ = THREAD_SIZE_MAX_THRESHHOLD;</span><br><span class="line">    taskSize_ = <span class="number">0</span>;</span><br><span class="line">    taskQueMaxThreshHold_ = TASK_MAX_THRESHHOLD;</span><br><span class="line">    poolMode_ = PoolMode::MODE_FIXED;</span><br><span class="line">    isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池析构</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁，用于等待线程池里面所有的线程结束运行（线程有两种状态：阻塞等待获取任务 &amp; 正在执行任务中）</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先获取互斥锁，然后再唤醒所有正在等待获取任务的线程，避免发生线程死锁问题</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程池里的所有线程回收完成</span></span><br><span class="line">    allExit_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的工作模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        poolMode_ = mode;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; !<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        threadSizeMaxThreshHold_ = threshhold;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">        taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查线程池的运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ThreadPool::checkRunningState</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isPoolRuning_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理已完成的任务执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::cleanTaskResult</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">    <span class="comment">// 将满足条件的元素移动到容器末尾</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::<span class="built_in">remove_if</span>(taskResults_.<span class="built_in">begin</span>(), taskResults_.<span class="built_in">end</span>(), [](<span class="keyword">const</span> std::shared_ptr&lt;Result&gt; &amp;res) {</span><br><span class="line">        <span class="keyword">return</span> res-&gt;<span class="built_in">isFinished</span>();</span><br><span class="line">    });</span><br><span class="line">    <span class="comment">// 删除容器末尾那段区域的所有元素</span></span><br><span class="line">    taskResults_.<span class="built_in">erase</span>(new_end, taskResults_.<span class="built_in">end</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="keyword">int</span> initThreadSize)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRuning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录初始的线程数量</span></span><br><span class="line">    initThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前线程池的线程数量</span></span><br><span class="line">    curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">        <span class="comment">// 创建线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">        std::unique_ptr&lt;Thread&gt; thread = extend::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="comment">// 将线程对象放入线程集合中</span></span><br><span class="line">        threads_.<span class="built_in">emplace</span>(thread-&gt;<span class="built_in">getId</span>(), std::<span class="built_in">move</span>(thread));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动初始的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();    <span class="comment">// 启动一个线程去执行线程处理函数</span></span><br><span class="line">        idleThreadSize_++;        <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span> </span>{</span><br><span class="line">    <span class="comment">// 记录当前线程首次运行的时间</span></span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For死循环，为了实现在线程池结束时，所有任务必须执行完成，线程池才可以回收线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 等待获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让当前线程等待获取任务，使用While循环避免虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 如果任务列表为空，且线程池要结束运行，则回收当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">                <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                <span class="comment">// 唤醒等待线程池回收完毕的线程</span></span><br><span class="line">                allExit_.<span class="built_in">notify_all</span>();</span><br><span class="line">                <span class="comment">// 打印日志信息</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">"thread pool destroy, thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 线程池Cached模式的处理,由于Cached模式下有可能已经创建了很多的线程，但是空闲时间超过最大阀值，因此需要将多余的空闲线程回收掉</span></span><br><span class="line">            <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_) {</span><br><span class="line">                std::cv_status waitResult = notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 需要区分超时返回，还是线程正常被唤醒返回</span></span><br><span class="line">                <span class="keyword">if</span> (std::cv_status::timeout == waitResult) {</span><br><span class="line">                    <span class="keyword">auto</span> nowTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">                    <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(nowTime - lastTime);</span><br><span class="line">                    <span class="comment">// 当线程的空闲时间超过最大阀值，且当前线程池的线程数量大于初始线程数量，则开始回收线程池中的空闲线程</span></span><br><span class="line">                    <span class="keyword">if</span> (duration.<span class="built_in">count</span>() &gt; THREAD_MAX_IDLE_TIME &amp;&amp; curThreadSize_ &gt; initThreadSize_) {</span><br><span class="line">                        <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                        threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                        <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">                        idleThreadSize_--;</span><br><span class="line">                        <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">                        curThreadSize_--;</span><br><span class="line">                        <span class="comment">// 打印日志信息</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">"idle thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                        <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 线程池Fixed模式的处理</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 等待任务队列不为空</span></span><br><span class="line">                notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新空闲线程数量（在当前线程执行任务之前）</span></span><br><span class="line">        idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从任务队列中获取需要执行的任务</span></span><br><span class="line">        std::shared_ptr&lt;Task&gt; task = taskQueue_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务从任务队列中移除</span></span><br><span class="line">        taskQueue_.<span class="built_in">pop</span>();</span><br><span class="line">        taskSize_--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 成功获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果获取了任务之后，任务队列依旧不为空，则继续通知其他线程执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (taskQueue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">            notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为刚获取了任务，任务队列肯定有空余位置（不满），通知用户提交任务到线程池</span></span><br><span class="line">        notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放互斥锁（在当前线程执行任务之前）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程负责执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) {</span><br><span class="line">            task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新空闲线程数量（在当前线程执行完任务之后）</span></span><br><span class="line">        idleThreadSize_++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理已完成的任务执行结果（在当前线程执行完任务之后）</span></span><br><span class="line">        <span class="built_in">cleanTaskResult</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前线程最后执行完任务的时间</span></span><br><span class="line">        lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务给线程池</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Result&gt; <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务队列有空余位置（不满）</span></span><br><span class="line">    <span class="keyword">bool</span> waitResult = notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [<span class="keyword">this</span>]() { <span class="keyword">return</span> taskQueue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; });</span><br><span class="line">    <span class="comment">// 如果等待超时，则返回无效的任务执行结果</span></span><br><span class="line">    <span class="keyword">if</span> (!waitResult) {</span><br><span class="line">        <span class="comment">// 打印错误信息</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"task queue is full, submit task failed."</span>;</span><br><span class="line">        <span class="comment">// 无效的任务执行结果</span></span><br><span class="line">        std::shared_ptr&lt;Result&gt; result = std::make_shared&lt;Result&gt;(task, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">        <span class="comment">// 将任务执行结果保存起来，防止用户未使用而导致提前析构</span></span><br><span class="line">        taskResults_.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">        <span class="comment">// 返回任务执行结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务队列有空余位置（不满），则将任务放入任务队列中</span></span><br><span class="line">    taskQueue_.<span class="built_in">emplace</span>(task);</span><br><span class="line">    taskSize_++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为刚放入了新任务，任务队列肯定不为空，通知线程池中的线程去执行任务</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池Cached模式的处理，根据任务数量动态增加线程池的线程数量</span></span><br><span class="line">    <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; taskSize_ &gt; idleThreadSize_ &amp;&amp; curThreadSize_ &lt; threadSizeMaxThreshHold_) {</span><br><span class="line">        <span class="comment">// 打印日志信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"expand and create new thread."</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 创建新线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">        std::unique_ptr&lt;Thread&gt; thread = extend::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="comment">// 获取线程ID（必须在线程放入线程集合之前获取一次线程ID，否则后续将可能获取到空值）</span></span><br><span class="line">        <span class="keyword">int</span> threadId = thread-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        <span class="comment">// 将新线程对象放入线程集合中</span></span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(thread));</span><br><span class="line">        <span class="comment">// 启动新线程</span></span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">        idleThreadSize_++;</span><br><span class="line">        <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">        curThreadSize_++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有效的任务执行结果</span></span><br><span class="line">    std::shared_ptr&lt;Result&gt; result = std::make_shared&lt;Result&gt;(task);</span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">resultLock</span><span class="params">(taskResultsMtx_)</span></span>;</span><br><span class="line">    <span class="comment">// 将任务执行结果保存起来，防止用户未使用而导致提前析构</span></span><br><span class="line">    taskResults_.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">    <span class="comment">// 返回任务执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><ul><li><code>test.cpp</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> ULong = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义任务类（模拟并行计算）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculateTask</span> :</span> <span class="keyword">public</span> Task {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CalculateTask</span>(ULong begin, ULong end) : <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"execute task by thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程执行计算</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ULong i = begin_; i &lt;= end_; ++i) {</span><br><span class="line">            sum += i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前线程的计算结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Any</span>(sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ULong begin_;    <span class="comment">// 开始计算的位置</span></span><br><span class="line">    ULong end_;      <span class="comment">// 结束计算的位置</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程池的工作模式</span></span><br><span class="line">    <span class="keyword">int</span> poolMode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 获取用户输入</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"请选择线程池的工作模式，0 - Fixed，1 - Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; poolMode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为非法输入</span></span><br><span class="line">        <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) {</span><br><span class="line">            <span class="comment">// 清除错误标志位</span></span><br><span class="line">            std::cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// 丢弃错误输入</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"输入无效，请重新输入一个合法的数字！\n"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部作用域开始</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPool pool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// Fixed模式（固定大小线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_FIXED);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Fixed"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Cached模式（缓存线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">            pool.<span class="built_in">setThreadSizeMaxThreshHold</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程池（指定初始的线程数量）</span></span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::shared_ptr&lt;Result&gt;&gt; results;</span><br><span class="line">        ULong begin = <span class="number">0</span>;</span><br><span class="line">        ULong end = <span class="number">0</span>;</span><br><span class="line">        ULong step = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交多个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 计算区间</span></span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">            end = begin + step - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建任务</span></span><br><span class="line">            std::shared_ptr&lt;Task&gt; task = std::make_shared&lt;CalculateTask&gt;(begin, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            std::shared_ptr&lt;Result&gt; result = pool.<span class="built_in">submitTask</span>(task);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储任务执行结果</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;<span class="built_in">isValid</span>()) {</span><br><span class="line">                results.<span class="built_in">emplace_back</span>(result);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计任务执行结果</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取任务执行结果</span></span><br><span class="line">            ULong result = results[i]-&gt;<span class="built_in">get</span>().cast&lt;ULong&gt;();</span><br><span class="line">            sum += result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出并行计算结果</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"==&gt; 计算结果：1 + 2 + ... + "</span> &lt;&lt; end &lt;&lt; <span class="string">" = "</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是Cached模式，则等待一段时间，触发线程池回收空闲线程</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">1</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）..."</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(THREAD_MAX_IDLE_TIME + <span class="number">5</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 局部作用域结束，线程池自动析构，回收线程池中的所有线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞主线程，直到用户按下任意键才结束程序</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 平台编译测试代码，生成并运行可执行测试程序（使用的 <code>g++</code> 版本是 <code>4.8.5</code>）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++ -Iinclude src/thread_pool.cpp src/test.cpp -o thread_pool_test -pthread -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行测试程序</span></span><br><span class="line">./thread_pool_test</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Fixed 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Fixed</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">thread pool destroy, thread 480 exited.</span><br><span class="line">thread pool destroy, thread 11872 exited.</span><br><span class="line">thread pool destroy, thread 2620 exited.</span><br><span class="line">thread pool destroy, thread 9140 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Cached 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Cached</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15144 成功获取任务...</span><br><span class="line">execute task by thread 15144</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 20812 成功获取任务...</span><br><span class="line">execute task by thread 20812</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 3904 成功获取任务...</span><br><span class="line">execute task by thread 3904</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 15616 成功获取任务...</span><br><span class="line">execute task by thread 15616</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 9800 成功获取任务...</span><br><span class="line">execute task by thread 9800</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）...</span><br><span class="line">idle thread 15616 exited.</span><br><span class="line">idle thread 9800 exited.</span><br><span class="line">idle thread 480 exited.</span><br><span class="line">idle thread 15144 exited.</span><br><span class="line">thread pool destroy, thread 20864 exited.</span><br><span class="line">thread pool destroy, thread 11812 exited.</span><br><span class="line">thread pool destroy, thread 20812 exited.</span><br><span class="line">thread pool destroy, thread 3904 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><h5 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h5><p>为了便于将线程池库提供给第三方使用，可以将线程池项目的核心源码编译成动态链接库。下面将以 Linux 平台为例，介绍使用不同的方式将线程池项目编译为动态链接库（<code>.so</code> 文件）。值得一提的是，C++ 线程池项目的目录结构如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c++-11-thread-pool</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│&nbsp;&nbsp; ├── extend.h</span><br><span class="line">│&nbsp;&nbsp; └── thread_pool.h</span><br><span class="line">└── src</span><br><span class="line">    ├── test.cpp</span><br><span class="line">    └── thread_pool.cpp</span><br></pre></td></tr></tbody></table></figure><h6 id="GCC-编译"><a href="#GCC-编译" class="headerlink" title="GCC 编译"></a>GCC 编译</h6><div class="admonition note"><p class="admonition-title">版本说明</p><p>本文使用的 <code>g++</code> 版本是 <code>4.8.5</code>，若版本过低，可能会出现线程池代码编译失败的问题。</p></div><ul><li>项目的编译构建</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成动态链接库</span></span><br><span class="line">g++ -fPIC -Iinclude -shared src/thread_pool.cpp -o libthread_pool.so -pthread -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++ -Iinclude src/thread_pool.cpp src/test.cpp -o thread_pool_test -pthread -std=c++11</span><br></pre></td></tr></tbody></table></figure><ul><li>编译参数的说明</li></ul><table><thead><tr><th>编译参数</th><th></th><th>参数说明</th></tr></thead><tbody><tr><td><code>-fPIC</code></td><td></td><td>生成位置无关代码，<code>.so</code> 文件必须使用</td></tr><tr><td><code>-Iinclude</code></td><td></td><td>指定头文件目录为 <code>include</code></td></tr><tr><td><code>-shared</code></td><td></td><td>指定编译生成共享库（动态链接库）</td></tr><tr><td><code>src/thread_pool.cpp</code></td><td></td><td>指定源文件路径</td></tr><tr><td><code>-o libthread_pool.so</code></td><td></td><td>指定编译输出的文件名</td></tr><tr><td><code>-pthread</code></td><td></td><td>链接 <code>pthread</code> 库</td></tr><tr><td><code>-std=c++11</code></td><td></td><td>指定 C++ 版本</td></tr></tbody></table><ul><li>动态链接库的安装（可选），如果不安装，第三方程序在运行时可能会遇到找不到动态链接库的问题</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将头文件安装到系统中</span></span><br><span class="line">sudo cp ./include/* /usr/<span class="built_in">local</span>/include</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将编译生成的动态链接库安装到系统中</span></span><br><span class="line">sudo cp libthread_pool.so /usr/<span class="built_in">local</span>/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统的动态链接库配置文件</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt; /etc/ld.so.conf.d/custom.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载系统的动态链接库配置</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></tbody></table></figure><h6 id="CMake-编译"><a href="#CMake-编译" class="headerlink" title="CMake 编译"></a>CMake 编译</h6><div class="admonition note"><p class="admonition-title">版本说明</p><p>本文使用的 <code>g++</code> 版本是 <code>4.8.5</code>，CMake 版本是 <code>3.25.1</code>，若版本过低，可能会出现线程池代码编译失败的问题。值得一提的是，CMake 的详细使用教程可以参考 <a href="/posts/b6161f29.html">这里</a>。</p></div><ul><li>项目的 CMake 配置</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line"># 项目名称和语言</span><br><span class="line">project(cxx_11_thread_pool VERSION 1.0 LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"># 设置 C++ 版本</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line"></span><br><span class="line"># 设置构建模式</span><br><span class="line">set(CMAKE_BUILD_TYPE Debug CACHE STRING "" FORCE)</span><br><span class="line"></span><br><span class="line"># 设置头文件目录</span><br><span class="line">include_directories(${CMAKE_SOURCE_DIR}/include)</span><br><span class="line"></span><br><span class="line"># 设置源文件</span><br><span class="line">file(GLOB SRC_FILES src/*.cpp)</span><br><span class="line"></span><br><span class="line"># 编译生成动态链接库</span><br><span class="line">add_library(thread_pool SHARED ${SRC_FILES})</span><br><span class="line"></span><br><span class="line"># 设置动态链接库的文件名称</span><br><span class="line">set_target_properties(thread_pool PROPERTIES</span><br><span class="line">        OUTPUT_NAME "thread_pool"</span><br><span class="line">        PREFIX "lib"</span><br><span class="line">        SUFFIX ".so"</span><br><span class="line">        POSITION_INDEPENDENT_CODE ON</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 设置动态链接库的链接标志</span><br><span class="line">if (CMAKE_SYSTEM_NAME STREQUAL "Linux")</span><br><span class="line">    target_link_libraries(thread_pool PRIVATE pthread)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line"># 编译生成可执行测试程序</span><br><span class="line">add_executable(thread_pool_test ${SRC_FILES})</span><br><span class="line"></span><br><span class="line"># 设置可执行测试程序的链接标志</span><br><span class="line">if (CMAKE_SYSTEM_NAME STREQUAL "Linux")</span><br><span class="line">    target_link_libraries(thread_pool_test PRIVATE pthread)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line"># 设置默认的安装前缀路径</span><br><span class="line">if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)</span><br><span class="line">    set(CMAKE_INSTALL_PREFIX "/usr/local" CACHE PATH "Install path prefix." FORCE)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"># 将头文件和编译生成的动态链接库安装到指定位置（可选）</span><br><span class="line">install(DIRECTORY include/ DESTINATION include)</span><br><span class="line">install(TARGETS thread_pool DESTINATION lib)</span><br></pre></td></tr></tbody></table></figure><ul><li>项目的编译构建</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成动态链接库和可执行测试程序</span></span><br><span class="line">cmake -S . -B build &amp;&amp; cmake --build build</span><br></pre></td></tr></tbody></table></figure><ul><li>编译参数的说明</li></ul><table><thead><tr><th>编译参数</th><th>参数说明</th></tr></thead><tbody><tr><td><code>-S .</code></td><td>指定源码目录为当前目录（包含 <code>CMakeLists.txt</code>）</td></tr><tr><td><code>-B build</code></td><td>指定构建目录为 <code>build</code>，不存在时会自动创建</td></tr><tr><td><code>cmake --build build</code></td><td>执行编译（相当于 <code>make</code>）</td></tr></tbody></table><ul><li>动态链接库的安装（可选），如果不安装，第三方程序在运行时可能会遇到找不到动态链接库的问题</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-11-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将头文件和编译生成的动态链接库安装到系统中</span></span><br><span class="line">sudo cmake --install build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统的动态链接库配置文件</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt; /etc/ld.so.conf.d/custom.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载系统的动态链接库配置</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></tbody></table></figure><h4 id="C-17-版本"><a href="#C-17-版本" class="headerlink" title="C++ 17 版本"></a>C++ 17 版本</h4><p>这里基于 C++ 17 手写一个线程池，使用了可变参数模板、<code>make_unique()</code>、<code>packaged_task</code>、<code>future</code> 特性。</p><div class="admonition note"><p class="admonition-title">代码下载</p><p>C++ 17 实现线程池的完整案例代码可以从 <a target="_blank" rel="external nofollow" href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-thread-pool/c%2B%2B-17-thread-pool">这里</a> 下载得到，所有案例代码都兼容 Windows 和 Linux 平台。</p></div><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><ul><li><code>thread_pool.h</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池核心参数 ///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的线程数量（默认是CPU的核心数）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INIT_THREAD_SIZE = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TASK_MAX_THRESHHOLD = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_SIZE_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程允许的最大空闲时间（单位秒）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">PoolMode</span> {</span></span><br><span class="line">    MODE_FIXED,    <span class="comment">// 固定大小线程池</span></span><br><span class="line">    MODE_CACHED    <span class="comment">// 缓存线程池</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数对象的类型</span></span><br><span class="line">    <span class="keyword">using</span> ThreadHandler = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程构造</span></span><br><span class="line">    <span class="built_in">Thread</span>(ThreadHandler handler) : <span class="built_in">threadHandler_</span>(handler), <span class="built_in">threadId_</span>(generateId_++) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程析构</span></span><br><span class="line">    ~<span class="built_in">Thread</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个线程，并执行线程处理函数</span></span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">(threadHandler_, threadId_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子线程设置为分离线程</span></span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> threadId_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> threadId_;                    <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> generateId_;           <span class="comment">// 用于辅助生成全局唯一的线程ID</span></span><br><span class="line">    ThreadHandler threadHandler_;     <span class="comment">// 线程处理函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于辅助生成全局唯一的线程ID</span></span><br><span class="line"><span class="keyword">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////// 线程池类 /////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程池构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>() {</span><br><span class="line">        idleThreadSize_ = <span class="number">0</span>;</span><br><span class="line">        curThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">        initThreadSize_ = INIT_THREAD_SIZE;</span><br><span class="line">        threadSizeMaxThreshHold_ = THREAD_SIZE_MAX_THRESHHOLD;</span><br><span class="line">        taskSize_ = <span class="number">0</span>;</span><br><span class="line">        taskQueMaxThreshHold_ = TASK_MAX_THRESHHOLD;</span><br><span class="line">        poolMode_ = PoolMode::MODE_FIXED;</span><br><span class="line">        isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池析构</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">        <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">        isPoolRuning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁，用于等待线程池里面所有的线程结束运行（线程有两种状态：阻塞等待获取任务 &amp; 正在执行任务中）</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须先获取互斥锁，然后再唤醒所有正在等待获取任务的线程，避免发生线程死锁问题</span></span><br><span class="line">        notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程池里的所有线程回收完成</span></span><br><span class="line">        allExit_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            poolMode_ = mode;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setThreadSizeMaxThreshHold</span><span class="params">(<span class="keyword">int</span> threshhold)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; !<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            threadSizeMaxThreshHold_ = threshhold;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置任务队列的最大任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="keyword">size_t</span> threshhold)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">            taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initThreadSize)</span> </span>{</span><br><span class="line">        <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">        isPoolRuning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录初始的线程数量</span></span><br><span class="line">        initThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前线程池的线程数量</span></span><br><span class="line">        curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建初始的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">            <span class="comment">// 创建线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">            std::unique_ptr&lt;Thread&gt; thread = std::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">            <span class="comment">// 将线程对象放入线程集合中</span></span><br><span class="line">            threads_.<span class="built_in">emplace</span>(thread-&gt;<span class="built_in">getId</span>(), std::<span class="built_in">move</span>(thread));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动初始的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) {</span><br><span class="line">            threads_[i]-&gt;<span class="built_in">start</span>();    <span class="comment">// 启动一个线程去执行线程处理函数</span></span><br><span class="line">            idleThreadSize_++;       <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务给线程池（使用可变参数模板 + 引用折叠 + 完美转发）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func &amp;&amp;func, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>{</span><br><span class="line">        <span class="comment">// 推导任务执行结果的类型（返回值类型）</span></span><br><span class="line">        <span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装一个任意可调用对象（函数、函数对象、Lambda表达式等）为异步任务</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">                std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取与异步任务关联的Future，方便用户获取任务执行结果</span></span><br><span class="line">        std::future&lt;RType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待任务队列有空余位置（不满）</span></span><br><span class="line">        <span class="keyword">bool</span> waitResult = notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [<span class="keyword">this</span>]() { <span class="keyword">return</span> taskQueue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; });</span><br><span class="line">        <span class="comment">// 如果等待超时，则直接返回Future</span></span><br><span class="line">        <span class="keyword">if</span> (!waitResult) {</span><br><span class="line">            <span class="comment">// 打印错误信息</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">"task queue is full, submit task failed."</span>;</span><br><span class="line">            <span class="comment">// 封装一个空的任务</span></span><br><span class="line">            <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;([]() -&gt; RType { <span class="keyword">return</span> <span class="built_in">RType</span>(); });</span><br><span class="line">            <span class="comment">// 执行一个空的任务</span></span><br><span class="line">            (*task)();</span><br><span class="line">            <span class="comment">// 返回与任务关联的Future</span></span><br><span class="line">            <span class="keyword">return</span> task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果任务队列有空余位置（不满），则将任务放入任务队列中</span></span><br><span class="line">        taskQueue_.<span class="built_in">emplace</span>([task]() {</span><br><span class="line">            (*task)();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前任务队列的任务数量</span></span><br><span class="line">        taskSize_++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为刚放入了新任务，任务队列肯定不为空，通知线程池中的线程去执行任务</span></span><br><span class="line">        notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池Cached模式的处理，根据任务数量动态增加线程池的线程数量</span></span><br><span class="line">        <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_ &amp;&amp; taskSize_ &gt; idleThreadSize_ &amp;&amp; curThreadSize_ &lt; threadSizeMaxThreshHold_) {</span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"expand and create new thread."</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 创建新线程对象，并将线程处理函数传递给线程对象的构造函数</span></span><br><span class="line">            std::unique_ptr&lt;Thread&gt; thread = std::make_unique&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadHandler, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">            <span class="comment">// 获取线程ID（必须在线程放入线程集合之前获取一次线程ID，否则后续将可能获取到空值）</span></span><br><span class="line">            <span class="keyword">int</span> threadId = thread-&gt;<span class="built_in">getId</span>();</span><br><span class="line">            <span class="comment">// 将新线程对象放入线程集合中</span></span><br><span class="line">            threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(thread));</span><br><span class="line">            <span class="comment">// 启动新线程</span></span><br><span class="line">            threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">            <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">            idleThreadSize_++;</span><br><span class="line">            <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">            curThreadSize_++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回与任务关联的Future</span></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程处理函数（负责执行任务）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadHandler</span><span class="params">(<span class="keyword">int</span> threadId)</span> </span>{</span><br><span class="line">        <span class="comment">// 记录当前线程首次运行的时间</span></span><br><span class="line">        <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For死循环，为了实现在线程池结束时，所有任务必须执行完成，线程池才可以回收线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 等待获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让当前线程等待获取任务，使用While循环避免虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 如果任务列表为空，且线程池要结束运行，则回收当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">checkRunningState</span>()) {</span><br><span class="line">                    <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                    threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                    <span class="comment">// 唤醒等待线程池回收完毕的线程</span></span><br><span class="line">                    allExit_.<span class="built_in">notify_all</span>();</span><br><span class="line">                    <span class="comment">// 打印日志信息</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">"thread pool destroy, thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 线程池Cached模式的处理,由于Cached模式下有可能已经创建了很多的线程，但是空闲时间超过最大阀值，因此需要将多余的空闲线程回收掉</span></span><br><span class="line">                <span class="keyword">if</span> (PoolMode::MODE_CACHED == poolMode_) {</span><br><span class="line">                    std::cv_status waitResult = notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 需要区分超时返回，还是线程正常被唤醒返回</span></span><br><span class="line">                    <span class="keyword">if</span> (std::cv_status::timeout == waitResult) {</span><br><span class="line">                        <span class="keyword">auto</span> nowTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">                        <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(nowTime - lastTime);</span><br><span class="line">                        <span class="comment">// 当线程的空闲时间超过最大阀值，且当前线程池的线程数量大于初始线程数量，则开始回收线程池中的空闲线程</span></span><br><span class="line">                        <span class="keyword">if</span> (duration.<span class="built_in">count</span>() &gt; THREAD_MAX_IDLE_TIME &amp;&amp; curThreadSize_ &gt; initThreadSize_) {</span><br><span class="line">                            <span class="comment">// 从线程集合中删除当前线程</span></span><br><span class="line">                            threads_.<span class="built_in">erase</span>(threadId);</span><br><span class="line">                            <span class="comment">// 更新空闲线程的数量</span></span><br><span class="line">                            idleThreadSize_--;</span><br><span class="line">                            <span class="comment">// 更新当前线程池的线程数量</span></span><br><span class="line">                            curThreadSize_--;</span><br><span class="line">                            <span class="comment">// 打印日志信息</span></span><br><span class="line">                            std::cout &lt;&lt; <span class="string">"idle thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" exited."</span> &lt;&lt; std::endl;</span><br><span class="line">                            <span class="comment">// 结束线程处理函数的执行，相当于结束当前线程</span></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 线程池Fixed模式的处理</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 等待任务队列不为空</span></span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新空闲线程数量（在当前线程执行任务之前）</span></span><br><span class="line">            idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从任务队列中获取需要执行的任务</span></span><br><span class="line">            Task task = taskQueue_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务从任务队列中移除</span></span><br><span class="line">            taskQueue_.<span class="built_in">pop</span>();</span><br><span class="line">            taskSize_--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志信息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" 成功获取任务..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果获取了任务之后，任务队列依旧不为空，则继续通知其他线程执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (taskQueue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">                notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为刚获取了任务，任务队列肯定有空余位置（不满），通知用户提交任务到线程池</span></span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放互斥锁（在当前线程执行任务之前）</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前线程负责执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新空闲线程数量（在当前线程执行完任务之后）</span></span><br><span class="line">            idleThreadSize_++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新当前线程最后执行完任务的时间</span></span><br><span class="line">            lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查线程池的运行状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> isPoolRuning_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;        <span class="comment">// 线程集合</span></span><br><span class="line">    PoolMode poolMode_;                                               <span class="comment">// 线程池的模式</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> isPoolRuning_;                                   <span class="comment">// 表示线程池是否正在运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> initThreadSize_;                                           <span class="comment">// 初始的线程数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> idleThreadSize_;                                  <span class="comment">// 空闲线程的数量</span></span><br><span class="line">    std::<span class="keyword">atomic_int</span> curThreadSize_;                                   <span class="comment">// 当前线程池的线程数量</span></span><br><span class="line">    <span class="keyword">int</span> threadSizeMaxThreshHold_;                                     <span class="comment">// 线程池Cached模式的最大线程数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;                               <span class="comment">// 类型重定义，使用Function类模板作为任务</span></span><br><span class="line">    std::queue&lt;Task&gt; taskQueue_;                                      <span class="comment">// 任务队列</span></span><br><span class="line">    std::<span class="keyword">atomic_uint</span> taskSize_;                                       <span class="comment">// 当前任务队列的任务数量</span></span><br><span class="line">    <span class="keyword">size_t</span> taskQueMaxThreshHold_;                                     <span class="comment">// 任务队列的最大任务数量</span></span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;                                           <span class="comment">// 任务队列操作的互斥锁</span></span><br><span class="line">    std::condition_variable notFull_;                                 <span class="comment">// 表示任务队列不满，用于通知用户线程提交任务</span></span><br><span class="line">    std::condition_variable notEmpty_;                                <span class="comment">// 表示任务队列不空，用于通知线程池中的线程执行任务</span></span><br><span class="line">    std::condition_variable allExit_;                                 <span class="comment">// 表示等待线程池回收所有线程</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// THREAD_POOL_H</span></span></span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><ul><li><code>test.cpp</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"thread_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> ULong = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算逻辑</span></span><br><span class="line"><span class="function">ULong <span class="title">sum</span><span class="params">(ULong begin, ULong end)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"execute task by thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程执行加法计算</span></span><br><span class="line">    ULong sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ULong i = begin; i &lt;= end; ++i) {</span><br><span class="line">        sum += i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计算结果</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 线程池的工作模式</span></span><br><span class="line">    <span class="keyword">int</span> poolMode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 获取用户输入</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"请选择线程池的工作模式，0 - Fixed，1 - Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; poolMode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为非法输入</span></span><br><span class="line">        <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) {</span><br><span class="line">            <span class="comment">// 清除错误标志位</span></span><br><span class="line">            std::cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// 丢弃错误输入</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"输入无效，请重新输入一个合法的数字！\n"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部作用域开始</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPool pool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程池的工作模式</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// Fixed模式（固定大小线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_FIXED);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Fixed"</span> &lt;&lt; std::endl;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Cached模式（缓存线程池）</span></span><br><span class="line">            pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程池Cached模式的最大线程数量</span></span><br><span class="line">            pool.<span class="built_in">setThreadSizeMaxThreshHold</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"线程池工作模式：Cached"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程池（指定初始的线程数量）</span></span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储与任务关联的Future</span></span><br><span class="line">        std::vector&lt;std::future&lt;ULong&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">        ULong begin = <span class="number">0</span>;</span><br><span class="line">        ULong end = <span class="number">0</span>;</span><br><span class="line">        ULong step = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交多个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 计算区间</span></span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">            end = begin + step - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            std::future&lt;ULong&gt; result = pool.<span class="built_in">submitTask</span>(sum, begin, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储与任务关联的Future</span></span><br><span class="line">            results.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(result));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计任务执行结果</span></span><br><span class="line">        ULong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取任务执行结果</span></span><br><span class="line">            ULong result = results[i].<span class="built_in">get</span>();</span><br><span class="line">            sum += result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出并行计算结果</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"==&gt; 计算结果：1 + 2 + ... + "</span> &lt;&lt; end &lt;&lt; <span class="string">" = "</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是Cached模式，则等待一段时间，触发线程池回收空闲线程</span></span><br><span class="line">        <span class="keyword">if</span> (poolMode == <span class="number">1</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）..."</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(THREAD_MAX_IDLE_TIME + <span class="number">5</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="comment">// 局部作用域结束，线程池自动析构，回收线程池中的所有线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞主线程，直到用户按下任意键才结束程序</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 平台编译测试代码，生成并运行可执行测试程序（使用的 <code>g++</code> 版本是 <code>12.2.0</code>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目的源码根目录</span></span><br><span class="line"><span class="built_in">cd</span> c++-17-thread-pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成可执行测试程序</span></span><br><span class="line">g++<span class="params"> -Iinclude</span> src/<span class="built_in">test</span>.cpp<span class="params"> -o</span> thread_pool_test<span class="params"> -pthread</span><span class="params"> -std</span>=c++17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行测试程序</span></span><br><span class="line">./thread_pool_test</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Fixed 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Fixed</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 2620 成功获取任务...</span><br><span class="line">execute task by thread 2620</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">thread 9140 成功获取任务...</span><br><span class="line">execute task by thread 9140</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 11872 成功获取任务...</span><br><span class="line">execute task by thread 11872</span><br><span class="line">thread 2620 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11872 等待获取任务...</span><br><span class="line">thread 9140 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">thread pool destroy, thread 480 exited.</span><br><span class="line">thread pool destroy, thread 11872 exited.</span><br><span class="line">thread pool destroy, thread 2620 exited.</span><br><span class="line">thread pool destroy, thread 9140 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果（线程池使用 Cached 模式）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">线程池工作模式：Cached</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">expand and create new thread.</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15144 成功获取任务...</span><br><span class="line">execute task by thread 15144</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 20812 成功获取任务...</span><br><span class="line">execute task by thread 20812</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 3904 成功获取任务...</span><br><span class="line">execute task by thread 3904</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 15616 成功获取任务...</span><br><span class="line">execute task by thread 15616</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 9800 成功获取任务...</span><br><span class="line">execute task by thread 9800</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 480 成功获取任务...</span><br><span class="line">execute task by thread 480</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 11812 成功获取任务...</span><br><span class="line">execute task by thread 11812</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">thread 20864 成功获取任务...</span><br><span class="line">execute task by thread 20864</span><br><span class="line">thread 20812 等待获取任务...</span><br><span class="line">thread 15144 等待获取任务...</span><br><span class="line">thread 15616 等待获取任务...</span><br><span class="line">thread 9800 等待获取任务...</span><br><span class="line">thread 3904 等待获取任务...</span><br><span class="line">thread 480 等待获取任务...</span><br><span class="line">thread 11812 等待获取任务...</span><br><span class="line">thread 20864 等待获取任务...</span><br><span class="line">==&gt; 计算结果：1 + 2 + ... + 1000000 = 500000500000</span><br><span class="line">==&gt; 等待空闲线程被回收（默认的最大空闲时间是60秒）...</span><br><span class="line">idle thread 15616 exited.</span><br><span class="line">idle thread 9800 exited.</span><br><span class="line">idle thread 480 exited.</span><br><span class="line">idle thread 15144 exited.</span><br><span class="line">thread pool destroy, thread 20864 exited.</span><br><span class="line">thread pool destroy, thread 11812 exited.</span><br><span class="line">thread pool destroy, thread 20812 exited.</span><br><span class="line">thread pool destroy, thread 3904 exited.</span><br><span class="line">&gt;&gt;&gt; 按下任意键，然后再按下回车键结束程序</span><br></pre></td></tr></tbody></table></figure><h5 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h5><div class="admonition warning"><p class="admonition-title">动态链接库说明</p><p>由于上面基于 C++ 17 实现的线程池，其核心源码全部都写在头文件中，也就是说 <code>thread_pool.h</code> 是纯 Header-Only（例如类模板 / 函数模板全部实现都在头文件中），因此该线程池项目是无法编译成动态链接库（比如 <code>.so</code>）的。如果一定要编译成动态链接库，可以将线程池的核心代码逻辑移植到 <code>.cpp</code> 源文件，然后再编译成动态链接库。由于篇幅有限，这里不再累述。</p></div><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>(1) 基于 C++ 11 / C++ 17 实现线程池，当线程池准备结束运行（销毁），需要等待线程池中所有线程退出时，发生线程死锁问题，导致应用进程无法正常退出。</li><li>(2) 基于 C++ 11 实现线程池，在 Windows 平台下可以正常运行，但在 Linux 平台下运行时自定义实现的信号量类型 Semaphore 会出现线程死锁问题（原因是 <code>condition_variable</code> 的析构函数为空导致，一旦 Result 对象比 Task 对象早被析构就会出现线程死锁）。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>这里提到的两个线程死锁问题，在上面给出的 C++ 11 / C++ 17 线程池代码中已经解决了。</p></div><h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h4><p>定位死锁问题时，通常可以通过 <code>gdb</code> 附加（<code>attach</code>）到正在运行的目标进程，然后使用以下命令进行分析：</p><ul><li>使用 <code>ps</code> 命令查找目标进程的 ID；</li><li>使用 <code>gdb attch &lt;pid&gt;</code> 命令附加到目标进程；</li><li>使用 <code>info threads</code> 命令查看当前进程中所有线程的状态及线程 ID；</li><li>使用 <code>thread &lt;tid&gt;</code> 命令切换到指定的线程；</li><li>使用 <code>bt</code> 命令查看当前线程的调用堆栈信息，判断其是否被阻塞、在等待互斥锁（<code>mutex</code>）、或处于循环等待状态；</li><li>重复以上操作，依次分析所有可疑线程的调用堆栈信息，找出多个线程相互等待资源的典型死锁原因。</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看目标进程的 ID</span></span><br><span class="line">ps -aux|grep thread_pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 附加的目标进程</span></span><br><span class="line">$ gdb attach &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（查看目标进程中的所有线程）</span></span><br><span class="line">&gt; (gdb) info threads</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（切换到指定的线程）</span></span><br><span class="line">&gt; (gdb) thread &lt;id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试操作（查看当前线程的调用堆栈信息）</span></span><br><span class="line">&gt; (gdb) bt</span><br></pre></td></tr></tbody></table></figure><p>结合项目源码和线程之间的加锁、解锁逻辑，定位到具体发生死锁的代码片段后，可以进一步分析导致死锁的根本原因，常见的原因包括：</p><ul><li>多个线程交叉持有多个锁，且锁的获取顺序不一致；</li><li>忽略了可能抛异常或提前返回，导致某个线程未能正确释放锁；</li><li>加锁和等待条件变量的时机不当等；</li><li>多个资源需要同时加锁时，未采用统一锁策略（比如没有统一使用 <code>lock()</code> 或 <code>unique_lock</code>）。</li></ul><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li>规范加锁顺序，避免循环依赖；</li><li>拆分锁或减少锁的粒度；</li><li>使用 <code>try_lock()</code> 等避免阻塞的锁操作；</li><li>引入超时机制，防止死锁的出现；</li><li>在合适的场景下，可以引入无锁并发编程模型（如基于 CAS 的算法），以提升性能并减少锁竞争带来的开销。</li></ul><h2 id="项目输出总结"><a href="#项目输出总结" class="headerlink" title="项目输出总结"></a>项目输出总结</h2><h3 id="应用到企业项目中"><a href="#应用到企业项目中" class="headerlink" title="应用到企业项目中"></a>应用到企业项目中</h3><ul><li>耗时任务处理</li><li>高并发高性能网络服务器</li><li> Master-Slave 线程模型（可用于并行计算）</li></ul><h3 id="输出到求职简历上"><a href="#输出到求职简历上" class="headerlink" title="输出到求职简历上"></a>输出到求职简历上</h3><ul><li><p><strong>项目名称</strong></p><ul><li>基于可变参数模板实现线程池</li></ul></li><li><p><strong>项目描述</strong></p><ul><li>基于可变参数模板和引用折叠原理，实现线程池 <code>submitTask</code> 接口，支持任意任务函数和任意参数的传递</li><li>使用 <code>future</code> 类型定制 <code>submitTask</code> 接口提交任务的返回值</li><li>使用 <code>map</code> 和 <code>queue</code> 容器管理线程对象和任务</li><li>基于条件变量 <code>condition_variable</code> 和互斥锁 <code>mutex</code> 实现任务提交线程和任务执行线程之间的通信机制</li><li>支持 Fixed 和 Cached 模式的线程池</li><li>……（自由发挥）</li></ul></li><li><p><strong>项目问题</strong></p><ul><li>遇到的问题<ul><li>基于 C++ 11 / C++ 17 实现线程池，当线程池准备结束运行（销毁），需要等待线程池中所有线程退出时，发生线程死锁问题，导致应用进程无法正常退出。</li><li>基于 C++ 11 实现线程池，在 Windows 平台下可以正常运行，但在 Linux 平台下运行时自定义实现的信号量类型会出现线程死锁问题（原因是 <code>condition_variable</code> 的析构函数为空导致，一旦 Result 对象比 Task 对象早被析构就会出现线程死锁）。</li></ul></li><li>问题的定位<ul><li>使用 <code>ps</code> 命令查找目标进程的 ID；</li><li>使用 <code>gdb attch &lt;pid&gt;</code> 命令附加到目标进程；</li><li>使用 <code>info threads</code> 命令查看当前进程中所有线程的状态及线程 ID；</li><li>使用 <code>thread &lt;tid&gt;</code> 命令切换到指定的线程；</li><li>使用 <code>bt</code> 命令查看当前线程的调用堆栈信息，判断其是否被阻塞、在等待互斥锁（<code>mutex</code>）、或处于循环等待状态；</li><li>重复以上操作，依次分析所有可疑线程的调用堆栈信息，找出多个线程相互等待资源的典型死锁原因。</li></ul></li><li>问题的解决<ul><li>结合项目源码和线程之间的加锁、解锁逻辑，定位到具体发生死锁的代码片段后，可以进一步分析导致死锁的根本原因，常见的原因包括：</li><li>(1) 多个线程交叉持有多个锁，且锁的获取顺序不一致。</li><li>(2) 忽略了可能抛异常或提前返回，导致某个线程未能正确释放锁。</li><li>(3) 加锁和等待条件变量的时机不当等。</li><li>(4) 多个资源需要同时加锁时，未采用统一锁策略（比如没有统一使用 <code>lock()</code> 或 <code>unique_lock</code>）。</li></ul></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/a2a7ad9b.html">C++ 多线程编程之一</a></li><li><a href="/posts/832c55b5.html">Java 之线程池使用详解</a></li><li><a href="/posts/17b04dfd.html">Java 线程死锁的定位与分析</a></li><li><a href="/posts/dc8f1477.html">如何估算 Java 线程池的大小与队列长度</a></li><li><a href="/posts/f7fd0987.html">Java 多线程编程之七队列、线程池、线程通信</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/585aa296.html" title="基于 C++ 手写线程池">https://www.techgrow.cn/posts/585aa296.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> Linux系统编程</a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 并发编程</a><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/5bc5018f.html" rel="prev" title="Nginx 内存池源码剖析"><i class="fa fa-angle-left"></i> Nginx 内存池源码剖析</a></div><div class="post-nav-item"> <a href="/posts/630b5e44.html" rel="next" title="VSCode 搭建远程 Linux 开发环境">VSCode 搭建远程 Linux 开发环境<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.9m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">29:06</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/585aa296.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>