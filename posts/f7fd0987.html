<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Java 中的队列、线程池、线程通信等内容。"><meta property="og:type" content="article"><meta property="og:title" content="Java 多线程编程之七队列、线程池、线程通信"><meta property="og:url" content="https://www.techgrow.cn/posts/f7fd0987.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 Java 中的队列、线程池、线程通信等内容。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/queue-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/queue-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/queue-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/queue-5.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/thread-pool-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/thread-pool-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/thread-pool-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/thread-pool-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/thread-callable-1.png"><meta property="article:published_time" content="2023-01-17T14:34:42.000Z"><meta property="article:modified_time" content="2023-01-17T14:34:42.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Java"><meta property="article:tag" content="并发编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2024/03/queue-3.png"><link rel="canonical" href="https://www.techgrow.cn/posts/f7fd0987.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/f7fd0987.html","path":"posts/f7fd0987.html","title":"Java 多线程编程之七队列、线程池、线程通信"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java 多线程编程之七队列、线程池、线程通信 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%B1%BB%E6%97%8F"><span class="nav-text">队列类族</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">阻塞队列的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">阻塞队列的核心方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">阻塞队列的使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="nav-text">使用案例一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="nav-text">使用案例二</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%89"><span class="nav-text">使用案例三</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E5%9B%9B"><span class="nav-text">使用案例四</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-text">线程池的概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">线程池的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">线程池的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">JUC 中的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E6%97%8F"><span class="nav-text">线程池类族</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">线程池的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">线程池的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%80-1"><span class="nav-text">使用案例一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%BA%8C-1"><span class="nav-text">使用案例二</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%B8%89-1"><span class="nav-text">使用案例三</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-text">线程池的底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="nav-text">线程池的七大参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-text">线程池的四大拒绝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AF%A6%E7%BB%86%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">线程池的详细工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">工作流程图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="nav-text">工作流程详解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">如何合理配置线程池的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">为什么不用默认创建的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90"><span class="nav-text">重点面试题解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">手写线程池的实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-text">生产者消费者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%89%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">同步版的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%89%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">可重入锁版的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%89%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">阻塞队列版的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="nav-text">保证多个线程同时执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-text">保证多个线程按顺序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%BA%8F%E4%BA%A4%E6%9B%BF%E6%89%A7%E8%A1%8C"><span class="nav-text">保证多个线程有序交替执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">对一个整型数组进行快速排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable-%E6%8E%A5%E5%8F%A3"><span class="nav-text">Callable 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">Callable 接口的介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">Callable 接口的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">Callable 接口的注意事项</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">710</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/f7fd0987.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java 多线程编程之七队列、线程池、线程通信 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 Java 中的队列、线程池、线程通信等内容。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Java 多线程编程之七队列、线程池、线程通信</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-17 22:34:42" itemprop="dateCreated datePublished" datetime="2023-01-17T22:34:42+08:00">2023-01-17</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/f7fd0987.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/f7fd0987.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>10k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>9 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/5bbede3c.html">Java 多线程编程之一 Java 内存模型浅析</a></li><li><a href="/posts/f7ed7888.html">Java 多线程编程之二 synchronize 锁对象竞争</a></li><li><a href="/posts/ed2e098d.html">Java 多线程编程之三 volatile 与 JMM 内存模型</a></li><li><a href="/posts/3b82844a.html">Java 多线程编程之四 CAS、ABA 问题、锁</a></li><li><a href="/posts/d9aa9f1f.html">Java 多线程编程之五 AQS 底层源码深度剖析</a></li><li><a href="/posts/1f270e10.html">Java 多线程编程之六集合类的线程安全问题</a></li><li><a href="/posts/f7fd0987.html">Java 多线程编程之七队列、线程池、线程通信</a></li><li><a href="/posts/4a0f41c0.html">Java 多线程编程之八 Fork/Join 框架使用</a></li><li><a href="/posts/d016a303.html">Java 多线程编程之九 ThreadLocal 使用</a></li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列类族"><a href="#队列类族" class="headerlink" title="队列类族"></a>队列类族</h3><p>BlockingQueue 阻塞队列是一个接口，它有七个实现类，如下所示：</p><ul><li><code>ArrayBlockQueue</code>：由数组结构组成的有界阻塞队列</li><li><code>LinkedBlockingQueue</code>：由链表结构组成的有界阻塞队列，虽然是有界的，但是界限非常大（默认大小 Integer.MAX_VALUE），相当于无界，也就是可以当成无界</li><li><code>PriorityBlockQueue</code>：支持优先级排序的无界阻塞队列</li><li><code>DelayQueue</code>：使用优先级队列实现的延迟无界阻塞队列</li><li><code>SynchronousQueue</code>：不存储元素的阻塞队列，即生产一个，消费一个</li><li><code>LinkedTransferQueue</code>：由链表结构组成的无界阻塞队列</li><li><code>LinkedBlockingDeque</code>：由链表结构组成的双向阻塞队列</li></ul><span id="more"></span><div class="admonition note"><p class="admonition-title">提示</p><p>必须重点掌握的队列类：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p></div><p><img data-src="../../../asset/2024/03/queue-3.png"></p><p><img data-src="../../../asset/2024/03/queue-2.png"></p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="阻塞队列的介绍"><a href="#阻塞队列的介绍" class="headerlink" title="阻塞队列的介绍"></a>阻塞队列的介绍</h4><p>BlockingQueue 阻塞队列，排队拥堵。首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p><p><img data-src="../../../asset/2024/03/queue-1.png"></p><p>线程 1 往阻塞队列尾部的插入元素，而线程 2 从阻塞队列的头部移除元素。BlockingQueue 阻塞队列的特点如下：</p><ul><li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</li><li>当阻塞队列是满时，从队列中插入元素的操作将会被阻塞</li></ul><p>也就是说试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列添加新的元素。同理，试图往已经满的阻塞队列中添加新元素的线程会被阻塞，直到其它线程往已满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来才能添加新元素。在多线程编程领域，所谓的阻塞，也就是在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒。</p><div class="admonition note"><p class="admonition-title">为什么需要 BlockingQueue？</p><p>使用 BlockingQueue 的优点是不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切都由 BlockingQueue 一手包办了。在 JUC 包发布以前，在多线程环境下，每个程序员都必须自己控制这些实现细节，尤其还要兼顾效率和线程安全，而这会给程序带来不小的复杂度。</p></div><h4 id="阻塞队列的核心方法"><a href="#阻塞队列的核心方法" class="headerlink" title="阻塞队列的核心方法"></a>阻塞队列的核心方法</h4><p><img data-src="../../../asset/2024/03/queue-5.png"></p><ul><li><p>抛出异常</p><ul><li>当阻塞队列为空，在调用 <code>remove()</code> 方法往队列中移除元素时，会抛出 <code>NoSuchException</code> 异常。</li><li>当阻塞队列已满，在调用 <code>add()</code> 方法往队列中插入元素时，会抛出 <code>IIIegalStateException：Queue full</code>　异常。</li></ul></li><li><p>特殊结果</p><ul><li>执行 <code>offer()</code> 插入方法，成功返回 true，失败返回 false。</li><li>执行 <code>poll()</code> 移除方法，成功返回移出队列的元素，队列为空会返回 NULL。</li></ul></li><li><p>检查队列</p><ul><li>当阻塞队列为空，在调用 <code>element()</code> 方法检查队列时，会抛出 <code>NoSuchElementException</code> 异常。</li><li>当阻塞队列不为空，在调用 <code>element()</code> 方法检查队列时，会返回队列头部的第一个元素。</li><li>在调用 <code>peek()</code> 方法检查队列时，成功会返回队列头部的第一个元素，失败会返回 NULL。</li></ul></li><li><p>一直阻塞</p><ul><li>当阻塞队列满，生产者继续往队列里 Put 元素时，队列会一直阻塞生产线程直到成功 Put 数据或者响应中断退出。</li><li>当阻塞队列空，消费者线程试图从队列里 Take 元素，队列会一直阻塞消费者线程直到队列可用（即存在至少一个队列元素）。</li></ul></li><li><p>超时恢复</p><ul><li>当阻塞队列已满，在调用 <code>offer(E e, long timeout, TimeUnit unit)</code> 方法往队列中插入元素时，队列会阻塞生产者线程一段时间，超过等待时间后生产者线程会恢复执行。</li><li>当阻塞队列为空，在调用 <code>poll(long timeout, TimeUnit unit)</code> 方法往队列中移除元素时，队列会阻塞消费者线程一段时间，超过等待时间后消费者线程会恢复执行。</li></ul></li></ul><h4 id="阻塞队列的使用案例"><a href="#阻塞队列的使用案例" class="headerlink" title="阻塞队列的使用案例"></a>阻塞队列的使用案例</h4><h5 id="使用案例一"><a href="#使用案例一" class="headerlink" title="使用案例一"></a>使用案例一</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入元素（会抛出异常）</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"A"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"B"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"C"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查队列，队列不为空返回队列头部的第一个元素，队列为空则抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.element());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除元素（会抛出异常）</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></tbody></table></figure><h5 id="使用案例二"><a href="#使用案例二" class="headerlink" title="使用案例二"></a>使用案例二</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入元素（不会抛出异常）</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"AA"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"BB"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"CC"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"DD"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查队列，成功会返回队列头部的第一个元素，队列为空会返回 NULL（不会抛出异常）</span></span><br><span class="line">        System.out.println(blockingQueue.peek());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除元素（不会抛出异常）</span></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">AA</span><br><span class="line">AA</span><br><span class="line">BB</span><br><span class="line">CC</span><br><span class="line">null</span><br></pre></td></tr></tbody></table></figure><h5 id="使用案例三"><a href="#使用案例三" class="headerlink" title="使用案例三"></a>使用案例三</h5><p>当阻塞队列为空，在调用 <code>poll(long timeout, TimeUnit unit)</code> 方法往队列中移除元素时，队列会阻塞消费者线程一段时间，超过等待时间后消费者线程会恢复执行。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo3</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            blockingQueue.put(<span class="string">"AAA"</span>);</span><br><span class="line">            blockingQueue.put(<span class="string">"BBB"</span>);</span><br><span class="line">            blockingQueue.put(<span class="string">"CCC"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除元素</span></span><br><span class="line">            System.out.println(blockingQueue.poll());</span><br><span class="line">            System.out.println(blockingQueue.poll());</span><br><span class="line">            System.out.println(blockingQueue.poll());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当队列为空，往队列移除元素时，阻塞等待 5 秒，超时后往下继续执行</span></span><br><span class="line">            System.out.println(blockingQueue.poll(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AAA</span><br><span class="line">BBB</span><br><span class="line">CCC</span><br><span class="line">null</span><br></pre></td></tr></tbody></table></figure><h5 id="使用案例四"><a href="#使用案例四" class="headerlink" title="使用案例四"></a>使用案例四</h5><p>SynchronousQueue 是没有容量的队列，与其他 BlockingQueue 阻塞队列不同，SynchronousQueue 是一个不存储任何元素的 BlockingQueue。简而言之，每一个 Put 操作都必须等待一个 Take 操作完成，否者不能继续插入元素。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo4</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        BlockingQueue blockingQueue = <span class="keyword">new</span> SynchronousQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" put 1"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"1"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" put 2"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"2"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" put 3"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"3"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"T1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 等待 5 秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get "</span> + blockingQueue.take());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待 5 秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get "</span> + blockingQueue.take());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待 5 秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get "</span> + blockingQueue.take());</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"T2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1 put 1</span><br><span class="line">T2 get 1</span><br><span class="line">T1 put 2</span><br><span class="line">T2 get 2</span><br><span class="line">T1 put 3</span><br><span class="line">T2 get 3</span><br></pre></td></tr></tbody></table></figure><p>从上述的运行结果可以看出，每次 T1 生产线程向阻塞队列添加元素后，T1 生产线程就会等待 T2 消费线程，T2 线程消费完之后处于挂起状态，等待 T1 生产线程再次添加元素，从而周而复始，形成一存一取的状态。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池的概述"><a href="#线程池的概述" class="headerlink" title="线程池的概述"></a>线程池的概述</h3><p>线程池是一种线程管理的机制，用于提高多线程任务处理的效率和性能。它由线程池管理器、工作队列和一组工作线程组成。</p><ul><li><code>线程池管理器</code>：负责创建、管理和调度线程池中的线程。它根据需要动态地创建或销毁线程，并分配任务给空闲的线程。</li><li><code>工作队列</code>：用于存储待执行的任务。线程池中的线程从工作队列中取出任务进行处理。当工作队列已满时，新提交的任务可能会被拒绝或者等待一段时间。</li><li><code>工作线程</code>：线程池中的实际执行单元。它们循环地从工作队列中取出任务执行，并在任务执行完毕后返回线程池等待下一次任务。</li></ul><h3 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h3><ul><li><code>降低资源消耗</code>：减少了线程的创建和销毁频率，降低了系统开销。</li><li><code>提高响应速度</code>：线程池中的线程通常是预先创建好的，可以立即处理任务，避免了线程创建的延迟。</li><li><code>提高系统稳定性</code>：通过控制线程的数量，避免了系统资源被耗尽的风险，防止系统因过度并发而崩溃。</li><li><code>提高可管理性</code>：通过线程池管理器，可以方便地监控、调整线程池的大小和任务执行情况。</li></ul><p>线程池广泛应用于各种多线程任务处理的场景，如网络服务器、数据库连接池、图像处理等。</p><h3 id="线程池的缺点"><a href="#线程池的缺点" class="headerlink" title="线程池的缺点"></a>线程池的缺点</h3><p>虽然线程池在提高多线程任务处理效率和性能方面有很多优点，但也存在一些缺点：</p><ul><li><code>资源占用</code>：线程池在运行过程中会占用一定的系统资源，包括内存和 CPU 资源。如果线程池的大小设置过大，可能会消耗过多的系统资源，影响其他程序的正常运行。</li><li><code>调优难度</code>：确定线程池的大小和配置参数需要一定的经验和调试，不同的应用场景可能需要不同的配置，而这种调优过程可能比较繁琐。</li><li><code>任务拥堵</code>：如果任务提交速度过快，超过了线程池的处理能力，会导致任务在工作队列中排队等待执行，可能造成任务响应时间延长或者任务被拒绝执行。</li><li><code>任务依赖性</code>：线程池中的线程都是独立的执行单元，无法直接控制线程间的依赖关系。如果有一些任务之间存在依赖关系，可能需要额外的同步机制来处理。</li><li><code>线程泄漏</code>：如果线程池中的线程没有适时地释放，可能会导致线程资源的泄漏，进而导致系统资源的浪费或者系统稳定性的下降。</li></ul><p>综上所述，虽然线程池可以提高多线程任务处理的效率和性能，但在使用时仍需注意合理配置线程池大小和参数，并且需要注意任务提交的速度，以免出现资源浪费或性能下降的情况。</p><h3 id="JUC-中的线程池"><a href="#JUC-中的线程池" class="headerlink" title="JUC 中的线程池"></a>JUC 中的线程池</h3><h4 id="线程池类族"><a href="#线程池类族" class="headerlink" title="线程池类族"></a>线程池类族</h4><p>JUC 中线程池是通过 Executor 框架实现的，该框架中用到了 Executor，ExecutorService、ThreadPoolExecutor、Executors（工具类）这几个核心类。</p><p><img data-src="../../../asset/2024/03/thread-pool-1.png"></p><h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><p>在 Java 中，创建线程池一共有 5 种方式，如下所示：</p><ul><li><p><code>Executors.newFixedThreadPool(int i)</code>：创建一个拥有固定线程数的线程池</p><ul><li>执行长期的任务时，性能会高很多</li><li>创建一个定长的线程池，可控制线程的最大并发数，超出的线程会在队列中等待</li></ul></li><li><p><code>Executors.newSingleThreadExecutor()</code>：创建一个只有 1 个线程的单线程池</p><ul><li>适用于一个任务一个任务顺序执行的业务场景</li><li>创建一个单线程化的线程池，它只会用唯一的一个工作线程来执行任务，保证所有任务按照指定顺序执行</li></ul></li><li><p><code>Executors.newCacheThreadPool()</code>：创建一个可扩容的线程池</p><ul><li>执行很多短期异步的小程序或者负载较轻的服务器</li><li>创建一个可缓存的线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则创建新的线程</li></ul></li><li><p><code>Executors.newScheduledThreadPool(int corePoolSize)</code>：创建一个支持定时以及周期性执行任务的线程池</p><ul><li><code>corePoolSize</code> 参数表示线程池的最大线程数</li><li>支持以任务调度的方式，定时以及周期性地执行任务</li></ul></li><li><p><code>Executors.newWorkStealingPool(int parallelism)</code>：创建持有足够线程的线程池来支持给定的并行级别</p><ul><li>Java 8 新增的 API，支持使用当前机器上可用的处理器作为它的并行级别，而且会使用多个队列来减少竞争</li><li><code>ExecutorService newWorkStealingPool()</code>：该方法是上面方法的简化版本，如果当前机器有 4 个 CPU，则目标并行级别被设置为 4</li><li> 在 Java 中，可以通过调用 <code>Runtime.getRuntime().availableProcessors()</code> 方法来获取 CPU 的核心数</li></ul></li></ul><div class="admonition note"><p class="admonition-title">线程池创建的 3 种常用方式</p><ul><li><code>Executors.newFixedThreadPool</code>：创建一个拥有固定线程数的线程池</li><li><code>Executors.newSingleThreadExecutor()</code>：创建一个只有 1 个线程的单线程池</li><li><code>Executors.newCacheThreadPool()</code>：创建一个可扩容的线程池</li></ul></div><p>API 的具体使用，首先需要使用 Executors 工具类创建线程池，这里演示创建一个拥有 5 个线程的线程池</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个拥有固定线程数的线程池</span></span><br><span class="line">ExecutorService threadPool1 = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个只有一个线程的单线程池</span></span><br><span class="line">ExecutorService threadPool2 = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个拥有 N 个线程的线程池，会根据调度情况创建合适数量的线程（即可扩容）</span></span><br><span class="line">ExecutorService threadPool3 = Executors.newCacheThreadPool();</span><br></pre></td></tr></tbody></table></figure><p>模拟 10 个用户来办理业务，每个用户就相当于是一个来自外部请求线程，需要调用 <code>threadPool.execute()</code> 方法执行业务，<code>execute()</code> 方法需要传入一个实现了 Runnable 接口的类作为参数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(() -&gt; {</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" 给用户办理业务"</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>线程池使用完毕后，记得必须关闭掉</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.shutdown()</span><br></pre></td></tr></tbody></table></figure><h4 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h4><h5 id="使用案例一-1"><a href="#使用案例一-1" class="headerlink" title="使用案例一"></a>使用案例一</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个拥有固定线程数的线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                threadPool.execute(() -&gt; {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" execute job "</span> + index);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 execute job 1</span><br><span class="line">pool-1-thread-2 execute job 2</span><br><span class="line">pool-1-thread-3 execute job 3</span><br><span class="line">pool-1-thread-4 execute job 4</span><br><span class="line">pool-1-thread-5 execute job 5</span><br><span class="line">pool-1-thread-4 execute job 9</span><br><span class="line">pool-1-thread-3 execute job 8</span><br><span class="line">pool-1-thread-2 execute job 7</span><br><span class="line">pool-1-thread-1 execute job 6</span><br><span class="line">pool-1-thread-5 execute job 10</span><br></pre></td></tr></tbody></table></figure><h5 id="使用案例二-1"><a href="#使用案例二-1" class="headerlink" title="使用案例二"></a>使用案例二</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个只有 1 个线程的单线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                threadPool.execute(() -&gt; {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" execute job "</span> + index);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 execute job 1</span><br><span class="line">pool-1-thread-1 execute job 2</span><br><span class="line">pool-1-thread-1 execute job 3</span><br><span class="line">pool-1-thread-1 execute job 4</span><br><span class="line">pool-1-thread-1 execute job 5</span><br><span class="line">pool-1-thread-1 execute job 6</span><br><span class="line">pool-1-thread-1 execute job 7</span><br><span class="line">pool-1-thread-1 execute job 8</span><br><span class="line">pool-1-thread-1 execute job 9</span><br><span class="line">pool-1-thread-1 execute job 10</span><br></pre></td></tr></tbody></table></figure><h5 id="使用案例三-1"><a href="#使用案例三-1" class="headerlink" title="使用案例三"></a>使用案例三</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo3</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建一个可扩容的线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                threadPool.execute(() -&gt; {</span><br><span class="line">                    <span class="comment">// 模拟业务延迟</span></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">100</span>));</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" execute job "</span> + index);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-7 execute job 7</span><br><span class="line">pool-1-thread-6 execute job 6</span><br><span class="line">pool-1-thread-3 execute job 3</span><br><span class="line">pool-1-thread-9 execute job 9</span><br><span class="line">pool-1-thread-8 execute job 8</span><br><span class="line">pool-1-thread-1 execute job 1</span><br><span class="line">pool-1-thread-2 execute job 2</span><br><span class="line">pool-1-thread-4 execute job 4</span><br><span class="line">pool-1-thread-10 execute job 10</span><br><span class="line">pool-1-thread-5 execute job 5</span><br></pre></td></tr></tbody></table></figure><h4 id="线程池的底层实现"><a href="#线程池的底层实现" class="headerlink" title="线程池的底层实现"></a>线程池的底层实现</h4><p>查看 <code>Executors.newFixedThreadPool()</code> 和 <code>Executors.newSingleThreadExecutor()</code> 的底层源码，能够发现都是使用了 ThreadPoolExecutor 类，还使用到了 LinkedBlockingQueue 链表阻塞队列。同时查看 <code>Executors.newCacheThreadPool()</code> 的底层源码，可以看到使用的是 SynchronousBlockingQueue 阻塞队列。</p><p><img data-src="../../../asset/2024/03/thread-pool-2.png"></p><h4 id="线程池的七大参数"><a href="#线程池的七大参数" class="headerlink" title="线程池的七大参数"></a>线程池的七大参数</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ThreadPoolExecutor 类是 ExecutorService 接口的一个实现，用于管理线程池。线程池在创建的时候，其构造函数包含 7 个参数，它们的含义如下：</p><ul><li><p><strong>corePoolSize</strong>：核心线程数，线程池中的常驻核心线程数</p><ul><li>在线程池创建后，当有请求任务过来，就会安排线程池中的线程去执行请求任务。</li><li><strong>当线程池中的线程数量超过 <code>corePoolSize</code> 后，就会把到达的请求任务放到工作队列中等待。</strong></li><li><strong>在没有任务执行时，核心线程会一直存活在线程池中，即使是处于空闲状态，核心线程也不会被销毁。如果使用了无界队列，即使没有任务执行，核心线程也不会超时退出。</strong></li></ul></li><li><p><strong>maximumPoolSize</strong>：最大线程数，线程池能够允许同时执行的最大线程数</p><ul><li><strong>相当于扩容后的线程数，即这个线程池能容纳的最大线程数，此值必须大于等于 1。</strong></li><li><strong>当线程池中的线程数量超过 <code>corePoolSize</code>，且工作队列已满时，会为新任务创建新的线程，直到达到最大线程数，超过最大线程数的任务将会被拒绝执行。</strong></li></ul></li><li><p><strong>keepAliveTime</strong>：多余的空闲线程存活时间</p><ul><li>当线程池中的线程数量超过 <code>corePoolSize</code> 时，多余的空闲线程在被回收前等待新任务到来的最长时间。</li><li>当空闲时间超过 <code>keepAliveTime</code> 时，多余的空闲线程会被销毁，直到只剩下 <code>corePoolSize</code> 个线程为止。</li><li><strong>在默认情况下，只有当线程池中的线程数量大于 <code>corePoolSize</code> 时，<code>keepAliveTime</code> 才会起作用。</strong></li></ul></li><li><p><strong>unit</strong>：存活时间的单位</p><ul><li>指定 <code>keepAliveTime</code> 参数的时间单位，可以是秒、毫秒、分钟等。</li></ul></li><li><p><strong>workQueue</strong>：工作队列（任务队列），存放被提交但未被执行的任务</p><ul><li>线程池通过该队列来管理待执行的任务。</li><li>常见的实现类包括 ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue 等。</li></ul></li><li><p><strong>threadFactory</strong>：用于创建新线程的工厂</p><ul><li>生成线程池中工作线程的线程工厂，一般用默认的即可。</li><li>可以通过该参数自定义线程的创建方式，如设置线程的名称、优先级等。</li></ul></li><li><p><strong>handler</strong>：拒绝策略</p><ul><li>当任务无法被线程池执行，通常是由于线程池已经关闭，或者超过了最大线程数（maximumPoolSize），并且队列已满时，如何来拒绝执行任务的策略。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">线程池最大的任务处理数</p><p>线程池最大的任务处理数 = 最大线程数（maximumPoolSize）+ 工作队列的长度</p></div><h4 id="线程池的四大拒绝策略"><a href="#线程池的四大拒绝策略" class="headerlink" title="线程池的四大拒绝策略"></a>线程池的四大拒绝策略</h4><p>Java 线程池提供了四大拒绝策略，用于处理无法接受新任务的情况，以下所有拒绝策略都实现了 RejectedExecutionHandler 接口。</p><ul><li><strong>AbortPolicy</strong>：这是默认拒绝策略，直接抛出 RejectedExcutionException 异常，以此通知调用者线程池无法接受新任务。</li><li><strong>DiscardPolicy</strong>：直接丢弃任务，不予任何处理也不抛出异常，如果允许任务丢失，这是一种较好的方案。</li><li><strong>DiscardOldestPolicy</strong>：丢弃工作队列中等待时间最长的任务（即最老的任务），然后尝试再次提交这个新任务，将其加入到工作队列中。</li><li><strong>CallerRunsPolicy</strong>：既不会丢弃任务，也不会抛出异常，而是调用任务提交者的线程来执行这个新任务（即谁提交由谁来执行）。这样一来，提交任务的线程就会尝试去执行该任务，从而避免任务的丢失，并降低新任务的流量。</li></ul><div class="admonition note"><p class="admonition-title">CallerRunsPolicy 策略详解</p><ul><li>上述提到的 CallerRunsPolicy 拒绝策略，如果线程池中的线程数达到最大线程数，工作队列也已经满了，并且任务提交者的线程也很忙，没时间去执行被拒绝的任务，那么线程池会怎么处理呢？</li><li>如果采用 CallerRunsPolicy 拒绝策略，此时线程池中的线程数达到最大线程数，且工作队列也已经满了，这意味着没有空闲的线程来执行任务，并且工作队列也无法继续接收新的任务。在这种情况下，线程池会尝试调用任务提交者的线程来执行这个被拒绝的任务。然而，如果提交该任务的线程也忙于执行其他任务，没有空闲的时间去执行被拒绝的任务，那么线程池就会继续阻塞任务提交者，直到工作队列有空间或者有空闲线程可用来执行任务为止。</li></ul></div><h4 id="线程池的详细工作流程"><a href="#线程池的详细工作流程" class="headerlink" title="线程池的详细工作流程"></a>线程池的详细工作流程</h4><h5 id="工作流程图"><a href="#工作流程图" class="headerlink" title="工作流程图"></a>工作流程图</h5><p><img data-src="../../../asset/2024/03/thread-pool-3.png"></p><hr><p><img data-src="../../../asset/2024/03/thread-pool-4.png"></p><h5 id="工作流程详解"><a href="#工作流程详解" class="headerlink" title="工作流程详解"></a>工作流程详解</h5><blockquote><p>线程池的底层工作流程</p></blockquote><ul><li>(1) 在创建了线程池后，等待提交过来的任务</li><li> (2) 当调用 <code>execute()</code> 方法执行一个任务时，线程池会作出如下判断<ul><li> a. 如果正在执行的线程数量小于 <code>corePoolSize</code>，那么马上创建线程执行这个任务</li><li> b. 如果正在执行的线程数量大于或等于 <code>corePoolSize</code>，那么将这个任务放入工作队列中</li><li> c. 如果这时候工作队列满了，并且正在执行的线程数量还小于 <code>maximumPoolSize</code>，那么还是创建非核心线程来执行这个任务</li><li> d. 如果这时候工作队列满了，并且正在执行的线程数量大于或等于 <code>maximumPoolSize</code>，那么线程池会启动拒绝策略来执行</li></ul></li><li> (3) 当一个线程完成任务后，它会从工作队列中取下一个任务来执行</li><li> (4) 当一个线程空闲一定的时间（<code>keepAliveTime</code>） 后，线程池会作出如下判断<ul><li> a. 如果当前执行的线程数大于 <code>corePoolSize</code>，那么这个线程就被销毁掉</li><li> b. 当线程池的所有任务都执行完成后，它最终会收缩到 <code>corePoolSize</code> 的大小</li></ul></li></ul><blockquote><p>以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p></blockquote><ul><li>(1) 最开始假设来了两个顾客，因为 <code>corePoolSize</code> 为 2，因此这两个顾客可以直接去窗口办理业务</li><li> (2) 后面又来了三个顾客，因为 <code>corePoolSize</code> 都已经被顾客占用了，因此只有去候客区等待，也就是在工作队列中等待</li><li> (3) 后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的临时窗口，这里的临时窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li><li> (4) 假设受理窗口已经达到最大数 <code>corePoolSize</code>，但请求数还是不断增加，此时候客区和线程池都已经满了，并且新增的临时窗口也不够用，为了防止大量请求压垮线程池，需要开启拒绝策略</li><li> (5) 临时增加的线程会因为超过了最大存活时间，就会被销毁，最后线程数量从最大数削减到核心数</li></ul><h4 id="如何合理配置线程池的参数"><a href="#如何合理配置线程池的参数" class="headerlink" title="如何合理配置线程池的参数"></a>如何合理配置线程池的参数</h4><blockquote><p>面试题：生产环境中如何配置线程池的 corePoolSize 和 maximumPoolSize 参数？</p></blockquote><p>首先需要弄清楚一点，业务系统是属于 CPU 密集型还是 I/O 密集型的。因为线程池的配置，是需要根据具体不同的业务来配置。</p><ul><li><p>CPU 密集型</p><ul><li>CPU 密集的意思是，该任务需要大量的运算，而且没有阻塞，CPU 一直全速运行</li><li> CPU 密集任务只有在真正的多核 CPU 上才可能得到加速执行（使用多线程），而在单核 CPU 上，无论启动几个模拟的多线程，该任务都不可能得到加速执行</li><li> CPU 密集型的任务，应该尽可能少的配置线程数量</li><li>一般配置公式：CPU 核心数 + 1 个线程数</li></ul></li><li><p> I/O 密集型</p><ul><li>IO 密集型的意思是，该任务需要大量的 I/O 操作（网络、磁盘等），大部分线程都会被阻塞</li><li>由于 I/O 密集型的任务线程并不是一直在执行任务，因此需要尽可能多配置线程数，如 CPU 核心数 * 2</li><li> 在单线程上执行 I/O 密集型的任务，会浪费大量的 CPU 运算能力，即花费大量时间在阻塞等待上；所以在 I/O 密集型任务中，使用多线程可以大大的加速程序的运行，这种加速主要就是利用了被浪费掉的阻塞时间</li><li>参考配置公式：CPU 核心数 / (1 - 阻塞系数)，阻塞系数在 0.8 ~ 0.9 左右</li></ul></li></ul><div class="admonition note"><p class="admonition-title">阅读扩展</p><ul><li>更多关于线程池的配置教程，请阅读<a href="/posts/dc8f1477.html">《如何估算 Java 线程池的大小与队列数》</a>。</li></ul></div><h4 id="为什么不用默认创建的线程池"><a href="#为什么不用默认创建的线程池" class="headerlink" title="为什么不用默认创建的线程池"></a>为什么不用默认创建的线程池</h4><h5 id="重点面试题解析"><a href="#重点面试题解析" class="headerlink" title="重点面试题解析"></a>重点面试题解析</h5><blockquote><p>面试题：线程池常用的创建方式有三种：固定数量的、单一线程的、可扩容的，那么在实际开发中，应该使用哪种方式？</p></blockquote><p>答案是在生产环境中三种方式都不用，而是使用自己自定义的。那为什么不用 JDK 中 Executors 提供的呢？在阿里巴巴的 Java 开发手册中，有以下的线程池使用要求：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</span><br><span class="line">    - 使用线程池的好处是可以减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</span><br><span class="line">    - 如果不使用线程池，有可能造成系统创建大量同类线程而导致内存消耗尽，或者导致 "过度切换" 的问题</span><br><span class="line"></span><br><span class="line">- 线程池不允许使用 Executors 去创建，而是应用通过 ThreadPoolExecutor 的方式手动创建，这样的处理方式可以让开发者更加明确线程池的运行规则，规避资源耗尽的风险</span><br><span class="line">    - 使用 Executors 创建线程池的弊端如下</span><br><span class="line">        - FixedThreadPool 和 SingleThreadPool</span><br><span class="line">            - 允许的工作队列长度为 Integer.MAX_VALUE，可能会堆积大量的任务，从而导致 OOM</span><br><span class="line">        - CacheThreadPool 和 ScheduledThreadPool</span><br><span class="line">            - 允许创建的线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM</span><br></pre></td></tr></tbody></table></figure><p>这里总结了一些不推荐使用默认 Executors 创建线程池的原因：</p><ul><li><p><strong>无界队列</strong>：默认情况下，Executors 工厂方法创建的线程池使用的是无界队列。这意味着如果任务提交的速度超过了线程池处理任务的速度，那么队列会不断增长，最终可能导致内存耗尽或者 OutOfMemoryError。因此，在某些情况下，使用有界队列更安全，当工作队列已满时，可以根据需要采取适当的拒绝策略。</p></li><li><p><strong>线程生命周期管理</strong>：使用默认的 Executors 创建的线程池，线程的生命周期（如线程的创建、销毁等）可能由线程池自动管理，而这种自动管理可能不适合所有的应用场景。例如，在某些情况下，可能需要对线程的创建和销毁进行更精细的控制，以避免资源泄露或者其他问题。</p></li><li><p><strong>线程池的大小</strong>：默认的 Executors 创建的线程池大小可能不符合实际需求。例如，如果任务量非常大，但是线程池的大小较小，那么可能会导致任务排队等待执行，从而影响系统的性能。因此，在实际应用中，通常需要根据实际情况来调整线程池的大小。</p></li></ul><h5 id="手写线程池的实现"><a href="#手写线程池的实现" class="headerlink" title="手写线程池的实现"></a>手写线程池的实现</h5><p>因为 Executors 创建的部分线程池，底层是使用 LinkBlockingQueue 作为阻塞队列的；而 LinkBlockingQueue 虽然是有界的，但它的上限是 Integer.MAX_VALUE，大概有 20 多亿之大，可以视为是无界了。这意味着可能会堆积大量的任务，从而导致 OOM。因此需要使用 ThreadPoolExecutor 手动创建线程池，然后指定阻塞队列的大小。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个核心线程数为 2，最大线程数为 5，并且工作队列大小为 3 的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo4</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> corePoolSize = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maximumPoolSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> queueSize = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> keepAliveTime = <span class="number">10L</span>;</span><br><span class="line">        </span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            corePoolSize,</span><br><span class="line">            maximumPoolSize,</span><br><span class="line">            keepAliveTime,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(queueSize),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                executorService.execute(() -&gt; {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" execute"</span>);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><h4 id="同步版的实现"><a href="#同步版的实现" class="headerlink" title="同步版的实现"></a>同步版的实现</h4><blockquote><p>面试题目：一个初始值为零的变量，两个线程对其交替操作，一个线程加 1，一个线程减 1，重复 5 轮操作。</p></blockquote><p>这里将给出基于 <code>synchronized</code>、<code>wait()</code> 与 <code>notifyAll()</code> 实现线程间通信的代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 使用 while 循环，而不是使用 if 判断，否则可能会导致虚假唤醒的现象</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 等待，不能往下执行</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            }</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + number);</span><br><span class="line">            <span class="comment">// 通知唤醒</span></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 使用 while 循环，而不是使用 if 判断，否则可能会导致虚假唤醒的现象</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 等待，不能往下执行</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            }</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + number);</span><br><span class="line">            <span class="comment">// 通知唤醒</span></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerDemo1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ShareData1 shareData = <span class="keyword">new</span> ShareData1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加 1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareData.increment();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"T1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减 1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareData.decrement();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"T2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T1 1</span><br><span class="line">T2 0</span><br><span class="line">T1 1</span><br><span class="line">T2 0</span><br><span class="line">T1 1</span><br><span class="line">T2 0</span><br><span class="line">T1 1</span><br><span class="line">T2 0</span><br><span class="line">T1 1</span><br><span class="line">T2 0</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">什么是虚假唤醒</p><p>线程的虚假唤醒（Spurious Wakeup）是指线程在没有明确通知的情况下，从等待状态被唤醒的现象。这种现象可能由操作系统的某些内部机制引起，因此在调用 <code>wait()</code> 方法时，必须在一个循环（while）中反复检查条件，以确保线程是因满足条件而被唤醒的。</p></div><h4 id="可重入锁版的实现"><a href="#可重入锁版的实现" class="headerlink" title="可重入锁版的实现"></a>可重入锁版的实现</h4><blockquote><p>面试题目：一个初始值为零的变量，两个线程对其交替操作，一个线程加 1，一个线程减 1，重复 5 轮操作。</p></blockquote><p>这里将给出基于 Lock、<code>await()</code> 与 <code>signalAll()</code> 实现线程间通信的代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 使用 while 循环，而不是使用 if 判断，否则可能会导致虚假唤醒的现象</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 等待，不能往下执行</span></span><br><span class="line">                condition.await();</span><br><span class="line">            }</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + number);</span><br><span class="line">            <span class="comment">// 通知唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 使用 while 循环，而不是使用 if 判断，否则可能会导致虚假唤醒的现象</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 等待，不能往下执行</span></span><br><span class="line">                condition.await();</span><br><span class="line">            }</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + number);</span><br><span class="line">            <span class="comment">// 通知唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerDemo2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ShareData2 shareData = <span class="keyword">new</span> ShareData2();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加 1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareData.increment();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"T1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减 1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    shareData.decrement();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"T2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T1 1</span><br><span class="line">T2 0</span><br><span class="line">T1 1</span><br><span class="line">T2 0</span><br><span class="line">T1 1</span><br><span class="line">T2 0</span><br><span class="line">T1 1</span><br><span class="line">T2 0</span><br><span class="line">T1 1</span><br><span class="line">T2 0</span><br></pre></td></tr></tbody></table></figure><h4 id="阻塞队列版的实现"><a href="#阻塞队列版的实现" class="headerlink" title="阻塞队列版的实现"></a>阻塞队列版的实现</h4><blockquote><p>面试题：一个初始值为零的变量，两个线程对其交替操作，一个加 1，一个减 1，重复 5 轮</p></blockquote><p>这里将给出基于 volatile、CAS、AtomicInteger、BlockQueue 实现线程间通信的代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData3</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 volatile 保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 使用原子包装类</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShareData3</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>{</span><br><span class="line">        FLAG = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 使用 while 循环，而不是使用 if 判断，否则可能会导致虚假唤醒的现象</span></span><br><span class="line">        <span class="keyword">while</span> (FLAG) {</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">""</span>;</span><br><span class="line">            <span class="comment">// 生产</span></span><br><span class="line">            result = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (result) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" produce success : "</span> + data);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" produce failed"</span>);</span><br><span class="line">            }</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"produce stop"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 使用 while 循环，而不是使用 if 判断，否则可能会导致虚假唤醒的现象</span></span><br><span class="line">        <span class="keyword">while</span> (FLAG) {</span><br><span class="line">            <span class="comment">// 消费，如果队列为空，当前线程会阻塞等待 2 秒</span></span><br><span class="line">            result = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == result) {</span><br><span class="line">                FLAG = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="string">"consume timeout, exit"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" consume success : "</span> + result);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"consume stop"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerDemo3</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ShareData3 shareData = <span class="keyword">new</span> ShareData3(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                shareData.produce();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"Producer thread"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                shareData.consume();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"Consumer thread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 5 秒后，生产和消费线程停止，主线程结束</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            shareData.stop();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Producer thread produce success : 1</span><br><span class="line">Consumer thread consume success : 1</span><br><span class="line">Producer thread produce success : 2</span><br><span class="line">Consumer thread consume success : 2</span><br><span class="line">Producer thread produce success : 3</span><br><span class="line">Consumer thread consume success : 3</span><br><span class="line">Producer thread produce success : 4</span><br><span class="line">Consumer thread consume success : 4</span><br><span class="line">Producer thread produce success : 5</span><br><span class="line">Consumer thread consume success : 5</span><br><span class="line">produce stop</span><br><span class="line">consume timeout, exit</span><br></pre></td></tr></tbody></table></figure><h3 id="保证多个线程同时执行"><a href="#保证多个线程同时执行" class="headerlink" title="保证多个线程同时执行"></a>保证多个线程同时执行</h3><blockquote><p>面试题：如何保证多个线程在同一时间开始执行指定的任务。</p></blockquote><p>这里将给出基于 <code>CountDownLatch</code> 实现线程间通信的代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunicationDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 阻塞等待，直至计算器为 0</span></span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" work, timestamp is "</span> + System.currentTimeMillis());</span><br><span class="line">            }, <span class="string">"T"</span> + i).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器减 1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T2 work, timestamp is 1716803989370</span><br><span class="line">T0 work, timestamp is 1716803989370</span><br><span class="line">T1 work, timestamp is 1716803989369</span><br><span class="line">T4 work, timestamp is 1716803989369</span><br><span class="line">T3 work, timestamp is 1716803989369</span><br></pre></td></tr></tbody></table></figure><h3 id="保证多个线程按顺序执行"><a href="#保证多个线程按顺序执行" class="headerlink" title="保证多个线程按顺序执行"></a>保证多个线程按顺序执行</h3><blockquote><p>面试题：多个线程之间按顺序执行，三个线程的执行顺序是 A -&gt; B -&gt; C ，具体要求如下：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A 打印 5 次</span><br><span class="line">B 打印 5 次</span><br><span class="line">C 打印 5 次</span><br><span class="line">A 打印 5 次</span><br><span class="line">B 打印 5 次</span><br><span class="line">C 打印 5 次</span><br><span class="line">......</span><br><span class="line">重复 10 轮</span><br></pre></td></tr></tbody></table></figure><p>这样的场景使用 <code>synchronized</code> 来完成的话，会非常的困难，但是使用 Lock 就非常方便了，也就是需要实现一个链式唤醒的操作。这里将给出利用锁绑定多个条件（Condition）来实现线程间通信的代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三个条件，相当于三把备用钥匙</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) {</span><br><span class="line">                condition1.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) {</span><br><span class="line">                condition2.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) {</span><br><span class="line">                condition3.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunicationDemo4</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                shareData.print5();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                shareData.print10();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                shareData.print15();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"C"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">A 1</span><br><span class="line">A 2</span><br><span class="line">A 3</span><br><span class="line">A 4</span><br><span class="line">A 5</span><br><span class="line">B 1</span><br><span class="line">B 2</span><br><span class="line">B 3</span><br><span class="line">B 4</span><br><span class="line">B 5</span><br><span class="line">C 1</span><br><span class="line">C 2</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br><span class="line">C 5</span><br><span class="line">A 1</span><br><span class="line">A 2</span><br><span class="line">A 3</span><br><span class="line">A 4</span><br><span class="line">A 5</span><br><span class="line">B 1</span><br><span class="line">B 2</span><br><span class="line">B 3</span><br><span class="line">B 4</span><br><span class="line">B 5</span><br><span class="line">C 1</span><br><span class="line">C 2</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br><span class="line">C 5</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><h3 id="保证多个线程有序交替执行"><a href="#保证多个线程有序交替执行" class="headerlink" title="保证多个线程有序交替执行"></a>保证多个线程有序交替执行</h3><blockquote><p>面试题：如何保证多个线程有序交替执行，具体要求如下：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><p>这里将给出基于 <code>Semaphore</code> 实现线程间通信的代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunicationDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 首先消耗 s2 和 s3 的许可，让线程 t2 和 线程 t3 一开始就阻塞等待</span></span><br><span class="line">            s2.acquire();</span><br><span class="line">            s3.acquire();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    s1.acquire();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"A"</span>);</span><br><span class="line">                s2.release();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"T1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    s2.acquire();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"B"</span>);</span><br><span class="line">                s3.release();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"T2"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    s3.acquire();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"C"</span>);</span><br><span class="line">                s1.release();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"T3"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><h3 id="对一个整型数组进行快速排序"><a href="#对一个整型数组进行快速排序" class="headerlink" title="对一个整型数组进行快速排序"></a>对一个整型数组进行快速排序</h3><p>基于 Java 的 Fork / Join 多线程框架，并使用分而治之的思想实现快速排序，具体代码请看以下教程：</p><ul><li><a href="/posts/d2eaf19f.html">使用多个线程对数组进行快速排序</a></li></ul><h2 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h2><p>创建线程有三种常见的实现方式：</p><ul><li>继承 Thread 类，并重写 <code>run()</code> 方法，其返回值是 void</li><li> 实现 Runnable 接口，并实现 <code>run()</code> 方法，其返回值是 void</li><li> 实现 Callable 接口，并实现 <code>call()</code> 方法，可以指定其返回值和抛出异常</li></ul><p><img data-src="../../../asset/2024/03/thread-callable-1.png"></p><h3 id="Callable-接口的介绍"><a href="#Callable-接口的介绍" class="headerlink" title="Callable 接口的介绍"></a>Callable 接口的介绍</h3><p>Callable 接口可以让线程执行完成后，返回执行结果。Callable 接口适用于批处理业务的场景，比如转账的时候，需要返回转账结果的状态码，记录本次操作是成功还是失败。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后将实现 Callable 接口的 MyCallable 类包装起来。这里需要用到的是 FutureTask 类，它实现了 Runnable 和 Future 接口，并且还需要传递一个实现 Callable 接口的实现类作为构造函数参数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br></pre></td></tr></tbody></table></figure><p>然后使用 Thread 类进行实例化，传入实现 Runnabnle 接口的 FutureTask 类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(futureTask, <span class="string">"A"</span>);</span><br><span class="line">t1.start();</span><br></pre></td></tr></tbody></table></figure><p>最后通过 <code>FutureTask.get()</code> 获取到返回值，这里的 <code>get()</code> 方法会阻塞线程的执行，直到 Callable 的任务执行完毕</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer result = futureTask.get();</span><br></pre></td></tr></tbody></table></figure><p>特别注意的是，当要获得 Callable 的计算结果时，如果任务线程没有计算完成就要去等待，也就是会导致线程阻塞，直到计算完成为止。<strong>简而言之，调用 <code>FutureTask.get()</code> 方法会阻塞线程的执行，直到 Callable 的任务执行完毕，因此往往会将 <code>FutureTask.get()</code> 方法写在最后面，这样就不会阻塞主线程。</strong>值得一提的是，也可以使用下面的算法，使用类似于自旋锁的方式来判断任务是否执行完毕。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!futureTask.isDone()) {</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Callable-接口的使用"><a href="#Callable-接口的使用" class="headerlink" title="Callable 接口的使用"></a>Callable 接口的使用</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 创建 Callable 实例</span></span><br><span class="line">        MyCallable callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="comment">// 用 FutureTask 类来包装 Callable 实例</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        <span class="comment">// 创建线程，执行 FutureTask</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"T1"</span>).start();</span><br><span class="line">        <span class="comment">// 会阻塞等待任务完成（（往往会写在最后面））</span></span><br><span class="line">        Integer result = futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1024</span><br></pre></td></tr></tbody></table></figure><h3 id="Callable-接口的注意事项"><a href="#Callable-接口的注意事项" class="headerlink" title="Callable 接口的注意事项"></a>Callable 接口的注意事项</h3><blockquote><p>多个线程执行同一个 FutureTask 的时候，最终只会执行一次任务。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" invoke call()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 创建 Callable 实例</span></span><br><span class="line">        MyCallable callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 FutureTask 类来包装 Callable 实例</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程，执行同一个 FutureTask</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"T1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"T2"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会阻塞等待任务完成（（往往会写在最后面））</span></span><br><span class="line">        Integer result = futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T1 invoke call()</span><br><span class="line">1024</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果需要多个线程执行多次任务，那么就使用多个不同的 FutureTask。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" invoke call()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 创建 Callable 实例</span></span><br><span class="line">        MyCallable callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义多个 FutureTask 类，用来包装 Callable 实例</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程，执行多个不同的 FutureTask</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask1, <span class="string">"T1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask2, <span class="string">"T2"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会阻塞等待任务完成（（往往会写在最后面））</span></span><br><span class="line">        Integer result1 = futureTask1.get();</span><br><span class="line">        Integer result2 = futureTask2.get();</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T1 invoke call()</span><br><span class="line">T2 invoke call()</span><br><span class="line">1024</span><br><span class="line">1024</span><br></pre></td></tr></tbody></table></figure><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/f7fd0987.html" title="Java 多线程编程之七队列、线程池、线程通信">https://www.techgrow.cn/posts/f7fd0987.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 并发编程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/503279b0.html" rel="prev" title="CentOS 7 通过 Shell 脚本实现磁盘监控报警"><i class="fa fa-angle-left"></i> CentOS 7 通过 Shell 脚本实现磁盘监控报警</a></div><div class="post-nav-item"> <a href="/posts/78bfedfa.html" rel="next" title="ChatGPT 资源汇总">ChatGPT 资源汇总<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.9m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">28:47</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/f7fd0987.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>