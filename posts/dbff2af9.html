<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 的进阶基础教程，包括智能指针、atomic 原子操作的介绍等。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 进阶基础之一"><meta property="og:url" content="https://www.techgrow.cn/posts/dbff2af9.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 的进阶基础教程，包括智能指针、atomic 原子操作的介绍等。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-11-25T13:55:33.000Z"><meta property="article:modified_time" content="2021-11-29T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.techgrow.cn/posts/dbff2af9.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/dbff2af9.html","path":"posts/dbff2af9.html","title":"C++ 进阶基础之一"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 进阶基础之一 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-text">智能指针的概念介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-ptr-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-text">unique_ptr 对象的简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-ptr-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-text">unique_ptr 对象的简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-ptr-%E5%AF%B9%E8%B1%A1%E7%8B%AC%E4%BA%AB%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-text">unique_ptr 对象独享所有权</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-text">智能指针的基础操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%A2%AB%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88"><span class="nav-text">获取被管理对象的原始指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5-unique-ptr-%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="nav-text">检查 unique_ptr 对象是否为空</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA-unique-ptr-%E5%AF%B9%E8%B1%A1"><span class="nav-text">使用原始指针创建 unique_ptr 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">智能指针的进阶操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE-unique-ptr-%E5%AF%B9%E8%B1%A1"><span class="nav-text">重置 unique_ptr 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-ptr-%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%85%81%E8%AE%B8%E5%A4%8D%E5%88%B6"><span class="nav-text">unique_ptr 对象不允许复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB-unique-ptr-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-text">转移 unique_ptr 对象的所有权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE-unique-ptr-%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E7%9A%84%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88"><span class="nav-text">释放 unique_ptr 对象关联的原始指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-14-%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA-unique-ptr-%E5%AF%B9%E8%B1%A1"><span class="nav-text">C++ 14 使用原始指针创建 unique_ptr 对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">原子操作的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B"><span class="nav-text">原子操作简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#atomic-%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-text">atomic 的简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#atomic-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">atomic 的使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E4%B8%8D%E4%BD%BF%E7%94%A8-atomic"><span class="nav-text">加锁不使用 atomic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8A%A0%E9%94%81%E4%BD%BF%E7%94%A8-atomic"><span class="nav-text">不加锁使用 atomic</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="nav-text">为什么要定义一个原子类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#atomic-%E4%B8%8D%E8%83%BD%E4%B8%8E-string-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-text">atomic 不能与 string 一起使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2"><span class="nav-text">参考博客</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">675</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/dbff2af9.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 进阶基础之一 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 的进阶基础教程，包括智能指针、atomic 原子操作的介绍等。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 进阶基础之一</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-25 21:55:33" itemprop="dateCreated datePublished" datetime="2021-11-25T21:55:33+08:00">2021-11-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-11-29 21:55:33" itemprop="dateModified" datetime="2021-11-29T21:55:33+08:00">2021-11-29</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/dbff2af9.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/dbff2af9.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>3.6k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>3 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/dbff2af9.html">C++ 进阶基础之一</a>、<a href="/posts/779107de.html">C++ 进阶基础之二</a>、<a href="/posts/35cd91d3.html">C++ 进阶基础之三</a></li><li><a href="/posts/791ffdcd.html">C++ 进阶基础之四</a>、<a href="/posts/64fd9f88.html">C++ 进阶基础之五</a>、<a href="/posts/62e4578b.html">C++ 进阶基础之六</a></li><li><a href="/posts/9e89901e.html">C++ 进阶基础之七</a>、<a href="/posts/8b87f2be.html">C++ 进阶基础之八</a>、<a href="/posts/360c74ef.html">C++ 进阶基础之九</a></li><li><a href="/posts/98e5b160.html">C++ 进阶基础之十</a>、<a href="/posts/f5674448.html">C++ 进阶基础之十一</a></li></ul><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="智能指针的概念介绍"><a href="#智能指针的概念介绍" class="headerlink" title="智能指针的概念介绍"></a>智能指针的概念介绍</h3><p>在 C++ 中，智能指针的类型有以下几种：</p><ul><li>(1) 带引用计数的智能指针：<code>share_ptr</code></li><li>(2) 不带引用计数的智能指针：<code>unique_ptr</code>、<code>scoped_ptr</code>、<code>auto_ptr</code></li><li>(3) 特殊的智能指针：<code>weak_ptr</code>（不增加引用计数，但可用于观察 <code>shared_ptr</code> 管理的资源）</li></ul><table><thead><tr><th>智能指针</th><th>所有权</th><th>带引用计数</th><th>适用场景</th></tr></thead><tbody><tr><td><code>unique_ptr</code></td><td>独占</td><td>否</td><td>资源独占，生命周期明确</td></tr><tr><td><code>shared_ptr</code></td><td>共享</td><td>是</td><td>资源共享，生命周期不固定</td></tr><tr><td><code>scoped_ptr</code></td><td>独占</td><td>否</td><td>生命周期受限于作用域，适用于简单的场景，避免资源泄漏</td></tr><tr><td><code>weak_ptr</code></td><td>观察 <code>shared_ptr</code></td><td>否</td><td>避免 <code>shared_ptr</code> 循环引用</td></tr><tr><td><code>auto_ptr</code></td><td>独占（拷贝时转移）</td><td>否</td><td>⚠ 已废弃，建议改用 <code>unique_ptr</code></td></tr></tbody></table><h4 id="unique-ptr-对象的简介"><a href="#unique-ptr-对象的简介" class="headerlink" title="unique_ptr 对象的简介"></a>unique_ptr 对象的简介</h4><p><code>unique_ptr</code> 是 C++ 11 提供的用于防止内存泄漏的智能指针中的一种实现，独享被管理对象指针所有权的智能指针。<code>unique_ptr</code> 对象包装了一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。<code>unique_ptr</code> 实现了 <code>-&gt;</code> 和 <code>*</code> 运算符的重载，因此它可以像普通指针一样使用。</p><span id="more"></span><h4 id="unique-ptr-对象的简单使用"><a href="#unique-ptr-对象的简单使用" class="headerlink" title="unique_ptr 对象的简单使用"></a>unique_ptr 对象的简单使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Task</span>(<span class="keyword">int</span> id) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">		cout &lt;&lt; <span class="string">"构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Task</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">23</span>))</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"id = "</span> &lt;&lt; taskPtr-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数被调用</span><br><span class="line">id = 23</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></tbody></table></figure><p><code>unique_ptr&lt;Task&gt;</code> 对象 <code>taskPtr</code> 接受原始指针作为参数。当 <code>main</code> 函数退出时，该对象超出作用范围就会自动调用自身的析构函数。在 <code>unique_ptr&lt;Task&gt;</code> 对象 <code>taskPtr</code> 的析构函数中，会删除关联的原始指针，这样就不用专门执行 Task 对象的 <code>delete</code> 操作了。以后不管函数正常退出还是异常退出（由于某些异常），也会始终调用 <code>taskPtr</code> 对象的析构函数。因此，原始指针将始终被删除并防止内存泄漏。</p><h4 id="unique-ptr-对象独享所有权"><a href="#unique-ptr-对象独享所有权" class="headerlink" title="unique_ptr 对象独享所有权"></a>unique_ptr 对象独享所有权</h4><p><code>unique_ptr</code> 对象始终是关联的原始指针的唯一所有者，因此开发者无法通过拷贝构造函数或赋值运算符复制 <code>unique_ptr</code> 对象的副本，只能移动它。由于每个 <code>unique_ptr</code> 对象都是原始指针的唯一所有者，因此在其析构函数中，它可以直接删除关联的指针，不需要任何参考计数。</p><h3 id="智能指针的基础操作"><a href="#智能指针的基础操作" class="headerlink" title="智能指针的基础操作"></a>智能指针的基础操作</h3><h4 id="获取被管理对象的原始指针"><a href="#获取被管理对象的原始指针" class="headerlink" title="获取被管理对象的原始指针"></a>获取被管理对象的原始指针</h4><p>在 <code>unique_ptr</code> 对象上调用 <code>get()</code> 函数，可以获取管理对象的原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task *p1 = taskPtr.<span class="built_in">get</span>();</span><br></pre></td></tr></tbody></table></figure><h4 id="检查-unique-ptr-对象是否为空"><a href="#检查-unique-ptr-对象是否为空" class="headerlink" title="检查 unique_ptr 对象是否为空"></a>检查 unique_ptr 对象是否为空</h4><p>有两种方法创建一个空的 <code>unique_ptr</code> 对象，因为没有与之关联的原始指针，所以它是空的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; ptr;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></tbody></table></figure><p>有两种方法可以检查 <code>unique_ptr</code> 对象是否为空或者是否有与之关联的原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ptr) {</span><br><span class="line">	cout&lt;&lt;<span class="string">"ptr is empty"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>){</span><br><span class="line">	cout&lt;&lt;<span class="string">"ptr is empty"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用原始指针创建-unique-ptr-对象"><a href="#使用原始指针创建-unique-ptr-对象" class="headerlink" title="使用原始指针创建 unique_ptr 对象"></a>使用原始指针创建 unique_ptr 对象</h4><p>要创建非空的 <code>unique_ptr</code> 对象，需要在创建对象时在其构造函数中传递原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">22</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr</span><span class="params">(<span class="keyword">new</span> unique_ptr&lt;Task&gt;::element_type(<span class="number">23</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>不能通过赋值的方法创建 <code>unique_ptr</code> 对象</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Task&gt; taskPtr = <span class="keyword">new</span> <span class="built_in">Task</span>();     <span class="comment">// 错误写法，编译失败</span></span><br></pre></td></tr></tbody></table></figure><h3 id="智能指针的进阶操作"><a href="#智能指针的进阶操作" class="headerlink" title="智能指针的进阶操作"></a>智能指针的进阶操作</h3><h4 id="重置-unique-ptr-对象"><a href="#重置-unique-ptr-对象" class="headerlink" title="重置 unique_ptr 对象"></a>重置 unique_ptr 对象</h4><p>在 <code>unique_ptr</code> 对象上调用 <code>reset()</code> 函数可以重置它，即它会 <code>delete</code> 已关联的原始指针，并将 <code>unique_ptr</code> 对象设置为空</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskPtr.<span class="built_in">reset</span>();</span><br></pre></td></tr></tbody></table></figure><h4 id="unique-ptr-对象不允许复制"><a href="#unique-ptr-对象不允许复制" class="headerlink" title="unique_ptr 对象不允许复制"></a>unique_ptr 对象不允许复制</h4><p>由于 <code>unique_ptr</code> 不可复制，只能移动。因此，无法通过拷贝构造函数或赋值运算符创建 <code>unique_ptr</code> 对象的副本</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr1</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">22</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr2</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">35</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;Task&gt; taskPtr4 = taskPtr1;  <span class="comment">// 错误写法，编译失败</span></span><br><span class="line"></span><br><span class="line">taskPtr2 = taskPtr1;    <span class="comment">// 错误写法，编译失败</span></span><br></pre></td></tr></tbody></table></figure><h4 id="转移-unique-ptr-对象的所有权"><a href="#转移-unique-ptr-对象的所有权" class="headerlink" title="转移 unique_ptr 对象的所有权"></a>转移 unique_ptr 对象的所有权</h4><p>不允许复制 <code>unique_ptr</code> 对象，但可以转移它们。这意味着 <code>unique_ptr</code> 对象可以将自身关联的原始指针的所有权转移给另一个 <code>unique_ptr</code> 对象</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过原始指针创建taskPtr1</span></span><br><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr1</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">55</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把taskPtr1中关联指针的所有权转移给taskPtr2</span></span><br><span class="line">unique_ptr&lt;Task&gt; taskPtr2 = <span class="built_in">move</span>(taskPtr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// taskPtr1关联指针的所有权现在转移到了taskPtr2中，此时taskPtr1关联的指针为空</span></span><br><span class="line"><span class="keyword">if</span> (taskPtr1 == <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr1 is empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// taskPtr1关联指针的所有权现在转移到了taskPtr2中，此时taskPtr2关联的指针不为空</span></span><br><span class="line"><span class="keyword">if</span> (taskPtr2 != <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr2 is not empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; taskPtr2-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskPtr1 is  empty</span><br><span class="line">taskPtr2 is not empty</span><br><span class="line">55</span><br></pre></td></tr></tbody></table></figure><h4 id="释放-unique-ptr-对象关联的原始指针"><a href="#释放-unique-ptr-对象关联的原始指针" class="headerlink" title="释放 unique_ptr 对象关联的原始指针"></a>释放 unique_ptr 对象关联的原始指针</h4><p>在 <code>unique_ptr</code> 对象上调用 <code>release()</code> 函数，将释放其关联的原始指针的所有权，并返回原始指针，同时设置 <code>unique_ptr</code> 对象为空。特别注意，这里是释放其关联的原始指针的所有权，并没有 <code>delete</code> 原始指针，而调用 <code>reset()</code> 函数则会 <code>delete</code> 原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr1</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">55</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (taskPtr1 != <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr1 is not empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放关联指针的所有权</span></span><br><span class="line">Task* ptr = taskPtr1.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (taskPtr1 == <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr1 is empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"id = "</span> &lt;&lt; ptr-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskPtr1 is <span class="keyword">not</span> empty</span><br><span class="line">taskPtr1 is empty</span><br><span class="line">id = <span class="number">55</span></span><br></pre></td></tr></tbody></table></figure><h4 id="C-14-使用原始指针创建-unique-ptr-对象"><a href="#C-14-使用原始指针创建-unique-ptr-对象" class="headerlink" title="C++ 14 使用原始指针创建 unique_ptr 对象"></a>C++ 14 使用原始指针创建 unique_ptr 对象</h4><p>C++ 引入了新的语法，可以使用 <code>make_unique</code> 来创建 <code>unique_ptr</code> 对象，省去了 <code>new</code> 关键字的使用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Task&gt; taskPtr = make_unique&lt;Task&gt;(<span class="number">34</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="原子操作的使用"><a href="#原子操作的使用" class="headerlink" title="原子操作的使用"></a>原子操作的使用</h2><h3 id="原子操作简介"><a href="#原子操作简介" class="headerlink" title="原子操作简介"></a>原子操作简介</h3><p>所谓的原子操作，取的就是 “原子是最小的、不可分割的最小个体” 的意义，它表示在多个线程访问同一个全局资源的时候，能够确保在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。在以往的 C++ 标准中并没有对原子操作进行规定，开发人员往往是使用汇编语言，或者是借助第三方的线程库，例如 Intel 的 <code>pthread</code> 来实现。在新标准 C++ 11 中，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如 <code>atomic_bool</code>、<code>atomic_int</code> 等等。如果在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问；这样就可以保证多个线程访问这个共享资源的正确性，从而避免了锁的使用，提高了效率。在新标准 C++ 11 中，<code>atomic</code> 对 <code>int</code>、<code>char</code>、<code>bool</code> 等基础数据结构进行了原子性封装，在多线程环境中，对 <code>atomic</code> 对象的访问不会造成资源竞争，利用 <code>atomic</code> 可实现数据结构的无锁设计。</p><h3 id="atomic-的简介"><a href="#atomic-的简介" class="headerlink" title="atomic 的简介"></a>atomic 的简介</h3><p>在新标准 C++ 11 中，新增了 <code>atomic</code> 关键字，可以使用它定义一个原子类型，详见 <a target="_blank" rel="external nofollow" href="https://zh.cppreference.com/w/cpp/atomic/atomic">C++ 参考手册一</a>、<a target="_blank" rel="external nofollow" href="http://www.cplusplus.com/reference/atomic/">C++ 参考手册二</a>。</p><ul><li>成员函数</li></ul><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td> store</td><td> 原子地以非原子对象替换原子对象的值</td></tr><tr><td> load</td><td> 原子地获得原子对象的值</td></tr><tr><td> operator=</td><td> 存储值于原子对象</td></tr><tr><td> is_lock_free</td><td> 检查原子对象是否免锁</td></tr><tr><td> operator T</td><td> 从原子对象加载值</td></tr><tr><td> exchange</td><td> 原子地替换原子对象的值，并获得它先前持有的值</td></tr><tr><td> compare_exchange_weak、compare_exchange_strong</td><td> 原子地比较原子对象与非原子参数的值，若相等则进行交换，若不相等则进行加载</td></tr></tbody></table><ul><li>特化成员函数</li></ul><table><thead><tr><th>特化成员函数</th><th>说明</th></tr></thead><tbody><tr><td> fetch_add</td><td> 原子地将参数加到存储于原子对象的值，并返回先前保有的值</td></tr><tr><td> fetch_sub</td><td> 原子地从存储于原子对象的值减去参数，并获得先前保有的值</td></tr><tr><td> fetch_and</td><td> 原子地进行参数和原子对象的值的逐位与，并获得先前保有的值</td></tr><tr><td> fetch_or</td><td> 原子地进行参数和原子对象的值的逐位或，并获得先前保有的值</td></tr><tr><td> fetch_xor</td><td> 原子地进行参数和原子对象的值的逐位异或，并获得先前保有的值</td></tr><tr><td><code>operator++</code>、<code>operator++(int)</code>、<code>operator--</code>、<code>operator--(int)</code></td><td>令原子值增加或者减少一</td></tr><tr><td><code>operator+=</code>、<code>operator-=</code>、<code>operator&amp;=</code>、<code>operator^=</code></td><td>加、减，或者与原子值进行逐位与、异或</td></tr></tbody></table><p>值得一提的是，所谓特化函数，也就是 <code>atomic</code> 自身提供的，可以进行原子操作的函数。使用这些函数进行的操作，都是原子的。</p><h3 id="atomic-的使用案例"><a href="#atomic-的使用案例" class="headerlink" title="atomic 的使用案例"></a>atomic 的使用案例</h3><h4 id="加锁不使用-atomic"><a href="#加锁不使用-atomic" class="headerlink" title="加锁不使用 atomic"></a>加锁不使用 atomic</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// 加锁防止多个线程同时访问同一资源</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		total++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">clock_t</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动多个线程</span></span><br><span class="line">	vector&lt;thread&gt; threads;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(threadFun));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thad : threads) {</span><br><span class="line">		thad.<span class="built_in">join</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检测total是否正确 10000*10 = 100000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"total number:"</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">clock_t</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"耗时："</span> &lt;&lt; end_time - start_time &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total number:10000000</span><br><span class="line">耗时：615ms</span><br></pre></td></tr></tbody></table></figure><h4 id="不加锁使用-atomic"><a href="#不加锁使用-atomic" class="headerlink" title="不加锁使用 atomic"></a>不加锁使用 atomic</h4><p>与加锁相比，使用原子操作（atomic）能大大地提高程序的运行效率。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">atomic&lt;<span class="keyword">size_t</span>&gt; <span class="title">total</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">		total++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">clock_t</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动多个线程</span></span><br><span class="line">	vector&lt;thread&gt; threads;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(threadFun));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thad : threads) {</span><br><span class="line">		thad.<span class="built_in">join</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检测total是否正确 10000*10 = 100000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"total number:"</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">clock_t</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"耗时："</span> &lt;&lt; end_time - start_time &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total number:10000000</span><br><span class="line">耗时：321ms</span><br></pre></td></tr></tbody></table></figure><h3 id="为什么要定义一个原子类型"><a href="#为什么要定义一个原子类型" class="headerlink" title="为什么要定义一个原子类型"></a>为什么要定义一个原子类型</h3><p>举个例子，<code>int64_t</code> 类型，在 32 位机器上为非原子操作。更新时该类型的值时，需要进行两步操作（高 32 位、低 32 位）。如果多线程操作该类型的变量，且在操作时未加锁，可能会出现读脏数据的情况。解决该问题的话，可以使用加锁，或者提供一种定义原子类型的方法。</p><ul><li>定义原子类型</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个"int64_t"的原子类型</span></span><br><span class="line">std::atomic&lt;<span class="keyword">int64_t</span>&gt; value;</span><br></pre></td></tr></tbody></table></figure><ul><li>自加操作（原子）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic提供的特化成员函数，已经重载了++运算符</span></span><br><span class="line">value++</span><br></pre></td></tr></tbody></table></figure><ul><li>读取变量值（原子）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处的原子操作，指的是读取value的值这一步，而不是将value的值赋给x</span></span><br><span class="line"><span class="keyword">int64_t</span> x = value.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br></pre></td></tr></tbody></table></figure><ul><li>更新变量（原子）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> x = <span class="number">10</span>;</span><br><span class="line">value.<span class="built_in">store</span>(x, std::memory_order_relaxed)</span><br></pre></td></tr></tbody></table></figure><h3 id="atomic-不能与-string-一起使用"><a href="#atomic-不能与-string-一起使用" class="headerlink" title="atomic 不能与 string 一起使用"></a>atomic 不能与 string 一起使用</h3><p>特别注意，<code>atomic</code> 关键字不能与 <code>string</code> 类型一起使用，因为 <code>string</code> 不是可简单复制的类型（TriviallyCopyable），详见 <a target="_blank" rel="external nofollow" href="https://en.cppreference.com/w/cpp/atomic/atomic">C++ 参考文档</a>：</p><blockquote><p>The primary std::atomic template may be instantiated with any TriviallyCopyable type T satisfying both CopyConstructible and CopyAssignable.</p></blockquote><hr><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::atomic&lt;std::string&gt; str{ <span class="string">"Hello"</span> };</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码编译后，C++ 编译器会出现编译错误，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C2338: atomic&lt;T&gt; requires T to be trivially copyable, copy constructible, move constructible, copy assignable, and move assignable.</span><br></pre></td></tr></tbody></table></figure><p>关于 C++ 编译器为什么会对 <code>std::atomic&lt;std::string&gt;</code> 给出简单的可复制错误，在 <a target="_blank" rel="external nofollow" href="https://stackoverflow.com/questions/58852618/">Stack Overflow</a> 上找到了一个类似的问题可供参考。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/taiyang-li/p/5914331.html">C++11 新特性之 atomic</a></li><li><a target="_blank" rel="external nofollow" href="https://blog.csdn.net/shaosunrise/article/details/85158249">C++ 智能指针 unique_ptr 详解与示例</a></li><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/91328039">为何优先选用 unique_ptr 而不是裸指针？</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/dbff2af9.html" title="C++ 进阶基础之一">https://www.techgrow.cn/posts/dbff2af9.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/c942e1de.html" rel="prev" title="C++ 使用 API 连接 MySQL 数据库"><i class="fa fa-angle-left"></i> C++ 使用 API 连接 MySQL 数据库</a></div><div class="post-nav-item"> <a href="/posts/779107de.html" rel="next" title="C++ 进阶基础之二">C++ 进阶基础之二<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.7m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">25:33</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/dbff2af9.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>