<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Java 中的集合类的线程安全问题。"><meta property="og:type" content="article"><meta property="og:title" content="Java 多线程编程之六集合类的线程安全问题"><meta property="og:url" content="https://www.techgrow.cn/posts/1f270e10.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 Java 中的集合类的线程安全问题。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/05/java-collection-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/05/java-collection-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/01/list-copy-on-write.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/copy-on-write-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/copy-on-write-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/copy-on-write-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/03/copy-on-write-1.png"><meta property="article:published_time" content="2023-01-05T14:34:42.000Z"><meta property="article:modified_time" content="2023-01-05T14:34:42.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Java"><meta property="article:tag" content="并发编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2024/05/java-collection-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/1f270e10.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/1f270e10.html","path":"posts/1f270e10.html","title":"Java 多线程编程之六集合类的线程安全问题"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java 多线程编程之六集合类的线程安全问题 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/app/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">集合类的简单介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">常见的集合类有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">常见的并发容器有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">HashMap 和 HashTable 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList-%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-text">ArrayList 的线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-text">ArrayList 的扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9"><span class="nav-text">ArrayList 的并发修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E7%9A%84%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-text">ArrayList 的写时复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">写时复制的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">写时复制的使用案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">写时复制的优缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet-%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-text">HashSet 的线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-text">HashSet 的底层结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9"><span class="nav-text">HashSet 的并发修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-%E7%9A%84%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-text">HashSet 的写时复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="nav-text">写时复制的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-1"><span class="nav-text">写时复制的使用案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-text">HashMap 的线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9"><span class="nav-text">HashMap 的并发修改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List-%E7%9A%84%E5%B9%B6%E5%8F%91%E8%BF%AD%E4%BB%A3%E4%BF%AE%E6%94%B9"><span class="nav-text">List 的并发迭代修改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-text">案例代码一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C"><span class="nav-text">案例代码二</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">613</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">52</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/1f270e10.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java 多线程编程之六集合类的线程安全问题 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 Java 中的集合类的线程安全问题。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Java 多线程编程之六集合类的线程安全问题</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-05 22:34:42" itemprop="dateCreated datePublished" datetime="2023-01-05T22:34:42+08:00">2023-01-05</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/1f270e10.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/1f270e10.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>5 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/5bbede3c.html">Java 多线程编程之一 Java 内存模型浅析</a></li><li><a href="/posts/f7ed7888.html">Java 多线程编程之二 synchronize 锁对象竞争</a></li><li><a href="/posts/ed2e098d.html">Java 多线程编程之三 volatile 与 JMM 内存模型</a></li><li><a href="/posts/3b82844a.html">Java 多线程编程之四 CAS、ABA 问题、锁</a></li><li><a href="/posts/d9aa9f1f.html">Java 多线程编程之五 AQS 底层源码深度剖析</a></li><li><a href="/posts/1f270e10.html">Java 多线程编程之六集合类的线程安全问题</a></li><li><a href="/posts/f7fd0987.html">Java 多线程编程之七队列、线程池、线程通信</a></li><li><a href="/posts/4a0f41c0.html">Java 多线程编程之八 Fork/Join 框架使用</a></li><li><a href="/posts/d016a303.html">Java 多线程编程之九 ThreadLocal 使用</a></li></ul><h2 id="集合类的简单介绍"><a href="#集合类的简单介绍" class="headerlink" title="集合类的简单介绍"></a>集合类的简单介绍</h2><h3 id="常见的集合类有哪些"><a href="#常见的集合类有哪些" class="headerlink" title="常见的集合类有哪些"></a>常见的集合类有哪些</h3><p>Java 中的集合类分为存储值（Collection）、存储键值对（Map）两种类型。Map 接口和 Collection 接口是所有集合框架的父接口，其中 Collection 接口的子接口包括 List 接口、Set 接口、Queue 接口。</p><span id="more"></span><p><img data-src="../../../asset/2024/05/java-collection-1.png"></p><ul><li>List 接口的实现类主要有：ArrayList、LinkedList、Vector、Stack 等</li><li> Set 接口的实现类主要有：HashSet、LinkedHashSet、TreeSet 等</li><li> Queue 接口的实现类主要有：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue、DelayedWorkQueue 等</li></ul><p><img data-src="../../../asset/2024/05/java-collection-2.png"></p><ul><li> Map 接口的实现类主要有：HashMap、HashTable、ConcurrentHashMap、TreeMap 等</li></ul><div class="admonition note"><p class="admonition-title">队列的使用</p><p>更多关于队列的使用教程，请阅读 <a href="/posts/f7fd0987.html#%E9%98%9F%E5%88%97">这里</a>。</p></div><h3 id="常见的并发容器有哪些"><a href="#常见的并发容器有哪些" class="headerlink" title="常见的并发容器有哪些"></a>常见的并发容器有哪些</h3><p>常见的并发容器（线程安全）有以下几种：</p><ul><li><code>ConcurrentHashMap</code>：是一个线程安全的 HashMap，它支持高并发的读和写，是 Java 中最常用的并发 Map 实现之一。</li><li><code>CopyOnWriteArraySet</code>：是一个线程安全的 Set，它通过对数据进行复制来保证线程安全，在写操作时会对数据进行复制，并进行写操作，读操作则不需要进行复制。</li><li><code>CopyOnWriteArrayList</code>：是一个线程安全的 ArrayList，它通过对数据进行复制来保证线程安全，在写操作时会对数据进行复制，并进行写操作，读操作则不需要进行复制。</li><li><code>BlockingQueue</code>：是一个阻塞队列，它可以在队列为空或队列已满时，暂停生产者线程或消费者线程的执行，从而避免了数据竞争和资源浪费。</li><li><code>ConcurrentLinkedQueue</code>：是一个非阻塞的队列，它可以支持高并发访问，并且性能优于 BlockingQueue。</li><li><code>PriorityQueue</code>：是一种优先队列，它可以实现按照优先级排序的队列，可用于解决某些求最小值或最大值的算法问题。</li><li><code>ConcurrentSkipListMap、ConcurrentSkipListSet</code>：是一种高并发的跳表，它可以支持高效的并发读写操作。</li></ul><h3 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h3><p>HashMap 和 HashTable 都是 Java 中用于存储键值对的数据结构，它们之间有以下几点区别：</p><ul><li><code>线程安全性</code>：HashTable 是线程安全的，而 HashMap 是非线程安全的。</li><li><code>null 键值</code>：在 HashMap 中，可以存储一个键或值为 null 的元素，如果尝试将相同的键多次放入 HashMap 中，后面的值会覆盖前面的值。相反的，在 HashTable 中，不允许键或值为 null。</li><li><code>继承关系</code>：HashMap 继承自 AbstractMap 类，而 HashTable 继承自 Dictionary 类，两者都实现了 Map 接口。</li><li><code>性能方面</code>：HashMap 的性能比 HashTable 更高，因为 HashTable 在每次访问时都需要进行同步处理，而 HashMap 不需要同步，因此在单线程环境下 HashMap 的性能更高。</li></ul><div class="admonition note"><p class="admonition-title">总结说明</p><ul><li>如果不需要线程安全，并且有可能会存储 null 键或值，推荐使用 HashMap。</li><li>如果需要线程安全，建议使用 ConcurrentHashMap，而避免使用 HashTable，因为它已经被官方标记为不推荐使用。</li><li>ConcurrentHashMap 通过把整个 Map 分为 N 个 Segment（类似 HashTable），可以提供相同的线程安全，但是性能提升 N 倍，性能默认提升 16 倍。</li></ul></div><h2 id="ArrayList-的线程不安全"><a href="#ArrayList-的线程不安全" class="headerlink" title="ArrayList 的线程不安全"></a>ArrayList 的线程不安全</h2><h3 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h3><p>当执行 <code>new ArrayList&lt;Integer&gt;()</code> 操作时，底层创建了一个空的数组，且数组的初始长度为 10。当向 ArrayList 添加元素时，如果当前元素个数达到了数组的容量，就会触发扩容操作。ArrayList 的扩容机制是通过调用 <code>grow()</code> 方法来实现的，而 <code>grow()</code> 方法则是调用 <code>Arrays.copyOf(elementData, netCapacity)</code> 方法进行扩容。具体的扩容过程如下：</p><ul><li>(1) 当创建 ArrayList 对象时，会初始化一个默认容量（一般为 10）的数组作为底层存储结构。</li><li>(2) 当添加新元素时，会首先判断是否需要扩容，即判断当前元素个数是否已经达到数组容量。</li><li>(3) 如果需要进行扩容，ArrayList 会计算新的容量大小，一般是当前容量的 1.5 倍（即旧容量 * 1.5）。</li><li>(4) 然后会创建一个新的数组，并将原数组中的元素复制到新数组中。</li><li>(5) 最后，ArrayList 会将新数组设置为内部存储数组，并丢弃旧数组。</li></ul><h3 id="ArrayList-的并发修改"><a href="#ArrayList-的并发修改" class="headerlink" title="ArrayList 的并发修改"></a>ArrayList 的并发修改</h3><p>为什么 ArrayList 是线程不安全的呢？因为在进行执行写操作的时候，方法上为了保证并发性，是没有添加 <code>synchronized</code> 修饰的，所以在并发写的时候，就会出现问题。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// ArrayList 不支持并发写操作</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br><span class="line">	at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1043)</span><br><span class="line">	at java.base/java.util.ArrayList$Itr.next(ArrayList.java:997)</span><br><span class="line">	at java.base/java.util.AbstractCollection.toString(AbstractCollection.java:472)</span><br><span class="line">	at java.base/java.lang.String.valueOf(String.java:2951)</span><br><span class="line">	at java.base/java.io.PrintStream.println(PrintStream.java:897)</span><br><span class="line">	at com.java.interview.test.ArrayListTest.lambda$main$0(ArrayListTest.java:14)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></tbody></table></figure><p>解决 ArrayList 并发写出现的异常：</p><ul><li>第一种方法：使用 JUC 里面的 CopyOnWriteArrayList （写时复制）类替代，其底层实现主要是一种读写分离的思想。</li><li>第二种方法：使用 Collectons 类，即使用 <code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code> 创建一个线程安全的 List。</li><li>第三种方法：使用 Vector 替代，Vector 底层是使用数组实现的，在每个方法上都加了锁，即使用 <code>synchronized</code> 修饰方法，这导致了其运行效率特别低。</li></ul><h3 id="ArrayList-的写时复制"><a href="#ArrayList-的写时复制" class="headerlink" title="ArrayList 的写时复制"></a>ArrayList 的写时复制</h3><h4 id="写时复制的实现原理"><a href="#写时复制的实现原理" class="headerlink" title="写时复制的实现原理"></a>写时复制的实现原理</h4><p>CopyOnWrite 容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器的 <code>Object[]</code> 添加，而是先将当前 <code>Object[]</code> 进行 Copy，复制出一个新的容器 <code>Object[] newElements</code>，然后新的容器 <code>Object[] newElements</code> 里添加元素，添加完元素之后，再将原容器的引用指向新的容器（<code>setArray（newElements）</code>）。这样做的好处是可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，所以 <strong>CopyOnWrite 容器也是一种读写分离的思想，读和写针对的是不同的容器。</strong>JDK 8 的 CopyOnWriteArrayList 的底层源码如下：</p><p><img data-src="../../../asset/2021/01/list-copy-on-write.png" alt="list-copy-on-write"></p><h4 id="写时复制的使用案例"><a href="#写时复制的使用案例" class="headerlink" title="写时复制的使用案例"></a>写时复制的使用案例</h4><p>这里简单介绍一下 CopyOnWriteArrayList 的使用，可以用于解决 ArrayList 的线程安全问题，示例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// CopyOnWriteArrayList 支持并发写操作</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[9d12f701]</span><br><span class="line">[9d12f701, 77f4feca, eb280a00]</span><br><span class="line">[9d12f701, 77f4feca]</span><br><span class="line">[9d12f701, 77f4feca, eb280a00, 859da88c, 3204da31, 0b594f8c, ff2a1328]</span><br><span class="line">[9d12f701, 77f4feca, eb280a00, 859da88c, 3204da31, 0b594f8c]</span><br><span class="line">[9d12f701, 77f4feca, eb280a00, 859da88c, 3204da31]</span><br><span class="line">[9d12f701, 77f4feca, eb280a00, 859da88c]</span><br><span class="line">[9d12f701, 77f4feca, eb280a00, 859da88c, 3204da31, 0b594f8c, ff2a1328, 6515bf2e, 175fb2da, 97a3832a]</span><br><span class="line">[9d12f701, 77f4feca, eb280a00, 859da88c, 3204da31, 0b594f8c, ff2a1328, 6515bf2e, 175fb2da]</span><br><span class="line">[9d12f701, 77f4feca, eb280a00, 859da88c, 3204da31, 0b594f8c, ff2a1328, 6515bf2e]</span><br></pre></td></tr></tbody></table></figure><h4 id="写时复制的优缺点"><a href="#写时复制的优缺点" class="headerlink" title="写时复制的优缺点"></a>写时复制的优缺点</h4><ul><li><p>优点</p><ul><li>适用于读多写少的业务场景，可以提高并发性能。</li></ul></li><li><p>缺点</p><ul><li>存在内存占用问题、数据一致性问题。</li><li>为了减少扩容带来开销，应该尽量使用批量添加（减少复制次数）。</li><li>CopyOnWrite 机制只能保证数据的最终一致性，不能保证实时数据的强一致性，因此如果希望写入的数据能马上能读到，那么就不能使用 CopyOnWrite 机制。</li></ul></li></ul><h2 id="HashSet-的线程不安全"><a href="#HashSet-的线程不安全" class="headerlink" title="HashSet 的线程不安全"></a>HashSet 的线程不安全</h2><h3 id="HashSet-的底层结构"><a href="#HashSet-的底层结构" class="headerlink" title="HashSet 的底层结构"></a>HashSet 的底层结构</h3><p>HashSet 的底层是使用 HashMap 进行实现的。</p><p><img data-src="../../../asset/2024/03/copy-on-write-2.png"></p><p>为什么调用 HashSet 的 <code>add()</code> 方法时，只需要传递一个参数，而 HashMap 是则需要传递 key-value 键值对呢？首先查看 HashSet 的 <code>add()</code> 方法（如下图），可以发现在调用 <code>add()</code> 方法的时候，新增的值只是作为 key，而 value 存储的是一个 Object 类型的常量。也就是说 HashSet 在存储数据时，只关心 key，而不关心 value。</p><p><img data-src="../../../asset/2024/03/copy-on-write-4.png"></p><p><img data-src="../../../asset/2024/03/copy-on-write-3.png"></p><h3 id="HashSet-的并发修改"><a href="#HashSet-的并发修改" class="headerlink" title="HashSet 的并发修改"></a>HashSet 的并发修改</h3><p>为什么 HashSet 是线程不安全的呢？因为在进行执行写操作的时候，方法上为了保证并发性，是没有添加 <code>synchronized</code> 修饰的，所以在并发写的时候，就会出现问题。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// HashSet 不支持并发写操作</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br><span class="line">	at java.base/java.util.HashMap$HashIterator.nextNode(HashMap.java:1493)</span><br><span class="line">	at java.base/java.util.HashMap$KeyIterator.next(HashMap.java:1516)</span><br><span class="line">	at java.base/java.util.AbstractCollection.toString(AbstractCollection.java:472)</span><br><span class="line">	at java.base/java.lang.String.valueOf(String.java:2951)</span><br><span class="line">	at java.base/java.io.PrintStream.println(PrintStream.java:897)</span><br><span class="line">	at com.java.interview.test.HashSetTest.lambda$main$0(HashSetTest.java:15)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></tbody></table></figure><p>解决 HashSet 并发写出现的异常：</p><ul><li>第一种方法：使用 CopyOnWriteArraySet（写时复制）类替代，其底层实现主要是一种读写分离的思想。</li><li>第二种方法：使用 Collectons 类，即使用 <code>Collections.synchronizedSet(new HashSet&lt;&gt;())</code> 创建一个线程安全的 HashSet。</li></ul><h3 id="HashSet-的写时复制"><a href="#HashSet-的写时复制" class="headerlink" title="HashSet 的写时复制"></a>HashSet 的写时复制</h3><h4 id="写时复制的实现原理-1"><a href="#写时复制的实现原理-1" class="headerlink" title="写时复制的实现原理"></a>写时复制的实现原理</h4><p>CopyOnWriteArraySet 的底层是使用 CopyOnWriteArrayList 进行实例化。</p><p><img data-src="../../../asset/2024/03/copy-on-write-1.png"></p><h4 id="写时复制的使用案例-1"><a href="#写时复制的使用案例-1" class="headerlink" title="写时复制的使用案例"></a>写时复制的使用案例</h4><p>这里简单介绍一下 CopyOnWriteArraySet 的使用，可以用于解决 HashSet 的线程安全问题，示例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// CopyOnWriteArraySet 支持并发修改</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[3c2e0351]</span><br><span class="line">[3c2e0351, 8f987008, 9b0e5b7d]</span><br><span class="line">[3c2e0351, 8f987008]</span><br><span class="line">[3c2e0351, 8f987008, 9b0e5b7d, 06eddb63, 7d4ca880, d68de36d]</span><br><span class="line">[3c2e0351, 8f987008, 9b0e5b7d, 06eddb63, 7d4ca880]</span><br><span class="line">[3c2e0351, 8f987008, 9b0e5b7d, 06eddb63]</span><br><span class="line">[3c2e0351, 8f987008, 9b0e5b7d, 06eddb63, 7d4ca880, d68de36d, 1e8ce86f, 0c4f7d93, 524f3f78, 31ef5f4a]</span><br><span class="line">[3c2e0351, 8f987008, 9b0e5b7d, 06eddb63, 7d4ca880, d68de36d, 1e8ce86f, 0c4f7d93, 524f3f78]</span><br><span class="line">[3c2e0351, 8f987008, 9b0e5b7d, 06eddb63, 7d4ca880, d68de36d, 1e8ce86f, 0c4f7d93]</span><br><span class="line">[3c2e0351, 8f987008, 9b0e5b7d, 06eddb63, 7d4ca880, d68de36d, 1e8ce86f]</span><br></pre></td></tr></tbody></table></figure><h2 id="HashMap-的线程不安全"><a href="#HashMap-的线程不安全" class="headerlink" title="HashMap 的线程不安全"></a>HashMap 的线程不安全</h2><h3 id="HashMap-的并发修改"><a href="#HashMap-的并发修改" class="headerlink" title="HashMap 的并发修改"></a>HashMap 的并发修改</h3><p>为什么 HashMap 是线程不安全的呢？因为在进行执行写操作的时候，方法上为了保证并发性，是没有添加 <code>synchronized</code> 修饰的，所以在并发写的时候，就会出现问题。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Map&lt;String, String&gt; set = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// HashMap 不支持并发写操作</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                String str = UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">                set.put(str, str);</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            }, String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br><span class="line">	at java.base/java.util.HashMap$HashIterator.nextNode(HashMap.java:1493)</span><br><span class="line">	at java.base/java.util.HashMap$EntryIterator.next(HashMap.java:1526)</span><br><span class="line">	at java.base/java.util.HashMap$EntryIterator.next(HashMap.java:1524)</span><br><span class="line">	at java.base/java.util.AbstractMap.toString(AbstractMap.java:551)</span><br><span class="line">	at java.base/java.lang.String.valueOf(String.java:2951)</span><br><span class="line">	at java.base/java.io.PrintStream.println(PrintStream.java:897)</span><br><span class="line">	at com.java.interview.test.HashMapTest.lambda$main$0(HashMapTest.java:16)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></tbody></table></figure><p>解决 HashMap 并发写出现的异常：</p><ul><li>第一种方法：使用 ConcurrentHashMap 替代，即使用 <code>Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;()</code>。</li><li>第二种方法：使用 Collectons 类，即使用 <code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code> 创建一个线程安全的 Map。</li></ul><h2 id="List-的并发迭代修改"><a href="#List-的并发迭代修改" class="headerlink" title="List 的并发迭代修改"></a>List 的并发迭代修改</h2><ul><li><p>普通 List</p><ul><li>在单线程环境下，普通的 List 默认不支持在迭代时，动态对容器进行插入、更改、删除等写操作，否则会抛出 <code>ConcurrentModificationException</code> 异常。</li><li>这是因为迭代器并不知道列表在迭代过程中是否发生了结构性修改，可以使用 ListIterator 来解决。</li></ul></li><li><p>CopyOnWriteArrayList</p><ul><li>在多个线程环境中，CopyOnWriteArrayList 支持并发访问，而且支持在迭代过程中对容器进行结构性修改，而且不需要借助 ListIterator。</li><li>这是因为容器每次修改时会创建一个新的容器副本（使用写时复制技术），然后再对新的容器副本进行修改，也就是说迭代的容器和修改的容器不是同一个，所以使用迭代器遍历容器不受修改的影响。</li></ul></li><li><p>Collections.synchronizedList()</p><ul><li>使用 <code>Collections.synchronizedList()</code> 创建的同步列表，支持在多个线程间安全地进行同步访问，但它并不完全支持并发修改。</li><li>具体来说，它在多个线程并发访问时，通过同步机制来保证每次只有一个线程可以访问该 List，从而避免数据不一致的问题。但是，这种同步机制并不支持多个线程在迭代过程中对容器进行结构性修改，否则会抛出 <code>ConcurrentModificationException</code> 异常，即使使用 ListIterator 也解决不了。</li><li>这是因为 <code>Collections.synchronizedList()</code> 通过内部的同步机制来保证单个操作的原子性，但不能保证迭代操作和修改操作之间的并发一致性。当在一个线程中使用 ListIterator 进行迭代时，另一个线程可以在任何时间对列表进行结构性修改（如添加、删除元素），这会导致迭代器检测到集合的并发修改，进而抛出异常。</li><li>ListIterator 使用快速失败（Fail-Fast）机制来检测集合的并发修改。每当集合进行结构性修改时，都会更新一个修改计数器（modCount）。当迭代器检测到集合的 modCount 与创建时的 modCount 不一致时，就会抛出 <code>ConcurrentModificationException</code> 异常。这种机制是在同步列表中同样适用的，因为同步列表并没有提供防止 modCount 变化的额外保护。</li><li>为了解决不支持在迭代过程中对容器进行结构性修改的问题，可以使用 CopyOnWriteArrayList 或者 ReentrantLock 来解决。</li></ul></li></ul><h3 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Runnable task = new Task1();  // 抛出异常</span></span><br><span class="line">        </span><br><span class="line">        Runnable task = <span class="keyword">new</span> Task2();     <span class="comment">// 正常运行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在单线程环境下，不支持在迭代过程中对容器进行结构性修改，因为在同步列表内部，迭代器并不知道列表在迭代过程中是否发生了结构性修改，可以使用 ListIterator 来解决</span></span><br><span class="line">    <span class="comment">// 在多线程环境下，支持并发访问，但不支持在迭代过程中对容器进行结构性修改，即使使用 ListIterator 进行迭代也解决不了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        list.add(<span class="string">"AAA"</span>);</span><br><span class="line">        list.add(<span class="string">"BBB"</span>);</span><br><span class="line">        list.add(<span class="string">"CCC"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        ListIterator&lt;String&gt; iterator = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            iterator.add(<span class="string">"DDD"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在多线程环境下，支持并发访问，且支持在迭代过程中对容器进行结构性修改</span></span><br><span class="line">    <span class="comment">// 因为容器每次修改时会创建一个新的容器副本，也就是说修改的容器和迭代的容器不是同一个，所以使用迭代器遍历容器不受修改的影响</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        list.add(<span class="string">"AAA"</span>);</span><br><span class="line">        list.add(<span class="string">"BBB"</span>);</span><br><span class="line">        list.add(<span class="string">"CCC"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            list.add(<span class="string">"DDD"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h3><p>针对 <code>Collections.synchronizedList()</code> 不支持多个线程在迭代过程中对容器进行结构性修改的问题，即使在遍历集合时使用 <code>synchronized</code> 块进行显式同步，也只能保证单个线程在该同步块内的操作是线程安全的。但如果另一个线程在同步块外对集合进行修改，这种结构性变化仍会被迭代器检测到，并抛出异常。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; syncList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;(List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个线程用于迭代</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (syncList) {</span><br><span class="line">                Iterator&lt;String&gt; iterator = syncList.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">                    System.out.println(<span class="string">"Iterating: "</span> + iterator.next());</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="comment">// 模拟迭代操作耗时</span></span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一个线程用于修改</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 确保修改线程在迭代线程开始后执行</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (syncList) {</span><br><span class="line">                syncList.add(<span class="string">"D"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Added D"</span>);</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述的代码可能会抛出 <code>ConcurrentModificationException</code> 异常，因为两个线程分别进行迭代和修改操作，即使同步块保证了单个操作的线程安全，但无法保证多个操作（整体）的并发一致性。</p><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/1f270e10.html" title="Java 多线程编程之六集合类的线程安全问题">https://www.techgrow.cn/posts/1f270e10.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 并发编程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/496af1ce.html" rel="prev" title="Docker 搭建 ZooKeeper 集群"><i class="fa fa-angle-left"></i> Docker 搭建 ZooKeeper 集群</a></div><div class="post-nav-item"> <a href="/posts/d2c9b56d.html" rel="next" title="Docker 搭建 Kafka 集群">Docker 搭建 Kafka 集群<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.5m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">22:28</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤 ICP 备 19024664 号</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035 号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/app/api/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/app/api/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/1f270e10.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>