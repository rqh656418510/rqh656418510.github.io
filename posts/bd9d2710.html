<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 巩固进阶之三"><meta property="og:url" content="https://www.techgrow.cn/posts/bd9d2710.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-03-02T13:55:33.000Z"><meta property="article:modified_time" content="2025-03-02T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.techgrow.cn/posts/bd9d2710.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/bd9d2710.html","path":"posts/bd9d2710.html","title":"C++ 巩固进阶之三"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 巩固进阶之三 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84-function-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">C++ 11 的 function 类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E8%AF%B4%E6%98%8E"><span class="nav-text">对比说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-text">案例代码一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C"><span class="nav-text">案例代码二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%89"><span class="nav-text">案例代码三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80-1"><span class="nav-text">案例代码一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C-1"><span class="nav-text">案例代码二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%89-1"><span class="nav-text">案例代码三</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84-bind-%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="nav-text">C++ 11 的 bind 绑定器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">概念介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bind-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">bind 的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind1st-%E4%B8%8E-bind2nd-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">bind1st 与 bind2nd 的概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-1"><span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bind-%E4%B8%8E-function-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-text">bind 与 function 基础使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind-%E4%B8%8E-function-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">bind 与 function 实现线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind1st-%E4%B8%8E-bind2nd-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-text">bind1st 与 bind2nd 基础使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind1st-%E4%B8%8E-bind2nd-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">bind1st 与 bind2nd 底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-bind1st-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">模拟实现 bind1st 的功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-bind2nd-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">模拟实现 bind2nd 的功能</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">C++ 11 的 Lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-2"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-2"><span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-text">Lambda 的核心特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda-%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-text">Lambda 的基础使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda-%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5"><span class="nav-text">Lambda 的应用实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">Lambda 的底层原理</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">738</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/bd9d2710.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 巩固进阶之三 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 的巩固教程。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 巩固进阶之三</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-03-02 21:55:33" itemprop="dateCreated datePublished" datetime="2025-03-02T21:55:33+08:00">2025-03-02</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/bd9d2710.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/bd9d2710.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.8k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>4 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-11-的-function-类模板"><a href="#C-11-的-function-类模板" class="headerlink" title="C++ 11 的 function 类模板"></a>C++ 11 的 function 类模板</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p><code>function</code> 是 C++ 11 引入的一个类模板，用于存储任何可以调用的目标（如普通函数、函数指针、函数对象、Lambda 表达式等），并通过统一的接口进行调用。它能够封装和管理函数，允许将函数作为对象传递和存储，位于 <code>&lt;functional&gt;</code> 头文件中，常用于回调和高阶函数。</p><ul><li><p>使用说明</p><ul><li>用函数类型实例化 <code>function</code> 类模板</li><li>通过 <code>function</code> 类模板调用 <code>operator()</code> 函数的时候，需要根据函数类型传入相应的参数</li></ul></li><li><p>使用特点</p><ul><li>通过类型擦除技术存储任意可调用对象（普通函数、Lambda 表达式、仿函数、成员函数指针等），无需关心具体类型，仅需关注调用签名‌</li><li>编译时会检查参数和返回类型是否匹配，避免了传统函数指针的类型不安全问题‌</li></ul></li><li><p>使用场景</p><ul><li>事件回调</li><li>作为函数参数传递可调用对象</li><li>存储 Lambda 表达式</li></ul></li></ul><h3 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h3><p>C 语言中的函数指针与 C++ 的 <code>function</code> 类模板的对比如下：</p><table><thead><tr><th>特性</th><th>函数指针 (C 语言)</th><th><code>function</code> 类模板 (C++)</th></tr></thead><tbody><tr><td> 灵活性</td><td>只能指向具有匹配签名的函数</td><td>可以封装多种类型的可调用对象 (函数、Lambda、函数对象)</td></tr><tr><td> 状态管理</td><td>不支持状态封装</td><td>支持状态封装（如 Lambda 表达式和函数对象）</td></tr><tr><td>类型安全</td><td>不提供额外的类型安全</td><td>提供类型安全检查</td></tr><tr><td>性能开销</td><td>较低</td><td>可能有较高的内存和性能开销</td></tr><tr><td>多态性</td><td>不支持多态</td><td>支持多态</td></tr></tbody></table><p>C 语言中的函数指针与 C++ 的 <code>function</code> 类模板的区别如下：</p><ul><li><p>基本概念</p><ul><li>函数指针（C 语言）<ul><li>函数指针是一个变量，用于存储函数的地址。通过该指针，可以间接调用对应的函数。</li><li>C 语言中的函数指针需要显式指定函数签名（返回值类型和参数类型）。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 是 C++ 11 引入的类模板，提供了一种通用的、类型安全的方式来存储、传递和调用可调用对象（如普通函数、函数指针、Lambda 表达式、函数对象等）。</li><li>它可以封装多种不同类型的可调用对象，并且允许它们通过统一的接口被调用。</li></ul></li></ul></li><li><p>灵活性和类型支持</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针只能指向具有相同函数签名（参数类型和返回类型）的函数。</li><li>不支持封装函数对象、Lambda 表达式等其他类型的可调用对象。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 支持多种类型的可调用对象，包括普通函数、函数指针、Lambda 表达式、函数对象等。</li><li>它的模板参数可以适配任意函数签名，支持更加灵活的调用。</li><li>还支持捕获外部状态的 Lambda 表达式，或者包含状态的函数对象。</li></ul></li></ul></li><li><p>状态管理</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针无法封装额外的状态信息，指向的仅仅是一个函数。</li><li>如果需要管理状态（如在函数调用前后执行某些操作），必须依赖外部的代码来实现。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 可以封装状态信息。例如，Lambda 表达式和函数对象可以拥有成员变量和成员函数，允许在调用时使用封装的状态。</li><li>这种能力使得 <code>function</code> 在处理回调和事件处理时更具优势。</li></ul></li></ul></li><li><p>类型安全</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针本身类型是静态的，编译时要求函数签名必须匹配，但它不提供额外的类型安全检查，错误的使用可能导致未定义行为。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 是类型安全的，编译时会检查存储的可调用对象是否与声明的函数签名一致。</li><li>C++ 编译器提供了类型安全的保证，避免了函数签名不匹配带来的错误。</li></ul></li></ul></li><li><p>内存管理和性能</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针直接存储函数的地址，不涉及额外的内存分配，因此它的性能开销较小。</li><li>由于没有额外的封装，也没有多态或状态的管理，性能上较为高效。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 需要进行额外的内存分配和类型擦除（Type Erasure）。对于 Lambda 表达式和函数对象，它会封装一个通用的接口，这可能带来额外的性能开销。</li><li>但是，它的灵活性和类型安全是 <code>function</code> 的优势。</li></ul></li></ul></li><li><p>多态和扩展性</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针没有多态性。它们只是简单地指向某个函数，无法支持运行时多态。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 支持通过函数对象、Lambda 表达式和虚拟函数等方式实现运行时多态，提供了更大的灵活性。</li><li>它可以封装复杂的行为，例如结合面向对象编程中的继承和多态来实现不同的回调机制。</li></ul></li></ul></li></ul><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello1</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello2</span><span class="params">(string str)</span> </span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// function 函数对象类型</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; function1 = hello1;</span><br><span class="line">    <span class="built_in">function1</span>();</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; function2 = hello2;</span><br><span class="line">    <span class="built_in">function2</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; function3 = sum;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="built_in">function3</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"total = "</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function 函数对象类型 + Lambda 表达式</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; function4 = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) {<span class="keyword">return</span> a + b; };</span><br><span class="line">    <span class="keyword">int</span> total2 = <span class="built_in">function4</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"total2 = "</span> &lt;&lt; total2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello peter</span><br><span class="line">total = 3</span><br><span class="line">total2 = 8</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 通过 function 函数对象类型，调用类的成员函数</span></span><br><span class="line">    Test t;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(Test*, string)&gt; function1 = &amp;Test::hello;</span><br><span class="line">    <span class="built_in">function1</span>(&amp;t, <span class="string">"peter"</span>);</span><br><span class="line">    <span class="built_in">function1</span>(&amp;<span class="built_in">Test</span>(), <span class="string">"peter"</span>);    <span class="comment">// 或者使用临时变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br><span class="line">hello peter</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码三"><a href="#案例代码三" class="headerlink" title="案例代码三"></a>案例代码三</h4><p>使用 <code>function</code> 函数对象类型来实现图书管理系统的菜单列表选择功能。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doShowAllBooks</span><span class="params">()</span> </span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"查看所有书籍"</span> &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBorrowBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"借书"</span> &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBackBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"还书"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doQueryBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"查询书籍"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoginOut</span><span class="params">()</span> </span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"注销"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="keyword">int</span>, function&lt;<span class="keyword">void</span>()&gt;&gt; actionMap;</span><br><span class="line">	actionMap.<span class="built_in">insert</span>({ <span class="number">1</span>, doShowAllBooks });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">2</span>, doBorrowBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">3</span>, doBackBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">4</span>, doQueryBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">5</span>, doLoginOut });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"\n-------------------"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"1. 查看所有书籍"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"2. 借书"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"3. 还书"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"4. 查询书籍"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"5. 注销"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"-------------------"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"请选择: "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测输入是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (!(cin &gt;&gt; choice)) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入数字无效，请重新输入!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 清除错误状态</span></span><br><span class="line">            cin.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="comment">// 丢弃错误输入</span></span><br><span class="line">            cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = actionMap.<span class="built_in">find</span>(choice);</span><br><span class="line">        <span class="keyword">if</span> (it == actionMap.<span class="built_in">end</span>()) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入数字无效，请重新输入!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        it-&gt;<span class="built_in">second</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有一个参数且不带返回值的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 模板类的特化，支持特定的函数签名 R(ARG)</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG 代表参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ARG&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg 传递给存储函数的参数</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG arg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 hello 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = hello;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 hello</span></span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有两个参数且带返回值的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG1, ARG2)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 模板类的特化，支持特定的函数签名 R(ARG1, ARG2)</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG1 代表第一个参数类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG2 代表第二个参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ARG1, <span class="keyword">typename</span> ARG2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG1, ARG2)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG1, ARG2) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG1, ARG2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line"><span class="comment">     * @param pfunc 指向函数的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg1 传递给存储函数的第一个参数</span></span><br><span class="line"><span class="comment">     * @param arg2 传递给存储函数的第二个参数</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG1 arg1, ARG2 arg2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg1, arg2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 sum 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func1 = sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 sum</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">func1</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: 8</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码三-1"><a href="#案例代码三-1" class="headerlink" title="案例代码三"></a>案例代码三</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有不同数量参数（可变参数列表）的函数，避免编写多个模板类的特例化。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG...)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief myfunction 模板类的特化，支持可变长参数列表</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG 代表参数列表（可以是任意数量的参数类型）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ... ARG&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG...)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG...) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line"><span class="comment">     * @param pfunc 指向函数的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg 传递给存储函数的参数列表</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG... arg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg...);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 hello 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = hello;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 hello</span></span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 sum函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func2 = sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func2 调用 sum</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">func2</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br><span class="line">result: 7</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的-bind-绑定器"><a href="#C-11-的-bind-绑定器" class="headerlink" title="C++ 11 的 bind 绑定器"></a>C++ 11 的 bind 绑定器</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><h4 id="bind-的概念"><a href="#bind-的概念" class="headerlink" title="bind 的概念"></a>bind 的概念</h4><p><code>bind</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的一个工具，用于创建可调用对象（Callable Object），它可以将函数与部分参数进行绑定，并返回一个新的可调用对象，方便后续调用。</p><ul><li><p>主要作用</p><ul><li>固定部分参数：可以预先绑定部分参数，简化后续调用的接口。</li><li>调整参数顺序：可以自定义参数的传递顺序，使函数调用更加灵活。</li><li>与标准库配合：可以与 <code>function</code>、<code>thread</code>、STL 算法等一起使用，提高程序的灵活性。</li></ul></li><li><p>关键点</p><ul><li><code>bind</code> 返回一个可调用对象（函数对象），类似于 Lambda 表达式。</li><li><code>placeholders::_1, placeholders::_2, ...</code> 代表占位符（最多可以有 20 个），表示绑定器调用时需要提供的参数。</li><li>适用于普通函数、类成员函数、仿函数（函数对象）等。</li></ul></li><li><p>使用场景</p><ul><li>配合 <code>function</code> 类模板使用，用于回调管理。</li><li>与 <code>thread</code> 配合，用于传递类成员函数。</li><li>在 STL 算法中自定义比较或筛选规则。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>尽管 <code>bind</code> 功能强大，但在 C++ 11 之后，Lambda 表达式在大多数情况下更加直观，建议优先使用 Lambda 表达式。</p></div><h4 id="bind1st-与-bind2nd-的概念"><a href="#bind1st-与-bind2nd-的概念" class="headerlink" title="bind1st 与 bind2nd 的概念"></a>bind1st 与 bind2nd 的概念</h4><p><code>bind1st</code> 和 <code>bind2nd</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的函数适配器，用于对二元（两个参数）函数对象进行绑定，使其成为一元（单参数）函数对象。这两个函数适配器用于旧版 C++（C++ 98 / C++ 03），在 C++ 11 及更新版本中已被 <code>bind</code> 取代。</p><ul><li><code>bind1st</code>：绑定二元（两个参数）函数对象的第一个参数，生成一个新的一元函数对象，该函数对象接收原函数的第二个参数作为输入。</li><li><code>bind2nd</code>：绑定二元（两个参数）函数对象的第二个参数，生成一个新的一元函数对象，该函数对象接收原函数的第一个参数作为输入。</li></ul><h3 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="bind-与-function-基础使用"><a href="#bind-与-function-基础使用" class="headerlink" title="bind 与 function 基础使用"></a><code>bind</code> 与 <code>function</code> 基础使用</h4><p>这里主要演示如何使用 C++ 11 中的 <code>bind</code> 和 <code>function</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 例子一，绑定拥有一个参数的普通函数</span></span><br><span class="line">    <span class="built_in">bind</span>(hello, <span class="string">"Hello Bind!"</span>)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子二，绑定拥有两个参数的普通函数</span></span><br><span class="line">    <span class="keyword">int</span> result1 = <span class="built_in">bind</span>(sum, <span class="number">3</span>, <span class="number">5</span>)();</span><br><span class="line">    cout &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子三，绑定类成员函数</span></span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="built_in">bind</span>(&amp;Test::sum, <span class="built_in">Test</span>(), <span class="number">5</span>, <span class="number">9</span>)();</span><br><span class="line">    cout &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子四，使用参数占位符绑定（最多可以有20个参数占位符）</span></span><br><span class="line">    <span class="built_in">bind</span>(hello, placeholders::_1)(<span class="string">"Hello Rust!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子五，使用 function 类模板实现 bind 绑定器的复用</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = <span class="built_in">bind</span>(hello, placeholders::_1);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"Hello Python"</span>);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"Hello Golang"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子六，使用参数占位符 + function 类模板进行绑定</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; func2 = <span class="built_in">bind</span>(sum, <span class="number">6</span>, placeholders::_1);    <span class="comment">// 绑定 6 作为第一个参数，第二个参数则手动传入</span></span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="built_in">func2</span>(<span class="number">5</span>);     <span class="comment">// 输出 11，相当于 sum(6, 5)</span></span><br><span class="line">    cout &lt;&lt; result3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hello Bind!</span><br><span class="line">8</span><br><span class="line">14</span><br><span class="line">Hello Rust!</span><br><span class="line">Hello Python</span><br><span class="line">Hello Golang</span><br><span class="line">11</span><br></pre></td></tr></tbody></table></figure><h4 id="bind-与-function-实现线程池"><a href="#bind-与-function-实现线程池" class="headerlink" title="bind 与 function 实现线程池"></a><code>bind</code> 与 <code>function</code> 实现线程池</h4><p>这里简单使用 C++ 11 的 <code>bind</code> 和 <code>function</code> 来模拟实现线程池。特别注意，下述代码中的 <code>ThreadPool::startPool()</code> 会调用 <code>join()</code> 来阻塞等待所有子线程执行完成，即线程池运行一次后就会结束，不能重复使用，而且也没有使用到任务队列来优化线程池。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Thread</span>(function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; func, <span class="keyword">int</span> id) : _func(func), _id(id) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(_func, _id)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; _func;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程池</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">        <span class="comment">// 释放堆上的资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _pool.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">delete</span> _pool[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建自定义的线程对象，并放入容器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="comment">// 使用 bind 绑定器</span></span><br><span class="line">            _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="keyword">this</span>, placeholders::_1), i));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子线程执行完成</span></span><br><span class="line">        <span class="keyword">for</span> (thread &amp;t : _handler) {</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Thread *&gt; _pool;</span><br><span class="line">    vector&lt;thread&gt; _handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runInThread() 成员函数充当线程函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runInThread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call runInThread! id: "</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">startPool</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call runInThread! id: 0</span><br><span class="line">call runInThread! id: 2</span><br><span class="line">call runInThread! id: 5</span><br><span class="line">call runInThread! id: 9</span><br><span class="line">call runInThread! id: 6</span><br><span class="line">call runInThread! id: 8</span><br><span class="line">call runInThread! id: 1</span><br><span class="line">call runInThread! id: 7</span><br><span class="line">call runInThread! id: 4</span><br><span class="line">call runInThread! id: 3</span><br></pre></td></tr></tbody></table></figure><h4 id="bind1st-与-bind2nd-基础使用"><a href="#bind1st-与-bind2nd-基础使用" class="headerlink" title="bind1st 与 bind2nd 基础使用"></a><code>bind1st</code> 与 <code>bind2nd</code> 基础使用</h4><p>这里主要演示如何使用旧版 C++ 提供的 <code>bind1st</code> 与 <code>bind2nd</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showContainer</span><span class="params">(Container &amp;con)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历容器并打印元素</span></span><br><span class="line">    <span class="keyword">typename</span> Container::iterator it = con.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; it != con.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序，greater 是二元函数对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 70 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind1st 绑定 greater 的第一个参数，使其始终为 70，让 greater(70, x) 变成一元函数对象，等价于 f(x) = (70 &gt; x)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind2nd 绑定 less 的第二个参数，使其始终为 70，让 less(x, 70) 变成一元函数对象，等价于 f(x) = (x &lt; 70)</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator it = find_if(vec.begin(), vec.end(), bind2nd(less&lt;int&gt;(), 70));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 70 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"================================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">20 67 35 49 100 43 28 63 71 46 </span><br><span class="line">20 28 35 43 46 49 63 67 71 100 </span><br><span class="line">100 71 67 63 49 46 43 35 28 20 </span><br><span class="line">================================</span><br><span class="line">76 88 70 53 82 84 42 38 91 64 </span><br><span class="line">91 88 84 82 76 70 64 53 42 38 </span><br><span class="line">找到小于 70 的第一个元素：64</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 C++ 11 及更新版本中，<code>bind1st</code> 和 <code>bind2nd</code> 已被 <code>bind</code> 取代，示例代码如下：</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 3 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind 绑定 greater 的第一个参数，等价于 f(x) = (3 &gt; x)</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>)&gt; predicate = <span class="built_in">bind</span>(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">3</span>, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind 绑定 less 的第二个参数，等价于 f(x) = (x &lt; 3)</span></span><br><span class="line">    <span class="comment">// function&lt;bool(int)&gt; predicate = bind(less&lt;int&gt;(), placeholders::_1, 3);</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), predicate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 3 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 3 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 C++ 11 及更新版本中，可以使用 Lambda 表达式（更现代的 C++ 方式）来实现，示例代码如下：</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 3 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x &lt; <span class="number">3</span>; });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 3 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 3 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><h4 id="bind1st-与-bind2nd-底层原理"><a href="#bind1st-与-bind2nd-底层原理" class="headerlink" title="bind1st 与 bind2nd 底层原理"></a><code>bind1st</code> 与 <code>bind2nd</code> 底层原理</h4><h5 id="模拟实现-bind1st-的功能"><a href="#模拟实现-bind1st-的功能" class="headerlink" title="模拟实现 bind1st 的功能"></a>模拟实现 bind1st 的功能</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象（一元函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">my_bind1st</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，比如：my_bind1st(greater&lt;int&gt;(), 5)</span></span><br><span class="line">    _my_bind1st(Compare comp, <span class="keyword">const</span> T &amp;first) : _comp(comp), _first(first) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;second)</span> </span>{</span><br><span class="line">        <span class="comment">// 底层调用的仍然是二元（两个参数）函数对象</span></span><br><span class="line">        <span class="keyword">return</span> _comp(_first, second);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _comp;</span><br><span class="line">    T _first;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定器（模拟 bind1st 的实现）</span></span><br><span class="line"><span class="comment">// 绑定二元（两个参数）函数对象的第一个参数，生成一个新的一元函数对象，该函数对象接收原函数的第二个参数作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_my_bind1st&lt;Compare, T&gt; <span class="title">my_bind1st</span><span class="params">(Compare comp, <span class="keyword">const</span> T &amp;first)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> _my_bind1st&lt;Compare, T&gt;(comp, first);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first)) {</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">9</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 5 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 my_bind1st 绑定 greater 的第一个参数，使其始终为 5，让 greater(5, x) 变成一元函数对象，等价于 f(x) = (5 &gt; x)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">my_bind1st</span>(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 5 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 5 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><h5 id="模拟实现-bind2nd-的功能"><a href="#模拟实现-bind2nd-的功能" class="headerlink" title="模拟实现 bind2nd 的功能"></a>模拟实现 bind2nd 的功能</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象（一元函数对象）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">my_bind2nd</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，比如：my_bind2nd(less&lt;int&gt;(), 5)</span></span><br><span class="line">    _my_bind2nd(Compare comp, <span class="keyword">const</span> T &amp;second) : _comp(comp), _second(second) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;first)</span> </span>{</span><br><span class="line">        <span class="comment">// 底层调用的仍然是二元（两个参数）函数对象</span></span><br><span class="line">        <span class="keyword">return</span> _comp(first, _second);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _comp;</span><br><span class="line">    T _second;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定器（模拟 bind2nd 的实现）</span></span><br><span class="line"><span class="comment">// 绑定二元（两个参数）函数对象的第二个参数，生成一个新的一元函数对象，该函数对象接收原函数的第一个参数作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_my_bind2nd&lt;Compare, T&gt; <span class="title">my_bind2nd</span><span class="params">(Compare comp, <span class="keyword">const</span> T &amp;second)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> _my_bind2nd&lt;Compare, T&gt;(comp, second);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first)) {</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">9</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 5 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 my_bind2nd 绑定 less 的第二个参数，使其始终为 5，让 less(x, 5) 变成一元函数对象，等价于 f(x) = (x &lt; 5)</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">my_bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 5 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到小于 5 的第一个元素：2</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的-Lambda-表达式"><a href="#C-11-的-Lambda-表达式" class="headerlink" title="C++ 11 的 Lambda 表达式"></a>C++ 11 的 Lambda 表达式</h2><h3 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>C++ 11 的 Lambda 表达式（Lambda Expressions）是一种用于定义匿名函数对象的简洁语法，使得代码更加简洁、灵活。其强大的变量捕获、类型推导和灵活性，使其在现代 C++ 开发中被广泛使用。</p><ul><li><p>Lambda 表达式的语法</p><ul><li><code>[capture](parameter_list) -&gt; return_type {function_body}</code>，即 <code>[捕获外部变量](形参列表) -&gt; 返回类型 {操作代码}</code></li><li><code>capture</code>（捕获列表）：定义 Lambda 访问外部变量的方式（比如：按值或按引用）。<ul><li><code>[]</code>：表示不捕获任何外部变量</li><li><code>[this]</code>：表示捕获外部的 <code>this</code> 指针。</li><li><code>[=]</code>：表示以传值的方式捕获外部的所有变量。</li><li><code>[&amp;]</code>：表示以传引用的方式捕获外部的所有变量。</li><li><code>[=, &amp;a]</code>：表示以传值的方式捕获外部的所有变量，但是 <code>a</code> 变量以传引用的方式捕获。</li><li><code>[a, b]</code>：表示以传值的方式捕获外部的 <code>a</code> 和 <code>b</code> 变量。</li><li><code>[a, &amp;b]</code>：表示以传值的方式捕获外部的 <code>a</code> 变量，以传引用的方式捕获外部的 <code>b</code> 变量。</li></ul></li><li><code>parameter_list</code>（形参列表）：类似普通函数的参数。</li><li><code>return_type</code>（返回类型）：可省略，通常编译器可自动推导。</li><li><code>function_body</code>（函数体）：Lambda 实现的具体逻辑。</li></ul></li><li><p>Lambda 表达式的适用场景</p><ul><li>STL 算法的回调（如 <code>std::for_each</code>）</li><li>多线程编程（如 <code>std::thread</code>）</li><li>回调函数（如事件处理）</li><li>临时函数对象（避免定义冗长的 <code>struct</code>）</li></ul></li></ul><div class="admonition note"><p class="admonition-title">Lambda 表达式的本质</p><p>C++ Lambda 表达式的本质是匿名的函数对象（Functor），即 没有名字的类的实例。C++ 编译器在编译 Lambda 时，会自动生成一个匿名类，并在其中重载 operator () 函数，从而使其行为类似于函数。值得一提的是，C++ Lambda 不是单纯的 “匿名函数”，而是一个匿名类的实例，即匿名的函数对象。</p></div><h3 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="Lambda-的核心特性"><a href="#Lambda-的核心特性" class="headerlink" title="Lambda 的核心特性"></a>Lambda 的核心特性</h4><ul><li>变量捕获（按值或按引用）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda1 = [x, &amp;y]() -&gt; <span class="keyword">void</span> { y = x + y; }; <span class="comment">// x 按值捕获，y 按引用捕获</span></span><br><span class="line"><span class="built_in">lambda1</span>();</span><br><span class="line">cout &lt;&lt; y;  <span class="comment">// 输出 30</span></span><br></pre></td></tr></tbody></table></figure><ul><li>省略返回类型</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);  <span class="comment">// 输出 8</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>mutable</code> 关键字修改按值捕获的变量</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> modify = [a]() <span class="keyword">mutable</span> -&gt; <span class="keyword">int</span> { a *= <span class="number">2</span>; <span class="keyword">return</span> a; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">modify</span>() &lt;&lt; endl; <span class="comment">// 输出 10</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 原变量 a 仍然是 5</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>function</code> 进行存储</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 输出 5</span></span><br></pre></td></tr></tbody></table></figure><ul><li>作为 STL 算法的回调</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">void</span> { cout &lt;&lt; item * <span class="number">2</span> &lt;&lt; <span class="string">" "</span>; }); <span class="comment">// 输出 2 4 6 8 10</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>若希望在 Lambda 表达式中不指定返回类型，那么可以省略 <code>-&gt; return_type</code>，比如：<code>auto add = [](int a, int b) { return a + b; };</code></p></div><h4 id="Lambda-的基础使用"><a href="#Lambda-的基础使用" class="headerlink" title="Lambda 的基础使用"></a>Lambda 的基础使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印容器</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">void</span> { cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>; });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> { <span class="keyword">return</span> a &gt; b; });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印容器</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">void</span> { cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>; });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个小于 5 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> item) -&gt; <span class="keyword">bool</span> { <span class="keyword">return</span> item &lt; <span class="number">50</span>; });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者简写</span></span><br><span class="line">    <span class="comment">// auto it = find_if(vec.begin(), vec.end(), [](int item) { return item &lt; 50; });</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"找到小于 50 的第一个元素："</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到符合条件的元素"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">91 18 37 28 55 86 50 47 66 52 </span><br><span class="line">91 86 66 55 52 50 47 37 28 18 </span><br><span class="line">找到小于 50 的第一个元素：47</span><br></pre></td></tr></tbody></table></figure><h4 id="Lambda-的应用实践"><a href="#Lambda-的应用实践" class="headerlink" title="Lambda 的应用实践"></a>Lambda 的应用实践</h4><p>这里主要介绍 Lambda 表达式的各种应用实战场景。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : _a(a), _b(b) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用 function 存储 Lambda 表达式</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    map[<span class="number">0</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">    map[<span class="number">1</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a - b; };</span><br><span class="line">    map[<span class="number">2</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a * b; };</span><br><span class="line">    map[<span class="number">3</span>] = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a / b; };</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"30 + 15 = "</span> &lt;&lt; map[<span class="number">0</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"30 - 15 = "</span> &lt;&lt; map[<span class="number">1</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"30 * 15 = "</span> &lt;&lt; map[<span class="number">2</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"30 / 15 = "</span> &lt;&lt; map[<span class="number">3</span>](<span class="number">30</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 智能指针自定义删除器</span></span><br><span class="line">    unique_ptr&lt;FILE, function&lt;<span class="built_in"><span class="keyword">void</span></span>(FILE *)&gt;&gt; <span class="built_in">ptr1</span>(<span class="built_in">fopen</span>(<span class="string">"data.txt"</span>, <span class="string">"w"</span>), [](FILE *p) -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="built_in">fclose</span>(p);</span><br><span class="line">        cout &lt;&lt; <span class="string">"Closed File"</span> &lt;&lt; endl;</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 优先级队列自定义元素排序规则</span></span><br><span class="line">    <span class="keyword">using</span> FUNC = function&lt;<span class="built_in"><span class="keyword">bool</span></span>(Data &amp;, Data &amp;)&gt;;</span><br><span class="line">    priority_queue&lt;Data, vector&lt;Data&gt;, FUNC&gt; <span class="built_in">queue</span>([](Data &amp;data1, Data &amp;data2) {</span><br><span class="line">        <span class="keyword">return</span> data1.<span class="built_in">getA</span>() &lt; data2.<span class="built_in">getA</span>();</span><br><span class="line">    });</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">18</span>, <span class="number">25</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">15</span>, <span class="number">23</span>));</span><br><span class="line">    queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">19</span>, <span class="number">28</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) {</span><br><span class="line">        Data data = queue.<span class="built_in">top</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; data.<span class="built_in">getA</span>() &lt;&lt; <span class="string">", b = "</span> &lt;&lt; data.<span class="built_in">getB</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">30 + 15 = 45</span><br><span class="line">30 - 15 = 15</span><br><span class="line">30 * 15 = 450</span><br><span class="line">30 / 15 = 2</span><br><span class="line">----------------</span><br><span class="line">Closed File</span><br><span class="line">----------------</span><br><span class="line">a = 19, b = 28</span><br><span class="line">a = 18, b = 25</span><br><span class="line">a = 15, b = 23</span><br><span class="line">a = 10, b = 20</span><br><span class="line">----------------</span><br></pre></td></tr></tbody></table></figure><h4 id="Lambda-的底层原理"><a href="#Lambda-的底层原理" class="headerlink" title="Lambda 的底层原理"></a>Lambda 的底层原理</h4><p>C++ Lambda 表达式的本质是匿名的函数对象（Functor），即 没有名字的类的实例。C++ 编译器在编译 Lambda 时，会自动生成一个匿名类，并在其中重载 <code>operator()</code> 函数，从而使其行为类似于函数。值得一提的是，C++ Lambda 不是单纯的 “匿名函数”，而是一个匿名类的实例，即匿名的函数对象。</p><ul><li><p>Lambda 是一个匿名类的实例</p><ul><li>编译器会为 Lambda 生成一个 匿名类，该类重载了 <code>operator()</code> 以实现调用操作。</li><li>这个匿名类的实例（匿名函数对象）即 Lambda 本身。</li></ul></li><li><p>Lambda 具有函数对象的性质</p><ul><li>Lambda 可以像普通函数一样被调用。</li><li>如果 Lambda 捕获了外部变量（如 <code>auto func = [x](int y) -&gt; int { return x + y; };</code>），那么编译器会为该匿名类生成成员变量来存储 <code>x</code>，并在 <code>operator()</code> 函数中使用这些成员变量。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">void</span>&gt;</span><br><span class="line">class MyLambda1 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda1</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T <span class="built_in"><span class="keyword">operator</span></span>()() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> func1 = []() -&gt; <span class="keyword">void</span> { cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl; };</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    MyLambda1&lt;&gt; t1;</span><br><span class="line">    <span class="built_in">t1</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLambda2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda2</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> fun2 = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> { <span class="keyword">return</span> a + b; };</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun2</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    MyLambda2&lt;<span class="keyword">int</span>&gt; t2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">t2</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">void</span>&gt;</span><br><span class="line">class MyLambda3 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : _a(a), _b(b) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in"><span class="keyword">operator</span></span>()() <span class="keyword">const</span> {</span><br><span class="line">        <span class="comment">// 交换两个变量的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = _a;</span><br><span class="line">        _a = _b;</span><br><span class="line">        _b = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值传递，并没有真正交换两个变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> func3 = [a, b]() <span class="keyword">mutable</span> -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">func3</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    <span class="function">MyLambda3&lt;<span class="keyword">int</span>&gt; <span class="title">t3</span><span class="params">(a, b)</span></span>;    <span class="comment">// 按值传递，并没有真正交换两个变量的值</span></span><br><span class="line">    <span class="built_in">t3</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">void</span>&gt;</span><br><span class="line">class MyLambda4 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLambda4</span>(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b) : _a(a), _b(b) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in"><span class="keyword">operator</span></span>()() <span class="keyword">const</span> {</span><br><span class="line">        <span class="comment">// 交换两个变量的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = _a;</span><br><span class="line">        _a = _b;</span><br><span class="line">        _b = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> &amp;_a;</span><br><span class="line">    <span class="keyword">int</span> &amp;_b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按引用传递，可以真正交换两个变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> func4 = [&amp;a, &amp;b]() <span class="keyword">mutable</span> -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">func4</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 Lambda 表达式等价于以下代码</span></span><br><span class="line">    <span class="function">MyLambda4&lt;<span class="keyword">int</span>&gt; <span class="title">t4</span><span class="params">(a, b)</span></span>;    <span class="comment">// 按引用传递，可以真正交换两个变量的值</span></span><br><span class="line">    <span class="built_in">t4</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">----------------</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">----------------</span><br><span class="line">a = 10, b = 30</span><br><span class="line">a = 10, b = 30</span><br><span class="line">----------------</span><br><span class="line">a = 30, b = 10</span><br><span class="line">a = 10, b = 30</span><br><span class="line">----------------</span><br></pre></td></tr></tbody></table></figure><blockquote><p>验证 Lambda 表达式是函数对象</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> lambda = [](<span class="keyword">int</span> x) { <span class="keyword">return</span> x * <span class="number">2</span>; };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 是一个匿名类的实例</span></span><br><span class="line">    cout &lt;&lt; std::boolalpha;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Lambda 是对象吗？ "</span> &lt;&lt; boolalpha &lt;&lt; is_object&lt;<span class="keyword">decltype</span>(lambda)&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 具有 operator() 函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Lambda(5) = "</span> &lt;&lt; <span class="built_in">lambda</span>(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lambda 是对象吗？ true</span><br><span class="line">Lambda(5) = 10</span><br></pre></td></tr></tbody></table></figure><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/bd9d2710.html" title="C++ 巩固进阶之三">https://www.techgrow.cn/posts/bd9d2710.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/2288a106.html" rel="prev" title="C++ 巩固进阶之二"><i class="fa fa-angle-left"></i> C++ 巩固进阶之二</a></div><div class="post-nav-item"> <a href="/posts/9fc5e76e.html" rel="next" title="UFW 导致 Docker 容器无法使用 IP 访问宿主机">UFW 导致 Docker 容器无法使用 IP 访问宿主机<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">30:54</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/bd9d2710.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>