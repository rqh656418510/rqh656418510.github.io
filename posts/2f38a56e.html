<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要记录 C++ 的高频面试题。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 高频面试题之一"><meta property="og:url" content="https://www.techgrow.cn/posts/2f38a56e.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要记录 C++ 的高频面试题。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/cxx-interview-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/12/gcc-step-view.png"><meta property="article:published_time" content="2020-07-19T14:32:18.000Z"><meta property="article:modified_time" content="2020-07-19T14:32:18.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/04/cxx-interview-1.png"><link rel="canonical" href="https://www.techgrow.cn/posts/2f38a56e.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/2f38a56e.html","path":"posts/2f38a56e.html","title":"C++ 高频面试题之一"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 高频面试题之一 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">基础面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E5%92%8C-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C 语言和 C++ 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">C++ 中多态的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">C++ 中多态的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">C++ 中继承的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-this-%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">C++ 中 this 指针的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中重载与重写的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-static-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">C++ 中 static 关键字的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-STL-%E4%B8%AD%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">C++ STL 中空间配置器的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-STL-%E4%B8%AD-vector-%E5%92%8C-list-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ STL 中 vector 和 list 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-STL-%E4%B8%AD-map-%E5%92%8C-multimap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ STL 中 map 和 multimap 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%9C%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="nav-text">C++ 在父类的构造函数中调用虚函数，可否实现多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84-new-%E5%92%8C-delete%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-new-%E7%94%B3%E8%AF%B7%EF%BC%8C%E9%9C%80%E8%A6%81%E7%94%A8-delete-%E9%87%8A%E6%94%BE%EF%BC%9F"><span class="nav-text">C++ 的 new 和 delete，什么时候用 new [] 申请，需要用 delete [] 释放？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">C++ 中如何防止内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0"><span class="nav-text">C++ 中如何调用 C 语言函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%AE%BF%E9%97%AE%E8%B6%8A%E7%95%8C"><span class="nav-text">C++ 什么时候会出现访问越界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%AE%BF%E9%97%AE%E8%B6%8A%E7%95%8C"><span class="nav-text">C++ 中如何避免访问越界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">C++ 中类的初始化列表的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-int-const-p-%E5%92%8C-const-int-p-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中 int * const p 和 const int * p 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-malloc-%E5%92%8C-new-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中 malloc 和 new 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-free-%E5%92%8C-delete-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C+ 中 free 和 delete 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-map-%E5%92%8C-set-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">C++ 中 map 和 set 的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-shared-ptr-%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-text">C++ 中 shared_ptr 的引用计数存储在哪里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-STL-%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">C++ 中 STL 容器都有哪些，底层结构是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-STL-%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">C++ STL 中迭代器失效的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-STL-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%AE%B9%E5%99%A8%E6%98%AF%E5%9F%BA%E4%BA%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0"><span class="nav-text">C++ STL 中哪些容器是基于红黑树实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD-struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中 struct 和 class 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-STL-%E4%B8%AD-vector-%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ STL 中 vector 和数组的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">C++ 中编译链接的全过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中初始化全局变量和未初始化全局变量的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中栈和堆的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%AE%8F%E5%92%8C%E5%86%85%E8%81%94%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">C++ 中宏和内联的区别</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">701</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/2f38a56e.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 高频面试题之一 | Clay 的技术空间"><meta itemprop="description" content="本文主要记录 C++ 的高频面试题。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 高频面试题之一</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-07-19 22:32:18" itemprop="dateCreated datePublished" datetime="2020-07-19T22:32:18+08:00">2020-07-19</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/2f38a56e.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/2f38a56e.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>11k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>10 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/2f38a56e.html">C++ 高频面试题之一</a></li><li><a href="/posts/feb80593.html">C++ 高频面试题之二</a></li></ul><h2 id="基础面试题"><a href="#基础面试题" class="headerlink" title="基础面试题"></a>基础面试题</h2><h3 id="C-语言和-C-的区别"><a href="#C-语言和-C-的区别" class="headerlink" title="C 语言和 C++ 的区别"></a>C 语言和 C++ 的区别</h3><p>C 是面向过程语言，注重函数和流程控制，而 C++ 是面向对象语言，是 C 的超集，支持类、继承、多态等特性。C++ 提供了丰富的标准库和更高层的抽象，比如 STL、模板、异常处理等。同时在语法上，C++ 支持命名空间、函数重载、引用、对象构造等，适合开发大型复杂系统，而 C 更适合底层和嵌入式开发。</p><table><thead><tr><th>分类</th><th> C 语言</th><th> C++</th></tr></thead><tbody><tr><td> 编程范式</td><td>过程式编程</td><td>支持过程式 + 面向对象 + 泛型</td></tr><tr><td>语言类型</td><td>中级语言</td><td>高级语言（兼容 C）</td></tr><tr><td>封装性</td><td>不支持类和对象</td><td>支持类、对象、继承、多态</td></tr><tr><td>函数重载</td><td>不支持</td><td>支持</td></tr><tr><td>命名空间</td><td>不支持</td><td>支持</td></tr><tr><td>异常处理</td><td>不支持</td><td>支持 <code>try-catch-throw</code></td></tr><tr><td>标准库</td><td>比较基础（如 <code>stdio.h</code>）</td><td>丰富的 STL（如 <code>vector</code>、<code>map</code>）</td></tr><tr><td>输入输出</td><td><code>printf</code>、<code>scanf</code></td><td><code>cin</code>、<code>cout</code>（可使用 <code>iostream</code>）</td></tr><tr><td>内存管理</td><td><code>malloc</code>、<code>free</code></td><td><code>new</code>、<code>delete</code>、<code>智能指针（现代 C++）</code></td></tr><tr><td>编译方式</td><td> C 编译器（如 <code>gcc</code>）</td><td>C++ 编译器（如 <code>g++</code>），也支持 C 编译</td></tr><tr><td>应用方向</td><td>嵌入式、底层系统</td><td>应用软件、大型系统</td></tr></tbody></table><span id="more"></span><h3 id="C-中多态的理解"><a href="#C-中多态的理解" class="headerlink" title="C++ 中多态的理解"></a>C++ 中多态的理解</h3><ul><li>多态的实现效果<ul><li>多态是在运行期间根据具体对象的类型决定函数调用，同样的调用语句有多种不同的表现形态</li></ul></li><li>多态实现的三个必要条件<ul><li>有继承、有虚函数（<code>virtual</code> ）的重写、有父类的指针（引用）指向子类对象</li></ul></li><li>多态的 C++ 实现<ul><li>使用 <code>virtual</code> 关键字，告诉编译器这个函数要支持多态；不是根据指针类型判断如何调用，而是要根据指针所指向的实际对象类型来判断如何调用</li></ul></li><li>多态的理论基础<ul><li>动态联编 Vs 静态联编，根据实际的对象类型来判断重写函数的调用</li></ul></li><li>多态的重要意义<ul><li>多态是设计模式的基础，是框架的基石</li></ul></li><li>实现多态的理论基础<ul><li>函数指针做函数参数</li><li>函数指针一般有两种用法（正、反）</li></ul></li><li>多态原理的探究<ul><li>与面试官展开讨论</li></ul></li></ul><h3 id="C-中多态的实现"><a href="#C-中多态的实现" class="headerlink" title="C++ 中多态的实现"></a>C++ 中多态的实现</h3><p>C++ 中的多态分为两类：</p><ul><li><strong>静态多态</strong>（编译期多态）：在编译阶段确定调用关系，典型代表是函数重载和模板。</li><li><strong>动态多态</strong>（运行期多态）：通过虚函数机制实现，当基类的指针或者引用指向派生类对象时，调用的是派生类中重写的函数。函数调用关系在运行时根据实际对象类型动态决定，从而实现接口统一、行为多样。</li></ul><h3 id="C-中继承的作用"><a href="#C-中继承的作用" class="headerlink" title="C++ 中继承的作用"></a>C++ 中继承的作用</h3><p>C++ 继承的主要作用有两个：</p><ul><li><p><strong>代码复用</strong>：</p><ul><li>在 C++ 中，继承是一种基本特性，它允许派生类继承基类的成员变量和成员函数。</li><li>通过这种方式，派生类可以直接使用基类已经实现的功能，这不仅实现了代码复用，还提高了开发效率。</li></ul></li><li><p><strong>实现多态</strong>：</p><ul><li>通过在基类中定义虚函数（特别是纯虚函数），子类重写后可实现运行时多态，使得基类的指针或者引用可以指向派生类的对象。</li><li>这样就可以在运行时根据对象的实际类型来调用对应的方法，使得程序更加灵活，能够应对不同的派生类对象，而无需在编译时确定具体的类型。</li></ul></li></ul><h3 id="C-中-this-指针的作用"><a href="#C-中-this-指针的作用" class="headerlink" title="C++ 中 this 指针的作用"></a>C++ 中 this 指针的作用</h3><p>在 C++ 中，一个类可以创建多个对象，每个对象都有自己的一份成员变量，但它们共享同一套成员函数。为了让成员函数知道是哪个对象在调用它，编译器会隐式地将当前对象的地址（即 <code>this</code> 指针）传入成员函数。比如 <code>t.test()</code> 实际上等价于 <code>test(&amp;t)</code>，<code>this</code> 就是指向 <code>t</code> 的指针。</p><ul><li><p>简而言之，<code>this</code> 指针是每个非静态成员函数的隐含参数，指向当前调用该成员函数的对象，主要作用包括：</p><ul><li><strong>访问当前对象的成员</strong>：在成员函数中，<code>this</code> 指针用于访问调用该函数的对象。</li><li><strong>区分成员变量和同名参数</strong>：当函数参数与成员变量同名时，使用 <code>this-&gt;</code> 明确指代成员变量。</li><li><strong>支持链式调用</strong>：通过在成员函数中返回 <code>*this</code> 的引用，实现方法链式调用。</li><li><strong>防止自赋值</strong>：在重载赋值运算符时，使用 <code>this</code> 指针检查自赋值情况。</li></ul></li><li><p>特别注意，静态成员函数没有 <code>this</code> 指针，因为它们不属于任何对象实例。</p></li></ul><h3 id="C-中重载与重写的区别"><a href="#C-中重载与重写的区别" class="headerlink" title="C++ 中重载与重写的区别"></a>C++ 中重载与重写的区别</h3><ul><li><p>函数重载</p><ul><li>必须在同一个类中进行</li><li>子类无法重载父类的函数，父类同名函数将被子类的覆盖（隐藏）</li><li>重载是在编译期间根据参数类型、参数个数和参数顺序决定函数的调用</li></ul></li><li><p>函数重写</p><ul><li>必须发生于父类与子类之间</li><li>父类与子类中的函数必须有完全相同的原型</li><li>使用 <code>virtual</code> 关键字声明之后，能够产生多态（如果不使用 <code>virtual</code> 关键字声明，那叫重定义）</li></ul></li></ul><h3 id="C-中-static-关键字的作用"><a href="#C-中-static-关键字的作用" class="headerlink" title="C++ 中 static 关键字的作用"></a>C++ 中 static 关键字的作用</h3><p>这道面试题可以从面向对象、ELF 结构、链接过程角度来回答。</p><ul><li><p>从面向对象角度看：</p><ul><li><code>static</code> 可以修饰类的成员变量和成员函数，使其属于类本身而非类的实例。</li><li><code>static</code> 成员变量在所有对象间共享一份，不随对象创建而复制。</li><li><code>static</code> 成员函数没有 <code>this</code> 指针，因此不能访问非 <code>static</code> 成员，只能访问类的静态成员。</li></ul></li><li><p>从编译链接过程看：</p><ul><li><code>static</code> 可以修饰全局变量和函数，使它们的符号绑定从全局（GLOBAL）变为局部（LOCAL），且只能在定义它们的 <code>.cpp</code> 文件内部被访问，起到封装作用。</li><li><code>static</code> 修饰的局部变量拥有静态存储周期，分配在 <code>.data</code> 或 <code>.bss</code> 段中，作用域仍限定在函数内，但生命周期贯穿整个程序运行期。由于它们不再分配在栈上，而是保存在数据段中，访问方式也由栈帧偏移改为固定地址或段偏移。</li></ul></li></ul><h3 id="C-STL-中空间配置器的作用"><a href="#C-STL-中空间配置器的作用" class="headerlink" title="C++ STL 中空间配置器的作用"></a>C++ STL 中空间配置器的作用</h3><p>空间配置器（Allocator）是给容器使用的，它的作用是将内存分配与对象构造分离，以及将对象析构与内存释放分离。</p><ul><li><strong>内存分配与对象构造分离</strong>：构造对象时，先调用 <code>allocate()</code> 分配原始的未初始化内存，然后调用 <code>construct()</code> 在这块内存上构造对象。</li><li><strong>对象析构与内存释放分离</strong>：销毁对象时，先调用 <code>destroy()</code> 进行对象析构，再用 <code>deallocate()</code> 释放原始内存。</li></ul><h3 id="C-STL-中-vector-和-list-的区别"><a href="#C-STL-中-vector-和-list-的区别" class="headerlink" title="C++ STL 中 vector 和 list 的区别"></a>C++ STL 中 vector 和 list 的区别</h3><ul><li><code>vector</code> 的底层是动态数组，容量不足时会自动扩容（通常近似两倍扩容），支持高效随机访问，适合访问频繁、尾部插入多的场景。</li><li><code>list</code> 的底层是双向链表，不支持随机访问，但任意位置插入和删除效率高，适合频繁修改结构的场景。</li></ul><h3 id="C-STL-中-map-和-multimap-的区别"><a href="#C-STL-中-map-和-multimap-的区别" class="headerlink" title="C++ STL 中 map 和 multimap 的区别"></a>C++ STL 中 map 和 multimap 的区别</h3><p>在 C++ 中，<code>map</code> 和 <code>multimap</code> 的主要区别：</p><ul><li>相同点：<ul><li>两者都是基于红黑树实现的有序关联容器，底层自动会对 key 进行排序。</li></ul></li><li>不同点：<ul><li><code>map</code> 不允许 key 重复，一个 key 对应唯一的映射表，插入相同 key 会失败。</li><li><code>multimap</code> 允许 key 重复，适用于一对多的映射关系。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">红黑树的介绍</p><p>红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（BST），它在插入或删除节点后通过颜色标记和旋转操作，保持树的平衡，从而保证查询、插入和删除的时间复杂度始终是 <code>O(log n)</code>。红黑树满足 5 个特性，可以避免树退化成链表；插入时最多旋转 2 次，删除时最多旋转 3 次，保证了 <code>map</code>、<code>multimap</code> 等容器在最坏情况下也能稳定地执行查找、插入和删除操作，时间复杂度始终为 <code>O(log n)</code>。</p></div><h3 id="C-在父类的构造函数中调用虚函数，可否实现多态"><a href="#C-在父类的构造函数中调用虚函数，可否实现多态" class="headerlink" title="C++ 在父类的构造函数中调用虚函数，可否实现多态"></a>C++ 在父类的构造函数中调用虚函数，可否实现多态</h3><p>子类的虚函数表指针（<code>VPTR</code>）是分步完成初始化的，当执行父类的构造函数时，子类 的 <code>VPTR</code> 指针指向父类的虚函数表，当父类的构造函数执行完毕后，会把子类的 <code>VPTR</code> 指针指向子类的虚函数表。因此，在父类的构造函数中调用虚函数，不能实现多态。</p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>对象在创建的时，由编译器对 <code>VPTR</code> 指针进行初始化。</li><li>只有当对象的构造全部完成后，<code>VPTR</code> 指针的指向才能最终确定。</li></ul></div><h3 id="C-的-new-和-delete，什么时候用-new-申请，需要用-delete-释放？"><a href="#C-的-new-和-delete，什么时候用-new-申请，需要用-delete-释放？" class="headerlink" title="C++ 的 new 和 delete，什么时候用 new[] 申请，需要用 delete[] 释放？"></a>C++ 的 new 和 delete，什么时候用 new [] 申请，需要用 delete [] 释放？</h3><p>在 C++ 中，<code>new</code> 和 <code>delete</code> 是成对使用的内存管理操作符：</p><ul><li><code>new</code> 对应 <code>delete</code>，<code>new[]</code> 对应 <code>delete[]</code>，必须严格匹配，否则可能导致未定义行为或内存泄漏。</li><li><code>new</code> 会调用构造函数分配对象，<code>delete</code> 会调用析构函数并释放内存。</li><li>如果是自定义类型并提供了构造函数，用 <code>new</code> 创建时一定要用 <code>delete</code> 来释放。</li><li>如果是数组申请（例如多个对象，尤其是自定义类型），必须使用 <code>new[]</code> 创建，并使用 <code>delete[]</code> 释放，这样才会调用每个数组元素的析构函数。</li></ul><h3 id="C-中如何防止内存泄漏"><a href="#C-中如何防止内存泄漏" class="headerlink" title="C++ 中如何防止内存泄漏"></a>C++ 中如何防止内存泄漏</h3><ul><li><p>遵循 RAII（资源获取即初始化）原则</p><ul><li>RAII 是 C++ 中管理资源的核心理念。​通过将资源的分配与对象的生命周期绑定，确保在对象销毁时自动释放资源，避免内存泄漏。</li><li>​例如，使用 <code>std::lock_guard</code> 管理互斥锁，或使用 <code>std::ofstream</code> 管理文件句柄。​</li></ul></li><li><p>避免裸指针和手动内存管理</p><ul><li>尽量避免直接使用 <code>new</code> 和 <code>delete</code>，因为手动管理内存容易导致泄漏。​</li><li>如果必须使用裸指针，确保每次分配的内存都有对应的释放操作。</li></ul></li><li><p>使用智能指针自动管理动态分配的内存</p><ul><li><code>std::unique_ptr</code> 实现独占所有权，适用于一个对象只有一个所有者的情况。​</li><li><code>std::shared_ptr</code> 实现共享所有权，适用于多个对象共享资源的情况。</li><li>在使用 <code>std::shared_ptr</code> 时，循环引用会导致内存无法释放；可以使用 <code>std::weak_ptr</code> 打破循环引用，确保资源正确释放。</li></ul></li><li><p>利用工具检测内存泄漏和未定义行为</p><ul><li>Valgrind：运行时内存调试工具，检测内存泄漏、越界访问等问题。​</li><li>AddressSanitizer（ASan）：编译器支持的内存错误检测工具，可以检测越界访问、使用后释放等问题。</li></ul></li><li><p>使用静态分析工具在编译前分析代码</p><ul><li>Cppcheck：静态代码分析工具，检查内存泄漏、未初始化变量等问题。</li></ul></li></ul><h3 id="C-中如何调用-C-语言函数"><a href="#C-中如何调用-C-语言函数" class="headerlink" title="C++ 中如何调用 C 语言函数"></a>C++ 中如何调用 C 语言函数</h3><p> C++ 调用在 C 语言中定义的函数时，默认会编译失败，这是因为 C++ 与 C 语言生成函数符号的规则是不同的，从而导致 C++ 在编译时找不到在 C 语言中定义的函数。解决方法是，在 C++ 代码中，使用 <code>extern "C" { }</code> 来包裹函数的声明。反之，如果是 C 语言需要调用在 C++ 中定义的函数，那么在 C++ 的代码中，也需要使用 <code>extern "C" { }</code> 包裹函数的定义。</p><ul><li>C 语言的源代码</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>C++ 的源代码</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记大括号里的函数符号是按照 C 语言的规则来生成</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line">    <span class="comment">// 函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在多语言的项目开发中，往往会看到下面这样的 C++ 代码，其中的 <code>__cplusplus</code> 是 C++ 编译器内置的宏名。这样写的好处是，无论是在 C++ 还是 C 语言的代码中调用 <code>sum()</code> 函数，编译器都可以正常编译。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="C-什么时候会出现访问越界"><a href="#C-什么时候会出现访问越界" class="headerlink" title="C++ 什么时候会出现访问越界"></a>C++ 什么时候会出现访问越界</h3><ul><li>数组访问越界</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="keyword">int</span> x = arr[<span class="number">5</span>];  <span class="comment">// 越界访问，合法索引是 0~4</span></span><br></pre></td></tr></tbody></table></figure><ul><li>指针操作不当</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>};</span><br><span class="line"><span class="keyword">int</span>* p = arr + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> x = *p;  <span class="comment">// 越界访问，指针 p 指向的是 arr [3]，这超出了数组边界</span></span><br></pre></td></tr></tbody></table></figure><ul><li>字符串访问越界</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> c = str[<span class="number">5</span>];  <span class="comment">// 合法索引是 0~4，而 str[5] 不会检查边界，可能读取垃圾值；推荐使用 str.at(5)，如果访问越界则会抛出异常</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>vector</code> 访问越界</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="keyword">int</span> x = vec[<span class="number">5</span>];  <span class="comment">// operator[] 访问越界，不会抛异常（程序可能崩溃）；推荐使用 vec.at(5)，如果访问越界则会抛出 std::out_of_range 异常</span></span><br></pre></td></tr></tbody></table></figure><ul><li>指针删除后访问（悬空指针）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">*p = <span class="number">100</span>;  <span class="comment">// 已释放内存，访问越界</span></span><br></pre></td></tr></tbody></table></figure><h3 id="C-中如何避免访问越界"><a href="#C-中如何避免访问越界" class="headerlink" title="C++ 中如何避免访问越界"></a>C++ 中如何避免访问越界</h3><ul><li>使用 STL 容器代替原始数组（如 <code>vector</code>、<code>string</code>）</li><li>使用 <code>at()</code> 函数进行安全访问</li><li>写循环时注意索引范围</li><li>尽量避免裸指针，使用智能指针</li><li>开启编译器警告（如 <code>-Wall -Wextra</code>）</li><li>使用工具检查，如 Valgrind（运行时内存调试工具）、ASan（内存错误检测工具）</li></ul><h3 id="C-中类的初始化列表的作用"><a href="#C-中类的初始化列表的作用" class="headerlink" title="C++ 中类的初始化列表的作用"></a>C++ 中类的初始化列表的作用</h3><p>在 C++ 中，类的初始化列表用于在构造函数体执行前初始化成员变量。它可以提高效率，避免成员先默认构造再赋值，尤其对于 <code>const</code> 成员、引用成员以及没有默认构造函数的成员对象，必须使用初始化列表。初始化列表的执行顺序与成员变量的声明顺序一致，而不是在初始化列表中写的顺序。</p><hr><ul><li><p>初始化列表的概念</p><ul><li>初始化列表（Initializer List）是类的构造函数的一种语法，用于在构造函数体执行前直接初始化成员变量，写在构造函数冒号 <code>:</code> 的后面。</li></ul></li><li><p>初始化列表的作用</p><ul><li>提高效率<ul><li>初始化列表直接调用成员变量的构造函数，比在构造函数体中赋值更高效。</li><li>特别是对于 <code>const</code> 成员、引用成员、对象成员，只能用初始化列表初始化。</li></ul></li><li>避免多次构造<ul><li>如果在构造函数体中使用赋值，成员对象会先被默认构造，再赋值，多了一步。</li></ul></li><li>必须使用初始化列表的情况：<ul><li>引用成员</li><li> const 成员</li><li>没有默认构造函数的成员对象</li></ul></li></ul></li><li><p>初始化列表的陷阱</p><ul><li>初始化列表的执行顺序与成员变量的声明顺序一致，不是在初始化列表中写的顺序。</li><li>如果顺序不一致，编译器可能会给出警告。</li><li>初始化顺序错误在某些情况下可能引发未定义行为。</li></ul></li></ul><h3 id="C-中-int-const-p-和-const-int-p-的区别"><a href="#C-中-int-const-p-和-const-int-p-的区别" class="headerlink" title="C++ 中 int * const p 和 const int * p 的区别"></a>C++ 中 int * const p 和 const int * p 的区别</h3><ul><li><code>int * const p</code> 是常量指针，指针地址不能改，指向的数据可以改。</li><li><code>const int * p</code> 是指向常量的指针，指向的数据不能改，但指针地址可以改。</li></ul><table><thead><tr><th>声明方式</th><th>中文名称</th><th>指针是否可变</th><th>值是否可变</th><th>使用说明</th></tr></thead><tbody><tr><td><code>int * const p</code></td><td>常量指针</td><td>❌ 不可变</td><td>✅ 可变</td><td>指针 p 不能指向别的地址，但可以改地址里的值</td></tr><tr><td><code>const int * p</code></td><td>指向常量的指针</td><td>✅ 可变</td><td>❌ 不可变</td><td>指针 p 可以指向别的地址，但不能改所指向的数据</td></tr><tr><td><code>const int * const p</code></td><td>指向常量的常量指针</td><td>❌ 不可变</td><td>❌ 不可变</td><td>什么都不能改，彻底只读</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">指针修饰顺序的口诀</p><ul><li>口诀一：左定值，右定向。</li><li>口诀二：<code>const</code> 靠近谁，谁就不能变。</li><li><code>const int * p</code> —— <code>int</code> 是 <code>const</code>，不能改值。</li><li><code>int * const p</code> —— <code>p</code> 是 <code>const</code>，不能改指针。</li></ul></div><h3 id="C-中-malloc-和-new-的区别"><a href="#C-中-malloc-和-new-的区别" class="headerlink" title="C++ 中 malloc 和 new 的区别"></a>C++ 中 malloc 和 new 的区别</h3><ul><li><p><code>new</code></p><ul><li>C++ 中的运算符（<code>operator new</code>），用于按类型动态分配内存。</li><li>底层同样是调用 <code>malloc()</code> 函数开辟内存，但还会调用类对象的构造函数（如果是类对象）进行初始化。</li><li>返回值是对应类型的指针，不需要强制类型转换。</li><li>开辟内存失败时，会抛出 <code>std::bad_alloc</code> 异常。</li></ul></li><li><p><code>malloc</code></p><ul><li>C 语言中的标准库函数，用于按字节动态分配内存。</li><li>不会初始化分配的内存，也不会调用类对象的构造函数（如果分配的内存是用于类对象）。</li><li>返回值是 <code>void *</code>，需要强制类型转换。</li><li>开辟内存失败时，返回 <code>nullptr</code>（或 C 中返回 <code>NULL</code>），需要手动检查。</li></ul></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>所属语言</td><td> C / C++</td><td>C++ 专用</td></tr><tr><td>本质</td><td>库函数（在 <code>&lt;cstdlib&gt;</code> 中）</td><td>运算符（可重载）</td></tr><tr><td>内存分配方式</td><td>按字节动态分配内存</td><td>按类型动态分配内存</td></tr><tr><td>返回值</td><td>返回 <code>void *</code>，需强制类型转换</td><td>返回对应类型的指针，无需类型转换</td></tr><tr><td>是否调用构造函数</td><td>❌ 不会调用构造函数</td><td>✅ 会调用构造函数</td></tr><tr><td>是否调用析构函数</td><td>❌ <code>free</code> 不会调用析构函数</td><td>✅ <code>delete</code> 调用析构函数</td></tr><tr><td>失败时的行为</td><td>返回 <code>nullptr</code>（或 C 中返回 <code>NULL</code>），需手动检查</td><td>抛出 <code>std::bad_alloc</code> 异常</td></tr><tr><td>是否可重载</td><td>❌ 不可重载</td><td>✅ 可重载 <code>operator new</code>、<code>operator delete</code></td></tr><tr><td>对象初始化</td><td>❌ 不支持</td><td>✅ 自动调用构造函数来初始化对象</td></tr><tr><td>释放方式</td><td>使用 <code>free(ptr)</code> 释放内存</td><td>使用 <code>delete ptr</code> 或 <code>delete[] ptr</code> 释放内存</td></tr></tbody></table><h3 id="C-中-free-和-delete-的区别"><a href="#C-中-free-和-delete-的区别" class="headerlink" title="C+ 中 free 和 delete 的区别"></a>C+ 中 free 和 delete 的区别</h3><ul><li><p><code>delete</code> 的概述</p><ul><li><code>delete</code> 操作符用于释放通过 <code>new</code> 分配的内存。</li><li>在释放内存之前，<code>delete</code> 会先调用类对象的析构函数，以确保资源（如文件句柄、网络连接等）正确释放。</li><li>如果分配的是数组，必须使用 <code>delete[]</code>，否则可能会导致未定义行为。</li></ul></li><li><p><code>free</code> 的概述</p><ul><li><code>free</code> 是 C 标准库函数，用于释放通过 <code>malloc/calloc/realloc</code> 分配的内存。</li><li>它只会释放内存，不会执行任何其他操作，例如对象的析构。</li></ul></li><li><p><code>delete</code> 与 <code>free</code> 不能混用</p><ul><li>通过 <code>new</code> 分配的内存必须用 <code>delete</code> 释放，不能用 <code>free</code>，否则可能会导致未定义行为。</li><li>通过 <code>malloc</code> 分配的内存必须用 <code>free</code> 释放，不能用 <code>delete</code>，否则可能会导致未定义行为。</li></ul></li><li><p><code>delete</code> 与 <code>free</code> 的内存布局和管理差异</p><ul><li><code>new</code> 和 <code>delete</code> 是 C++ 的操作符，它们了解对象的类型，并能为复杂类型的构造和析构做出正确的处理。</li><li><code>malloc</code> 和 <code>free</code> 是 C 的函数，它们只分配和释放内存，不了解对象的类型。</li></ul></li></ul><table><thead><tr><th>特性</th><th><code>delete</code></th><th><code>free</code></th></tr></thead><tbody><tr><td>适用语言</td><td> C++ 专用</td><td> C 和 C++</td></tr><tr><td> 适用对象</td><td>动态分配的对象（通过 <code>new</code> 分配）</td><td>动态分配的内存块（通过 <code>malloc/calloc/realloc</code> 分配）</td></tr><tr><td>是否调用析构函数</td><td>会调用类对象的析构函数</td><td>只释放内存，不调用类对象的析构函数</td></tr><tr><td>分配与释放的匹配要求</td><td>必须和 <code>new</code> 成对使用</td><td>必须和 <code>malloc/calloc/realloc</code> 成对使用</td></tr><tr><td>数组释放</td><td>使用 <code>delete[]</code> 释放动态数组</td><td>没有专门的数组释放功能</td></tr><tr><td>底层机制</td><td> C++ 的运行时库负责，处理更高级的资源管理</td><td> C 的运行时库负责，直接释放内存</td></tr></tbody></table><h3 id="C-中-map-和-set-的实现原理"><a href="#C-中-map-和-set-的实现原理" class="headerlink" title="C++ 中 map 和 set 的实现原理"></a>C++ 中 map 和 set 的实现原理</h3><ul><li><code>map</code> 和 <code>set</code> 是 C++ STL（标准模板库）中的关联式容器，它们的底层都是采用红黑树（Red-Black Tree）实现。</li><li><code>set</code> 只存储 key，而 <code>map</code> 存储的是 key-value 键值对。元素在容器中都是自动按 key 排序的，默认使用 <code>&lt;</code> 运算符，也可以自定义比较函数。</li><li>如果追求更高性能或无序需求，也可以考虑使用 <code>unordered_map</code> / <code>unordered_set</code>，它们的底层是基于哈希表实现，平均复杂度为 <code>O(1)</code>。</li></ul><table><thead><tr><th>容器</th><th>存储内容</th><th>底层结构</th><th>是否有序</th><th>是否允许重复</th></tr></thead><tbody><tr><td><code>set</code></td><td>只存储 key</td><td> 红黑树</td><td>✅ 按 key 排序</td><td>❌ 不允许重复（可以改用 <code>multiset</code>）</td></tr><tr><td><code>map</code></td><td>存储 <code>[key, value]</code></td><td>红黑树</td><td>✅ 按 key 排序</td><td>❌ key 不可重复（可以改用 <code>multimap</code>）</td></tr></tbody></table><h3 id="C-中-shared-ptr-的引用计数存储在哪里"><a href="#C-中-shared-ptr-的引用计数存储在哪里" class="headerlink" title="C++ 中 shared_ptr 的引用计数存储在哪里"></a>C++ 中 shared_ptr 的引用计数存储在哪里</h3><p><code>shared_ptr</code> 的引用计数是和对象是分开存储在堆上的。引用计数并不是存在被管理对象中，而是存储在由 <code>shared_ptr</code> 内部管理的一个独立控制块（Control Block）中。这种设计可以支持多个指针共享对象的同时，又能独立于对象本体跟踪引用和生命周期。</p><ul><li><p>控制块中存储的内容包括：</p><ul><li>指向真实对象的指针。</li><li><code>use_count</code>：共享引用计数，用于追踪有多少个 <code>shared_ptr</code> 指向这块内存。</li><li><code>weak_count</code>：弱引用计数，用于追踪有多少个 <code>weak_ptr</code> 还在引用。</li><li>可能还有删除器（<code>deleter</code>），比如自定义内存释放策略。</li></ul></li><li><p>控制块在什么时候释放</p><ul><li>当 <code>use_count</code> 变为 0 时，对象占用的内存会被释放，但控制块还保留（供 <code>weak_ptr</code> 判断是否过期）。</li><li>当 <code>use_count = 0</code> 且 <code>weak_count = 0</code> 时，控制块才会被销毁。</li></ul></li></ul><p><img data-src="../../../asset/2025/04/cxx-interview-1.png"></p><h3 id="C-中-STL-容器都有哪些，底层结构是什么"><a href="#C-中-STL-容器都有哪些，底层结构是什么" class="headerlink" title="C++ 中 STL 容器都有哪些，底层结构是什么"></a>C++ 中 STL 容器都有哪些，底层结构是什么</h3><ul><li><strong>顺序容器</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构</th></tr></thead><tbody><tr><td><code>vector</code></td><td>动态数组容器，支持快速随机访问，尾部插入删除效率高</td><td>连续线性数组</td></tr><tr><td><code>deque</code></td><td>双端队列容器，支持头尾快速插入删除</td><td>支持动态扩展的二维数组结构（分段连续空间）</td></tr><tr><td><code>list</code></td><td>双向链表容器，插入 / 删除效率高，不支持随机访问</td><td>双向链表</td></tr></tbody></table><ul><li><strong>有序关联容器（底层为红黑树）</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构</th></tr></thead><tbody><tr><td><code>set</code></td><td>不可重复集合，自动按 key 排序</td><td>红黑树</td></tr><tr><td><code>map</code></td><td>键值对映射表，key 唯一，自动按 key 排序</td><td>红黑树</td></tr><tr><td><code>multiset</code></td><td>可重复元素集合，自动按 key 排序</td><td>红黑树</td></tr><tr><td><code>multimap</code></td><td>可重复键的映射表，自动按 key 排序</td><td>红黑树</td></tr></tbody></table><ul><li><strong>无序关联容器（底层为哈希表）</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构</th></tr></thead><tbody><tr><td><code>unordered_set</code></td><td>无序集合，key 唯一，查找效率高</td><td>哈希表（开链法）</td></tr><tr><td><code>unordered_map</code></td><td>无序映射表，key 唯一，存储 <code>&lt;key, value&gt;</code> 键值对</td><td>哈希表（开链法）</td></tr><tr><td><code>unordered_multiset</code></td><td>无序集合，元素可重复</td><td>哈希表（开链法）</td></tr><tr><td><code>unordered_multimap</code></td><td>无序映射表，key 可重复</td><td>哈希表（开链法）</td></tr></tbody></table><ul><li><strong>容器适配器</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构（默认）</th></tr></thead><tbody><tr><td><code>stack</code></td><td>后进先出（LIFO）栈结构</td><td><code>deque</code></td></tr><tr><td><code>queue</code></td><td>先进先出（FIFO）队列</td><td><code>deque</code></td></tr><tr><td><code>priority_queue</code></td><td>优先队列，自动排序</td><td>堆（默认最大堆，用 <code>vector</code> + <code>make_heap</code> 实现）</td></tr></tbody></table><ul><li><strong>近容器</strong></li></ul><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构</th></tr></thead><tbody><tr><td><code>array</code></td><td>固定大小的数组容器，编译期确定大小</td><td>静态数组（连续内存）</td></tr><tr><td><code>string</code></td><td>字符串容器，支持动态扩展与字符串操作</td><td>动态字符数组</td></tr><tr><td><code>bitset</code></td><td>定长位集容器，适合二进制标志管理</td><td>位数组（每个位单独存储）</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><p>STL 中的哈希表采用开链法（Separate Chaining）解决哈希冲突，桶结构的底层可能是链表或更优化的数据结构（如 C++ 17 后可用链表 + 跳表等）。</p></div><h3 id="C-STL-中迭代器失效的问题"><a href="#C-STL-中迭代器失效的问题" class="headerlink" title="C++ STL 中迭代器失效的问题"></a>C++ STL 中迭代器失效的问题</h3><blockquote><p>迭代器失效的定义</p></blockquote><p>当对容器执行某些修改操作（如插入、删除等）后，原有的迭代器、引用或指针变得不再有效，继续使用可能导致未定义行为（如访问野指针、崩溃等），这就是迭代器失效。</p><blockquote><p>不同容器的迭代器失效情况</p></blockquote><ul><li><p><code>list</code></p><ul><li>插入元素：不会失效</li><li>删除元素：指向被删除元素的迭代器失效，其他迭代器仍然有效。</li></ul></li><li><p><code>vector</code> / <code>deque</code></p><ul><li>插入元素：所有迭代器都可能失效，因为可能会导致整体扩容。</li><li>删除元素：被删除元素之后的迭代器都会失效。</li></ul></li><li><p><code>map</code> / <code>set</code> / <code>multimap</code> / <code>multiset</code></p><ul><li>插入元素：通常不会使迭代器失效。</li><li>删除元素：指向被删除元素的迭代器失效，其他迭代器仍然有效。</li></ul></li><li><p><code>unordered_map</code> / <code>unordered_set</code></p><ul><li>插入元素：所有迭代器都可能失效，因为可能涉及哈希表重排。</li><li>删除元素：所有迭代器都可能失效，因为可能涉及哈希表重排。</li></ul></li></ul><blockquote><p>如何避免迭代器失效</p></blockquote><ul><li>在容器结构修改后，需要及时对迭代器进行更新，如 <code>it = vec.erase(it);</code>。</li><li>不要在遍历容器时，修改容器结构，或者要注意修改方式。</li><li>使用 Stable 容器（如 <code>list</code>）处理频繁插入 / 删除的场景。</li></ul><h3 id="C-STL-中哪些容器是基于红黑树实现"><a href="#C-STL-中哪些容器是基于红黑树实现" class="headerlink" title="C++ STL 中哪些容器是基于红黑树实现"></a>C++ STL 中哪些容器是基于红黑树实现</h3><table><thead><tr><th>容器名称</th><th>描述</th><th>底层结构</th></tr></thead><tbody><tr><td><code>set</code></td><td>不可重复集合，自动按 key 排序</td><td>红黑树</td></tr><tr><td><code>map</code></td><td>键值对映射表，key 唯一，自动按 key 排序</td><td>红黑树</td></tr><tr><td><code>multiset</code></td><td>可重复元素集合，自动按 key 排序</td><td>红黑树</td></tr><tr><td><code>multimap</code></td><td>可重复键的映射表，自动按 key 排序</td><td>红黑树</td></tr></tbody></table><h3 id="C-中-struct-和-class-的区别"><a href="#C-中-struct-和-class-的区别" class="headerlink" title="C++ 中 struct 和 class 的区别"></a>C++ 中 struct 和 class 的区别</h3><ul><li><code>struct</code> 和 <code>class</code> 最本质的区别是默认访问权限不同：</li></ul><table><thead><tr><th>类型</th><th>默认成员访问权限</th><th>默认继承权限</th></tr></thead><tbody><tr><td> class</td><td>private</td><td>private</td></tr><tr><td>struct</td><td>public</td><td>public</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><ul><li><code>struct</code> 和 <code>class</code> 除了默认访问权限不同，其他功能几乎完全一样：<ul><li>都可以有构造函数 / 析构函数。</li><li>都支持继承、多态。</li><li>都支持访问控制（public /protected/private）。</li><li>都可以包含成员函数、静态成员、模板等。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>在标准 C++ 中，<code>struct</code> 和 <code>class</code> 在大小上没有本质区别，空的结构体和空类的大小都至少占 1 个字节，主要是为了满足对象的地址唯一性要求。</li><li>在标准 C 语言中，空结构体是不被允许的，是非法的。但像 GCC 这样的编译器出于兼容性和底层优化，会提供非标准扩展，允许存在空结构体，且空结构体的大小默认为 0。这种用法不具备可移植性，不建议在跨平台项目中使用。</li></ul></div><h3 id="C-STL-中-vector-和数组的区别"><a href="#C-STL-中-vector-和数组的区别" class="headerlink" title="C++ STL 中 vector 和数组的区别"></a>C++ STL 中 vector 和数组的区别</h3><ul><li><code>vector</code> 是 C++ STL 中的动态数组容器，能够自动管理内存、支持动态扩容。</li><li>数组是固定大小的内存块，功能有限，需要手动管理内存。</li><li>数组的最大缺点是固定大小，并且没有访问越界检查。</li><li><code>vector</code> 适合现代 C++ 开发，更安全，更灵活，但比数组有略微的性能开销（需要构造、析构等）</li></ul><blockquote><p>vector 与 数组的深入对比</p></blockquote><table><thead><tr><th>特性</th><th> vector</th><th> 数组</th></tr></thead><tbody><tr><td>大小可变</td><td>✅ 支持动态扩容</td><td>❌ 固定大小（静态）或需手动重新分配（动态）</td></tr><tr><td>内存管理</td><td>自动管理（构造 / 析构 / 扩容）</td><td>手动管理</td></tr><tr><td>安全性</td><td>有边界检查（<code>at()</code>）</td><td>无边界检查，容易越界</td></tr><tr><td>功能接口</td><td>提供丰富成员函数（如 <code>push_back()</code>、<code>insert()</code>、<code>resize()</code>）</td><td>无成员函数</td></tr><tr><td>与 STL 配合</td><td>完美兼容 STL 算法</td><td>需要手动传长度或转换为迭代器</td></tr><tr><td>类型支持</td><td>支持对象元素（构造 / 析构函数会被调用）</td><td>只能存储裸数据，管理复杂</td></tr><tr><td>复制 / 赋值</td><td>拷贝构造 &amp; 深拷贝（对象语义）</td><td>默认浅拷贝（指针语义）</td></tr><tr><td>性能</td><td>稍微多点性能开销（如扩容、拷贝构造）</td><td>更轻量，性能高，但需谨慎使用</td></tr></tbody></table><h3 id="C-中编译链接的全过程"><a href="#C-中编译链接的全过程" class="headerlink" title="C++ 中编译链接的全过程"></a>C++ 中编译链接的全过程</h3><p>C++ 的编译链接过程主要分为 4 个阶段：预处理（Preprocessing）→ 编译（Compilation）→ 汇编（Assembly）→ 链接（Linking），最终生成可执行文件。</p><ul><li>预处理：展开头文件内容（<code>#include</code>），处理宏替换（<code>#define</code>），处理条件编译，去除注释。</li><li>编译：将预处理后的代码（<code>.i</code> 文件）编译成汇编代码（<code>.s</code> 文件），会进行语法 / 语义分析、生成中间代码。</li><li>汇编：将汇编代码（<code>.s</code> 文件）翻译成机器码，生成二进制格式的目标文件（<code>.o</code>），其中包含符号表、段信息等。</li><li>链接：将多个目标文件（<code>.o</code> 文件）和库文件合并，解决符号地址引用，生成最终的可执行文件。</li></ul><p><img data-src="../../../asset/2021/12/gcc-step-view.png"></p><h3 id="C-中初始化全局变量和未初始化全局变量的区别"><a href="#C-中初始化全局变量和未初始化全局变量的区别" class="headerlink" title="C++ 中初始化全局变量和未初始化全局变量的区别"></a>C++ 中初始化全局变量和未初始化全局变量的区别</h3><p>初始化的全局变量存放在 <code>.data 段</code>，未初始化的全局变量存放在 <code>.bss</code> 段，但都属于静态存储区，程序运行前就已经分配好。未初始化的全局变量默认值为 0。</p><blockquote><p>初始化全局变量和未初始化全局变量的深入对比</p></blockquote><ul><li><p>存储区域</p><ul><li><code>.data</code> 段：负责存储已初始化的全局变量。</li><li><code>.bbs</code> 段：负责存储未初始化、或者初始化值为 0 的全局变量。</li></ul></li><li><p>是否初始化</p><ul><li>初始化的全局变量：程序启动时由编译器 / 操作系统赋初值。</li><li>未初始化的全局变量：会被自动初始化为 0（基本类型）。</li></ul></li><li><p>程序运行前的表现</p><ul><li><code>.data</code> 段（已初始化）：编译时已确定，程序启动时拷贝进内存。</li><li><code>.bss</code> 段（未初始化）：不占用可执行文件的实际存储空间，程序运行时清零。</li></ul></li><li><p>汇编层面的差异</p><ul><li>在编译后的汇编代码中：<ul><li>初始化的变量在 <code>.data</code> 段中有实际数据。</li><li>未初始化的变量在 <code>.bss</code> 段中标记为零初始化。</li></ul></li></ul></li></ul><h3 id="C-中栈和堆的区别"><a href="#C-中栈和堆的区别" class="headerlink" title="C++ 中栈和堆的区别"></a>C++ 中栈和堆的区别</h3><p>栈适合临时、小型、自动管理的内存；堆适合长期、动态、大型对象的内存，但需要程序员手动管理内存。</p><blockquote><p>栈和堆的深入对比</p></blockquote><ul><li><p>内存分配方式</p><ul><li>栈：由编译器自动分配和释放，速度快。</li><li>堆：由程序员使用 <code>new</code> / <code>delete</code> 手动分配和释放，速度相对较慢。</li></ul></li><li><p>生命周期</p><ul><li>栈：变量在离开作用域时自动销毁（例如函数返回）。</li><li>堆：变量在程序员手动 <code>delete</code> 后才销毁，或者由智能指针管理。</li></ul></li><li><p>内存大小限制</p><ul><li>栈：空间较小（通常几 MB），适合小型数据。</li><li>堆：空间大（受限于系统内存），适合存放大型对象或数组。</li></ul></li><li><p>使用方式</p><ul><li>栈上的变量示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure></li><li>堆上的变量示例：<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>内存碎片</p><ul><li>栈：几乎没有内存碎片，因为是连续分配。</li><li>堆：容易产生碎片，特别是在频繁 <code>new</code> / <code>delete</code> 的场景中。</li></ul></li><li><p>安全性</p><ul><li>栈：更安全，系统自动管理，出错概率低。</li><li>堆：容易发生内存泄漏、悬空指针等问题，需手动管理，出错风险较高。</li></ul></li><li><p>性能</p><ul><li>栈：性能高，内存分配和释放速度快。</li><li>堆：性能稍差，涉及系统调用和管理开销。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>在 C++ 11 及以后（现代 C++），推荐使用智能指针（如 <code>unique_ptr</code>、<code>shared_ptr</code>）管理堆内存，减少内存泄漏风险。</p></div><h3 id="C-中宏和内联的区别"><a href="#C-中宏和内联的区别" class="headerlink" title="C++ 中宏和内联的区别"></a>C++ 中宏和内联的区别</h3><p>宏是简单的文本替换，不安全；内联函数是真正的函数，有类型检查，更推荐使用。</p><table><thead><tr><th>项目</th><th>宏（Macro）</th><th>内联函数（Inline Function）</th></tr></thead><tbody><tr><td>定义方式</td><td>使用 <code>#define</code> 预处理指令定义</td><td>使用 <code>inline</code> 关键字定义</td></tr><tr><td>处理阶段</td><td>预处理器在编译前展开（文本替换）</td><td>编译器在编译阶段决定是否内联</td></tr><tr><td>类型检查</td><td>没有类型检查，纯粹文本替换</td><td>有严格的类型检查</td></tr><tr><td>调试</td><td>展开后难以调试，出错时排查困难</td><td>支持调试，可以单步进入函数内部</td></tr><tr><td>语法特点</td><td>不能访问作用域、命名空间、模板等高级特性</td><td>可以访问作用域、命名空间、模板等特性</td></tr><tr><td>容易出错</td><td>宏可能因为括号缺失或优先级问题导致错误</td><td>内联函数遵循 C++ 语法规范，不易出错</td></tr><tr><td>适用场景</td><td>一些简单的常量、短小的代码块（但现代 C++ 用 const /constexpr/inline 替代宏）</td><td>频繁调用的小函数，希望减少函数调用开销</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><ul><li>内联只是给编译器的优化建议，不是强制要求，编译器可以忽略 <code>inline</code> 关键字。</li><li>如果函数过于复杂（如有循环、递归、异常处理），即使加了 <code>inline</code> 也可能不会被内联。</li><li>过度使用内联会导致程序体积膨胀（代码膨胀问题），影响指令缓存命中率，反而可能拖慢性能。</li></ul></div><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/2f38a56e.html" title="C++ 高频面试题之一">https://www.techgrow.cn/posts/2f38a56e.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/127f17a7.html" rel="prev" title="Redis 分布式解决方案 - Codis"><i class="fa fa-angle-left"></i> Redis 分布式解决方案 - Codis</a></div><div class="post-nav-item"> <a href="/posts/feb80593.html" rel="next" title="C++ 高频面试题之二">C++ 高频面试题之二<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.8m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">27:40</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/2f38a56e.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>