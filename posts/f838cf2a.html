<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Redisson 分布式锁的基础使用教程，包括可重入锁、读写锁、闭锁、信号量等。"><meta property="og:type" content="article"><meta property="og:title" content="Redisson 分布式锁使用教程"><meta property="og:url" content="https://www.techgrow.cn/posts/f838cf2a.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 Redisson 分布式锁的基础使用教程，包括可重入锁、读写锁、闭锁、信号量等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/02/redission-locks.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/02/redission-semaphore.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/08/redisson-locks-1.png"><meta property="article:published_time" content="2021-02-15T15:42:21.000Z"><meta property="article:modified_time" content="2023-02-23T15:42:21.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="Java"><meta property="article:tag" content="微服务"><meta property="article:tag" content="分布式"><meta property="article:tag" content="缓存"><meta property="article:tag" content="并发编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2023/02/redission-locks.png"><link rel="canonical" href="https://www.techgrow.cn/posts/f838cf2a.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/f838cf2a.html","path":"posts/f838cf2a.html","title":"Redisson 分布式锁使用教程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Redisson 分布式锁使用教程 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script>
  (function () {

  // 防止 Pjax 重复绑定事件
  if (window.__moonMenuCodeExpandBound) {
    return;
  }
  window.__moonMenuCodeExpandBound = true;

  const STORAGE_KEY = 'moon_menu_code_fold';

  /* ===============================
   * 1. 设置 moon-menu 按钮的 title
   * =============================== */
  (function bindMoonMenuTitles() {
    const items = [
      { selector: '#moon-menu-item-code',        title: '展开 / 折叠代码块' },
      { selector: '#moon-menu-item-back2top',    title: '回到页面顶部' },
      { selector: '#moon-menu-item-back2bottom', title: '回到页面底部' }
    ];

    let allReady = true;

    items.forEach(item => {
      const el = document.querySelector(item.selector);
      if (!el) {
        allReady = false;
        return;
      }
      el.setAttribute('title', item.title);
    });

    if (!allReady) {
      setTimeout(bindMoonMenuTitles, 100);
    }
  })();

  /* =================================
   * 2. 页面首次加载：代码块恢复展开或折叠状态
   * ================================= */
  function applyStoredCodeState() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    const state = localStorage.getItem(STORAGE_KEY);
    if (!state) {
      return;
    }

    containers.forEach(container => {
      if (state === 'expanded') {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else if (state === 'folded') {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });
  }

  // 等代码块出现后，再恢复展开或折叠状态
  function waitAndApplyState() {
    const containers = document.querySelectorAll('.code-container');

    if (!containers.length) {
      setTimeout(waitAndApplyState, 100);
      return;
    }

    applyStoredCodeState();
  }

  // 页面首次加载时恢复状态
  waitAndApplyState();
  
  // Pjax 切换页面后，必须重新恢复状态
  document.addEventListener('pjax:complete', function () {
    waitAndApplyState();
  });

  /* ===============================
   * 3. 点击按钮：切换状态并保存
   * =============================== */
  document.addEventListener('click', function (e) {
    const codeMenu = e.target.closest('#moon-menu-item-code');
    if (!codeMenu) {
      return;
    }

    toggleAllCodeBlocks();
  });

  // 展开或折叠代码块
  function toggleAllCodeBlocks() {
    const containers = document.querySelectorAll('.code-container');
    if (!containers.length) {
      return;
    }

    // 只要存在折叠的代码块，就认为当前是折叠状态
    const hasFolded = Array.from(containers).some(c => {
      return c.classList.contains('highlight-fold');
    });

    containers.forEach(container => {
      if (hasFolded) {
        // 展开代码块
        container.classList.remove('highlight-fold');
      } else {
        // 折叠代码块
        container.classList.add('highlight-fold');
      }
    });

    // 记录展开或折叠状态
    localStorage.setItem(
      STORAGE_KEY,
      hasFolded ? 'expanded' : 'folded'
    );
  }

})();
</script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90"><span class="nav-text">学习资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson-%E7%AE%80%E4%BB%8B"><span class="nav-text">Redisson 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson-%E5%AF%B9%E8%B1%A1"><span class="nav-text">Redisson 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-text">Redisson 基础使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-%E6%95%B4%E5%90%88-Redisson"><span class="nav-text">Spring 整合 Redisson</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-Reentrant-Lock"><span class="nav-text">可重入锁 (Reentrant Lock)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-ReadWriteLock"><span class="nav-text">读写锁 (ReadWriteLock)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E9%94%81-CountDownLatch"><span class="nav-text">闭锁 (CountDownLatch)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphore"><span class="nav-text">信号量 (Semaphore)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BF%87%E6%9C%9F%E6%80%A7%E4%BF%A1%E5%8F%B7%E9%87%8F-PermitExpirableSemaphore"><span class="nav-text">可过期性信号量 (PermitExpirableSemaphore)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson-%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8"><span class="nav-text">Redisson 进阶使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-RedLock-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">基于 RedLock 算法实现分布式锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot-%E6%95%B4%E5%90%88-Redisson"><span class="nav-text">SpringBoot 整合 Redisson</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-Maven-%E4%BE%9D%E8%B5%96"><span class="nav-text">引入 Maven 依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0-YML-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="nav-text">添加 YML 配置信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Redission-%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="nav-text">创建 Redission 配置类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">单元测试代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2"><span class="nav-text">参考博客</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">798</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">56</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/f838cf2a.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Redisson 分布式锁使用教程 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 Redisson 分布式锁的基础使用教程，包括可重入锁、读写锁、闭锁、信号量等。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Redisson 分布式锁使用教程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-02-15 23:42:21" itemprop="dateCreated datePublished" datetime="2021-02-15T23:42:21+08:00">2021-02-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-02-23 23:42:21" itemprop="dateModified" datetime="2023-02-23T23:42:21+08:00">2023-02-23</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/f838cf2a.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/f838cf2a.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>7.9k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>7 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/150bedf.html">Redis 缓存与分布式锁</a></li><li><a href="/posts/f838cf2a.html">Redisson 分布式锁使用教程</a></li><li><a href="/posts/51ce4ef9.html">Redis 分布式锁中 Lua 脚本的使用</a></li><li><a href="/posts/912f33ba.html">Java 基于 MySQL 实现分布式锁</a></li><li><a href="/posts/f4b8817b.html">基于 ZooKeeper 原生 API 实现分布式锁</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a target="_blank" rel="external nofollow" href="https://redisson.org/">Redisson 官网</a></li><li><a target="_blank" rel="external nofollow" href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95">Redisson 官方文档</a></li><li><a target="_blank" rel="external nofollow" href="https://github.com/redisson/redisson">Redisson GitHub 仓库</a></li></ul><h2 id="Redisson-简介"><a href="#Redisson-简介" class="headerlink" title="Redisson 简介"></a>Redisson 简介</h2><p>Redisson 是架设在 Redis 基础上的一个 Java 驻内存数据网格（In-Memory Data Grid）。充分地利用了 Redis 键值数据库提供的一系列优势，基于 Java 实用工具包中的常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。Redisson 的宗旨是促进使用者对 Redis 的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。值得一提的是，Redisson 底层采用的是 Netty 框架。支持 Redis 2.8 以上版本，支持 Java 1.6+ 以上版本。</p><span id="more"></span><p><img data-src="../../../asset/2023/02/redission-locks.png"></p><h2 id="Redisson-对象"><a href="#Redisson-对象" class="headerlink" title="Redisson 对象"></a>Redisson 对象</h2><p>Redis 命令和 Redisson 对象匹配列表请阅读 <a target="_blank" rel="external nofollow" href="https://github.com/redisson/redisson/wiki/11.-redis%E5%91%BD%E4%BB%A4%E5%92%8Credisson%E5%AF%B9%E8%B1%A1%E5%8C%B9%E9%85%8D%E5%88%97%E8%A1%A8">这里</a>。</p><h2 id="Redisson-基础使用"><a href="#Redisson-基础使用" class="headerlink" title="Redisson 基础使用"></a>Redisson 基础使用</h2><h3 id="Spring-整合-Redisson"><a href="#Spring-整合-Redisson" class="headerlink" title="Spring 整合 Redisson"></a>Spring 整合 Redisson</h3><ul><li>引入 Maven 依赖</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>配置 Redisson 客户端的连接信息，包括 Reids 服务器的地址、密码等内容。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisssonConfig</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(destroyMethod = "shutdown")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                <span class="comment">// 地址</span></span><br><span class="line">                .setAddress(<span class="string">"redis://127.0.0.1:6379"</span>)</span><br><span class="line">                <span class="comment">// 密码</span></span><br><span class="line">                .setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>上述的配置方式同样适用于 SpringBoot 项目。</li><li>配置完 Redisson 客户端后，在 Java 业务代码里就可以直接注入 <code>RedissonClient</code> 实例对象来使用 Redisson 提供的各种分布式锁了。</li></ul></div><h3 id="可重入锁-Reentrant-Lock"><a href="#可重入锁-Reentrant-Lock" class="headerlink" title="可重入锁 (Reentrant Lock)"></a>可重入锁 (Reentrant Lock)</h3><p>基于 Redis 的 Redisson 分布式可重入锁 <code>RLock</code> 实现了 <code>java.util.concurrent.locks.Lock</code> 接口，同时还提供了异步（Async）、反射式（Reactive）和 RxJava2 标准的接口。众所周知，如果负责储存这个分布式锁的 Redisson 节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson 内部提供了一个监控锁的看门狗，它的作用是在 Redisson 实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是 <code>30</code> 秒钟，也可以通过修改 <code>Config.lockWatchdogTimeout</code> 来另行指定。另外 Redisson 还为加锁的方法提供了 <code>leaseTime</code> 参数来指定加锁的时间，超过这个时间后锁便会自动解开。</p><ul><li>直接获取锁，阻塞等待直至获取到锁</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 获取可重入锁</span></span><br><span class="line">        RLock lock = redissonClient.getLock(<span class="string">"rLock"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阻塞等待，直至获取到锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"==&gt; success to get locker"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>RLock.lock()</code> 方法加锁后，默认加的锁的有效期是 30 秒。</li><li><code>RLock.lock()</code> 方法加锁后，如果业务耗时超长，Redisson 在业务执行期间会周期性地自动给锁续上新的 30 秒有效期（看门狗机制），不用担心业务执行时间过长，锁自动过期被删掉的问题。</li><li><code>RLock.lock()</code> 方法加锁后，只要加锁的业务运行完成，Redisson 就不会再给当前锁续期，即使不手动解锁，锁默认会在 30 秒内自动删除。</li></ul></div><ul><li>直接获取锁，阻塞等待直至获取到锁，且上锁以后 10 秒自动解锁</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 获取可重入锁</span></span><br><span class="line">        RLock lock = redissonClient.getLock(<span class="string">"rLock"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阻塞等待，直至获取到锁，且上锁以后10秒自动解锁</span></span><br><span class="line">        lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"==&gt; success to get locker"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>调用 <code>RLock.lock(10, TimeUnit.SECONDS)</code> 方法加锁时，设置自动解锁的时间必须大于业务的执行时间。</li><li>调用 <code>RLock.lock(10, TimeUnit.SECONDS)</code> 方法加锁时，在锁时间到了以后，即使业务未执行完成，Redisson 也不会给锁续期，也就是看门狗机制此时不会生效。</li></ul></div><ul><li>尝试获取锁，阻塞等待，但不能超过指定的最大等待时间，且上锁以后 10 秒自动解锁</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 获取可重入锁</span></span><br><span class="line">        RLock lock = redissonClient.getLock(<span class="string">"rLock"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line">        <span class="keyword">boolean</span> res = lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (res) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"==&gt; success to get locker"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>调用 <code>RLock.tryLock(100, 10, TimeUnit.SECONDS)</code> 方法加锁时，设置自动解锁的时间必须大于业务的执行时间。</li><li>调用 <code>RLock.tryLock(100, 10, TimeUnit.SECONDS)</code> 方法加锁时，在锁时间到了以后，即使业务未执行完成，Redisson 也不会给锁续期，也就是看门狗机制此时不会生效。</li></ul></div><h3 id="读写锁-ReadWriteLock"><a href="#读写锁-ReadWriteLock" class="headerlink" title="读写锁 (ReadWriteLock)"></a>读写锁 (ReadWriteLock)</h3><p>基于 Redis 的 Redisson 分布式可重入读写锁 <code>RReadWriteLock</code> 实现了 <code>java.util.concurrent.locks.ReadWriteLock</code> 接口，其中读锁和写锁都继承了 <code>RLock</code> 接口。<strong>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</strong></p><div class="admonition note"><p class="admonition-title">读写锁的特性</p><ul><li><code>读 + 读</code>：相当于无锁，支持并发读</li><li><code>写 + 读</code>：读操作需要等待写操作完成</li><li><code>读 + 写</code>：写操作需要等待读操作完成</li><li><code>写 + 写</code>：互斥，需要等待对方的锁释放</li><li>简而言之，只要有写锁存在，则其他操作都必须阻塞等待</li></ul></div><ul><li>单元测试代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存（非线程安全）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; CACHES = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">writeValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        RReadWriteLock rwLock = redissonClient.getReadWriteLock(<span class="string">"rw-lock"</span>);</span><br><span class="line">        RLock writeLock = rwLock.writeLock();</span><br><span class="line">        </span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 加写锁</span></span><br><span class="line">            writeLock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">            CACHES.put(<span class="string">"uuid"</span>, uuid);</span><br><span class="line">            System.out.println(<span class="string">"==&gt; write uuid : "</span> + uuid);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解写锁</span></span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uuid;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">readValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 获取读锁</span></span><br><span class="line">        RReadWriteLock rwLock = redissonClient.getReadWriteLock(<span class="string">"rw-lock"</span>);</span><br><span class="line">        RLock readLock = rwLock.readLock();</span><br><span class="line">        </span><br><span class="line">        String uuid = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 加读锁</span></span><br><span class="line">            readLock.lock();</span><br><span class="line">            uuid = CACHES.get(<span class="string">"uuid"</span>);</span><br><span class="line">            System.out.println(<span class="string">"==&gt; read uuid : "</span> + uuid);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解读锁</span></span><br><span class="line">            readLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uuid;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readWriteLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>::writeValue).start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读操作（会阻塞等待写操作完成才执行）</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>::readValue).start();</span><br><span class="line">        </span><br><span class="line">        System.in.read();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>单元测试结果</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==&gt; write uuid : 7d611f3a-2437-413d-b1aa-4041decc344e</span><br><span class="line">==&gt; read uuid : 7d611f3a-2437-413d-b1aa-4041decc344e</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>读锁是一个共享锁，支持并发地执行读操作。</li><li>写锁是一个排他锁（互斥锁 / 独占锁），可防止并发地执行写操作。</li><li>使用读写锁，可以保证读到的数据永远是最新的；只要写锁没有释放掉，那么拥有读锁的操作就会一直阻塞等待，直至写锁被释放。</li></ul></div><h3 id="闭锁-CountDownLatch"><a href="#闭锁-CountDownLatch" class="headerlink" title="闭锁 (CountDownLatch)"></a>闭锁 (CountDownLatch)</h3><p>基于 Redis 的 Redisson 分布式闭锁 <code>RCountDownLatch</code> 采用了与 <code>java.util.concurrent.CountDownLatch</code> 相似的接口和用法。<strong>闭锁适用于等待一个多线程的操作，也就是等待 N 个线程把所有业务执行完毕后，再处理一个业务。</strong>关于闭锁的使用场景，可以想象一下公司的门卫如何等所有员工下班后再关门。公司一共有五名员工，门卫需要等这五名员工下班后，才能关闭大门。</p><div class="admonition note"><p class="admonition-title">闭锁的使用场景</p><ul><li>闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：</li><li>(a) 确保某个计算在其需要的所有资源都被初始化之后才继续执行</li><li> (b) 确保某个服务在其他依赖的所有其他服务都已经启动之后才启动</li><li> (c) 等待直到某个操作所有参与者都准备就绪再继续执行</li></ul></div><ul><li>单元测试代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 门卫关门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockDoor</span><span class="params">()</span> </span>{</span><br><span class="line">        RCountDownLatch countDownLatch = redissonClient.getCountDownLatch(<span class="string">"countDownLatch"</span>);</span><br><span class="line">        <span class="comment">// 设置总共有5个员工</span></span><br><span class="line">        countDownLatch.trySetCount(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 门卫等待所有员工下班</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">"==&gt; 门卫关门成功"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 员工下班</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offWork</span><span class="params">(<span class="keyword">long</span> num)</span> </span>{</span><br><span class="line">        RCountDownLatch countDownLatch = redissonClient.getCountDownLatch(<span class="string">"countDownLatch"</span>);</span><br><span class="line">        <span class="comment">// 未下班的员工计数减一</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        System.out.println(<span class="string">"==&gt; "</span> + num + <span class="string">" 号员工下班"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDownLatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 模拟门卫关门</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>::lockDoor).start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模拟5个员工下班</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                offWork(Thread.currentThread().getId());</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        System.in.read();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>单元测试结果</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt; 113 号员工下班</span><br><span class="line">==&gt; 112 号员工下班</span><br><span class="line">==&gt; 114 号员工下班</span><br><span class="line">==&gt; 115 号员工下班</span><br><span class="line">==&gt; 116 号员工下班</span><br><span class="line">==&gt; 门卫关门成功</span><br></pre></td></tr></tbody></table></figure><h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 (Semaphore)"></a>信号量 (Semaphore)</h3><p>基于 Redis 的 Redisson 的分布式信号量 <code>RSemaphore</code> 采用了与 <code>java.util.concurrent.Semaphore</code> 相似的接口和用法，同时还提供了异步（Async）、反射式（Reactive）和 RxJava2 标准的接口。关于信号量的使用场景，可以想象一下平时停车场如何停车。一共有十辆车准备停车，停车位有五个，当五个停车位满了后，其他车只能等有车位空出来才能停车。可以把停车位比作信号，现在有五个信号，停一次车，用掉一个信号，车离开就是释放一个信号。<strong>值得一提的是，RSemaphore 可用于实现分布式限流。</strong>RSemaphore 的原理图如下。</p><p><img data-src="../../../asset/2023/02/redission-semaphore.png"></p><ul><li>单元测试代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">semaphore</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">// 获取信号量</span></span><br><span class="line">        RSemaphore semaphore = redissonClient.getSemaphore(<span class="string">"semaphore"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置许可数量，模拟五个停车位</span></span><br><span class="line">        semaphore.trySetPermits(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建10个线程，模拟10辆车过来停车</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            executorService.submit(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 占用信号（停车位）</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"==&gt; 车辆 "</span> + Thread.currentThread().getId() + <span class="string">" 进入停车场"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 释放信号（停车位）</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(<span class="string">"==&gt; 车辆 "</span> + Thread.currentThread().getId() + <span class="string">" 离开停车场"</span>);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        System.in.read();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>单元测试结果</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">==&gt; 车辆 113 进入停车场</span><br><span class="line">==&gt; 车辆 110 进入停车场</span><br><span class="line">==&gt; 车辆 109 进入停车场</span><br><span class="line">==&gt; 车辆 111 进入停车场</span><br><span class="line">==&gt; 车辆 108 进入停车场</span><br><span class="line">==&gt; 车辆 108 离开停车场</span><br><span class="line">==&gt; 车辆 109 离开停车场</span><br><span class="line">==&gt; 车辆 110 离开停车场</span><br><span class="line">==&gt; 车辆 111 离开停车场</span><br><span class="line">==&gt; 车辆 113 离开停车场</span><br><span class="line">==&gt; 车辆 112 进入停车场</span><br><span class="line">==&gt; 车辆 117 进入停车场</span><br><span class="line">==&gt; 车辆 114 进入停车场</span><br><span class="line">==&gt; 车辆 116 进入停车场</span><br><span class="line">==&gt; 车辆 116 离开停车场</span><br><span class="line">==&gt; 车辆 114 离开停车场</span><br><span class="line">==&gt; 车辆 112 离开停车场</span><br><span class="line">==&gt; 车辆 117 离开停车场</span><br><span class="line">==&gt; 车辆 115 进入停车场</span><br><span class="line">==&gt; 车辆 115 离开停车场</span><br></pre></td></tr></tbody></table></figure><h3 id="可过期性信号量-PermitExpirableSemaphore"><a href="#可过期性信号量-PermitExpirableSemaphore" class="headerlink" title="可过期性信号量 (PermitExpirableSemaphore)"></a>可过期性信号量 (PermitExpirableSemaphore)</h3><p>基于 Redis 的 Redisson 可过期性信号量 <code>RPermitExpirableSemaphore</code> 是在 <code>RSemaphore</code> 对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的 ID 来辨识，释放时只能通过提交这个 ID 才能释放。它提供了异步（Async）、反射式（Reactive）和 RxJava2 标准的接口。</p><ul><li>单元测试代码</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expirableSemaphore</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">// 获取可过期性信号量</span></span><br><span class="line">        RPermitExpirableSemaphore semaphore = redissonClient.getPermitExpirableSemaphore(<span class="string">"expirable-semaphore"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置许可数量，模拟五个停车位</span></span><br><span class="line">        semaphore.trySetPermits(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建10个线程，模拟10辆车过来停车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                <span class="comment">// 信号的 ID 标识</span></span><br><span class="line">                String permitId = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 占用信号量（停车位），有效期只有5秒</span></span><br><span class="line">                    permitId = semaphore.acquire(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"==&gt; 车辆 "</span> + Thread.currentThread().getId() + <span class="string">" 进入停车场"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 释放信号量（停车位）</span></span><br><span class="line">                    semaphore.release(permitId);</span><br><span class="line">                    System.out.println(<span class="string">"==&gt; 车辆 "</span> + Thread.currentThread().getId() + <span class="string">" 离开停车场"</span>);</span><br><span class="line">                }</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">        System.in.read();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>单元测试结果</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">==&gt; 车辆 115 进入停车场</span><br><span class="line">==&gt; 车辆 109 进入停车场</span><br><span class="line">==&gt; 车辆 112 进入停车场</span><br><span class="line">==&gt; 车辆 111 进入停车场</span><br><span class="line">==&gt; 车辆 113 进入停车场</span><br><span class="line">==&gt; 车辆 113 离开停车场</span><br><span class="line">==&gt; 车辆 115 离开停车场</span><br><span class="line">==&gt; 车辆 111 离开停车场</span><br><span class="line">==&gt; 车辆 109 离开停车场</span><br><span class="line">==&gt; 车辆 112 离开停车场</span><br><span class="line">==&gt; 车辆 110 进入停车场</span><br><span class="line">==&gt; 车辆 114 进入停车场</span><br><span class="line">==&gt; 车辆 108 进入停车场</span><br><span class="line">==&gt; 车辆 106 进入停车场</span><br><span class="line">==&gt; 车辆 114 离开停车场</span><br><span class="line">==&gt; 车辆 108 离开停车场</span><br><span class="line">==&gt; 车辆 106 离开停车场</span><br><span class="line">==&gt; 车辆 110 离开停车场</span><br><span class="line">==&gt; 车辆 107 进入停车场</span><br><span class="line">==&gt; 车辆 107 离开停车场</span><br></pre></td></tr></tbody></table></figure><h2 id="Redisson-进阶使用"><a href="#Redisson-进阶使用" class="headerlink" title="Redisson 进阶使用"></a>Redisson 进阶使用</h2><h3 id="基于-RedLock-算法实现分布式锁"><a href="#基于-RedLock-算法实现分布式锁" class="headerlink" title="基于 RedLock 算法实现分布式锁"></a>基于 RedLock 算法实现分布式锁</h3><blockquote><p>RedLock 算法的核心思想</p></blockquote><p>RedLock 算法的核心思想是在多个独立的 Redis 实例（不存在主从、集群关系，彼此互相隔离）上同时获取锁，从而保证分布式锁的高可用性和可靠性。即使某些 Redis 实例出现故障，只要在大多数实例（至少 <code>N/2 + 1</code> 个）中成功获取到锁，整个系统仍然可以认为锁是成功获取的（有效）。</p><blockquote><p>RedLock 算法的实现步骤</p></blockquote><ul><li><p>(1) <strong>获取当前时间</strong>：</p><ul><li>客户端获取当前时间，用于计算获取锁的总耗时。</li></ul></li><li><p>(2) <strong>依次向 N 个实例请求锁</strong>：</p><ul><li>客户端依次向 N 个 Redis 实例（通常是 5 个）发送获取锁的请求。</li><li>请求锁的命令是 <code>SET key value NX PX milliseconds</code>，其中：<ul><li><code>key</code> 是锁的标识。</li><li><code>value</code> 是客户端的唯一标识（通常使用类似 UUID 这样的随机值）。</li><li><code>NX</code> 表示只有在键不存在时才进行设置。</li><li><code>PX</code> 表示设置键的过期时间（毫秒）。</li></ul></li></ul></li><li><p>(3) <strong>计算总耗时</strong>：</p><ul><li>客户端在每次请求锁后，立即获取当前时间，计算从开始请求到成功获取锁的总耗时。</li></ul></li><li><p>(4) <strong>验证锁获取成功</strong>：</p><ul><li>如果客户端在大多数（至少 <code>N/2 + 1</code> 个）实例上成功获取锁，并且获取锁的总耗时小于锁的过期时间，则认为锁获取成功。</li><li>如果锁获取失败，客户端应当立即释放在所有实例上已成功获取的锁。</li></ul></li><li><p>(5) <strong>使用锁</strong>：</p><ul><li>客户端在获取锁成功后，执行相关的业务逻辑。</li><li>为了防止锁提前被释放掉，业务逻辑应在锁的有效期内完成。</li></ul></li><li><p>(6) <strong>释放锁</strong>：</p><ul><li>客户端在所有实例上执行释放锁操作，确保释放所有持有的锁。</li><li>释放锁的操作通常是一个 Lua 脚本，用于原子性检查锁的值是否匹配客户端的唯一标识（防止误删其他客户端加的锁），然后再删除锁。</li></ul></li></ul><blockquote><p>RedLock 算法的优缺点</p></blockquote><ul><li><strong>优点</strong>：<ul><li>高可用性：通过在多个独立的 Redis 实例（没有主从、集群关系）上获取锁，RedLock 提高了锁的可用性和容错能力。</li><li>强一致性：RedLock 保证了分布式锁的一致性，只要大多数实例成功获取锁，即使部分实例发生故障，仍然可以正确获取和释放锁。</li><li>防止死锁：锁设置了过期时间，确保即使客户端崩溃或未能正常释放锁，锁也会在超时后自动释放，避免死锁问题。</li></ul></li><li><strong>缺点</strong>：<ul><li>实例独立性：要求每个 Redis 实例是独立且不会同时宕机，通常部署在不同的物理或虚拟机上。</li><li>时钟同步：客户端的系统时钟需要尽可能准确，以确保计算获取锁的总耗时和锁的过期时间准确无误。</li><li>网络延迟：在获取锁和释放锁的过程中，可能会受到网络延迟的影响，需要在系统设计时考虑这些因素。</li></ul></li></ul><blockquote><p>RedLock 算法的部署建议</p></blockquote><ul><li>Redis 官方建议针对 RedLock 算法至少部署 5 个相互独立的 Redis 实例（不存在主从、集群关系，彼此互相隔离），以容忍 2 个实例出现故障；若服务器资源不足，要求部署至少 3 个相互独立的 Redis 实例，以容忍 1 个实例出现故障。</li></ul><hr><blockquote><p>通过 Redisson 实现不同类型的 Redis 分布式锁</p></blockquote><p>Redisson 基于 Redis 提供了多种分布式锁 API，包括：<code>RLock</code>、<code>RedissonMultiLock</code> 和 <code>RedissonRedLock</code> 等，如下图所示：</p><p><img data-src="../../../asset/2025/08/redisson-locks-1.png"></p><ul><li><p><strong>RLock（可重入锁）</strong></p><ul><li>可以在单个 Redis 节点上加锁，也可在 Redis 集群的单个主节点上加锁。</li><li>局限性：存在单机故障问题，或者集群模式下如果主节点故障且锁数据未同步到从节点，主从切换完成后，新主节点可能重复授予锁，从而导致锁的互斥性失效。</li><li>主要实现类：<ul><li><code>RedissonLock</code> — 基于单个 Redis 节点（或 Redis 集群单个主节点）的普通可重入锁实现。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取可重入锁（基于 RLock 接口）</span></span><br><span class="line">RLock lock = redissonClient.getLock(<span class="string">"my_lock"</span>);</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 抢占锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="comment">// 执行业务逻辑</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 释放锁</span></span><br><span class="line">   lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><code>RedissonFairLock</code> — 公平锁，按请求顺序获取锁，避免 “插队”。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取公平锁（基于 RLock 接口）</span></span><br><span class="line">RLock lock = redissonClient.getFairLock(<span class="string">"my_lock"</span>);</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 抢占锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="comment">// 执行业务逻辑</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 释放锁</span></span><br><span class="line">   lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><code>RedissonReadLock</code> — 读写锁的读锁部分，支持读并发。</li><li><code>RedissonWriteLock</code> — 读写锁的写锁部分，互斥访问。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取读写锁</span></span><br><span class="line">RReadWriteLock rwLock = redissonClient.getReadWriteLock(<span class="string">"my_lock"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁（基于 RLock 接口）</span></span><br><span class="line">RLock readLock = rwLock.readLock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 抢占读锁</span></span><br><span class="line">   readLock.lock();</span><br><span class="line">   <span class="comment">// 执行读操作</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 释放读锁</span></span><br><span class="line">   readLock.unlock();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写锁（基于 RLock 接口）</span></span><br><span class="line">RLock writeLock = rwLock.writeLock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 抢占写锁</span></span><br><span class="line">   writeLock.lock();</span><br><span class="line">   <span class="comment">// 执行写操作</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 释放写锁</span></span><br><span class="line">   writeLock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><code>RedissonSpinLock</code> — 自旋锁，短时间内高频尝试获取锁，减少阻塞等待。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取自旋锁（基于 RLock 接口）</span></span><br><span class="line">RLock spinLock = redisson.getSpinLock(<span class="string">"my_lock"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="keyword">boolean</span> locked = spinLock.tryLock(<span class="number">5000</span>, <span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">if</span> (locked) {</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 执行业务逻辑</span></span><br><span class="line">   } <span class="keyword">finally</span> {</span><br><span class="line">      <span class="comment">// 释放锁</span></span><br><span class="line">      spinLock.unlock();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p><strong>‌RedissonMultiLock（联锁）</strong></p><ul><li>作用：一次性对多个独立的 <code>RLock</code> 加锁，所有锁都成功获取才算整体加锁成功。</li><li>锁资源类型：这些锁可以是同一个 Redis 节点上不同的 Key，也可以是不同 Redis 节点上的同一个 Key。</li><li>设计目的：侧重于跨资源的原子性加锁，而非 Redis 集群的容错与一致性保证。</li><li>应用场景：适用于需要同时锁定多个资源（如订单、库存等）的跨资源并发控制。</li><li>局限性：不符合 Redis 官方提出 RedLock 算法规范，在 Redis 集群场景下无法保证分布式锁的强一致性与安全性。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有需要加锁的资源</span></span><br><span class="line">RLock lock1 = redissonClient.getLock(<span class="string">"lock1"</span>);</span><br><span class="line">RLock lock2 = redissonClient.getLock(<span class="string">"lock2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建联锁</span></span><br><span class="line">RedissonMultiLock multiLock = <span class="keyword">new</span> RedissonMultiLock(lock1, lock2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 尝试获取多个锁资源的联锁，最多等待 5 秒，成功加锁后 10 秒自动释放，只有所有子锁都加锁成功才算获得锁</span></span><br><span class="line">   locked = multiLock.tryLock(<span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">if</span> (locked) {</span><br><span class="line">      <span class="comment">// 执行业务逻辑</span></span><br><span class="line">   } </span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 只在获取锁成功时解锁</span></span><br><span class="line">   <span class="keyword">if</span> (locked) {</span><br><span class="line">      multiLock.unlock();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>RedissonRedLock（红锁）</strong></p><ul><li>基于 Redis 官方的 RedLock 算法实现。</li><li>在多个独立 Redis 节点上（不存在主从、集群关系，彼此互相隔离）尝试加锁；</li><li>只有当超过半数（<code>N/2 + 1</code>）的节点加锁成功时，才认为锁获取成功，符合 RedLock 的多数派原则；</li><li>优势：严格实现 Redis 官方提出的 RedLock 算法。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直连第一个独立 Redis 节点</span></span><br><span class="line">Config config1 = <span class="keyword">new</span> Config();</span><br><span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直连第二个独立 Redis 节点</span></span><br><span class="line">Config config2 = <span class="keyword">new</span> Config();</span><br><span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6380"</span>);</span><br><span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直连第三个独立 Redis 节点</span></span><br><span class="line">Config config3 = <span class="keyword">new</span> Config();</span><br><span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6381"</span>);</span><br><span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个 Redis 节点上获取一个普通 RLock</span></span><br><span class="line">RLock lock1 = redissonClient1.getLock(<span class="string">"lock1"</span>);</span><br><span class="line">RLock lock2 = redissonClient2.getLock(<span class="string">"lock2"</span>);</span><br><span class="line">RLock lock3 = redissonClient3.getLock(<span class="string">"lock3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合成一个 RedLock</span></span><br><span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 尝试同时加锁（要求在大部分节点上加锁成功才算真正获得锁），等待最多 100 秒，加锁成功后 10 秒自动释放</span></span><br><span class="line">   isLocked = redLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">if</span> (isLocked) {</span><br><span class="line">      <span class="comment">// 执行业务逻辑</span></span><br><span class="line">   }</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 只在获取锁成功时解锁</span></span><br><span class="line">   <span class="keyword">if</span> (isLocked) {</span><br><span class="line">      redLock.unlock();</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">redissonClient1.shutdown();</span><br><span class="line">redissonClient2.shutdown();</span><br><span class="line">redissonClient3.shutdown();</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">RedissonRedLock 的正确使用方法</p><ul><li>RedLock 算法的核心思想是在多个独立的 Redis 实例（不存在主从、集群关系，彼此互相隔离）上同时获取锁，从而保证分布式锁的高可用性和可靠性。即使某些 Redis 实例出现故障，只要在大多数实例（至少 <code>N/2 + 1</code> 个）中成功获取到锁，整个系统仍然可以认为锁是成功获取的（有效）。</li><li>因此，在使用 <code>RedissonRedLock</code> 时，强烈建议直接部署多个独立的 Redis 实例（不存在主从、集群关系，彼此互相隔离），或者多个独立 Redis 集群的 Master 节点，通常节点数量为奇数（比如 3 个或者 5 个），然后分别连接这些 Redis 节点，获取各自的 <code>RLock</code>，再组合成 <code>RedissonRedLock</code>。</li><li>使用 <code>RedissonRedLock</code> 时，千万不要依赖同一个 Redis 集群的多个 Maser 节点作为 RedLock 节点；因为同一个 Redis 集群的 Master 节点不是独立节点，由于使用分片存储方式，相同的 Key 永远只会落到同一个 Master 节点，因此不能满足 RedLock 的多数派原则，容易破坏分布式锁的强一致性。另一个更重要的原因是，集群内部发生故障转移（主从切换）期间可能会造成锁丢失。</li></ul></div><blockquote><p>在单个 Redis 集群中使用 <code>RedissonRedLock</code> 的问题</p></blockquote><p><strong>不建议在单个 Redis 集群中使用 <code>RedissonRedLock</code> 来保证强一致性和安全性，因为它无法达到设计目标，甚至可能比使用单个 Redis 节点或者 Redis 集群自身的锁机制（Redisson 的 <code>RLock</code>）更不安全。原因如下：</strong></p><ul><li><p>(1) RedLock 算法的核心前提是独立故障域：</p><ul><li>RedLock 的设计初衷是用于多个独立 Redis 节点的环境（例如，部署在不同物理机、不同机架、甚至不同数据中心的 3 个或 5 个单独的 Redis 实例，没有主从关系）。</li><li>它的安全性依赖于一个关键假设：这些节点是故障隔离的。一个节点失效（宕机、网络分区）不会立即或必然导致另一个节点也失效。</li></ul></li><li><p>(2) Redis 集群破坏了 “独立故障域” 的前提：</p><ul><li>比如，在 3 主 3 从 的 Redis 集群中：<ul><li>主节点之间是协作关系： 它们共同组成一个逻辑集群，通过 Gossip 协议通信共享集群状态。</li><li>主从节点是强关联的： 每个主节点都有对应的从节点。当主节点故障时，集群会自动进行故障转移，将其一个从节点提升为新的主节点，这个提升过程是自动且快速的。</li></ul></li><li>关键问题 - 故障转移期间的锁丢失（这是 RedLock 在集群环境下失效的核心原因）<ul><li>假设客户端 C1 成功使用 RedLock 在 3 个主节点（M1、M2、M3）上都获取了锁（满足 RedLock 的 <code>N/2 + 1</code> 原则）。</li><li>在 C1 持有锁期间，主节点 M1 发生故障。</li><li>集群检测到 M1 故障，触发故障转移。M1 的一个从节点（S1）被提升为新的主节点（称为 NewM1）。</li><li>问题在于：故障转移过程（特别是异步复制）可能导致 NewM1 上缺失 C1 在旧 M1 上设置的锁！<ul><li>如果 C1 在旧 M1 上设置的锁信息还没来得及复制到 S1，那么 NewM1 启动后就没有这个锁的记录。</li><li>即使旧 M1 上设置的锁复制到 NewM1 里面了，故障转移过程也可能导致短暂的数据不一致窗口。</li></ul></li><li>此时，另一个客户端 C2 尝试获取同一把锁。它使用 RedLock 向当前存活的主节点（NewM1、M2、M3）发起加锁请求。</li><li>C2 很可能在 NewM1（它上面没有旧锁记录）和另外两个节点中的至少一个（比如 M2）上成功获取锁，从而满足 RedLock 的 <code>N/2 + 1</code> 原则（例如 2/3）。这样，C1 和 C2 同时认为自己持有锁，导致分布式锁的互斥性被破坏！</li></ul></li></ul></li><li><p>(3) 集群网络分区（脑裂）问题加剧风险：</p><ul><li>如果发生网络分区，将集群分割成两个或多个无法通信的小分区。</li><li>每个小分区可能都认为自己拥有足够的主节点（满足 RedLock 的 <code>N/2 + 1</code> 原则），并允许客户端在不同分区内获取同一把锁，这种情况同样导致多个客户端同时获取到锁，导致分布式锁的互斥性被破坏。</li></ul></li><li><p>(4) 性能开销无意义：</p><ul><li>RedLock 需要在多个独立的 Redis 节点上顺序执行加锁操作，这本身就有显著性能开销。</li><li>在一个 Redis 集群内部使用 RedLock，这些操作本质上是跨节点通信，开销比在单个节点上加锁大很多，但却没有换来预期的安全性提升，得不偿失。</li></ul></li></ul><p><strong>Redis 集群自身的锁机制（Redisson 的 <code>RLock</code>）对比在单个 Redis 集群中使用 <code>RedissonRedLock</code>：</strong></p><ul><li>Redisson 的普通 <code>RLock</code> 对象（<code>redissonClient.getLock("myLock")</code>）在 Redis 集群模式下是安全可用的。</li><li>它的工作原理：<ul><li>(1) 客户端根据 Key 计算哈希槽。</li><li>(2) 将加锁请求发送到负责存储该哈希槽的主节点。</li><li>(3) 锁只存储在这个单个主节点上。</li><li>(4) 主节点会异步复制锁信息（<code>SET</code> 命令）给它的从节点。</li></ul></li><li>优点：简单、高效，利用了集群的分片和故障转移能力。</li><li>缺点：在极端故障场景下（主节点宕机且其锁信息未能复制到新提升的主节点），也存在短暂的锁丢失风险（与 RedLock 在集群下遇到的问题是类似的本质，但只发生在一个分片上）。然而，这种风险通常被认为是可接受的，并且比在单个 Redis 集群内错误使用 RedLock 导致必然的互斥性破坏要小得多、可控得多。</li><li>关键区别： Redis 集群模式下的 <code>RLock</code> 只依赖一个主节点，而在单个集群内使用的 RedLock 需要依赖多个主节点。但是，在单个 Redis 集群环境下，这多个主节点不是独立的故障域，故障转移机制使得依赖多个节点反而引入了额外的、更严重的失效点（即新主节点丢失旧锁）。</li></ul><p><strong>RedLock 算法的使用总结与建议：</strong></p><ul><li>绝对要避免在单个 Redis 集群内使用 <code>RedissonRedLock</code>：它无法提供比 Redis 集群自身的锁机制（Redisson 的 <code>RLock</code>）更好的安全性，反而会因为集群的自动故障转移特性，在高可用设计下引入更严重的锁互斥性破坏风险。</li><li>在单个 Redis 集群中，使用 Redisson 的普通 <code>RLock</code>（集群模式）： 这是正确且推荐的方式。它利用了 Redis 集群的分片和故障转移特性，提供了在集群环境下合理的高可用分布式锁。但需要理解并接受其在极端故障场景下（主节点崩溃 + 锁未被复制）存在理论上的短暂锁失效风险，但在实践中，结合合理的锁超时设置，这通常是可管理的风险。</li><li>RedLock 的正确使用场景：仅当拥有 N 个 (N 为奇数，通常 3 或 5) 完全独立部署、不存在主从关系、且物理 / 逻辑故障域隔离 的 Redis 节点 / 实例时，才应该考虑使用 RedLock。例如：<ul><li>3 个分别部署在独立虚拟机或物理机上的 Redis 单机实例。</li><li>3 个独立的 Redis Sentinel（比如，每个 Sentinel 都是一主多从，且都有自己的 Redis 主节点）。</li><li>3 个独立的 Redis Cluster（每个集群作为一个逻辑节点参与 RedLock，但这很复杂且通常不推荐，不如直接用独立实例）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">参考资料</p><ul><li><a target="_blank" rel="external nofollow" href="https://cloud.tencent.com/developer/article/2421423">使用 Redisson 实现分布式锁</a></li><li><a target="_blank" rel="external nofollow" href="https://cloud.tencent.com/developer/article/2376301">如何使用 Redisson 实现分布式锁</a></li><li><a target="_blank" rel="external nofollow" href="https://blog.51cto.com/universsky/6846798">Redis 实现分布式锁的方案和缺陷分析</a></li><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/cb1186512739/p/12802177.html">Redisson 的 RedissonRedLock（红锁）使用介绍</a></li></ul></div><h2 id="SpringBoot-整合-Redisson"><a href="#SpringBoot-整合-Redisson" class="headerlink" title="SpringBoot 整合 Redisson"></a>SpringBoot 整合 Redisson</h2><h3 id="引入-Maven-依赖"><a href="#引入-Maven-依赖" class="headerlink" title="引入 Maven 依赖"></a>引入 Maven 依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="添加-YML-配置信息"><a href="#添加-YML-配置信息" class="headerlink" title="添加 YML 配置信息"></a>添加 YML 配置信息</h3><ul><li>配置 Redis 的连接信息，包括主机地址、端口、密码等信息。</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></tbody></table></figure><h3 id="创建-Redission-配置类"><a href="#创建-Redission-配置类" class="headerlink" title="创建 Redission 配置类"></a>创建 Redission 配置类</h3><ul><li>创建 Redission 配置类，用于定义 Redission 的客户端。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.data.redis.RedisProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisssonConfig</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisProperties redisProperties;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(destroyMethod = "shutdown")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span> </span>{</span><br><span class="line">        String password = redisProperties.getPassword();</span><br><span class="line">        String url = String.format(<span class="string">"redis://%s:%s"</span>, redisProperties.getHost() + <span class="string">""</span>, redisProperties.getPort() + <span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(url).setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="单元测试代码"><a href="#单元测试代码" class="headerlink" title="单元测试代码"></a>单元测试代码</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 获取可重入锁</span></span><br><span class="line">        RLock lock = redissonClient.getLock(<span class="string">"rLock"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阻塞等待，直至获取到锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"==&gt; success to get locker"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a target="_blank" rel="external nofollow" href="https://cloud.tencent.com/developer/article/1841604">分布式锁中的王者方案 - Redisson</a></li><li><a target="_blank" rel="external nofollow" href="http://redis.cn/topics/distlock.html">Redis 分布式锁：关于使用 Redlock 算法的官方说明 (中文版)</a></li><li><a target="_blank" rel="external nofollow" href="https://redis.io/docs/manual/patterns/distributed-locks/">Redis 分布式锁：关于使用 Redlock 算法的官方说明 (英文版)</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/f838cf2a.html" title="Redisson 分布式锁使用教程">https://www.techgrow.cn/posts/f838cf2a.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag"><i class="fa fa-tag"></i> 微服务</a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 分布式</a><a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"><i class="fa fa-tag"></i> 缓存</a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 并发编程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/51ce4ef9.html" rel="prev" title="Redis 分布式锁中 Lua 脚本的使用"><i class="fa fa-angle-left"></i> Redis 分布式锁中 Lua 脚本的使用</a></div><div class="post-nav-item"> <a href="/posts/3644bd49.html" rel="next" title="JetBrains IDEA 2020.3.2 破解激活教程">JetBrains IDEA 2020.3.2 破解激活教程<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2026</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.4m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">35:49</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"/lib/mathjax/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/f838cf2a.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div><div id="moon-menu-item-code" class="moon-menu-item"><i class="fa-solid fa-code"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>