<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 从基础到进阶的内容。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 杂记之一从基础到进阶"><meta property="og:url" content="https://www.techgrow.cn/posts/332ad818.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 从基础到进阶的内容。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-08-10T13:55:33.000Z"><meta property="article:modified_time" content="2023-08-10T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.techgrow.cn/posts/332ad818.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/332ad818.html","path":"posts/332ad818.html","title":"C++ 杂记之一从基础到进阶"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 杂记之一从基础到进阶 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4-for"><span class="nav-text">范围 for</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4-for-%E6%A6%82%E5%BF%B5"><span class="nav-text">范围 for 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4-for-%E4%BD%BF%E7%94%A8"><span class="nav-text">范围 for 使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4-for-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">范围 for 适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4-for-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">范围 for 底层原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#auto-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">auto 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">auto 核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">auto 使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA"><span class="nav-text">auto 功能增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">auto 使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">constexpr 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E7%AE%80%E4%BB%8B"><span class="nav-text">constexpr 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E5%8F%98%E9%87%8F"><span class="nav-text">constexpr 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E5%87%BD%E6%95%B0"><span class="nav-text">constexpr 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">constexpr 构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">constexpr 应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">constexpr 使用注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97%E5%AF%B9%E6%AF%94"><span class="nav-text">constexpr 与相关关键字对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-C-%E4%BA%94%E5%A4%A7%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="nav-text">C/C++ 五大存储区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-%E4%B8%8E-free-%E4%BD%BF%E7%94%A8"><span class="nav-text">malloc 与 free 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">基础语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">使用案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E4%B8%8E-delete-%E4%BD%BF%E7%94%A8"><span class="nav-text">new 与 delete 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-1"><span class="nav-text">基础语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-1"><span class="nav-text">使用案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-%E5%92%8C-new-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">malloc 和 new 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-%E5%92%8C-delete-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">free 和 delete 的区别</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">751</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/332ad818.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 杂记之一从基础到进阶 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 从基础到进阶的内容。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 杂记之一从基础到进阶</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-08-10 21:55:33" itemprop="dateCreated datePublished" datetime="2023-08-10T21:55:33+08:00">2023-08-10</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/332ad818.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/332ad818.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.8k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>4 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/332ad818.html">C++ 杂记之一从基础到进阶</a></li><li><a href="/posts/68a580cf.html">C++ 杂记之二从基础到进阶</a></li></ul><h2 id="范围-for"><a href="#范围-for" class="headerlink" title="范围 for"></a>范围 for</h2><h3 id="范围-for-概念"><a href="#范围-for-概念" class="headerlink" title="范围 for 概念"></a>范围 for 概念</h3><p>C++ 的 范围 for 循环（Range-based for loop） 是 C++ 11 引入的一种简洁的遍历容器或数组的语法。</p><ul><li><p>特点：</p><ul><li>简洁，代码量少</li><li>自动推导类型（结合 <code>auto</code> 使用更方便）</li><li>无法直接获取索引（如果需要索引，还是用普通 <code>for</code>）</li></ul></li><li><p>适用：</p><ul><li>数组</li><li><code>vector</code>、<code>list</code>、<code>map</code> 等 STL 容器</li><li>自定义支持 <code>begin()</code> / <code>end()</code> 函数的类</li></ul></li></ul><span id="more"></span><h3 id="范围-for-使用"><a href="#范围-for-使用" class="headerlink" title="范围 for 使用"></a>范围 for 使用</h3><ul><li>基础语法</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型 变量名 : 容器或数组) {</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>遍历数组</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : arr) {</span><br><span class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>遍历容器</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = {<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : v) {</span><br><span class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>引用遍历（避免拷贝）- 如果元素是大对象，或需要修改元素，建议用引用</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = {<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;item : v) {</span><br><span class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>引用遍历（避免拷贝）- 如果不想修改元素但又不想拷贝，可以用 <code>const&amp;</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = {<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;item : v) {</span><br><span class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="范围-for-适用场景"><a href="#范围-for-适用场景" class="headerlink" title="范围 for 适用场景"></a>范围 for 适用场景</h3><table><thead><tr><th>适用场景</th><th>建议用法</th></tr></thead><tbody><tr><td>简单遍历</td><td><code>for (auto x : container)</code></td></tr><tr><td>遍历时需要修改元素</td><td><code>for (auto&amp; x : container)</code></td></tr><tr><td>遍历时保证不修改元素</td><td><code>for (const auto&amp; x : container)</code></td></tr></tbody></table><h3 id="范围-for-底层原理"><a href="#范围-for-底层原理" class="headerlink" title="范围 for 底层原理"></a>范围 for 底层原理</h3><ul><li>C++ 编译器会自动把范围 for 循环转换成类似以下形式：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = std::<span class="built_in">begin</span>(obj); it != std::<span class="built_in">end</span>(obj); ++it) {</span><br><span class="line">    <span class="keyword">auto</span> x = *it;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>所以要求容器或对象：<ul><li>是原生数组</li><li>或者支持 <code>begin()</code> 和 <code>end()</code> 函数（可以是成员函数，也可以是 <code>std::begin()</code> 和 <code>std::end()</code>）</li></ul></li></ul><h2 id="auto-关键字"><a href="#auto-关键字" class="headerlink" title="auto 关键字"></a>auto 关键字</h2><p><code>auto</code> 是 C++ 中的一个关键字，用于让编译器自动推导变量的类型（自动类型推导），从而使代码更简洁、灵活，减少重复声明类型的麻烦。它在 C++11 中首次引入，并在 C++14、C++17 中得到了进一步增强。</p><h3 id="auto-核心概念"><a href="#auto-核心概念" class="headerlink" title="auto 核心概念"></a>auto 核心概念</h3><ul><li><code>auto</code> 的基础语法： <code>auto 变量名 = 初始值;</code></li><li><code>auto</code> 可以根据初始化表达式，自动推导变量的类型，无需显式写出类型。</li><li><code>auto</code> 必须在声明时初始化，因为编译器需要通过初始值推导具体的类型。</li><li><code>auto</code> 的自动类型推导发生在编译期间，因此使用 <code>auto</code> 不会影响程序的运行效率。</li><li><code>auto</code> 支持泛型、模板编程等现代 C++ 风格，常用于范围 <code>for</code> 和 Lambda 表达式中。</li></ul><h3 id="auto-使用场景"><a href="#auto-使用场景" class="headerlink" title="auto 使用场景"></a>auto 使用场景</h3><ul><li>简单类型声明</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>简化复杂类型声明</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = myMap.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>();    <span class="comment">// 使用 auto 简洁很多</span></span><br></pre></td></tr></tbody></table></figure><ul><li>与范围 <code>for</code> 搭配使用</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> val : vec) {</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Lambda 表达式和模板返回值推导</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) { <span class="keyword">return</span> a + b; };</span><br></pre></td></tr></tbody></table></figure><h3 id="auto-功能增强"><a href="#auto-功能增强" class="headerlink" title="auto 功能增强"></a>auto 功能增强</h3><ul><li>C++14 的增强：<code>auto</code> 可以用于函数返回类型</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 返回类型自动推导为 int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>C++20 的增强：<code>auto</code> 可以用于范围推导（简化结构绑定）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="keyword">int</span>, std::string&gt; p = {<span class="number">1</span>, <span class="string">"hello"</span>};</span><br><span class="line"><span class="keyword">auto</span> [id, name] = p;</span><br></pre></td></tr></tbody></table></figure><h3 id="auto-使用注意事项"><a href="#auto-使用注意事项" class="headerlink" title="auto 使用注意事项"></a>auto 使用注意事项</h3><ul><li>必须在声明时初始化</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x;     <span class="comment">// 错误写法：没有初始值，编译器无法推导类型</span></span><br></pre></td></tr></tbody></table></figure><ul><li>推导的是值类型</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = x;</span><br><span class="line"><span class="keyword">auto</span> a = ref;       <span class="comment">// a 是 int，不是 int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; b = ref;      <span class="comment">// 若想保留引用，需要显式声明，b 是 int&amp;，会改变 x</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>const</code> 会被保留 / 去除</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = ci;   <span class="comment">// a 是 int，去掉了 const</span></span><br><span class="line"><span class="keyword">auto</span>&amp; b = ci;  <span class="comment">// b 是 const int&amp;，保留了 const</span></span><br></pre></td></tr></tbody></table></figure><h2 id="constexpr-关键字"><a href="#constexpr-关键字" class="headerlink" title="constexpr 关键字"></a>constexpr 关键字</h2><h3 id="constexpr-简介"><a href="#constexpr-简介" class="headerlink" title="constexpr 简介"></a>constexpr 简介</h3><p><code>constexpr</code> 是 C++ 11 引入的一个关键字，表示 <code>编译时常量表达式</code>。它用于指示编译器：一个变量、函数或构造函数的值可以在编译期间求值，从而实现更高效的代码（例如：避免运行时计算、提升性能、在模板中使用等）。</p><h3 id="constexpr-变量"><a href="#constexpr-变量" class="headerlink" title="constexpr 变量"></a>constexpr 变量</h3><ul><li><code>constexpr</code> 变量表示这个变量的值在编译时就已知，类似 <code>const</code>，但更强：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> size = <span class="number">10</span>;  <span class="comment">// 编译期常量</span></span><br><span class="line"><span class="keyword">int</span> arr[size];            <span class="comment">// 可以作为数组大小</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>constexpr</code> 区别于 <code>const</code>：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="built_in">rand</span>();       <span class="comment">// 编译通过，但不是编译期常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> b = <span class="built_in">rand</span>();   <span class="comment">// 编译失败，不是编译期常量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> c = <span class="number">3</span> + <span class="number">4</span>;    <span class="comment">// 编译通过，是编译期常量</span></span><br></pre></td></tr></tbody></table></figure><h3 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a>constexpr 函数</h3><ul><li><code>constexpr</code> 函数表示用于定义可以在编译期执行的函数，在 C++ 11 中其定义规则：(1) 函数体必须只有一个 <code>return</code> 表达式； (2) 所有参数和调用都必须是常量表达式；</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="built_in">square</span>(<span class="number">4</span>)];  <span class="comment">// 编译通过，square(4) 在编译期间计算结果为 16</span></span><br></pre></td></tr></tbody></table></figure><ul><li>从 C++ 14 开始，<code>constexpr</code> 函数可以有：多条语句、条件判断（<code>if</code>）、循环（<code>for</code>、<code>while</code>）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14 及以后支持的写法</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">        res *= i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="constexpr-构造函数"><a href="#constexpr-构造函数" class="headerlink" title="constexpr 构造函数"></a>constexpr 构造函数</h3><p>从 C++ 11 开始，可以将一个类的构造函数定义为 <code>constexpr</code>，使得该类可以在编译期构造对象：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x_, <span class="keyword">int</span> y_)</span> : x(x_), y(y_) {</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;  <span class="comment">// p1 为编译期对象</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="constexpr-应用场景"><a href="#constexpr-应用场景" class="headerlink" title="constexpr 应用场景"></a>constexpr 应用场景</h3><table><thead><tr><th>场景</th><th>用途</th></tr></thead><tbody><tr><td>定义静态数组大小</td><td><code>constexpr int size = 100; int arr[size];</code></td></tr><tr><td>作为模板参数</td><td><code>template&lt;int N&gt; struct Array {}</code></td></tr><tr><td>提高性能</td><td>避免运行时计算，提升速度</td></tr><tr><td><code>switch</code> 中使用</td><td><code>case square(3):</code></td></tr><tr><td>元编程</td><td>与 <code>template</code>、<code>type_traits</code> 等结合实现复杂编译期计算</td></tr></tbody></table><h3 id="constexpr-使用注意事项"><a href="#constexpr-使用注意事项" class="headerlink" title="constexpr 使用注意事项"></a>constexpr 使用注意事项</h3><ul><li><code>constexpr</code> 不等于 “只在编译期计算”，它也可以在运行期使用，只是如果传入常量，它可以在编译期计算。</li><li>从 C++ 20 起，<code>constexpr</code> 支持的功能更强，几乎可用于所有逻辑控制（包括 <code>try/catch</code> 限制性支持）。</li><li><code>constexpr</code> 与 <code>consteval</code>、<code>constinit</code> 是不同的概念（见下表）。</li></ul><h3 id="constexpr-与相关关键字对比"><a href="#constexpr-与相关关键字对比" class="headerlink" title="constexpr 与相关关键字对比"></a>constexpr 与相关关键字对比</h3><table><thead><tr><th>关键字</th><th>引入版本</th><th>含义</th></tr></thead><tbody><tr><td><code>const</code></td><td>C++ 98</td><td> 值不可变（可用于编译期或运行期常量）</td></tr><tr><td><code>constexpr</code></td><td>C++ 11</td><td> 编译期可求值的常量或函数（从 C++ 14 开始支持更复杂的函数体）</td></tr><tr><td><code>consteval</code></td><td>C++ 20</td><td> 必须在编译期计算的函数（调用时就会被立即求值）</td></tr><tr><td><code>constinit</code></td><td>C++ 20</td><td> 保证用于初始化 <code>static</code> 或 <code>thread_local</code> 变量时没有静态初始化顺序问题</td></tr></tbody></table><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><div class="admonition note"><p class="admonition-title">野指针、悬空指针、裸指针</p><ul><li><code>野指针（Wild Pointer）</code>：指向一块未初始化或非法内存区域的指针，一旦访问就有可能触发未定义行为。</li><li><code>悬空指针（Dangling Pointer）</code>：指针仍然指向一块已被释放或无效的内存区域，一旦访问就有可能触发未定义行为。</li><li><code>裸指针（Raw Pointer）</code>：普通的 C/C++ 指针，直接指向有效的内存，但不具备自动内存管理能力（非智能指针），也没有生命周期约束，比如平常写的这种指针 <code>int *p = new int(42);</code> 就是裸指针。</li></ul></div><h3 id="C-C-五大存储区"><a href="#C-C-五大存储区" class="headerlink" title="C/C++ 五大存储区"></a>C/C++ 五大存储区</h3><blockquote><p>C/C++ 程序的存储区有以下几个：</p></blockquote><ul><li><p>程序代码区（Text Segment）</p><ul><li>作用：<ul><li>存放程序的机器指令（代码）</li></ul></li><li>特点：<ul><li>只读（防止程序自修改）</li><li>多个进程可以共享（操作系统支持代码段共享）</li></ul></li></ul></li><li><p>常量存储区（RODATA Segment）</p><ul><li>存放：<ul><li>字符串常量</li><li><code>const</code> 修饰的全局常量（在一些编译器实现中）</li></ul></li><li>特点：<ul><li>只读（通常有内存保护）</li><li>与 <code>.data</code> 段分开，防止误修改</li><li>注意：局部 <code>const</code> 变量通常在栈上分配，但全局 <code>const</code> 变量可能分配在常量区</li></ul></li></ul></li><li><p>全局 / 静态存储区（Data Segment）</p><ul><li>已初始化全局 / 静态区（<code>.data</code> 段）<ul><li>存放：已初始化的全局变量、静态变量</li><li>生命周期：程序运行整个过程，程序结束时由系统自动释放</li></ul></li><li>未初始化全局 / 静态区（<code>.bss</code> 段）<ul><li>存放：未初始化的全局变量、静态变量</li><li>系统会自动初始化为 0 或 NULL</li></ul></li></ul></li><li><p> 堆（Heap）</p><ul><li>用途：<ul><li>程序运行时动态分配内存</li></ul></li><li>分配：<ul><li>C 语言：<code>malloc()</code> / <code>free()</code></li><li>C++：<code>new</code> / <code>delete</code></li></ul></li><li>特点：<ul><li>程序员手动分配和释放内存（忘记释放会造成内存泄漏）</li><li>灵活，但效率比栈稍低</li></ul></li></ul></li><li><p>栈（Stack）</p><ul><li>存放：<ul><li>局部变量（非 <code>static</code>）</li><li>函数参数、返回地址、临时变量</li></ul></li><li>特点：<ul><li>由编译器自动分配和释放内存</li><li>后进先出（LIFO）</li><li>每个线程有独立栈空间</li><li>栈空间有限，过大可能导致 栈溢出</li></ul></li></ul></li></ul><blockquote><p>C/C++ 程序各个存储区的布局</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">地址低</span><br><span class="line">  ↓</span><br><span class="line">+-----------------------------+</span><br><span class="line">|      程序代码区（.text）    |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|      常量区（.rodata）      |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|   已初始化全局变量（.data）  |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|   未初始化全局变量（.bss）  |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|            堆               |</span><br><span class="line">| （向上增长，从低地址开始）   |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|            栈               |</span><br><span class="line">| （向下增长，从高地址开始）   |</span><br><span class="line">+-----------------------------+</span><br><span class="line">  ↑</span><br><span class="line">地址高</span><br></pre></td></tr></tbody></table></figure><blockquote><p>C/C++ 程序各个存储区的对比</p></blockquote><table><thead><tr><th>区域</th><th>主要内容</th><th>生命周期</th><th>典型分配方式</th></tr></thead><tbody><tr><td>程序代码区</td><td>可执行代码</td><td>程序运行期间</td><td>编译生成</td></tr><tr><td>常量区（RODATA）</td><td>字符串字面量、常量</td><td>程序运行期间</td><td>编译生成</td></tr><tr><td>静态区（Data / BSS）</td><td>全局变量、静态变量</td><td>程序运行期间</td><td>编译生成</td></tr><tr><td>栈</td><td>局部变量、函数调用信息</td><td>函数调用时分配，调用结束时释放</td><td>自动管理</td></tr><tr><td>堆</td><td>动态分配内存</td><td>程序员控制，包括 <code>new</code>/<code>delete</code>、<code>malloc()</code>/<code>free()</code></td><td>手动管理</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><p>C 语言和 C++ 程序都有上面五大存储区，但它们的使用方式和细节略有不同。</p></div><h3 id="malloc-与-free-使用"><a href="#malloc-与-free-使用" class="headerlink" title="malloc 与 free 使用"></a>malloc 与 free 使用</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><ul><li><p><code>malloc()</code> 动态分配内存</p><ul><li>函数原型：<code>void* malloc(size_t size);</code></li><li>参数：<code>size</code> 是要分配的字节数</li><li>返回：返回 <code>void*</code> 指针，指向新分配的内存</li><li>在 C++ 中，返回值需要强制类型转换为目标类型</li></ul></li><li><p><code>free()</code> 释放内存</p><ul><li>函数原型：<code>void free(void* ptr);</code></li><li>参数：<code>ptr</code> 是 <code>malloc()</code> 返回的指针</li><li>作用：释放指定的内存，防止内存泄漏</li></ul></li></ul><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><ul><li>为 <code>int</code> 数组动态分配内存</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>为 <code>char</code> 数组动态分配内存</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *c = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">20</span>;</span><br><span class="line">c = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="keyword">if</span> (c != <span class="literal">nullptr</span>) {</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, size);    <span class="comment">// 建议初始化内存（防止访问越界），char 类型值为 0 时，就等于 '\0' 字符</span></span><br><span class="line">    <span class="built_in">strcpy</span>(c, <span class="string">"hello world"</span>);</span><br><span class="line">    std::cout &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="new-与-delete-使用"><a href="#new-与-delete-使用" class="headerlink" title="new 与 delete 使用"></a>new 与 delete 使用</h3><h4 id="基础语法-1"><a href="#基础语法-1" class="headerlink" title="基础语法"></a>基础语法</h4><ul><li><p>new 的基础语法</p><ul><li>(1) <code>指针变量名 = new 类型标识符</code>，比如 <code>int *p = new int;</code>，分配一个 <code>int</code> 类型的内存，但未初始化，值是未定义的。</li><li>(2) <code>指针变量名 = new 类型标识符(初始值)</code>，比如 <code>int *p = new int(3);</code>，分配一个 <code>int</code> 类型的内存，并将值初始化为 3。</li><li>(3) <code>指针变量名 = new 类型标识符[内存单元个数]</code>，比如 <code>int *arr = new int[5];</code>，分配一个包含 5 个 <code>int</code> 类型的数组，未初始化（值未定义）。</li></ul></li><li><p>delete 基础语法</p><ul><li>(1) <code>delete 指针变量名</code>，释放指针内存。</li><li>(2) <code>delete[] 指针变量名</code>，释放数组内存。</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li><code>new</code> 与 <code>delete</code> 必须结对使用；使用 <code>new[]</code> 申请的内存，必须使用 <code>delete[]</code> 释放内存。</li><li><code>delete</code> 不能重复调用，否则会引发未定义行为；正确做法是调用 <code>delete</code> 后将指针设为 <code>nullptr</code>，当 <code>ptr == nullptr</code> 时，<code>delete ptr;</code> 是安全的，不会做任何操作。</li></ul></div><h4 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h4><ul><li>使用案例一</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;               <span class="comment">// 分配一个int类型的内存，但未初始化，值是未定义的</span></span><br><span class="line">*p = <span class="number">5</span>;                         <span class="comment">// 手动赋值</span></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;   <span class="comment">// 输出：5</span></span><br><span class="line"><span class="keyword">delete</span> p;                       <span class="comment">// 释放内存</span></span><br><span class="line">p = <span class="literal">nullptr</span>;                    <span class="comment">// 避免悬空指针</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用案例二</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">3</span>);            <span class="comment">// 分配一个int类型的内存，并初始化为3</span></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;   <span class="comment">// 输出：3</span></span><br><span class="line"><span class="keyword">delete</span> p;                       <span class="comment">// 释放内存</span></span><br><span class="line">p = <span class="literal">nullptr</span>;                    <span class="comment">// 避免悬空指针</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用案例三</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"A constructor: "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">A *obj = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">10</span>);  <span class="comment">// 调用 A 的构造函数</span></span><br><span class="line"><span class="keyword">delete</span> obj;</span><br><span class="line">obj = <span class="literal">nullptr</span>;  <span class="comment">// 避免悬空指针</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用案例四</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];  <span class="comment">// 分配一个包含5个int的数组，未初始化（值未定义）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">    arr[i] = i * <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">    std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;  <span class="comment">// 输出：0 10 20 30 40</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] arr;   <span class="comment">// 必须用 delete[] 释放数组内存</span></span><br><span class="line">arr = <span class="literal">nullptr</span>;  <span class="comment">// 避免悬空指针</span></span><br></pre></td></tr></tbody></table></figure><h3 id="malloc-和-new-的区别"><a href="#malloc-和-new-的区别" class="headerlink" title="malloc 和 new 的区别"></a>malloc 和 new 的区别</h3><ul><li><p><code>new</code></p><ul><li>C++ 中的运算符（<code>operator new</code>），用于按类型动态分配内存。</li><li>底层同样是调用 <code>malloc()</code> 函数开辟内存，但还会调用类对象的构造函数（如果是类对象）进行初始化。</li><li>返回值是对应类型的指针，不需要强制类型转换。</li><li>开辟内存失败时，会抛出 <code>std::bad_alloc</code> 异常。</li></ul></li><li><p><code>malloc</code></p><ul><li>C 语言中的标准库函数，用于按字节动态分配内存。</li><li>不会初始化分配的内存，也不会调用类对象的构造函数（如果分配的内存是用于类对象）。</li><li>返回值是 <code>void *</code>，需要强制类型转换。</li><li>开辟内存失败时，返回 <code>nullptr</code>（或 C 中返回 <code>NULL</code>），需要手动检查。</li></ul></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>所属语言</td><td> C / C++</td><td>C++ 专用</td></tr><tr><td>本质</td><td>库函数（在 <code>&lt;cstdlib&gt;</code> 中）</td><td>运算符（可重载）</td></tr><tr><td>内存分配方式</td><td>按字节动态分配内存</td><td>按类型动态分配内存</td></tr><tr><td>返回值</td><td>返回 <code>void *</code>，需强制类型转换</td><td>返回对应类型的指针，无需类型转换</td></tr><tr><td>是否调用构造函数</td><td>❌ 不会调用构造函数</td><td>✅ 会调用构造函数</td></tr><tr><td>是否调用析构函数</td><td>❌ <code>free</code> 不会调用析构函数</td><td>✅ <code>delete</code> 调用析构函数</td></tr><tr><td>失败时的行为</td><td>返回 <code>nullptr</code>（或 C 中返回 <code>NULL</code>），需手动检查</td><td>抛出 <code>std::bad_alloc</code> 异常</td></tr><tr><td>是否可重载</td><td>❌ 不可重载</td><td>✅ 可重载 <code>operator new</code>、<code>operator delete</code></td></tr><tr><td>对象初始化</td><td>❌ 不支持</td><td>✅ 自动调用构造函数来初始化对象</td></tr><tr><td>释放方式</td><td>使用 <code>free(ptr)</code> 释放内存</td><td>使用 <code>delete ptr</code> 或 <code>delete[] ptr</code> 释放内存</td></tr></tbody></table><h3 id="free-和-delete-的区别"><a href="#free-和-delete-的区别" class="headerlink" title="free 和 delete 的区别"></a>free 和 delete 的区别</h3><ul><li><p><code>delete</code> 的概述</p><ul><li><code>delete</code> 操作符用于释放通过 <code>new</code> 分配的内存。</li><li>在释放内存之前，<code>delete</code> 会先调用类对象的析构函数，以确保资源（如文件句柄、网络连接等）正确释放。</li><li>如果分配的是数组，必须使用 <code>delete[]</code>，否则可能会导致未定义行为。</li></ul></li><li><p><code>free</code> 的概述</p><ul><li><code>free</code> 是 C 标准库函数，用于释放通过 <code>malloc/calloc/realloc</code> 分配的内存。</li><li>它只会释放内存，不会执行任何其他操作，例如对象的析构。</li></ul></li><li><p><code>delete</code> 与 <code>free</code> 不能混用</p><ul><li>通过 <code>new</code> 分配的内存必须用 <code>delete</code> 释放，不能用 <code>free</code>，否则可能会导致未定义行为。</li><li>通过 <code>malloc</code> 分配的内存必须用 <code>free</code> 释放，不能用 <code>delete</code>，否则可能会导致未定义行为。</li></ul></li><li><p><code>delete</code> 与 <code>free</code> 的内存布局和管理差异</p><ul><li><code>new</code> 和 <code>delete</code> 是 C++ 的操作符，它们了解对象的类型，并能为复杂类型的构造和析构做出正确的处理。</li><li><code>malloc</code> 和 <code>free</code> 是 C 的函数，它们只分配和释放内存，不了解对象的类型。</li></ul></li></ul><table><thead><tr><th>特性</th><th><code>delete</code></th><th><code>free</code></th></tr></thead><tbody><tr><td>适用语言</td><td> C++ 专用</td><td> C 和 C++</td></tr><tr><td> 适用对象</td><td>动态分配的对象（通过 <code>new</code> 分配）</td><td>动态分配的内存块（通过 <code>malloc/calloc/realloc</code> 分配）</td></tr><tr><td>是否调用析构函数</td><td>会调用类对象的析构函数</td><td>只释放内存，不调用类对象的析构函数</td></tr><tr><td>分配与释放的匹配要求</td><td>必须和 <code>new</code> 成对使用</td><td>必须和 <code>malloc/calloc/realloc</code> 成对使用</td></tr><tr><td>数组释放</td><td>使用 <code>delete[]</code> 释放动态数组</td><td>没有专门的数组释放功能</td></tr><tr><td>底层机制</td><td> C++ 的运行时库负责，处理更高级的资源管理</td><td> C 的运行时库负责，直接释放内存</td></tr></tbody></table><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/332ad818.html" title="C++ 杂记之一从基础到进阶">https://www.techgrow.cn/posts/332ad818.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/308cedc0.html" rel="prev" title="SpringBoot 3 进阶教程之四自定义 Starter"><i class="fa fa-angle-left"></i> SpringBoot 3 进阶教程之四自定义 Starter</a></div><div class="post-nav-item"> <a href="/posts/cdbde47c.html" rel="next" title="Debian 安装 JDK">Debian 安装 JDK<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2.2m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">32:44</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/332ad818.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>