<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Kafka 的使用教程。"><meta property="og:type" content="article"><meta property="og:title" content="Kafka 入门教程之五"><meta property="og:url" content="https://www.techgrow.cn/posts/ed9d5bd.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 Kafka 的使用教程。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-update-configs.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-producer-optimize-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-producer-optimize-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/11/message-queue-order-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2023/12/kafka-producer-9.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-producer-optimize-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-producer-optimize-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-consumer-optimize-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-consumer-optimize-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-consumer-optimize-3.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/11/kafka-consumer-18.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-consumer-optimize-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-consumer-optimize-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-global-optimize-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/12/kafka-global-optimize-2.png"><meta property="article:published_time" content="2022-09-08T14:13:45.000Z"><meta property="article:modified_time" content="2022-09-08T14:13:45.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="分布式"><meta property="article:tag" content="消息队列"><meta property="article:tag" content="大数据"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2024/12/kafka-update-configs.png"><link rel="canonical" href="https://www.techgrow.cn/posts/ed9d5bd.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/ed9d5bd.html","path":"posts/ed9d5bd.html","title":"Kafka 入门教程之五"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Kafka 入门教程之五 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90"><span class="nav-text">学习资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%BC%8F"><span class="nav-text">Kafka 配置更新模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%B0%83%E4%BC%98"><span class="nav-text">Kafka 生产环境调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E9%85%8D%E7%BD%AE%E9%80%89%E6%8B%A9"><span class="nav-text">硬件配置选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E"><span class="nav-text">业务场景说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E9%87%8F%E9%80%89%E6%8B%A9"><span class="nav-text">服务器数量选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E9%80%89%E6%8B%A9"><span class="nav-text">磁盘选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E9%80%89%E6%8B%A9"><span class="nav-text">CPU 选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%A9"><span class="nav-text">网络选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%80%89%E6%8B%A9"><span class="nav-text">内存选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%9F%A5%E7%9C%8B"><span class="nav-text">堆内存查看</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E8%B0%83%E6%95%B4"><span class="nav-text">堆内存调整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E7%BC%93%E5%AD%98%E4%BC%B0%E7%AE%97"><span class="nav-text">页缓存估算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E8%B0%83%E4%BC%98"><span class="nav-text">Kafka 生产者调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-text">生产者的核心参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">生产者提高吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-text">生产者保证数据可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-text">生产者保证数据有序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E9%81%BF%E5%85%8D%E5%8D%95%E5%88%86%E5%8C%BA%E4%B9%B1%E5%BA%8F"><span class="nav-text">生产者避免单分区乱序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81"><span class="nav-text">生产者避免消息重复发送</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%BC%80%E5%90%AF%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-text">生产者开启幂等性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">生产者使用事务机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-Broker-%E8%B0%83%E4%BC%98"><span class="nav-text">Kafka Broker 调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Broker-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-text">Broker 的核心参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Broker-%E6%9C%8D%E5%BD%B9%E6%96%B0%E8%8A%82%E7%82%B9"><span class="nav-text">Broker 服役新节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Broker-%E9%80%80%E5%BD%B9%E6%97%A7%E8%8A%82%E7%82%B9"><span class="nav-text">Broker 退役旧节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Broker-%E5%A2%9E%E5%8A%A0%E5%88%86%E5%8C%BA%E6%95%B0%E9%87%8F"><span class="nav-text">Broker 增加分区数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Broker-%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98"><span class="nav-text">Broker 自动创建主题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E6%B6%88%E8%B4%B9%E8%80%85%E8%B0%83%E4%BC%98"><span class="nav-text">Kafka 消费者调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-text">消费者的核心参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">消费者提高吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">消费者分区再平衡的优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E6%95%B4%E4%BD%93%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-text">Kafka 整体性能调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E6%95%B4%E4%BD%93%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">提高整体吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B2%BE%E7%A1%AE%E4%B8%80%E6%AC%A1"><span class="nav-text">数据精确一次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%E5%88%86%E5%8C%BA%E6%95%B0%E9%87%8F"><span class="nav-text">合理设置分区数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%9D%A1%E6%B6%88%E6%81%AF%E5%A4%A7%E4%BA%8E-1M"><span class="nav-text">单条消息大于 1M</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Broker-%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA"><span class="nav-text">Broker 节点宕机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka-%E9%9B%86%E7%BE%A4%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="nav-text">Kafka 集群压力测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="nav-text">生产者压力测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="nav-text">消费者压力测试</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">677</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/ed9d5bd.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Kafka 入门教程之五 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 Kafka 的使用教程。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Kafka 入门教程之五</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-09-08 22:13:45" itemprop="dateCreated datePublished" datetime="2022-09-08T22:13:45+08:00">2022-09-08</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/ed9d5bd.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/ed9d5bd.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>12k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>11 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/b6be8183.html">Kafka 入门教程之一</a>、<a href="/posts/60ddcede.html">Kafka 入门教程之二</a>、<a href="/posts/228158d3.html">Kafka 入门教程之三</a></li><li><a href="/posts/c61757ff.html">Kafka 入门教程之四</a>、<a href="/posts/ed9d5bd.html">Kafka 入门教程之五</a>、<a href="/posts/e73bffc6.html">Kafka 入门教程之六</a></li><li><a href="/posts/50c7d080.html">Kafka 入门教程之七</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li><a target="_blank" rel="external nofollow" href="https://kafka.apache.org/documentation/">Kafka 官方文档</a></li><li><a href="/posts/ac64f898.html">Kafka 学习路线</a></li></ul><span id="more"></span><h2 id="Kafka-配置更新模式"><a href="#Kafka-配置更新模式" class="headerlink" title="Kafka 配置更新模式"></a>Kafka 配置更新模式</h2><p>在 Kafka <a target="_blank" rel="external nofollow" href="https://kafka.apache.org/documentation/#dynamicbrokerconfigs">官方文档</a> 中，提到 Kafka 的配置更新有三种模式，如下所示：</p><p><img data-src="../../../asset/2024/12/kafka-update-configs.png"></p><p>从 Kafka 的 <code>1.1</code> 版本开始，一些 Broker 配置可以在无需重启 Broker 的情况下进行更新。可以参考 <a target="_blank" rel="external nofollow" href="https://kafka.apache.org/documentation/#brokerconfigs">Broker Configs</a> 中的 <code>Dynamic Update Mode</code>（动态更新模式），了解每个 Broker 配置的更新模式。</p><ul><li><strong>read-only（只读）</strong>：需要重启 Broker 才能更新配置。</li><li><strong>per-broker（单个 Broker 动态更新）</strong>：可以为每个 Broker 动态更新配置，不需要重启 Broker。</li><li><strong>cluster-wide（集群范围动态更新）</strong>：可以作为集群范围的默认值动态更新，也可以为单个 Broker 设置不同的值（例如用于测试），不需要重启 Broker。</li></ul><h2 id="Kafka-生产环境调优"><a href="#Kafka-生产环境调优" class="headerlink" title="Kafka 生产环境调优"></a>Kafka 生产环境调优</h2><h3 id="硬件配置选择"><a href="#硬件配置选择" class="headerlink" title="硬件配置选择"></a>硬件配置选择</h3><h4 id="业务场景说明"><a href="#业务场景说明" class="headerlink" title="业务场景说明"></a>业务场景说明</h4><ul><li>每天的数据量：100 万日活，每人每天 100 条日志，每天总共的日志条数是 100 万 * 100 条 = 1 亿条（中型规模的公司）。</li><li>每秒钟的日志条数：1 亿 / 24 小时 / 60 分 / 60 秒 = 1150 条 / 每秒钟。</li><li>每条日志的大小：0.5k ~ 2k（取 1k）。</li><li>每天的数据大小：1 亿条 * 1k ≈ 100g。</li><li>每秒钟的数据量：1150 条 / 每秒钟 * 1k ≈ 1m/s。</li><li>高峰期每秒钟的日志条数：1150 条 * 20 倍 = 23000 条。</li><li>高峰期每秒钟的数据量：20MB/s。</li></ul><h4 id="服务器数量选择"><a href="#服务器数量选择" class="headerlink" title="服务器数量选择"></a>服务器数量选择</h4><ul><li>计算公式：服务器数量 = 2 * (生产者每秒钟的峰值生产速率 * 副本数量 / 100) + 1</li><li> 比如：3 台 = 2 * (20m/s * 2 / 100) + 1</li></ul><h4 id="磁盘选择"><a href="#磁盘选择" class="headerlink" title="磁盘选择"></a>磁盘选择</h4><ul><li>Kafka 底层主要是顺序写，固态硬盘和机械硬盘的顺序写速度差不多，建议选择普通的机械硬盘。</li><li>每天的数据大小：1 亿条 * 1k ≈ 100g。</li><li>每天的总数据大小：100g * 2 个副本 * 日志保存时间 3 天 / 磁盘使用率 0.7 ≈ 1T。</li><li>根据以上计算结果，建议三台服务器的硬盘总大小大于等于 1T。</li></ul><h4 id="CPU-选择"><a href="#CPU-选择" class="headerlink" title="CPU 选择"></a>CPU 选择</h4><ul><li><code>num.io.threads = 8</code>：负责写磁盘的线程数量，这个参数要占 CPU 总核数的 50%。</li><li><code>num.replica.fetchers = 1</code>：副本同步时用于拉取数据的线程数量，这个参数占 CPU 总核数的 50% 的 1/3。</li><li><code>num.network.threads = 3</code>：处理网络请求的线程数量，这个参数占 CPU 总核数的 50% 的 2/3。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>建议使用 32 核的 CPU，这样可以最大程度地发挥 Kafka 的性能。</p></div><h4 id="网络选择"><a href="#网络选择" class="headerlink" title="网络选择"></a>网络选择</h4><ul><li>选择千兆网卡即可。</li><li>网络带宽 = 峰值吞吐量 ≈ 20MB/s。</li><li>100Mbps 的单位是 bit；1byte = 8bit；10M/s 的单位是 byte；100Mbps/8 = 12.5M/s。</li><li>一般百兆的网卡（100Mbps）、千兆的网卡（1000Mbps）、万兆的网卡（10000Mbps）。</li></ul><h4 id="内存选择"><a href="#内存选择" class="headerlink" title="内存选择"></a>内存选择</h4><div class="admonition note"><p class="admonition-title">提示</p><p>Kafka 的内存组成：堆内存（Kafka 内部配置） + 页缓存（操作系统内存）。</p></div><h5 id="堆内存查看"><a href="#堆内存查看" class="headerlink" title="堆内存查看"></a>堆内存查看</h5><ul><li>查看 Kafka 的进程号</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">58882 Kafka</span><br><span class="line">5255 Jps</span><br><span class="line">1931 QuorumPeerMain</span><br></pre></td></tr></tbody></table></figure><ul><li>根据 Kafka 进程号，查看 Kafka 的 GC 情况</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 58882 1s 10</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  15360.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  15360.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  15360.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  15360.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  15360.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  15360.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  16384.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  16384.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  16384.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br><span class="line">0.0   2048.0  0.0   1515.7 53248.0  16384.0   993280.0   145686.5  36032.0 35748.0 4160.0 4020.3      4    0.033   0      0.000    0.033</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td> S0C</td><td> 第一个幸存区的大小</td></tr><tr><td> S1C</td><td> 第二个幸存区的大小</td></tr><tr><td> S0U</td><td> 第一个幸存区的使用大小</td></tr><tr><td> S1U</td><td> 第二个幸存区的使用大小</td></tr><tr><td> EC</td><td> 伊甸园区的大小</td></tr><tr><td> EU</td><td> 伊甸园区的使用大小</td></tr><tr><td> OC</td><td> 老年代大小</td></tr><tr><td> OU</td><td> 老年代使用大小</td></tr><tr><td> MC</td><td> 方法区大小</td></tr><tr><td> MU</td><td> 方法区使用大小</td></tr><tr><td> CCSC</td><td> 压缩类空间大小</td></tr><tr><td> CCSU</td><td> 压缩类空间使用大小</td></tr><tr><td> YGC</td><td> 年轻代垃圾回收次数</td></tr><tr><td> YGCT</td><td> 年轻代垃圾回收消耗时间</td></tr><tr><td> FGC</td><td> 老年代垃圾回收次数</td></tr><tr><td> FGCT</td><td> 老年代垃圾回收消耗时间</td></tr><tr><td> GCT</td><td> 垃圾回收消耗总时间</td></tr></tbody></table><ul><li>根据 Kafka 进程号，查看 Kafka 的堆内存信息</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 较低版本的 JDK（比如 JDK 8）</span></span><br><span class="line">$ jmap -heap 58882</span><br><span class="line"></span><br><span class="line"><span class="comment"># 较高版本的 JDK（比如 JDK 11）</span></span><br><span class="line">$ jhsdb jmap --heap --pid 58882</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 58882, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 1.8.0_361-b09</span><br><span class="line"></span><br><span class="line">using parallel threads in the new generation.</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 8 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 4294967296 (4096.0MB)</span><br><span class="line">   NewSize                  = 268435456 (256.0MB)</span><br><span class="line">   MaxNewSize               = 1431306240 (1365.0MB)</span><br><span class="line">   OldSize                  = 543948800 (518.75MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   PermSize                 = 67108864 (64.0MB)</span><br><span class="line">   MaxPermSize              = 268435456 (256.0MB)</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 1530920960 (1460.0MB)</span><br><span class="line">   used     = 322122560 (307.0MB)</span><br><span class="line">   free     = 1208798400 (1153.0MB)</span><br><span class="line">   21.0% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 255852544 (244.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 255852544 (244.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 255852544 (244.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 255852544 (244.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 2348810240 (2240.0MB)</span><br><span class="line">   used     = 1610612736 (1536.0MB)</span><br><span class="line">   free     = 738197504 (704.0MB)</span><br><span class="line">   68.6% used</span><br><span class="line"></span><br><span class="line">50449 interned Strings occupying 4156344 bytes.</span><br></pre></td></tr></tbody></table></figure><p>Heap Configuration（堆内存的配置）的参数说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td> MinHeapFreeRatio</td><td> 堆中空闲空间的最小比率。</td></tr><tr><td>MaxHeapFreeRatio</td><td> 堆中空闲空间的最大比率。</td></tr><tr><td>MaxHeapSize</td><td> 堆的最大大小。</td></tr><tr><td>NewSize</td><td> 年轻代的初始大小。</td></tr><tr><td>MaxNewSize</td><td> 年轻代的最大大小。</td></tr><tr><td>OldSize</td><td> 老年代的初始大小。</td></tr><tr><td>NewRatio</td><td> 年轻代与老年代容量的比率。</td></tr><tr><td>SurvivorRatio</td><td>Eden 区与 Survivor 区容量的比率。</td></tr><tr><td>PermSize</td><td> 永久代的初始大小（适用于 Java 8 及之前）。</td></tr><tr><td>MaxPermSize</td><td> 永久代的最大大小（适用于 Java 8 及之前）。</td></tr><tr><td>G1HeapRegionSize</td><td>G1 垃圾回收器的堆区域大小（如果使用 G1 收集器）。</td></tr></tbody></table><p>Heap Usage（堆内存的使用情况）的参数说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td> PS Young Generation</td><td> 年轻代的堆使用情况。</td></tr><tr><td>Eden Space</td><td>Eden 区的容量、已用空间和空闲空间。</td></tr><tr><td>From Space</td><td>From Survivor 区的容量、已用空间和空闲空间。</td></tr><tr><td>To Space</td><td>To Survivor 区的容量、已用空间和空闲空间。</td></tr><tr><td>PS Old Generation</td><td> 老年代的堆使用情况。</td></tr><tr><td>Capacity (Old Generation)</td><td> 老年代的总容量。</td></tr><tr><td>Used (Old Generation)</td><td> 老年代的已用空间。</td></tr><tr><td>Free (Old Generation)</td><td> 老年代的空闲空间。</td></tr></tbody></table><p>Interned Strings 的参数说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td> String Count</td><td> 输出 JVM 中字符串池中缓存的字符串数量。</td></tr><tr><td>Total Size</td><td> 字符串池中缓存字符串的总大小（以字节为单位）。</td></tr></tbody></table><ul><li>或者使用 <code>jcmd</code> 工具，查看 Kafka 的堆内存信息</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 58882 GC.heap_info</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">garbage-first heap   total 1048576K, used 185072K [0x00000000c0000000, 0x0000000100000000)</span><br><span class="line">  region size 1024K, 27 young (27648K), 2 survivors (2048K)</span><br><span class="line">Metaspace       used 39203K, committed 39616K, reserved 1114112K</span><br><span class="line">  class space    used 4512K, committed 4672K, reserved 1048576K</span><br></pre></td></tr></tbody></table></figure><h5 id="堆内存调整"><a href="#堆内存调整" class="headerlink" title="堆内存调整"></a>堆内存调整</h5><ul><li>Kafka 堆内存建议每个节点设置 10G ~ 15G，堆内存大小可以在 <code>kafka-server-start.sh</code> 脚本文件中修改：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_HEAP_OPTS</span>"</span> = <span class="string">"x"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">"-Xmx10G -Xms10G"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure><h5 id="页缓存估算"><a href="#页缓存估算" class="headerlink" title="页缓存估算"></a>页缓存估算</h5><ul><li>页缓存是 Linux 操作系统的内存，一般只需要保证 1 个 SeGment（1G 大小）中 25% 的数据可以存放在内存中就行了。</li><li>计算公式：每个节点的页缓存大小 = (分区数量 * 1G * 25%) / 节点数。</li><li>比如：3 个节点和 10 个分区，那么页缓存大小 = (10 * 1G * 25%) / 3 ≈ 1G。</li><li>根据以上计算结果，建议服务器内存大于等于 11G，其中有 10G 是 Kafka 的堆内存使用，剩余的 1G 是页缓存使用。</li></ul><h3 id="Kafka-生产者调优"><a href="#Kafka-生产者调优" class="headerlink" title="Kafka 生产者调优"></a>Kafka 生产者调优</h3><h4 id="生产者的核心参数"><a href="#生产者的核心参数" class="headerlink" title="生产者的核心参数"></a>生产者的核心参数</h4><blockquote><p>Kafka 生产者的工作流程</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-producer-optimize-1.png"></p><blockquote><p>Kafka 生产者的核心参数</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-producer-optimize-2.png"></p><h4 id="生产者提高吞吐量"><a href="#生产者提高吞吐量" class="headerlink" title="生产者提高吞吐量"></a>生产者提高吞吐量</h4><p>为了让生产者提高吞吐量（发送消息的效率），可以优化以下几个参数：</p><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>buffer.memory</code></td><td>RecordAccumulator 缓冲区的总大小，默认值为 <code>32m</code>。</td></tr><tr><td><code>batch.size</code></td><td>缓冲区中一批数据的最大大小，默认值为 <code>16k</code>。适当增加该值，可以提高吞吐量；但是，如果该值设置得太大，会导致数据传输延迟增加。</td></tr><tr><td><code>linger.ms</code></td><td>如果数据量迟迟未达到 <code>batch.size</code>，Sender 线程等待 <code>linger.ms</code> 之后就会发送数据。单位是 <code>ms</code>，默认值为 <code>0ms</code>，表示没有延迟。生产环境建议该值大小为 5 ~ 100ms 之间。</td></tr><tr><td><code>compression.type</code></td><td>生产者发送的所有数据的压缩方式。默认值为 <code>none</code>，也就是不压缩。支持压缩类型：<code>none</code>、<code>gzip</code>、<code>snappy</code>、<code>lz4</code> 和 <code>zstd</code>。</td></tr></tbody></table><h4 id="生产者保证数据可靠性"><a href="#生产者保证数据可靠性" class="headerlink" title="生产者保证数据可靠性"></a>生产者保证数据可靠性</h4><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>acks</code></td><td><code>0</code>：生产者发送过来的数据，不需要等数据落盘才应答。<br> <code>1</code>：生产者发送过来的数据，Leader 收到数据后才应答。<br> <code>-1 (all)</code>：生产者发送过来的数据，Leader 和 ISR 队列里面的所有节点收到数据后才应答。默认值是 <code>-1</code>，而且 <code>-1</code> 和 <code>all</code> 是等价的。<br></td></tr><tr><td><code>retries</code></td><td>发送消息的失败重试次数，建议设置一个很大很大的值，表示一旦消息发送失败，就无限重试。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><p>至少一次（At Least Once） = ACK 级别设置为 <code>-1</code> + 分区副本数量大于等于 2 + ISR 里应答的最小副本数量大于等于 2。</p></div><h4 id="生产者保证数据有序性"><a href="#生产者保证数据有序性" class="headerlink" title="生产者保证数据有序性"></a>生产者保证数据有序性</h4><ul><li><strong>在 Kafka 单分区内，数据是有序（需要满足一定的条件）。</strong><ul><li>在单个分区内，Kafka 保证消息是按生产者写入的顺序进行存储的，并且消费者在读取时也是按这个顺序读取的。因此，只要满足一定的条件，单分区内的数据是有序的。</li><li>为了保证单分区的有序性，需要满足以下任意一个条件：<ul><li>第一种情况： <code>max.in.flight.requests.per.connection=1</code>，不需要开启幂等性，但会影响生产者的吞吐量。</li><li>第二种情况：开启幂等性 <code>enable.idempotence=true</code>，并且设置 <code>max.in.flight.requests.per.connection</code> 的值在 1 ~ 5 之间。</li></ul></li></ul></li><li><strong>在 Kafka 多分区内，分区与分区之间的数据是无序。</strong><ul><li>在多分区的情况下，Kafka 会将消息分布到不同的分区中。由于分区之间是并行处理的，Kafka 不会保证分区之间的消息顺序。因此，从全局视角来看，多分区的数据是无序的。</li></ul></li><li><strong>在 MQ（比如 Kafka）中，保证消息的顺序性，最关键的是严格保证生产者、MQ 队列、消费者这三者是一对一的关系。</strong><ul><li>要保证一个生产者只对应一个 Topic，一个 Topic 只对应一个 Partition，并且一个 Partition 只对应一个消费者。</li><li>比如，生产者在发送消息的时候，可以指定一个 Key，比如指定某个订单 的 ID 作为 Key，那么这个订单相关的所有消息，一定都会被分发到同一个 Partition 中去，而且这个 Partition 中的数据一定是有顺序的。当消费者从 Partition 中读取消息的时候，也一定是有顺序的。另外，如果消费者是单线程进行消费处理，而处理比较耗时的话，假设处理一条消息耗时几十毫秒，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。建议在消费者内部使用单线程进行消费时，将消息写入 N 个内存队列，并且通过哈希算法将拥有相同 Key 的消息都写入到同一个内存队列里面；最后启动 N 个线程，每个线程分别消费一个内存队列即可，这就能保证消息的顺序性，也能大大提高消费消息的吞吐量。整个处理流程如下图所示：</li></ul></li></ul><p><img data-src="../../../asset/2024/11/message-queue-order-2.png"></p><h4 id="生产者避免单分区乱序"><a href="#生产者避免单分区乱序" class="headerlink" title="生产者避免单分区乱序"></a>生产者避免单分区乱序</h4><p>Kafka 生产者解决<strong>单分区</strong>内的乱序问题，主要是依赖以下两个参数：</p><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>enable.idempotence</code></td><td>是否开启幂等性，默认值为 <code>true</code>， 表示默认开启幂等性。</td></tr><tr><td><code>max.in.flight.requests.per.connection</code></td><td>允许最多没有返回 ACK 应答的次数，默认为 <code>5</code>，开启幂等性后必须保证该参数值在 1 ~ 5 范围内。</td></tr></tbody></table><blockquote><p>注意事项</p></blockquote><ul><li>只开启 <code>enable.idempotence</code> 可以防止失败重试时的出现消息重复，但可能不能完全解决单分区内的乱序问题（这取决于 <code>max.in.flight.requests.per.connection</code> 参数的设置）。</li><li>要彻底解决 Kafka 单分区内的乱序问题，<code>enable.idempotence</code> 和 <code>max.in.flight.requests.per.connection</code> 这两个参数需要配合使用，这样才可以确保消息的顺序性和幂等性，但是会牺牲一定的生产吞吐量。</li><li><strong>特别注意，这两个配置参数只能保证 Kafka 单分区内的数据顺序，多分区之间的数据顺序 Kafka 无法保证。</strong></li></ul><blockquote><p>参数说明</p></blockquote><ul><li><code>max.in.flight.requests.per.connection</code> 是 Kafka Producer 的一个配置参数，用于控制在同一个 TCP 连接上未被 Broker 确认（ACK）的请求的最大数量。默认值是 <code>5</code>，意味着在同一个连接上，最多可以有 5 个未确认的请求。</li><li>如果启用了消息重试（<code>retries &gt; 0</code>，默认启用重试机制），并且设置的 <code>max.in.flight.requests.per.connection &gt; 1</code>，在某些情况下可能会导致单分区内的消息乱序。例如：一个较早的请求失败并被重试时，后续的请求可能已经被成功发送并确认。</li><li>当 <code>enable.idempotence=true</code>（启用幂等性），<code>max.in.flight.requests.per.connection</code> 的值不能超过 <code>5</code>，否则 Kafka 会拒绝启动 Producer。在启用幂等性后默认配置 <code>max.in.flight.requests.per.connection=5</code>，这是经过优化的平衡设置。</li></ul><blockquote><p>版本区别</p></blockquote><ul><li><p>Kafka 在 <code>1.x</code> 版本之前可以保证数据单分区的有序性，条件如下:</p><ul><li><code>max.in.flight.requests.per.connection = 1</code>，不需要考虑是否开启幂等性。</li></ul></li><li><p>Kafka 在 <code>1.x</code> 及以后版本可以保证数据单分区的有序性，条件如下:</p><ul><li>未开启幂等性<ul><li><code>max.in.flight.requests.per.connection</code> 需要必须设置为 1。</li></ul></li><li>开启幂等性<ul><li><code>max.in.flight.requests.per.connection</code> 的值必须设置在 1 ~ 5 之间。</li><li>原因说明：因为在 Kafka <code>1.x</code> 版本以后，启用幂等性后，Kafka 服务端会缓存 Producer 发来的最近 5 个 Request 的元数据，因此无论如何，都可以保证最近 5 个 Request 的数据都是有序的（如下图所示）。</li></ul></li></ul></li></ul><p><img data-src="../../../asset/2023/12/kafka-producer-9.png"></p><blockquote><p>情景分析</p></blockquote><ul><li><p><code>max.in.flight.requests.per.connection</code> 的值为 1（最严格的保证）</p><ul><li>每次只有一个请求正在处理，前一个请求完成后，才会发送下一个请求。</li><li>在这种配置下，绝对可以保证单分区的有序性，但会牺牲生产者的吞吐量。</li></ul></li><li><p><code>max.in.flight.requests.per.connection</code> 的值在 1 ~ 5 之间</p><ul><li>配置的前提条件：必须设置 <code>enable.idempotence=true</code> 和 <code>acks=all</code>。</li><li>当满足上述前提条件时，Kafka 的生产者重试机制会确保消息的顺序，即使发生失败重试，也能按顺序处理请求。</li><li>Kafka <code>1.1</code> 及以后版本，启用幂等性后，生产者可以保证单分区的顺序性，只要 <code>max.in.flight.requests.per.connection</code> 的值在 1 ~ 5 之间即可。</li><li>配置风险：<ul><li>如果 <code>enable.idempotence=false</code>，同时 <code>max.in.flight.requests.per.connection &gt; 1</code>，则单分区内可能会出现消息乱序。这是因为并行发送的请求，在发送失败后会重新发送，后发送的请求可能先完成，从而打破顺序。</li><li>如果 <code>enable.idempotence=false</code>，为了保证单分区的顺序性，<code>max.in.flight.requests.per.connection</code> 的值必须设置为 1。</li></ul></li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><ul><li>当 <code>enable.idempotence=true</code> 且 <code>acks=all</code> 时，<code>max.in.flight.requests.per.connection</code> 的值在 1 ~ 5 之间，Kafka 仍然可以保证单分区的有序性。</li><li>设置为 <code>max.in.flight.requests.per.connection=1</code> 时，这是最简单、最安全的配置，但会影响生产者的吞吐量。</li><li>设置为 <code>max.in.flight.requests.per.connection &gt; 1</code> 时，能保证单分区的有序性，同时可以提高吞吐量，但需要依赖 <code>enable.idempotence=true</code>（启用幂等性）。</li><li>如果 <code>enable.idempotence=false</code>，即没有启用幂等性，那么 <code>max.in.flight.requests.per.connection</code> 的值必须设置为 1，这样才能保证单分区的有序性。</li></ul></div><h4 id="生产者避免消息重复发送"><a href="#生产者避免消息重复发送" class="headerlink" title="生产者避免消息重复发送"></a>生产者避免消息重复发送</h4><p>生产者避免消息重复发送有两种实现方案，包括开启幂等性和使用事务机制。</p><h5 id="生产者开启幂等性"><a href="#生产者开启幂等性" class="headerlink" title="生产者开启幂等性"></a>生产者开启幂等性</h5><div class="admonition note"><p class="admonition-title">什么是 Kafka 的幂等性</p><ul><li>Kafka 的幂等性是指 Producer (生产者) 无论向 Broker 发送多少条重复消息，Broker 端都只会持久化一条消息，保证了消息不重复。</li><li>精确一次 (Exactly Once) = 开启幂等性 + 至少一次 (<code>acks = -1</code> + <code>分区副本数 &gt;= 2</code> + <code>ISR 里应答的最小副本数量 &gt;= 2</code>)。</li><li>Kafka 官方文档中的幂等性详细介绍可以看 <a target="_blank" rel="external nofollow" href="https://kafka.apache.org/documentation/#producerconfigs_enable.idempotence">这里</a>。</li></ul></div><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>enable.idempotence</code></td><td>是否开启幂等性，默认值为 <code>true</code>， 表示默认开启幂等性。</td></tr><tr><td><code>max.in.flight.requests.per.connection</code></td><td>允许最多没有返回 ACK 应答的次数，默认为 <code>5</code>，开启幂等性后必须保证该参数值在 1 ~ 5 范围内。</td></tr></tbody></table><ul><li><p>在 Kafka 中开启幂等性的配置参数是 <code>enable.idempotence</code>，默认值为 <code>true</code>，设置 <code>false</code> 会关闭幂等性。如果没有设置冲突的配置，默认情况下会启用幂等性。如果设置了冲突的配置，并且未显式启用幂等性，则会禁用幂等性。如果显式启用了幂等性，并且设置了冲突的配置，则会抛出 ConfigException 异常。</p></li><li><p>当在生产者端设置 <code>enable.idempotence</code> 为 <code>true</code> 时，生产者将确保数据流中只写入每条消息的一个副本，即可以确保生产者不会写入重复消息。如果设置为 <code>false</code>，由于代理失败等原因，生产者重试发送消息，可能会在数据流中写入重试消息的副本，即生产者可能会写入重复消息。</p></li></ul><div class="admonition warning"><p class="admonition-title">Kafka 启用幂等性要至少满足以下 4 个条件</p><ul><li>(1) 在生产者端设置 <code>enable.idempotence</code> 参数：这个值必须为 <code>true</code>，即开启幂等性</li><li> (2) 在生产者端设置 <code>max.in.flight.requests.per.connection</code> 参数：这个值必须小于或等于 5</li><li>(3) 在生产者端设置 <code>acks = -1</code>：这是要求每条消息，必须是写入到所有 Replica（副本）之后，才能认为是发送成功</li><li> (4) 在生产者端设置 <code>retries</code>：这个值必须大于 0，即必须要有重试机制</li></ul></div><h5 id="生产者使用事务机制"><a href="#生产者使用事务机制" class="headerlink" title="生产者使用事务机制"></a>生产者使用事务机制</h5><p>Kafa 除了可以使用幂等性来解决生产者重复发送消息之外，还可以使用事务机制来解决，关于 Kafka 事务机制的详细介绍请看 <a href="/posts/60ddcede.html#%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8">这里</a>。Kafka 的事务一共有以下 5 个 API：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.初始化事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initTransactions</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.开启事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在事务内提交已经消费的偏移量(主要用于消费者)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOffsetsToTransaction</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, String consumerGroupId)</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commitTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.放弃事务(类似于回滚事务的操作)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abortTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="Kafka-Broker-调优"><a href="#Kafka-Broker-调优" class="headerlink" title="Kafka Broker 调优"></a>Kafka Broker 调优</h3><h4 id="Broker-的核心参数"><a href="#Broker-的核心参数" class="headerlink" title="Broker 的核心参数"></a>Broker 的核心参数</h4><blockquote><p>Broker 的工作流程</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-producer-optimize-3.png"></p><blockquote><p>Broker 的核心参数</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-producer-optimize-4.png"></p><h4 id="Broker-服役新节点"><a href="#Broker-服役新节点" class="headerlink" title="Broker 服役新节点"></a>Broker 服役新节点</h4><ul><li><a href="/posts/228158d3.html#%E6%9C%8D%E5%BD%B9%E6%96%B0%E8%8A%82%E7%82%B9">Kafka Broker 最佳实践</a></li></ul><h4 id="Broker-退役旧节点"><a href="#Broker-退役旧节点" class="headerlink" title="Broker 退役旧节点"></a>Broker 退役旧节点</h4><ul><li><a href="/posts/228158d3.html#%E9%80%80%E5%BD%B9%E6%97%A7%E8%8A%82%E7%82%B9">Kafka Broker 最佳实践</a></li></ul><h4 id="Broker-增加分区数量"><a href="#Broker-增加分区数量" class="headerlink" title="Broker 增加分区数量"></a>Broker 增加分区数量</h4><ul><li>通过 <code>kafka-topics.sh</code> 脚本增加 Topic 的分区数量</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --alter --topic first --partitions 3</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>Kafka 的分区数量只能增加，不能减少。值得一提的是，Kafka 同样不支持减少已创建的主题的副本数量，但是可以通过 <code>kafka-reassign-partitions.sh</code> 脚本重新分配副本的方式来实现。</p></div><h4 id="Broker-自动创建主题"><a href="#Broker-自动创建主题" class="headerlink" title="Broker 自动创建主题"></a>Broker 自动创建主题</h4><ul><li><p>如果将 Broker 端的配置参数 <code>auto.create.topics.enable</code> 设置为 <code>true</code>（默认值是 <code>true</code>），那么当生产者向一个未创建的主题发送消息时，Broker 会自动创建一个分区数为 <code>num.partitions</code>（默认值为 1）、副本因子为 <code>default.replication.factor</code>（默认值为 1）的主题。</p></li><li><p>除此之外，当一个消费者开始从未知主题中读取消息时，或者当任意一个客户端向未知主题发送元数据请求时，都会自动创建一个相应的主题。这种创建主题的方式是非预期的，增加了主题管理和维护的难度。在生产环境下，强烈建议将 <code>auto.create.topics.enable</code> 设置为 <code>false</code>。</p></li></ul><h3 id="Kafka-消费者调优"><a href="#Kafka-消费者调优" class="headerlink" title="Kafka 消费者调优"></a>Kafka 消费者调优</h3><h4 id="消费者的核心参数"><a href="#消费者的核心参数" class="headerlink" title="消费者的核心参数"></a>消费者的核心参数</h4><blockquote><p>消费者组的初始化流程</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-consumer-optimize-1.png"></p><blockquote><p>消费者组的完整消费流程</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-consumer-optimize-2.png"></p><blockquote><p>消费者的核心参数</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-consumer-optimize-3.png"></p><h4 id="消费者提高吞吐量"><a href="#消费者提高吞吐量" class="headerlink" title="消费者提高吞吐量"></a>消费者提高吞吐量</h4><p>Kafka 如何提高消费者的消费速度呢？</p><ul><li><p>(1) 如果是 Kafka 消费能力不足，则可以考虑增加 Topic 的分区数量，并且同时增加消费组的消费者数量，这两个条件缺一不可，即 <code>消费组的消费者数量 = Topic 的分区数量</code>。</p></li><li><p>(2) 如果是下游的数据处理不及时（有较大延迟），则可以提高消费者每批次拉取消息的数量（默认每批次拉取 500 条消息）。每批次拉取数据过少（拉取的数据量 / 数据处理时间 &lt; 生产速度），会使消费者处理数据的速度小于生产者生产数据的速度，从而可能导致消息积压。</p></li></ul><p><img data-src="../../../asset/2024/11/kafka-consumer-18.png"></p><ul><li>(3) 消费者提高吞吐量的相关配置参数</li></ul><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>fetch.max.bytes</code></td><td>消费者获取服务器端一批消息的最大字节数，默认值为 <code>50m</code>。如果服务器端一批次的消息大于该值，仍然可以将这批消息拉取回来，所以这不是一个绝对最大值。消费者拉取一批次消息的大小受 <code>message.max.bytes</code>（Broker 配置）或者 <code>max.message.bytes</code>（Topic 配置）影响。</td></tr><tr><td><code>max.poll.records</code></td><td>消费者每次调用 <code>poll()</code> 方法时，最多能拉取的消息数量，默认值为 <code>500</code>。</td></tr></tbody></table><h4 id="消费者分区再平衡的优化"><a href="#消费者分区再平衡的优化" class="headerlink" title="消费者分区再平衡的优化"></a>消费者分区再平衡的优化</h4><p>Kafka 消费者的分区再平衡（Partition Rebalancing）是指当消费者组中的成员发生变更时（如消费者加入、退出或故障），Kafka 自动调整分区与消费者之间的映射关系，以确保所有分区都会被消费者组中的成员消费。</p><blockquote><p>消费者组的初始化流程</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-consumer-optimize-1.png"></p><blockquote><p>分区再平衡相关的配置参数</p></blockquote><p><img data-src="../../../asset/2024/12/kafka-consumer-optimize-4.png"></p><blockquote><p>分区再平衡的优缺点</p></blockquote><ul><li>优点：<ul><li>动态调整分区分配，支持弹性扩展。</li><li>确保分区始终被有效消费。</li></ul></li><li>缺点：<ul><li>短暂中断：再平衡期间会暂停消费，导致短时间内消息未被处理。</li><li>分区切换开销：消费者需要重新建立分区的连接和状态。</li></ul></li></ul><blockquote><p>分区再平衡的优化措施</p></blockquote><ul><li>使用静态成员 ID（<code>group.instance.id</code>），减少分区再平衡的频率。</li><li>控制心跳和会话超时（<code>heartbeat.interval.ms</code> 和 <code>session.timeout.ms</code>），避免误触发分区再平衡。</li><li>通过配置参数 <code>partition.assignment.strategy</code> 来调整分区分配策略，以适应具体场景需求。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>更多关于 Kafka 消费者的分区再平衡介绍请看 <a href="/posts/c61757ff.html#Kafka-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8">这里</a>。</li></ul></div><h3 id="Kafka-整体性能调优"><a href="#Kafka-整体性能调优" class="headerlink" title="Kafka 整体性能调优"></a>Kafka 整体性能调优</h3><h4 id="提高整体吞吐量"><a href="#提高整体吞吐量" class="headerlink" title="提高整体吞吐量"></a>提高整体吞吐量</h4><p>为了提高 Kafka 整体的吞吐量，可以从以下四个角度进行优化。</p><blockquote><p>(1) 增加 Topic 的分区数量</p></blockquote><ul><li>通过 <code>kafka-topics.sh</code> 脚本增加 Topic 的分区数量（注意：分区数量只能增加，不能减少）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --alter --topic first --partitions 3</span><br></pre></td></tr></tbody></table></figure><blockquote><p>(2) 提高生产吞吐量</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>buffer.memory</code></td><td>发送消息的缓冲区大小，默认值是 <code>32m</code>，生产环境可以增加到 <code>64m</code>。</td></tr><tr><td><code>batch.size</code></td><td>缓冲区中一批数据的最大大小，默认值是 <code>16k</code>。如果 Batch 设置太小，会导致频繁发送网络请求，吞吐量下降；如果 Batch 设置太大，会导致一条消息需要等待很久才能够被发送出去，增加网络延迟。</td></tr><tr><td><code>linger.ms</code></td><td>如果数据迟迟未达到 <code>batch.size</code>，那么 Sender 等待 <code>linger.ms</code> 之后就会发送消息。默认值是 <code>0</code>，表示立刻发送消息。生产环境建议设置 5 ~ 100 毫秒之间。如果 <code>linger.ms</code> 设置太小，会导致频繁发送网络请求，吞吐量下降；如果 <code>linger.ms</code> 设置太大，会导致一条消息需要等待很久才能被发送出去，增加网络延迟。</td></tr><tr><td><code>compression.type</code></td><td>默认值是 <code>none</code>，表示不压缩直接发送消息。支持的压缩类型：<code>none</code>、<code>gzip</code>、<code>snappy</code>、<code>lz4</code> 和 <code>zstd</code>。生产环境也可以使用 <code>gzip</code> 压缩，效率还是不错的，压缩之后可以减小数据量，提升吞吐量，但是会加大 Producer 端的 CPU 开销。</td></tr></tbody></table><blockquote><p>(3) 提高消费吞吐量</p></blockquote><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>fetch.max.bytes</code></td><td>消费者获取服务器端一批消息的最大字节数，默认值为 <code>50m</code>。如果服务器端一批次的消息大于该值，仍然可以将这批消息拉取回来，所以这不是一个绝对最大值。消费者拉取一批次消息的大小受 <code>message.max.bytes</code>（Broker 配置）或者 <code>max.message.bytes</code>（Topic 配置）影响。</td></tr><tr><td><code>max.poll.records</code></td><td>消费者每次调用 <code>poll()</code> 方法时，最多能拉取的消息数量，默认值为 <code>500</code>。</td></tr></tbody></table><blockquote><p>(4) 增加消费者的数量</p></blockquote><p>当增加了 Topic 的分区数量后，还需要同时增加消费组的消费者数量，这两个条件缺一不可，即 <code>消费组的消费者数量 = Topic 的分区数量</code>，这样才能提高消费吞吐量。</p><h4 id="数据精确一次"><a href="#数据精确一次" class="headerlink" title="数据精确一次"></a>数据精确一次</h4><p>在 Kafka 中，为了保证消息被精确一次发送和消费，必须满足以下全部条件，缺一不可。</p><blockquote><p>(1) 生产者角度</p></blockquote><ul><li>将 <code>acks</code> 参数设置为 <code>-1</code>。</li><li>开启幂等性 <code>enable.idempotence = true</code>，默认开启。</li><li>在生产端使用事务机制发送消息。</li></ul><blockquote><p>(2) Broker 角度</p></blockquote><ul><li>分区的副本数量大于等于 2（<code>--replication-factor 2</code>）。</li><li>ISR 里应答的最小副本数量大于等于 2 (<code>min.insync.replicas = 2</code>)。</li></ul><blockquote><p>(3) 消费者角度</p></blockquote><ul><li>事务机制 + 手动提交 Offset（<code>enable.auto.commit = false</code>）。</li><li>消费者输出的目标存储系统必须支持事务（比如 MySQL、Kafka）。</li></ul><h4 id="合理设置分区数量"><a href="#合理设置分区数量" class="headerlink" title="合理设置分区数量"></a>合理设置分区数量</h4><p>如何为某个 Topic 合理设置分区数量呢？以下是估算分区数量的方法：</p><ul><li>(1) 创建一个只有 1 个分区的 Topic。</li><li>(2) 测试这个 Topic 的 Producer 吞吐量和 Consumer 吞吐量。</li><li>(3) 假设它们吞吐量的值分别是 Tp 和 Tc，单位是 MB/s。</li><li>(4) 然后，假设总的目标吞吐量是 Tt，那么 <code>分区数 = Tt /min (Tp, Tc)</code>。</li><li>(5) 比如：Producer 吞吐量是 20m/s，Consumer 吞吐量是 50m/s，期望吞吐量 100m/s，那么 <code>分区数 = 100 / min (20, 50) = 5 个分区</code>。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Kafka 的分区数一般设置为：3 ~ 10 个。</li><li>Kafka 的分区数并不是越多越好，也不是越少越好，需要搭建完 Kafka 集群，然后对集群进行压测，再根据压测结果调整分区的数量。</li></ul></div><h4 id="单条消息大于-1M"><a href="#单条消息大于-1M" class="headerlink" title="单条消息大于 1M"></a>单条消息大于 1M</h4><p>当 Kafka 单条消息的大小大于 1M，那么可以通过以下参数进行优化：</p><p><img data-src="../../../asset/2024/12/kafka-global-optimize-1.png"></p><h4 id="Broker-节点宕机"><a href="#Broker-节点宕机" class="headerlink" title="Broker 节点宕机"></a>Broker 节点宕机</h4><p>在 Kafka 生产环境（集群部署）中，如果某个 Broker 节点挂掉，正常的处理方法如下：</p><ul><li>(1) 先尝试重新启动 Broker 节点，如果能够正常启动，那问题直接解决。</li><li>(2) 如果无法正常重启，考虑增加内存、增加 CPU、增加网络带宽。</li><li>(3) 如果是将整个 Broker 节点误删除掉<ul><li>如果分区的副本数大于等于 2，那么可以按照 Kafka 服役新节点的方式重新服役一个新节点，并执行负载均衡，将部分数据迁移到新节点。</li><li>如果分区的副本只有一个，那么只能 “批量重导”，也就是写个临时程序将丢失的那批数据查询出来，然后重新将消息写入 Kafka 里面。</li></ul></li></ul><h4 id="Kafka-集群压力测试"><a href="#Kafka-集群压力测试" class="headerlink" title="Kafka 集群压力测试"></a>Kafka 集群压力测试</h4><p>Kafka 的性能调优（包括生产者、Broker、消费者）并不是一成不变的，需要根据不同的业务场景来调整参数。比如，A 项目单条消息的大小为 1K，而 B 项目单条消息的大小为 1M，那么两者的性能调优参数是不一样的。为了得到更符合具体场景的性能调优参数，Kafka 官方提供了压测脚本，可以很方便地对 Kafka 进行压测。</p><ul><li>生产者压测脚本：<code>kafka-producer-perf-test.sh</code></li><li>消费者压测脚本：<code>kafka-consumer-perf-test.sh</code></li></ul><p>上述脚本支持对 Kafka 集群进行压测，如下图所示：</p><p><img data-src="../../../asset/2024/12/kafka-global-optimize-2.png"></p><h5 id="生产者压力测试"><a href="#生产者压力测试" class="headerlink" title="生产者压力测试"></a>生产者压力测试</h5><ul><li>(1) 创建一个新的 Topic，并设置 3 个分区和 3 个副本</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --create --replication-factor 3 --partitions 3 --topic bench</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 执行生产者的压测脚本</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-producer-perf-test.sh --topic bench --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 batch.size=16384 linger.ms=0</span><br></pre></td></tr></tbody></table></figure><p>生产者压测脚本的参数：</p><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>--record-size</code></td><td>表示单条信息有多大，单位是字节（Byte）。</td></tr><tr><td><code>--num-records</code></td><td>表示总共发送多少条信息。</td></tr><tr><td><code>--throughput</code></td><td>表示每秒发送多少条信息。当设置为 <code>-1</code>，则表示不限流，即尽可能快地生产数据，可以测出生产者的最大吞吐量。</td></tr><tr><td><code>--producer-props</code></td><td>用于配置生产者的相关参数，比如 <code>batch.size</code> 配置为 <code>16k</code>。</td></tr></tbody></table><p>生产者压测的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">37021 records sent, 7401.2 records/sec (7.23 MB/sec), 1136.0 ms avg latency, 1453.0 ms max latency.</span><br><span class="line">50535 records sent, 10107.0 records/sec (9.87 MB/sec), 1199.5 ms avg latency, 1404.0 ms max latency.</span><br><span class="line">47835 records sent, 9567.0 records/sec (9.34 MB/sec), 1350.8 ms avg latency, 1570.0 ms max latency.</span><br><span class="line">......</span><br><span class="line">42390 records sent, 8444.2 records/sec (8.25 MB/sec), 3372.6 ms avg latency, 4008.0 ms max latency.</span><br><span class="line">37800 records sent, 7558.5 records/sec (7.38 MB/sec), 4079.7 ms avg latency, 4758.0 ms max latency.</span><br><span class="line">33570 records sent, 6714.0 records/sec (6.56 MB/sec), 4549.0 ms avg latency, 5049.0 ms max latency.</span><br><span class="line">1000000 records sent, 9180.713158 records/sec (8.97 MB/sec), 1894.78 ms avg latency, 5049.00 ms max latency, 1335 ms 50th, 4128 ms 95th, 4719 ms 99th, 5030 ms 99.9th</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 调整 <code>batch.size</code> 大小为 <code>32k</code>，然后进行压测</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-producer-perf-test.sh --topic bench --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 batch.size=32768 linger.ms=0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">49922 records sent, 9978.4 records/sec (9.74 MB/sec), 64.2 ms avg latency, 340.0 ms max latency.</span><br><span class="line">49940 records sent, 9988.0 records/sec (9.75 MB/sec), 15.3 ms avg latency, 31.0 ms max latency.</span><br><span class="line">50018 records sent, 10003.6 records/sec (9.77 MB/sec), 16.4 ms avg latency, 52.0 ms max latency.</span><br><span class="line">......</span><br><span class="line">49960 records sent, 9992.0 records/sec (9.76 MB/sec), 17.2 ms avg latency, 40.0 ms max latency.</span><br><span class="line">50090 records sent, 10016.0 records/sec (9.78 MB/sec), 16.9 ms avg latency, 47.0 ms max latency.</span><br><span class="line">1000000 records sent, 9997.600576 records/sec (9.76 MB/sec), 20.20 ms avg latency, 340.00 ms max latency, 16 ms 50th, 30 ms 95th, 168 ms 99th, 249ms 99.9th.</span><br></pre></td></tr></tbody></table></figure><ul><li>(4) 调整 <code>batch.size</code> 大小为 <code>4k</code>，然后进行压测</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-producer-perf-test.sh --topic bench --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 batch.size=4096 linger.ms=0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">15598 records sent 3117.1 records/sec (3.04 MB/sec) 1878.3 ms avg latency, 3458.0 ms max latency.</span><br><span class="line">17748 records sent 3549.6 records/sec (3.47 MB/sec) 5072.5 ms avg latency, 6705.0 ms max latency.</span><br><span class="line">18675 records sent 3733.5 records/sec (3.65 MB/sec) 6800.9 ms avg latency, 7052.0 ms max latency.</span><br><span class="line">......</span><br><span class="line">19125 records sent, 3825.0 records/sec (3.74 MB/sec), 6416.5 ms avg latency, 7023.0 ms max latency.</span><br><span class="line">1000000 records sent, 3660.201531 records/sec (3.57 MB/sec), 6576.68 ms avg latency, 7677.00 ms max latency, 6745 ms 50th, 7298 ms 95th, 7507 ms 99th, 7633 ms 99.9th.</span><br></pre></td></tr></tbody></table></figure><ul><li>(5) 调整 <code>linger.ms</code> 时间为 <code>50ms</code>，然后进行压测</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-producer-perf-test.sh --topic bench --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 batch.size=4096 linger.ms=50</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">16804 records sent, 3360.1 records/sec (3.28 MB/sec), 1841.6 ms avg latency, 3338.0 ms max latency·</span><br><span class="line">18972 records sent, 3793.6 records/sec (3.70 MB/sec), 4877.7 ms avg latency, 6453.0 ms max latency.</span><br><span class="line">19269 records sent, 3852.3 records/sec (3,76 MB/sec), 6477.9 ms avg latency, 6686.0 ms max latency.</span><br><span class="line">......</span><br><span class="line">17073 records sent, 3414.6 records/sec (3.33 MB/sec), 6987.7 ms avg latency, 7353.0 ms max latency.</span><br><span class="line">19326 records sent, 3865.2 records/sec (3.77 MB/sec), 6756.5 ms avg latency, 7357.0 ms max latency.</span><br><span class="line">1000000 records sent, 3842.754486 records/sec (3.75 MB/sec), 6272.49 ms avg latency, 7437.00 ms max latency, 6308 ms 50th, 6880 ms 95th, 7289 ms 99th, 7387 ms 99.9th.</span><br></pre></td></tr></tbody></table></figure><ul><li>(6) 调整 <code>compression.type</code> 为 <code>snappy</code>，然后进行压测</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-producer-perf-test.sh --topic bench --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 batch.size=4096 linger.ms=50 compression.type=snappy</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">17244 records sent, 3446.0 records/sec (3.37 MB/sec), 5207.0 ms avg latency, 6861.0 ms max latency.</span><br><span class="line">18873 records sent, 3774.6 records/sec (3.69 MB/sec), 6865.0 ms avg latency, 7094.0 ms max latency·</span><br><span class="line">18378 records sent, 3674.1 records/sec (3.59 MB/sec), 6579.2 ms avg latency, 6738.0 ms max latency.</span><br><span class="line">......</span><br><span class="line">17631 records sent, 3526.2 records/sec (3.44 MB/sec), 6671.3 ms avg latency, 7566.0 ms max latency.</span><br><span class="line">19116 records sent, 3823.2 records/sec (3.73 MB/sec), 6739.4 ms avg latency, 7630.0 ms max latency.</span><br><span class="line">1000000 records sent, 3722.925028 records/sec (3.64 MB/sec), 6467.75 ms avg latency, 7727.00 ms max latency, 6440 ms 50th, 7308 ms 95th, 7553 ms 99th, 7665 ms 99.9th.</span><br></pre></td></tr></tbody></table></figure><ul><li>(7) 调整 <code>compression.type</code> 为 <code>zstd</code>，然后进行压测</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-producer-perf-test.sh --topic bench --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 batch.size=4096 linger.ms=50 compression.type=zstd</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">23820 records sent, 4763.0 records/sec (4.65 MB/sec), 1580.2 ms avg latency, 2651.0 ms max latency.</span><br><span class="line">29340 records sent, 5868.0 records/sec (5.73 MB/sec), 3666.0 ms avg latency, 4752.0 ms max latency·</span><br><span class="line">28950 records sent, 5788.8 records/sec (5.65 MB/sec), 5785.2 ms avg latency, 6865.0 ms max latency.</span><br><span class="line">......</span><br><span class="line">29580 records sent, 5916.0 records/sec (5.78 MB/sec), 6907.6 ms avg latency, 7432.0 ms max latency.</span><br><span class="line">29925 records sent, 5981.4 records/sec (5.84 MB/sec), 6948.9 ms avg latency, 7541.0 ms max latency.</span><br><span class="line">1000000 records sent, 5733.583318 records/sec (5.60 MB/sec), 6824.75 ms avg latency, 7595.00 ms max latency, 7067 ms 50th, 7400 ms 95th, 7500 ms 99th, 7552 ms 99.9th.</span><br></pre></td></tr></tbody></table></figure><ul><li>(8) 调整 <code>compression.type</code> 为 <code>gzip</code>，然后进行压测</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-producer-perf-test.sh --topic bench --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 batch.size=4096 linger.ms=50 compression.type=gzip</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">27170 records sent, 5428.6 records/sec (5.30 MB/sec), 1374.0 ms avg latency, 2311.0 ms max latency.</span><br><span class="line">31050 records sent, 6210.0 records/sec (6.06 MB/sec), 3183.8 ms avg latency, 4228.0 ms max latency.</span><br><span class="line">32145 records sent, 6427.7 records/sec (6.28 MB/sec), 5028.1 ms avg latency, 6042.0 ms max latency.</span><br><span class="line">......</span><br><span class="line">31710 records sent, 6342.0 records/sec (6.19 MB/sec), 6457.1 ms avg latency, 6777.0 ms max latency.</span><br><span class="line">31755 records sent, 6348.5 records/sec (6.20 MB/sec), 6498.7 ms avg latency, 6780.0 ms max latency.</span><br><span class="line">32760 records sent, 6548.1 records/sec (6.39 MB/sec), 6375.7 ms avg latency, 6822.0 ms max latency.</span><br><span class="line">1000000 records sent, 6320.153706 records/sec (6.17 MB/sec), 6155.42 ms avg latency, 6943.00 ms max latency, 6437 ms 50th, 6774 ms 95th, 6863 ms 99th, 6912 ms 99.9th.</span><br></pre></td></tr></tbody></table></figure><ul><li>(9) 调整 <code>compression.type</code> 为 <code>lz4</code>，然后进行压测</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-producer-perf-test.sh --topic bench --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 batch.size=4096 linger.ms=50 compression.type=lz4</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">16696 records sent, 3339.2 records/sec (3.26 MB/sec), 1924.5 ms avg latency, 3355.0 ms max latency.</span><br><span class="line">19647 records sent, 3928.6 records/sec (3.84 MB/sec), 4841.5 ms avg latency, 6320.0 ms max latency·</span><br><span class="line">20142 records sent, 4028.4 records/sec (3.93 MB/sec), 6203.2 ms avg latency, 6378.0 ms max latency.</span><br><span class="line">......</span><br><span class="line">20130 records sent, 4024.4 records/sec (3.93 MB/sec), 6073.6 ms avg latency, 6396.0 ms max latency.</span><br><span class="line">19449 records sent, 3889.8 records/sec (3.80 MB/sec), 6195.6 ms avg latency, 6500.0 ms max latency.</span><br><span class="line">19872 records sent, 3972.8 records/sec (3.88 MB/sec), 6274.5 ms avg latency, 6565.0 ms max latency.</span><br><span class="line">1000000 records sent, 3956.087430 records/sec (3.86 MB/sec), 6085.62 ms avg latency, 6745.00 ms max latency, 6212 ms 50th, 6524 ms 95th, 6610 ms 99th, 6695 ms 99.9th.</span><br></pre></td></tr></tbody></table></figure><ul><li>(10) 调整 <code>buffer.memory</code> 为 <code>64m</code>，然后进行压测</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-producer-perf-test.sh --topic bench --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 batch.size=4096 linger.ms=50 buffer.memory=67108864</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">20170 records sent, 4034.0 records/sec (3.94 MB/sec), 1669.5 ms avg latency, 3040.0 ms max latency.</span><br><span class="line">21996 records sent, 4399.2 records/sec (4.30 MB/sec), 4407.9 ms avg latency, 5806.0 ms max latency.</span><br><span class="line">22113 records sent, 4422.6 records/sec (4.32 MB/sec), 7189.0 ms avg latency, 8623.0 ms max latency.</span><br><span class="line">......</span><br><span class="line">19818 records sent, 3963.6 records/sec (3.87 MB/sec), 12416.0 ms avg latency, 12847.0 ms max latency.</span><br><span class="line">20331 records sent, 4062.9 records/sec (3.97 MB/sec), 12400.4 ms avg latency, 12874.0 ms max latency.</span><br><span class="line">19665 records sent, 3933.0 records/sec (3.84 MB/sec), 12303.9 ms avg latency, 12838.0 ms max latency.</span><br><span class="line">1000000 records sent, 4020.100503 records/sec (3.93 MB/sec), 11692.17 ms avg latency, 13796.00 ms max latency, 12238 ms 50th, 12949 ms 95th, 13691 ms 99th, 13766 ms 99.9th.</span><br></pre></td></tr></tbody></table></figure><blockquote><p>生产者压测结果汇总</p></blockquote><table><thead><tr><th>生产者核心参数</th><th>生产者的吞吐量</th><th>说明</th></tr></thead><tbody><tr><td><code>batch.size=16384 linger.ms=0</code></td><td>8.97 MB/sec</td><td></td></tr><tr><td><code>batch.size=32768 linger.ms=0</code></td><td>9.76 MB/sec</td><td></td></tr><tr><td><code>batch.size=4096 linger.ms=0</code></td><td>3.57 MB/sec</td><td></td></tr><tr><td><code>batch.size=4096 linger.ms=50</code></td><td>3.75 MB/sec</td><td> 在测试环境进行压测时，可能感受不到 <code>linger.ms</code> 参数调整带来的影响；但在生产环境下，<code>linger.ms</code> 参数对生产吞吐量的影响较大。</td></tr><tr><td><code>batch.size=4096 linger.ms=50 compression.type=snappy</code></td><td>3.64 MB/sec</td><td></td></tr><tr><td><code>batch.size=4096 linger.ms=50 compression.type=zstd</code></td><td>5.60 MB/sec</td><td></td></tr><tr><td><code>batch.size=4096 linger.ms=50 compression.type=gzip</code></td><td>6.17 MB/sec</td><td></td></tr><tr><td><code>batch.size=4096 linger.ms=50 compression.type=lz4</code></td><td>3.86 MB/sec</td><td></td></tr><tr><td><code>batch.size=4096 linger.ms=50 buffer.memory=67108864</code></td><td>3.93 MB/sec</td><td></td></tr></tbody></table><h5 id="消费者压力测试"><a href="#消费者压力测试" class="headerlink" title="消费者压力测试"></a>消费者压力测试</h5><ul><li>(1) 执行消费者的压测脚本</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-consumer-perf-test.sh --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 --topic bench --messages 1000000 --consumer.config ../config/consumer.properties</span><br></pre></td></tr></tbody></table></figure><p>消费者压测脚本的参数：</p><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td><code>--bootstrap-server</code></td><td>指定 Kafka 集群地址。</td></tr><tr><td><code>--topic</code></td><td>指定 Topic 的名称。</td></tr><tr><td><code>--messages</code></td><td>总共要消费的消息数量。</td></tr><tr><td><code>--consumer.config</code></td><td>指定消费者使用的配置文件。</td></tr></tbody></table><p>消费者压测的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start.time, end.time, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec, rebalance.time.ms, fetch.time.ms, fetch.MB.sec, fetch.nMsg.sec</span><br><span class="line">2022-09-08 21:58:26:171, 2022-09-08 21:58:33:321, 977.0166, 136.6457, 1000465, 139925.1748, 415, 6735, 145.0656, 148547.1418</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 在 Kafka 的配置文件 <code>config/consumer.properties</code> 中，更改消费者一次拉取消息的最大数量为 <code>2000</code>，然后执行压测</li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">max.poll.records</span>=<span class="string">2000</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-consumer-perf-test.sh --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 --topic bench --messages 1000000 --consumer.config ../config/consumer.properties</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start.time, end.time, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec, rebalance.time.ms, fetch.time.ms, fetch.MB.sec, fetch.nMsg.sec</span><br><span class="line">2022-09-08 21:18:06:268, 2022-09-08 21:18:12:863, 977.5146, 148.2206, 1000975, 151777.8620, 358, 6237, 156.7283, 160489.8188</span><br></pre></td></tr></tbody></table></figure><ul><li>(3) 在 Kafka 的配置文件 <code>config/consumer.properties</code> 中，更改消费者拉取一批数据的最大大小为 <code>100m</code>，然后执行压测</li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">fetch.max.bytes</span>=<span class="string">104857600</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./kafka-consumer-perf-test.sh --bootstrap-server 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 --topic bench --messages 1000000 --consumer.config ../config/consumer.properties</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start.time, end.time, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec, rebalance.time.ms, fetch.time.ms, fetch.MB.sec, fetch.nMsg.sec</span><br><span class="line">2022-09-08 21:26:13:203, 2022-09-08 21:26:19:662, 977.5146, 151.3415, 1000975, 154973.6801, 362, 6097, 160.3272, 164175.0041</span><br></pre></td></tr></tbody></table></figure><blockquote><p>消费者压测结果汇总</p></blockquote><table><thead><tr><th>消费者的核心参数</th><th>消费者的吞吐量</th><th>说明</th></tr></thead><tbody><tr><td><code>max.poll.records=500 fetch.max.bytes=52428800</code></td><td>136.6457 MB/sec</td><td></td></tr><tr><td><code>max.poll.records=2000 fetch.max.bytes=52428800</code></td><td>148.2206 MB/sec</td><td></td></tr><tr><td><code>max.poll.records=2000 fetch.max.bytes=104857600</code></td><td>151.3415 MB/sec</td><td></td></tr></tbody></table><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/ed9d5bd.html" title="Kafka 入门教程之五">https://www.techgrow.cn/posts/ed9d5bd.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 分布式</a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> 消息队列</a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag"><i class="fa fa-tag"></i> 大数据</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/c61757ff.html" rel="prev" title="Kafka 入门教程之四"><i class="fa fa-angle-left"></i> Kafka 入门教程之四</a></div><div class="post-nav-item"> <a href="/posts/e33a339c.html" rel="next" title="Docker 安装 Oracle 11g 数据库">Docker 安装 Oracle 11g 数据库<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.7m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">25:45</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/ed9d5bd.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>