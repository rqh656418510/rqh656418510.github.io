<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 巩固基础之一"><meta property="og:url" content="https://www.techgrow.cn/posts/8c3cfc46.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2021/12/gcc-step-view.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2024/11/process-address.png"><meta property="article:published_time" content="2024-10-26T13:55:33.000Z"><meta property="article:modified_time" content="2024-10-26T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2021/12/gcc-step-view.png"><link rel="canonical" href="https://www.techgrow.cn/posts/8c3cfc46.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/8c3cfc46.html","path":"posts/8c3cfc46.html","title":"C++ 巩固基础之一"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 巩固基础之一 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="nav-text">编译与链接原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4"><span class="nav-text">编译命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0"><span class="nav-text">编译参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="nav-text">编译流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%88%86%E6%9E%90"><span class="nav-text">编译分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-text">C++ 的内存分配与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">C++ 的内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E5%92%8C-malloc-%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-text">new 和 malloc 的概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E5%92%8C-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">new 和 malloc 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="nav-text">C++ 的内存释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#delete-%E5%92%8C-free-%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-text">delete 和 free 的概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete-%E5%92%8C-free-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">delete 和 free 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">内存分配与释放的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E5%92%8C-delete-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">new 和 delete 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-%E5%92%8C-free-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">malloc 和 free 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="nav-text">new 的几种常见用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84-const%E3%80%81%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8"><span class="nav-text">C++ 的 const、指针、引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">C 语言案例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-text">C++ 案例代码一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C"><span class="nav-text">C++ 案例代码二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%89"><span class="nav-text">C++ 案例代码三</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9B%9B"><span class="nav-text">C++ 案例代码四</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%BD%A2%E5%8F%82%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">C++ 形参带默认值的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">C++ 内联函数的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">C++ 函数重载的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-text">函数重载案例代码一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E9%87%8D%E8%BD%BD%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="nav-text">函数代码重载案例二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-text">进程之间的通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E5%92%8C%E5%B8%83%E5%B1%80"><span class="nav-text">进程的虚拟地址空间内存划分和布局</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">686</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/8c3cfc46.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 巩固基础之一 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 的巩固教程。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 巩固基础之一</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-10-26 21:55:33" itemprop="dateCreated datePublished" datetime="2024-10-26T21:55:33+08:00">2024-10-26</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/8c3cfc46.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/8c3cfc46.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>6.2k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>6 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><h2 id="编译与链接原理"><a href="#编译与链接原理" class="headerlink" title="编译与链接原理"></a>编译与链接原理</h2><div class="admonition note"><p class="admonition-title">提示</p><p>强烈建议在阅读完本节的内容后，多花点时间深入读一遍《深入理解计算机系统 - 第三版》的第 7 章 "链接"。</p></div><h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><table><thead><tr><th>步骤</th><th>命令</th></tr></thead><tbody><tr><td> 1. 预处理</td><td> gcc -E hello.c -o hello.i</td></tr><tr><td>2. 编译到汇编代码</td><td> gcc -S hello.i -o hello.s</td></tr><tr><td>3. 汇编到目标代码（机器语言）</td><td>gcc -c hello.s -o hello.o</td></tr><tr><td>4. 链接，生成可执行文件</td><td> gcc hello.o -o hello</td></tr><tr><td> 以上四个步骤，可以合成一个步骤，直接编译链接成可执行的目标文件</td><td> gcc hello.c -o hello</td></tr></tbody></table><span id="more"></span><h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><table><thead><tr><th>参数</th><th>作用</th><th>编译示例</th><th>示例说明</th></tr></thead><tbody><tr><td> -o</td><td> 指定输出可执行程序的名称，默认文件名为”a.out”</td><td>gcc hello.c -o hello</td><td> 编译单个源文件 hello.c，指定输出可执行程序的名称为 hello，支持同时编译多个源文件</td></tr><tr><td> -E</td><td> 仅作预处理，不进行编译、汇编和链接</td><td> gcc -E hello.c -o hello.i</td><td> 仅预处理源文件，指定生成中间文件 <code>*.i</code>，此阶段主要处理源文件中的 #ifdef、#include、#define 等预处理命令</td></tr><tr><td> -S</td><td> 只编译到汇编语言，不进行汇编和链接，生成汇编代码</td><td> gcc -S hello.c -o hello.s</td><td> 仅编译到汇编语言，指定生成汇编源文件 <code>*.s</code></td></tr><tr><td>-c</td><td> 只编译、汇编到目标代码，不进行链接，生成目标文件（机器语言）</td><td>gcc -c hello.s -o hello.o</td><td> 根据汇编源文件 <code>*.s</code>，指定生成目标文件 <code>*.o</code>，最后根据生成的目标文件，可执行 <code>gcc hello.o -o hello</code> 命令生成可执行程序</td></tr><tr><td> -l</td><td> 指定程序链接哪个静态库或者动态库</td><td></td><td></td></tr><tr><td> -m</td><td> 表示是数学库，也就是使用 math.h 头文件</td><td> gcc hello.c -o hello -lm</td><td> 编译单个源文件 hello.c，指定输出可执行程序名称为 hello，并指定程序链接到数学库</td></tr><tr><td> -I dir</td><td> 在头文件的搜索路径列表中添加 dir 目录</td><td></td><td></td></tr><tr><td> -L dir</td><td> 在库文件的搜索路径列表中添加 dir 目录</td><td></td><td></td></tr><tr><td> -O、-O2、-O3</td><td> 将优化状态打开，该选项不能与”-g” 选项联合使用</td><td></td><td></td></tr><tr><td> -g</td><td> 在生成的可执行程序中包含标准调试信息</td><td></td><td></td></tr><tr><td> -Wall</td><td> 在发生警告时取消编译操作，即将警告看作是错误</td><td></td><td></td></tr><tr><td> -pedantic</td><td> 严格要求代码符合 ANSI/ISO C 标准，若不符合则给出编译警告信息</td><td></td><td></td></tr><tr><td> -w</td><td> 禁止输出所有警告</td><td></td><td></td></tr><tr><td> -v</td><td> 打印编译器内部编译各过程的命令行信息和编译器的版本号</td><td></td><td> </td></tr></tbody></table><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>C++ 的编译和链接过程通常分为四个主要阶段：预处理、编译、汇编和链接。每个阶段都有特定的任务，最终生成可执行文件。这些阶段的流程如下：</p><ul><li><strong>预处理</strong>：处理 <code>#include</code>、<code>#define</code> 等指令，生成纯文本代码。</li><li><strong>编译</strong>：将代码转换成汇编代码。</li><li><strong>汇编</strong>：将汇编代码转换成机器代码，生成目标文件。</li><li><strong>链接</strong>：将目标文件和库文件组合，生成可执行文件。</li></ul><p><img data-src="../../../asset/2021/12/gcc-step-view.png"></p><blockquote><p>第一步：预处理</p></blockquote><p>预处理阶段由预处理器处理，主要任务是处理源代码中的以 <code>#</code> 开头的指令，包括 <code>#include</code>、<code>#define</code> 等。预处理的主要任务包括：</p><ul><li><strong>头文件包含</strong>：将 <code>#include</code> 引用的头文件内容插入代码中。</li><li><strong>宏替换</strong>：将 <code>#define</code> 宏展开成具体内容。</li><li><strong>条件编译</strong>：根据 <code>#if</code>、<code>#ifdef</code> 等条件编译指令有选择地编译代码片段。</li></ul><p>经过预处理后的代码形成一个纯文本文件，通常称为 “预处理文件”。</p><blockquote><p>第二步：编译</p></blockquote><p>在编译阶段，编译器将预处理后的代码转换成<strong>汇编代码</strong>。编译的主要任务包括：</p><ul><li><strong>语法分析和语义分析</strong>：检查代码的语法和语义是否正确，如变量是否定义、数据类型是否匹配等。</li><li><strong>生成中间代码</strong>：将源码转换成一种与机器无关的中间表示，以便后续优化和生成目标代码。</li><li><strong>优化</strong>：编译器可能会优化代码以提高执行效率，比如消除冗余代码、优化循环等。</li></ul><p>编译阶段输出的通常是一个 <code>.s</code> 文件，其中包含汇编代码。</p><blockquote><p>第三步：汇编</p></blockquote><p>汇编阶段由汇编器将汇编代码转换为<strong>机器代码</strong>。机器代码是与目标 CPU 架构相关的低级二进制指令。汇编器会生成一个<strong>目标文件</strong>，通常带有 <code>.o</code> 或 <code>.obj</code> 后缀。值得一提的是，每个源文件都会经过汇编阶段，生成一个独立的目标文件。</p><blockquote><p>第四步：链接</p></blockquote><p>链接阶段由链接器负责，主要任务是将多个目标文件和库文件组合成一个<strong>可执行文件</strong>。链接的主要任务包括：</p><ul><li><strong>符号解析</strong>：将所有函数和变量的引用与其定义关联起来。例如，如果一个文件引用了另一个文件的函数，链接器会将引用解析为实际地址。</li><li><strong>地址分配</strong>：链接器分配每个符号（函数、变量）在最终可执行文件中的内存地址。</li><li><strong>合并代码段和数据段</strong>：链接器会将所有目标文件的代码段、数据段等部分合并，形成最终的可执行文件。</li></ul><p>链接完成后，生成最终的可执行文件，程序可以在操作系统上直接执行。</p><h3 id="编译分析"><a href="#编译分析" class="headerlink" title="编译分析"></a>编译分析</h3><blockquote><p>C++ 编译示例代码</p></blockquote><ul><li><code>sum.cpp</code> 的源码</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> gdata = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>main.cpp</code> 的源码</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> gdata;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = gdata;</span><br><span class="line">    <span class="keyword">int</span> b = data;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>编译代码生成可执行文件（默认是 <code>a.out</code>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp sum.cpp</span><br></pre></td></tr></tbody></table></figure><blockquote><p>C++ 编译分析命令</p></blockquote><ul><li>只编译、汇编到目标代码，不进行链接</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="params"> -c</span> sum.cpp</span><br><span class="line">g++<span class="params"> -c</span> main.cpp</span><br></pre></td></tr></tbody></table></figure><ul><li>查看目标文件的符号表，包括函数和全局变量的地址、大小等信息</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump<span class="params"> -t</span> sum.o</span><br><span class="line">objdump<span class="params"> -t</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>显示目标文件中各个段的内容（即十六进制和 ASCII 表示的原始数据）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump<span class="params"> -s</span> sum.o</span><br><span class="line">objdump<span class="params"> -s</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>查看目标文件的文件头信息</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readelf<span class="params"> -h</span> sum.o</span><br><span class="line">readelf<span class="params"> -h</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>查看目标文件中各段的详细信息，包括段的名称、大小、地址、类型和属性等</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readelf<span class="params"> -S</span> sum.o</span><br><span class="line">readelf<span class="params"> -S</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>将目标文件中的汇编代码（通过反汇编得到）与源代码进行对比显示，以便进行调试和分析</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="params"> -c</span> main.cpp<span class="params"> -g</span>    // 生成目标文件，-g 参数表示带上调试信息</span><br><span class="line">objdump<span class="params"> -S</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>链接所有目标文件，并查看指定文件的符号表信息</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="params"> -e</span> main *.o     // 将所有的目标文件链接成一个完整的程序，默认会生成一个名为 a.out 的可执行文件</span><br><span class="line">objdump<span class="params"> -t</span> a.out</span><br></pre></td></tr></tbody></table></figure><ul><li>查看可执行文件（通常是 ELF 格式）的程序头信息</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf<span class="params"> -l</span> a.out</span><br></pre></td></tr></tbody></table></figure><h2 id="C-的内存分配与释放"><a href="#C-的内存分配与释放" class="headerlink" title="C++ 的内存分配与释放"></a>C++ 的内存分配与释放</h2><h3 id="C-的内存分配"><a href="#C-的内存分配" class="headerlink" title="C++ 的内存分配"></a>C++ 的内存分配</h3><h4 id="new-和-malloc-的概述"><a href="#new-和-malloc-的概述" class="headerlink" title="new 和 malloc 的概述"></a>new 和 malloc 的概述</h4><ul><li><p><code>new</code></p><ul><li>C++ 中的运算符（<code>operator new</code>），用于按类型动态分配内存。</li><li>底层同样是调用 <code>malloc()</code> 函数开辟内存，但还会调用类对象的构造函数（如果是类对象）进行初始化。</li><li>返回值是对应类型的指针，不需要强制类型转换。</li><li>开辟内存失败时，会抛出 <code>std::bad_alloc</code> 异常。</li></ul></li><li><p><code>malloc</code></p><ul><li>C 语言中的标准库函数，用于按字节动态分配内存。</li><li>不会初始化分配的内存，也不会调用类对象的构造函数（如果分配的内存是用于类对象）。</li><li>返回值是 <code>void *</code>，需要强制类型转换。</li><li>开辟内存失败时，返回 <code>nullptr</code>（或 C 中返回 <code>NULL</code>），需要手动检查。</li></ul></li></ul><h4 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc 的区别"></a>new 和 malloc 的区别</h4><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>所属语言</td><td> C / C++</td><td>C++ 专用</td></tr><tr><td>本质</td><td>库函数（在 <code>&lt;cstdlib&gt;</code> 中）</td><td>运算符（可重载）</td></tr><tr><td>内存分配方式</td><td>按字节动态分配内存</td><td>按类型动态分配内存</td></tr><tr><td>返回值</td><td>返回 <code>void *</code>，需强制类型转换</td><td>返回对应类型的指针，无需类型转换</td></tr><tr><td>是否调用构造函数</td><td>❌ 不会调用构造函数</td><td>✅ 会调用构造函数</td></tr><tr><td>是否调用析构函数</td><td>❌ <code>free</code> 不会调用析构函数</td><td>✅ <code>delete</code> 调用析构函数</td></tr><tr><td>失败时的行为</td><td>返回 <code>nullptr</code>（或 C 中返回 <code>NULL</code>），需手动检查</td><td>抛出 <code>std::bad_alloc</code> 异常</td></tr><tr><td>是否可重载</td><td>❌ 不可重载</td><td>✅ 可重载 <code>operator new</code>、<code>operator delete</code></td></tr><tr><td>对象初始化</td><td>❌ 不支持</td><td>✅ 自动调用构造函数来初始化对象</td></tr><tr><td>释放方式</td><td>使用 <code>free(ptr)</code> 释放内存</td><td>使用 <code>delete ptr</code> 或 <code>delete[] ptr</code> 释放内存</td></tr></tbody></table><h3 id="C-的内存释放"><a href="#C-的内存释放" class="headerlink" title="C++ 的内存释放"></a>C++ 的内存释放</h3><h4 id="delete-和-free-的概述"><a href="#delete-和-free-的概述" class="headerlink" title="delete 和 free 的概述"></a>delete 和 free 的概述</h4><ul><li><p><code>delete</code> 的概述</p><ul><li><code>delete</code> 操作符用于释放通过 <code>new</code> 分配的内存。</li><li>在释放内存之前，<code>delete</code> 会先调用类对象的析构函数，以确保资源（如文件句柄、网络连接等）正确释放。</li><li>如果分配的是数组，必须使用 <code>delete[]</code>，否则可能会导致未定义行为。</li></ul></li><li><p><code>free</code> 的概述</p><ul><li><code>free</code> 是 C 标准库函数，用于释放通过 <code>malloc/calloc/realloc</code> 分配的内存。</li><li>它只会释放内存，不会执行任何其他操作，例如对象的析构。</li></ul></li><li><p><code>delete</code> 与 <code>free</code> 不能混用</p><ul><li>通过 <code>new</code> 分配的内存必须用 <code>delete</code> 释放，不能用 <code>free</code>，否则可能会导致未定义行为。</li><li>通过 <code>malloc</code> 分配的内存必须用 <code>free</code> 释放，不能用 <code>delete</code>，否则可能会导致未定义行为。</li></ul></li><li><p><code>delete</code> 与 <code>free</code> 的内存布局和管理差异</p><ul><li><code>new</code> 和 <code>delete</code> 是 C++ 的操作符，它们了解对象的类型，并能为复杂类型的构造和析构做出正确的处理。</li><li><code>malloc</code> 和 <code>free</code> 是 C 的函数，它们只分配和释放内存，不了解对象的类型。</li></ul></li></ul><h4 id="delete-和-free-的区别"><a href="#delete-和-free-的区别" class="headerlink" title="delete 和 free 的区别"></a>delete 和 free 的区别</h4><table><thead><tr><th>特性</th><th><code>delete</code></th><th><code>free</code></th></tr></thead><tbody><tr><td>适用语言</td><td> C++ 专用</td><td> C 和 C++</td></tr><tr><td> 适用对象</td><td>动态分配的对象（通过 <code>new</code> 分配）</td><td>动态分配的内存块（通过 <code>malloc/calloc/realloc</code> 分配）</td></tr><tr><td>是否调用析构函数</td><td>会调用类对象的析构函数</td><td>只释放内存，不调用类对象的析构函数</td></tr><tr><td>分配与释放的匹配要求</td><td>必须和 <code>new</code> 成对使用</td><td>必须和 <code>malloc/calloc/realloc</code> 成对使用</td></tr><tr><td>数组释放</td><td>使用 <code>delete[]</code> 释放动态数组</td><td>没有专门的数组释放功能</td></tr><tr><td>底层机制</td><td> C++ 的运行时库负责，处理更高级的资源管理</td><td> C 的运行时库负责，直接释放内存</td></tr></tbody></table><h3 id="内存分配与释放的使用"><a href="#内存分配与释放的使用" class="headerlink" title="内存分配与释放的使用"></a>内存分配与释放的使用</h3><h4 id="new-和-delete-的使用"><a href="#new-和-delete-的使用" class="headerlink" title="new 和 delete 的使用"></a>new 和 delete 的使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>); <span class="comment">// 分配内存，并且会初始化内存为 20</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]();    <span class="comment">// 数组初始化为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">delete</span>[] arr;   <span class="comment">// 释放数组内存</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = 20</span><br><span class="line">0 0 0 0 0 </span><br></pre></td></tr></tbody></table></figure><h4 id="malloc-和-free-的使用"><a href="#malloc-和-free-的使用" class="headerlink" title="malloc 和 free 的使用"></a>malloc 和 free 的使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"p = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = 20</span><br></pre></td></tr></tbody></table></figure><h4 id="new-的几种常见用法"><a href="#new-的几种常见用法" class="headerlink" title="new 的几种常见用法"></a>new 的几种常见用法</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 第一种用法</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种用法</span></span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="built_in"><span class="keyword">new</span></span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 即使内存分配失败，也不抛出异常</span></span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种用法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">delete</span> p3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四种用法</span></span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p4 = <span class="built_in"><span class="keyword">new</span></span> (&amp;data) <span class="built_in"><span class="keyword">int</span></span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"data = "</span> &lt;&lt; data &lt;&lt; endl; <span class="comment">// 输出 50</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = 50</span><br></pre></td></tr></tbody></table></figure><h2 id="C-的-const、指针、引用"><a href="#C-的-const、指针、引用" class="headerlink" title="C++ 的 const、指针、引用"></a>C++ 的 const、指针、引用</h2><ul><li>引用的本质<ul><li>引用本质上是一种更安全的指针。</li></ul></li><li>指针与引用的区别<ul><li>引用必须初始化，指针可以不初始化。</li><li>引用只有一级引用，没有多级引用；指针可以有一级指针，也可以有多级指针。</li><li>定义一个引用变量和定义一个指针变量，其底层的汇编指令是一模一样的。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="/posts/b03c11a0.html">C++ 的 const 与引用介绍</a></li></ul></div><h3 id="C-语言案例代码"><a href="#C-语言案例代码" class="headerlink" title="C 语言案例代码"></a>C 语言案例代码</h3><ul><li>C 语言中常量的使用</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _main() {</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这行代码 C 编译器编译不通过，因为 a 虽然是常量，但在 C 语言中，它并不是编译期常量（即不是编译器在编译时可以确定的常量），而是运行时的常量</span></span><br><span class="line">    <span class="comment">// 标准 C 语言（C89/C90 和 C99）要求数组大小在编译时确定，所以不能使用 const int 变量来定义数组大小</span></span><br><span class="line">    <span class="comment">// int array[a] = {};</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C 语言中的 const 变量属于伪常量，有自己的内存空间，可以通过操作指针的方式来修改 const 变量的值</span></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, *p, *(&amp;a));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 30 30</span><br></pre></td></tr></tbody></table></figure><h3 id="C-案例代码一"><a href="#C-案例代码一" class="headerlink" title="C++ 案例代码一"></a>C++ 案例代码一</h3><ul><li>C++ 中常量的使用</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 用字面量常量初始化常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 C++ 中，常量可以作为数组大小，因为 C++ 中 const 常量是在编译时确定的</span></span><br><span class="line">    <span class="keyword">int</span> array[a] = {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 C++ 中，不可以通过操作指针的方式来修改 const 变量的值</span></span><br><span class="line">    <span class="comment">// 当使用 &amp; 操作符取 const 常量的地址时，编译器会临时开辟一块内存空间</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, *p, *(&amp;a));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 用变量来初始化常量（通常叫常变量）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时不能再用来作为数组大小</span></span><br><span class="line">    <span class="comment">// int array[b] = {};</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时可以通过操作指针的方式来修改 const 变量的值</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, *p, *(&amp;a));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 20 3</span><br><span class="line">20 20 20</span><br></pre></td></tr></tbody></table></figure><h3 id="C-案例代码二"><a href="#C-案例代码二" class="headerlink" title="C++ 案例代码二"></a>C++ 案例代码二</h3><ul><li>C++ 中指针与引用的使用</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> {</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级指针作函数参数，参数 p 是一个指向 Person 指针的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocatMemory1</span><span class="params">(Person **p)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态分配内存给 *p，使其指向一个新的 Person 对象</span></span><br><span class="line">    *p = (Person *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    (*p)-&gt;age = <span class="number">18</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义一个 Person 类型的指针 p，初始化为 NULL（空指针）</span></span><br><span class="line">    Person *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 传入 &amp;p（Person* 的地址）</span></span><br><span class="line">    <span class="built_in">allocatMemory1</span>(&amp;p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; p-&gt;age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针引用作函数参数，参数 p 是 Person* 类型的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocatMemory2</span><span class="params">(Person *&amp;p)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态分配内存给 p，使其指向一个新的 Person 对象</span></span><br><span class="line">    p = (Person *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    p-&gt;age = <span class="number">20</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义一个 Person 类型的指针 p，初始化为 NULL（空指针）</span></span><br><span class="line">    Person *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 直接传入 p</span></span><br><span class="line">    <span class="built_in">allocatMemory2</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; p-&gt;age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 常量引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;num = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内存的0x0018ff44位置写一个4字节的10</span></span><br><span class="line">    <span class="comment">// int *p = (int *) 0x0018ff44;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级指针</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> **q = &amp;p;</span><br><span class="line">    cout &lt;&lt; **q &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级指针</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针引用</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">age = 18</span><br><span class="line">age = 20</span><br></pre></td></tr></tbody></table></figure><h3 id="C-案例代码三"><a href="#C-案例代码三" class="headerlink" title="C++ 案例代码三"></a>C++ 案例代码三</h3><ul><li>C++ 中指针与引用、左值引用与右值引用的使用</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针与引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a; <span class="comment">// 引用，其底层是基于指针实现的</span></span><br><span class="line">    <span class="comment">// int &amp;c = 20; // 错误写法</span></span><br><span class="line"></span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// 20 20 20</span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// 30 30 30</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针与引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// swap1(&amp;a, &amp;b);</span></span><br><span class="line">    <span class="built_in">swap2</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;   <span class="comment">// a = 20, b = 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用数组变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> array[<span class="number">5</span>] = {};</span><br><span class="line">    <span class="keyword">int</span> *p = array;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(array) &lt;&lt; endl;  <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个引用变量来引用数组变量</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (&amp;q)[<span class="number">5</span>] = array;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(q) &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左值引用与右值引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 左值，它有内存，有名称，值可以修改</span></span><br><span class="line">    <span class="keyword">int</span> &amp;b = a; <span class="comment">// 左值引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// b = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int &amp;c = 20; // 错误写法，左值引用只能引用左值，20 是右值（没有内存和名称），不能引用 20</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;c = <span class="number">20</span>; <span class="comment">// 正确写法，C++ 提供了右值引用</span></span><br><span class="line">    <span class="comment">// int &amp;&amp;c = a; // 错误写法，右值引用只能引用右值，a 是左值，不能引用 a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// c = 20</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">20 20 20</span><br><span class="line">30 30 30</span><br><span class="line">a = 20, b = 10</span><br><span class="line">20</span><br><span class="line">4</span><br><span class="line">20</span><br><span class="line">b = 10</span><br><span class="line">c = 20</span><br></pre></td></tr></tbody></table></figure><h3 id="C-案例代码四"><a href="#C-案例代码四" class="headerlink" title="C++ 案例代码四"></a>C++ 案例代码四</h3><ul><li>const 与一二级指针的使用</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const与一级指针的结合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// int *p = &amp;a; // 错误写法，不能将常量的地址泄漏给一个普通的指针或者普通的引用变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const与一级指针的结合</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; C++的语言规范：const 修饰的是离它最近的类型</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; const 在 * 的左边则定值，const 在 * 的右边则定向，即左定值右定向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种写法（左定值）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    p = &amp;b; <span class="comment">// 正确写法，可以任意指向不同的int类型的内存</span></span><br><span class="line">    <span class="comment">// *p = 30; // 错误写法，不能通过指针间接修改指向的内存的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"p = "</span> &lt;&lt; *p &lt;&lt; endl; <span class="comment">// p = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种写法的变体（左定值）</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> *p2 = &amp;a;</span><br><span class="line">    p2 = &amp;b; <span class="comment">// 正确写法，可以任意指向不同的int类型的内存</span></span><br><span class="line">    <span class="comment">// *p2 = 30; // 错误写法，不能通过指针间接修改指向的内存的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"p2 = "</span> &lt;&lt; *p2 &lt;&lt; endl; <span class="comment">// p2 = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种写法（右定向）</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">    <span class="comment">// p3 = &amp;b; // 错误写法，不可以任意指向不同的int类型的内存</span></span><br><span class="line">    *p3 = <span class="number">30</span>; <span class="comment">// 正确写法，可以通过指针间接修改指向的内存的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"p3 = "</span> &lt;&lt; *p3 &lt;&lt; <span class="string">", a = "</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// p3 = 30, a = 30</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const与二级指针的结合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种写法</span></span><br><span class="line">    <span class="comment">// const int **q = &amp;p;  // 错误写法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种写法</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> *q = &amp;p;  <span class="comment">// 正确写法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种写法</span></span><br><span class="line">    <span class="comment">// int **const q = &amp;p;  // 错误写法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = 20</span><br><span class="line">p2 = 20</span><br><span class="line">p3 = 30, a = 30</span><br></pre></td></tr></tbody></table></figure><h2 id="C-形参带默认值的函数"><a href="#C-形参带默认值的函数" class="headerlink" title="C++ 形参带默认值的函数"></a>C++ 形参带默认值的函数</h2><ul><li>形参设置默认值的时候，必须从右向左设置。</li><li>形参是否设置默认值，对函数的调用效率会产生影响（底层生成的汇编指令会有差别）。</li><li>函数定义时可以给形参设置默认值，函数声明时也可以给形参设置默认值。</li><li>形参设置默认值的时候，不管是在函数定义处，还是在函数声明处，形参的默认值设置只能出现一次。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的形参带默认值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a = <span class="number">30</span>, <span class="keyword">int</span> b = <span class="number">40</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> result = a + b;</span><br><span class="line">    cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="built_in">sum</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result2 = "</span> &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="built_in">sum</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"result3 = "</span> &lt;&lt; result3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = 30</span><br><span class="line">result2 = 50</span><br><span class="line">result3 = 70</span><br></pre></td></tr></tbody></table></figure><h2 id="C-内联函数的使用"><a href="#C-内联函数的使用" class="headerlink" title="C++ 内联函数的使用"></a>C++ 内联函数的使用</h2><ul><li>普通函数<ul><li>普通函数的调用会有开销，比如：参数压栈、函数栈帧的开辟、回退等操作。</li></ul></li><li>内联函数<ul><li>内联函数在编译过程中，就没有函数的调用开销，而是在函数的调用点直接用函数的代码展开（替换）处理。</li><li><code>inline</code> 关键字只是建议编译器将指定的函数处理成内联函数，但并不是所有的 <code>inline</code> 关键字都会被编译器处理成内联函数，比如：递归函数。</li><li>在 Debug 版本中，<code>inline</code> 关键字是不起作用的，<code>inline</code> 关键字只有在 Release 版本中才起作用。</li><li>当编译器将 <code>inline</code> 关键字修饰的函数处理成内联函数后，就不会再生成该函数对应的符号表内容。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="C-函数重载的使用"><a href="#C-函数重载的使用" class="headerlink" title="C++ 函数重载的使用"></a>C++ 函数重载的使用</h2><p>一组函数，其中函数名相同，参数列表的个数、类型、顺序不同，那么这一组函数就称为 - 函数重载。</p><ul><li>(1) 一组函数要称得上是函数重载，那么这组函数必须是处于同一个作用域当中的。</li><li>(2) 一组函数，函数名称相同，参数列表相同，仅仅返回值不同，这不叫函数重载。</li><li>(3) C++ 的多态有两种表现形式，包括静态多态（编译时期）和动态多态（运行时期），而函数重载属于静态多态的一种。</li><li>(4) <code>const</code> 关键字不能作为判断函数是否重载的条件，比如 <code>void sub(int a);</code> 与 <code>void sub(const int a)</code> 之间不是重载关系。</li></ul><div class="admonition note"><p class="admonition-title">为什么 C++ 支持函数重载，而 C 语言不支持函数重载？</p><ul><li>C++ 代码产生函数符号的时候，由函数名 + 参数列表决定。</li><li>C 语言代码产生函数符号的时候，仅由函数名决定。</li></ul></div><h3 id="函数重载案例代码一"><a href="#函数重载案例代码一" class="headerlink" title="函数重载案例代码一"></a>函数重载案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"compare_int_int"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"compare_double_double"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"compare_char*_char*"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">compare</span>(<span class="number">3.4</span>, <span class="number">2.4</span>);</span><br><span class="line">    <span class="built_in">compare</span>(<span class="string">"abc"</span>, <span class="string">"efd"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="函数代码重载案例二"><a href="#函数代码重载案例二" class="headerlink" title="函数代码重载案例二"></a>函数代码重载案例二</h3><p>C++ 调用在 C 语言中定义的函数时，默认会编译失败，这是因为 C++ 与 C 语言生成函数符号的规则是不同的，从而导致 C++ 在编译时找不到在 C 语言中定义的函数。解决方法是，在 C++ 代码中，使用 <code>extern "C" { }</code> 来包裹函数的声明。</p><ul><li>C 语言的源代码</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>C++ 的源代码</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记大括号里的函数符号是按照 C 语言的规则来生成</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line">    <span class="comment">// 函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>如果是 C 语言需要调用在 C++ 中定义的函数，那么在 C++ 的代码中，也需要使用 <code>extern "C" { }</code> 包裹函数的定义。</p></div><p>值得一提的是，在多语言的项目开发中，往往会看到下面这样的 C++ 代码，其中的 <code>__cplusplus</code> 是 C++ 编译器内置的宏名。这样写的好处是，无论是在 C++ 还是 C 语言的代码中调用 <code>sum()</code> 函数，编译器都可以正常编译。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="进程之间的通信方式"><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a>进程之间的通信方式</h2><p>在 C++ 中，进程间通信（IPC）有多种方式可供选择。以下是一些常见的 IPC 方法：</p><ul><li><p><strong>管道（Pipe）</strong></p><ul><li>匿名管道：只能在父子进程之间通信。它在 Unix 和 Windows 上都支持。</li><li>命名管道：允许不同的进程进行通信。它可以跨不同的无亲缘关系的进程进行通信。</li></ul></li><li><p><strong>信号（Signal）</strong></p><ul><li>信号是一种异步通知机制，可以用于进程之间的简单通信。通常用于通知进程某个事件发生，例如终止、暂停等。信号适用于 Unix 系统。</li></ul></li><li><p><strong>消息队列（Message Queue）</strong></p><ul><li>消息队列允许进程之间通过发送和接收消息进行通信。这种方式支持消息的优先级排序，能够在多种操作系统上实现。POSIX 和 System V 都提供了消息队列的实现。</li></ul></li><li><p><strong>共享内存（Shared Memory）</strong></p><ul><li>共享内存是一种高效的 IPC 方式，允许多个进程共享同一块内存区域。由于数据直接存储在共享的内存空间中，读写速度较快，但需要使用同步机制来避免竞争条件。</li></ul></li><li><p><strong>信号量（Semaphore）</strong></p><ul><li>信号量是一种用于多进程间同步的机制，通常和共享内存配合使用，以保证进程对共享资源的有序访问。System V 和 POSIX 都提供了信号量的实现。</li></ul></li><li><p><strong>套接字（Socket）</strong></p><ul><li>套接字是一种强大的通信方式，支持同一台机器上的进程通信（本地套接字）以及不同机器之间的网络通信（网络套接字）。它具有跨平台的特性，广泛用于分布式系统。</li></ul></li><li><p><strong>内存映射文件（Memory-Mapped Files）</strong></p><ul><li>内存映射文件可以将文件内容映射到进程的地址空间中，多个进程可以通过映射相同的文件来实现数据共享。这种方式在 Unix 和 Windows 系统上都支持。</li></ul></li><li><p><strong>远程过程调用（Remote Procedure Call）</strong></p><ul><li>RPC 允许进程在远程主机上执行函数调用。虽然并非严格意义上的 IPC 机制，但它能够在分布式系统中用于进程通信。gRPC 是一种流行的 RPC 框架。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>在选择 IPC 方式时，可以根据应用的需求（如速度、复杂性、跨平台性）来选择合适的方式。例如，管道和消息队列适合简单的通信需求，而共享内存适合大数据量的高效通信。</p></div><h2 id="进程的虚拟地址空间内存划分和布局"><a href="#进程的虚拟地址空间内存划分和布局" class="headerlink" title="进程的虚拟地址空间内存划分和布局"></a>进程的虚拟地址空间内存划分和布局</h2><p>在 X86 32 位的 Linux 系统上，Linux 系统会给进程分配 2^32 大小（4GB）的一块空间，其中用户空间（User Space）占 3GB，内核空间（Kernel Space）占 1GB。值得一提的是，每一个进程的用户空间是私有的，但是内核空间是共享的。</p><p><img data-src="../../../asset/2024/11/process-address.png"></p><ul><li><code>.text</code>：已编译程序的机器代码。</li><li><code>.rodata</code>：只读数据，比如 <code>printf</code> 语句中的格式串和开关语句的跳转表。</li><li><code>.data</code>：已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不出现在 <code>.data</code> 节中，也不出现在 <code>.bss</code> 节中。</li><li><code>.bss</code>：未初始化的全局和静态 C 变量，以及所有被初始化为 <code>0</code> 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。程序运行时，在内存中分配这些变量，初始值为 <code>0</code>。</li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/8c3cfc46.html" title="C++ 巩固基础之一">https://www.techgrow.cn/posts/8c3cfc46.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/e5c0e9c6.html" rel="prev" title="Flatpak 解决 OBS 多路推流插件不生效的问题"><i class="fa fa-angle-left"></i> Flatpak 解决 OBS 多路推流插件不生效的问题</a></div><div class="post-nav-item"> <a href="/posts/e3aa2fd8.html" rel="next" title="Linux 生产环境搭建 Kafka-KRaft 集群">Linux 生产环境搭建 Kafka-KRaft 集群<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.8m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">26:46</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/8c3cfc46.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>