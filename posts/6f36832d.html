<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要记录 Redis 日常使用的笔记。"><meta property="og:type" content="article"><meta property="og:title" content="Redis 开发随笔"><meta property="og:url" content="https://www.techgrow.cn/posts/6f36832d.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要记录 Redis 日常使用的笔记。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/07/redis-thread-model.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/08/redisson-locks-1.png"><meta property="article:published_time" content="2018-05-26T15:20:42.000Z"><meta property="article:modified_time" content="2018-05-26T15:20:42.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="开发随笔"><meta property="article:tag" content="缓存"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/07/redis-thread-model.png"><link rel="canonical" href="https://www.techgrow.cn/posts/6f36832d.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/6f36832d.html","path":"posts/6f36832d.html","title":"Redis 开发随笔"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Redis 开发随笔 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">Redis 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-Redis-%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-text">如何查看 Redis 的内存使用情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-Redis-%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="nav-text">如何查看 Redis 的最大占用内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E9%BB%98%E8%AE%A4%E6%9C%89%E5%A4%9A%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8"><span class="nav-text">Redis 默认有多大的内存可以使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9-Redis-%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-text">生产环境如何修改 Redis 的内存大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E8%B6%85%E5%87%BA%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="nav-text">Redis 内存使用超出设置的最大值会怎样</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-text">Redis 删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%AF%B9%E8%BF%87%E6%9C%9F-Key-%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-text">Redis 对过期 Key 的删除策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">Redis 的内存淘汰策略有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-Redis-%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-text">如何查看 Redis 的内存淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9-Redis-%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-text">如何修改 Redis 的内存淘汰策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">Redis 分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="nav-text">分布式锁都有哪些实现方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">分布式锁使用的注意事项有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E3%80%81ZooKeeper-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">Redis、ZooKeeper 实现分布式锁的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">Redis 底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%92%91%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-text">Redis 是单线程的为什么还可以支撑高并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E4%BD%BF%E7%94%A8%E8%AF%AF%E5%8C%BA"><span class="nav-text">Redis 使用误区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%80-Redis-%E9%87%8C%E5%86%99%E7%9A%84%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E6%B2%A1%E4%BA%86"><span class="nav-text">往 Redis 里写的数据怎么没了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%98%8E%E6%98%8E%E9%83%BD%E8%BF%87%E6%9C%9F%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E8%BF%98%E5%8D%A0%E7%94%A8%E7%9D%80%E5%86%85%E5%AD%98"><span class="nav-text">数据明明都过期了，怎么还占用着内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E4%BA%8E%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E9%9A%9C%E6%84%8F%E4%B9%89"><span class="nav-text">主节点持久化对于主从架构的安全保障意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-RedLock-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">基于 RedLock 算法实现分布式锁</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">733</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/6f36832d.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Redis 开发随笔 | Clay 的技术空间"><meta itemprop="description" content="本文主要记录 Redis 日常使用的笔记。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Redis 开发随笔</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-05-26 23:20:42" itemprop="dateCreated datePublished" datetime="2018-05-26T23:20:42+08:00">2018-05-26</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/6f36832d.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/6f36832d.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>14k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>13 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="Redis 内存管理"></a>Redis 内存管理</h2><h3 id="如何查看-Redis-的内存使用情况"><a href="#如何查看-Redis-的内存使用情况" class="headerlink" title="如何查看 Redis 的内存使用情况"></a>如何查看 Redis 的内存使用情况</h3><p>使用 Redis 的 INFO 命令，可以获取有关 Redis 服务器的内存信息，命令如下：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info memory</span><br></pre></td></tr></tbody></table></figure><p>其中与内存使用情况相关的输出信息如下：</p><ul><li><code>used_memory</code>：已使用的内存</li></ul><span id="more"></span><h3 id="如何查看-Redis-的最大占用内存"><a href="#如何查看-Redis-的最大占用内存" class="headerlink" title="如何查看 Redis 的最大占用内存"></a>如何查看 Redis 的最大占用内存</h3><blockquote><p>第一种查看方式</p></blockquote><p>要查看 Redis 的最大占用内存，可以使用 Redis 的 CONFIG 命令来获取 Redis 服务器的内存配置信息，命令如下：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get maxmemory</span><br></pre></td></tr></tbody></table></figure><blockquote><p>第二种查看方式</p></blockquote><p>要查看 Redis 的最大占用内存，可以使用 Redis 的 INFO 命令来获取 Redis 服务器的内存信息，命令如下：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info memory</span><br></pre></td></tr></tbody></table></figure><p>其中与最大占用内存相关的输出信息如下：</p><ul><li><code>maxmemory</code>：可使用的最大内存（最大占用内存）</li></ul><h3 id="Redis-默认有多大的内存可以使用"><a href="#Redis-默认有多大的内存可以使用" class="headerlink" title="Redis 默认有多大的内存可以使用"></a>Redis 默认有多大的内存可以使用</h3><p>如果 Redis 不设置最大内存大小，或者设置最大内存大小为 0，那么在 64 位操作系统下不限制内存大小，在 32 位操作系统下最多可以使用 3GB 内存。因为 32 位系统最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 Redis 限制 32 位系统最大有 3GB 内存可以使用。</p><h3 id="生产环境如何修改-Redis-的内存大小"><a href="#生产环境如何修改-Redis-的内存大小" class="headerlink" title="生产环境如何修改 Redis 的内存大小"></a>生产环境如何修改 Redis 的内存大小</h3><p>在生产环境中，一般推荐设置 Redis 的内存大小为最大物理内存的四分之三。Redis 内存大小的修改，有以下两种方式：</p><ul><li>第一种方式，通过配置文件永久修改<ul><li>打开 Redis 的配置文件（通常是 <code>redis.conf</code>），找到并设置 <code>maxmemory</code> 参数的值，该参数是 <code>bytes</code> 字节类型，需要注意单位的转换。</li><li>重新启动 Redis 服务，以使新的内存配置生效。</li></ul></li><li>第二种方式，通过命令临时修改<ul><li>使用 <code>config set maxmemory xxxx</code> 命令修改 Redis 的内存大小，单位是字节。</li><li>特别注意，在 Redis 服务器重启之后，这个修改会失效，也就是说使用命令这种修改方式不会永久保存到配置文件中。</li></ul></li></ul><h3 id="Redis-内存使用超出设置的最大值会怎样"><a href="#Redis-内存使用超出设置的最大值会怎样" class="headerlink" title="Redis 内存使用超出设置的最大值会怎样"></a>Redis 内存使用超出设置的最大值会怎样</h3><p>当 Redis 的内存使用超出了设置的最大内存限制（<code>maxmemory</code>）时，通常会导致以下几种情况之一：</p><ul><li><strong>数据丢失：</strong> 如果 Redis 的内存超出了设置的最大值，并且未启用持久化（如 RDB 快照或 AOF 日志），那么一旦 Redis 进程重新启动，超出内存限制的数据可能会丢失。</li><li><strong>操作失败：</strong> 当 Redis 超出内存限制时，它可能会拒绝执行新的写操作（如 SET、LPUSH 等），并返回错误给客户端。这种情况下，客户端可能会收到类似于 <code>OOM command not allowed when used memory &gt; 'maxmemory'</code> 的错误信息。</li><li><strong>触发操作系统的交换：</strong> 当 Redis 使用的内存超出物理内存限制时，操作系统可能会将一部分内存数据交换到磁盘上的交换空间（Swap Space）中。这会导致系统性能急剧下降，因为磁盘访问速度远远低于内存访问速度。这种情况下，Redis 的响应时间会显著增加，而且可能会出现超时或请求失败的情况。</li></ul><p>为了避免这些问题，可以考虑以下解决方案：</p><ul><li>监控 Redis 的内存使用情况，及时发现异常并采取措施。</li><li>合理设置 Redis 的最大内存限制，确保不会超出系统的物理内存。</li><li>使用合适的数据持久化方案（如 RDB 快照或 AOF 日志）以防止数据丢失。</li><li>如果条件允许，考虑使用集群模式或分片来分散数据，以减少单个实例的内存使用量。</li></ul><h2 id="Redis-删除数据"><a href="#Redis-删除数据" class="headerlink" title="Redis 删除数据"></a>Redis 删除数据</h2><h3 id="Redis-对过期-Key-的删除策略"><a href="#Redis-对过期-Key-的删除策略" class="headerlink" title="Redis 对过期 Key 的删除策略"></a>Redis 对过期 Key 的删除策略</h3><p>如果一个键是过期的，那它到了过期时间之后，是不是马上就从内存中被删除呢？答案肯定是否定的，因为 Redis 不可能时时刻刻遍历所有被设置了过期时间的 Key，来检测数据是否已经到达了过期时间，然后对它进行删除。<strong>Redis 针对过期 Key，提供了三种不同的删除策略，分别是：定时删除、惰性删除、定期删除。</strong></p><ul><li><p>定时删除</p><ul><li>定时删除能保证内存中数据的最大新鲜度，因为它可以保证过期 Key 会在过期后马上被删除，其所占用的内存也会随之释放，可以理解为 “立即删除”。</li><li>因为删除操作会占用 CPU 资源，如果刚好碰上了 CPU 很忙的时候，比如正在做交集或排序等计算的时候，就会给 CPU 造成额外的压力。这会产生大量的性能消耗，同时也会影响数据的读取操作。因此定时删除策略的缺点是：它对 CPU 是最不友好的。</li><li>简而言之，定时删除对 CPU 不友好，但对内存友好，相当于用处理器性能换取存储空间（即时间换空间）。</li></ul></li><li><p>惰性删除</p><ul><li>惰性删除的策略刚好和定时删除相反，惰性删除在数据到达过期时间后不做任何处理，等下次访问该数据时发现已过期，并将其删除，并返回不存在。</li><li>使用惰性删除访问数据的特点：访问一个数据，如果发现其在过期时间之内，则返回该数据；如果发现已经过了过期时间，则将其删除，并返回不存在。</li><li>如果一个键已经过期，而这个键又仍然保留在内存中，那么只要这个过期 Key 不被删除，它所占用的内存就不会释放。因此惰性删除策略的缺点是：它对内存是最不友好的。</li><li>在使用惰性删除策略时，如果内存中有非常多的过期 Key，而这些过期 Key 又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行 FLUSHDB），甚至可以将这种情况看作是一种内存泄漏 —— 无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的 Redis 服务器来说，肯定不是一个好消息。</li><li>简而言之，惰性删除对内存不友好，但对 CPU 友好，相当于用存储空间换取处理器性能（即空间换时间）。</li></ul></li><li><p>定期删除</p><ul><li>定期删除策略是前两种策略的折中：定期删除策略每隔一段时间执行一次删除过期 Key 操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。其做法为：周期性轮询 Redis 中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频率。</li><li>定期删除策略的特点：CPU 性能占用设置有峰值，检测频率可自定义设置。内存压力不是很大，长期占用内存的冷数据会被持续清理。</li><li>定期删除策略的难点是确定删除操作执行的时长和频率。Redis 不可能时时刻刻遍历所有被设置了过期时间的 Key，来检测数据是否已经到达了过期时间，然后对它进行删除。如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将 CPU 时间过多地消耗在删除过期 Key 上面。如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。因此，如果采用定期删除策略，Redis 服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</li><li>定期删除的举例：Redis 默认每间隔 100ms 检查是否有过期的 Key，如果有过期 Key 则删除。特别注意，Redis 不是每隔 100ms 将所有的 Key 检查一次，而是随机抽取进行检查。因此，如果只采用定期删除策略，会导致很多 Key 到达过期时间了也没有被删除。</li><li>简而言之，定期删除可以周期性抽查内存空间（随机抽查，重点抽查），然后将无用的内存空间释放掉。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>惰性删除和定期删除都存在数据没有被抽到的情况，如果这些数据已经到了过期时间，不会被删除掉，这会导致大量过期的 Key 堆积在内存中，最终使 Redis 内存空间紧张或者很快耗尽。因此必须要有一个更好的兜底方案，那就是使用 Redis 的内存淘汰策略。</p></div><h3 id="Redis-的内存淘汰策略有哪些"><a href="#Redis-的内存淘汰策略有哪些" class="headerlink" title="Redis 的内存淘汰策略有哪些"></a>Redis 的内存淘汰策略有哪些</h3><p>在 Redis 中，允许用户通过 <code>maxmemory</code> 参数设置最大使用内存的大小 ，这在内存有限的情况下是很有用的。当 Redis 内存数据集大小上升到一定大小的时候，就会执行内存淘汰策略。其中 LRU 和 LFU 都是用于缓存淘汰策略的算法，它们的作用是在缓存空间不足时确定哪些数据应该被删除掉。</p><ul><li><code>LRU (Least Recently Used)</code>：根据最近使用的顺序来淘汰数据，即<strong>淘汰最长时间未被访问的数据</strong>。当有新的数据被访问时，LRU 会将其移到最近使用的位置。</li><li><code>LFU (Least Frequently Used)</code>：根据数据被访问的频率来淘汰数据，即<strong>淘汰访问频率最低的数据</strong>。当缓存空间不足时，LFU 会选择访问次数最少的数据进行删除。</li></ul><p>Redis 4.0 之前一共实现了 6 种内存淘汰策略，但是在 4.0 之后，又增加了 2 种策略。截止目前为止（Redis 6.0.8 版本），Redis 定义了 8 种内存淘汰策略来处理内存空间不足的情况。</p><ul><li><code>noeviction</code>：不会淘汰任何数据，当使用的内存空间超过 <code>maxmemory</code> 值时，返回错误。</li><li><code>volatile-ttl</code>：从已设置过期时间的数据集中，挑选将要过期的数据进行淘汰。</li><li><code>volatile-random</code>：从已设置过期时间的数据集中，随机挑选一个数据进行淘汰。</li><li><code>volatile-lru</code>：从已设置过期时间的数据集中，挑选最长时间未被访问（LRU）的数据进行淘汰。</li><li><code>volatile-lfu</code>：从已设置过期时间的数据集中，挑选访问频率最低（LFU）的数据进行淘汰。</li><li><code>allkeys-random</code>：从所有数据集中，随机选择一个数据进行淘汰。</li><li><code>allkeys-lru</code>：从所有数据集中，挑选最长时间未被访问（LRU）的数据进行淘汰。</li><li><code>allkeys-lfu</code>：从所有数据集中，挑选访问频率最低（LFU）的数据进行淘汰。</li></ul><p>这些内存淘汰策略，涵盖了两个维度：过期键和所有键，涉及四个方面：TTL、Radom、LRU、LFU。<strong>在实际工作中，使用得最多的内存淘汰策略是 <code>allkeys-lru</code>，即从所有数据集中，挑选最长时间未被访问（LRU）的数据进行淘汰。</strong></p><div class="admonition note"><p class="admonition-title">阅读扩展</p><ul><li><a target="_blank" rel="external nofollow" href="https://blog.csdn.net/m0_63435402/article/details/129422878">《Redis 内存淘汰策略介绍》</a></li><li><a target="_blank" rel="external nofollow" href="https://blog.csdn.net/Ch97CKd/article/details/126273055">《Redis 如何设置内存淘汰策略》</a></li></ul></div><h3 id="如何查看-Redis-的内存淘汰策略"><a href="#如何查看-Redis-的内存淘汰策略" class="headerlink" title="如何查看 Redis 的内存淘汰策略"></a>如何查看 Redis 的内存淘汰策略</h3><blockquote><p>第一种查看方式</p></blockquote><p>要查看 Redis 的内存淘汰策略，可以使用 Redis 的 CONFIG 命令来获取 Redis 服务器的内存配置信息，命令如下：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get maxmemory-policy</span><br></pre></td></tr></tbody></table></figure><blockquote><p>第二种查看方式</p></blockquote><p>要查看 Redis 的内存淘汰策略，可以使用 Redis 的 INFO 命令来获取 Redis 服务器的内存信息，命令如下：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info memory</span><br></pre></td></tr></tbody></table></figure><p>其中与内存淘汰策略相关的输出信息如下：</p><ul><li><code>maxmemory-policy</code>：内存淘汰策略</li></ul><h3 id="如何修改-Redis-的内存淘汰策略"><a href="#如何修改-Redis-的内存淘汰策略" class="headerlink" title="如何修改 Redis 的内存淘汰策略"></a>如何修改 Redis 的内存淘汰策略</h3><ul><li>第一种方式，通过配置文件永久修改<ul><li>打开 Redis 的配置文件（通常是 <code>redis.conf</code>），找到并设置 <code>maxmemory-policy</code> 参数的值，比如设置为 <code>allkeys-lru</code>。</li><li>重新启动 Redis 服务，以使新的内存配置生效。</li></ul></li><li>第二种方式，通过命令临时修改<ul><li>使用 <code>config set maxmemory-policy xxx</code> 命令修改内存淘汰策略。</li><li>特别注意，在 Redis 服务器重启之后，这个修改会失效，也就是说使用命令这种修改方式不会永久保存到配置文件中。</li></ul></li></ul><h2 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h2><h3 id="分布式锁都有哪些实现方案"><a href="#分布式锁都有哪些实现方案" class="headerlink" title="分布式锁都有哪些实现方案"></a>分布式锁都有哪些实现方案</h3><ul><li>基于 MySQL 实现分布式锁。</li><li>基于 Redis 实现分布式锁，常用的 Redis 客户端是 Redisson。</li><li>基于 ZooKeeper 实现分布式锁，常用的 ZooKeeper 客户端是 Curator。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>JVM 层面的加锁，都是单机版的锁，比如 Synchronized、ReentrantLock 等。</li><li>分布式微服务架构中，拆分后各个微服务之间为了解决资源竞争而加入的锁，是分布式锁。</li></ul></div><h3 id="分布式锁使用的注意事项有哪些"><a href="#分布式锁使用的注意事项有哪些" class="headerlink" title="分布式锁使用的注意事项有哪些"></a>分布式锁使用的注意事项有哪些</h3><ul><li>Redis 的分布式锁是基于 <code>SETNX</code> 命令。</li><li>如果出异常的话，可能无法释放锁，所以必须在 <code>finally</code> 代码块中释放锁。</li><li>如果应用服务宕机了，在代码层面根本没有走到 <code>finally</code> 代码块，也就没办法可以保证解锁，因此需要设置锁的过期时间，防止出现死锁现象。</li><li>除了设置锁的过期时间之外，还必须保证 <code>SETNX</code> 操作和设置锁过期时间的操作是原子性操作（不可分割）。</li><li>规定只能删除自己的锁，不能误删别人的锁，可以使用 Lua 脚本或者 Redis 事务来实现这一规则。</li><li>判断锁归属的操作和删除锁的操作必须是原子性操作（不可分割）。</li></ul><h3 id="Redis、ZooKeeper-实现分布式锁的区别"><a href="#Redis、ZooKeeper-实现分布式锁的区别" class="headerlink" title="Redis、ZooKeeper 实现分布式锁的区别"></a>Redis、ZooKeeper 实现分布式锁的区别</h3><p>CAP 理论指出，在分布式系统中，Consistency（一致性）、Availability（可用性）和 Partition tolerance（分区容忍性）这三个特性无法同时实现，只能在其中两个特性之间进行权衡。针对 CAP 理论，Redis 与 ZooKeeper 实现分布式锁的区别如下：</p><ul><li><p>Redis 集群</p><ul><li><strong>Redis 集群满足 CAP 理论中的 AP，可以保证可用性和分区容忍性。</strong></li><li><strong>Redis 集群不保证一致性，它的主从复制属于异步复制，而异步复制可能会造成锁的丢失。</strong></li><li>比如：主节点没来得及将刚刚插入进来的数据复制给从节点就宕机了，那么主节点和从节点的数据就不一致。此时如果是在集群模式下，就得使用 Redisson 来解决这方面的问题。</li></ul></li><li><p>ZooKeeper 集群</p><ul><li><strong>ZooKeeper 集群满足 CAP 理论中的 CP，可以保证一致性和分区容忍性。</strong></li><li><strong>ZooKeeper 集群可以保证强一致性，对于集群中所有节点来说，要么全部更新成功，要么全部更新失败，因此使用 ZooKeeper 集群并不存在主从节点数据不一致的问题，也就不会造成锁的丢失。</strong></li><li>ZooKeeper 集群不保证服务可用性，在 Leader 选举期间集群是不可用的，虽然服务最终能够恢复。由于选举 Leader 的时间一般比较长，可能需要花费 30s ~ 120s，漫长的选举时间导致的服务长期不可用，这往往是不能容忍的。</li></ul></li></ul><h2 id="Redis-底层原理"><a href="#Redis-底层原理" class="headerlink" title="Redis 底层原理"></a>Redis 底层原理</h2><h3 id="Redis-是单线程的为什么还可以支撑高并发"><a href="#Redis-是单线程的为什么还可以支撑高并发" class="headerlink" title="Redis 是单线程的为什么还可以支撑高并发"></a>Redis 是单线程的为什么还可以支撑高并发</h3><p>这是一道高频的 BAT 面试题，其答案如下。</p><blockquote><p>面试题剖析</p></blockquote><p>Redis 基于 Reactor 模式开发了网络事件处理器，这个处理器称为文件事件处理器（File Event Handler）。这个文件事件处理器是单线程的，所以 Redis 才叫做单线程模型。它是 Redis 单线程架构的核心组件，采用 I/O 多路复用机制同时监听多个 socket，并根据 socket 上的事件来选择对应的事件处理器来处理这个事件，以实现高性能的网络通信。</p><ul><li><p>文件事件处理器</p><ul><li>工作原理：<ul><li>当被监听的 socket 准备好执行如 <code>accept</code>、<code>read</code>、<code>write</code>、<code>close</code> 等操作时，Redis 会将这些操作抽象为不同的 “文件事件”。此时，文件事件处理器会调用预先注册好的具体事件处理器来响应这些事件。</li><li>文件事件处理器本身是单线程运行的，但通过 I/O 多路复用机制（如 <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code> 等）可以高效地监听多个 socket。这样既保持了 Redis 内部线程模型的简洁性，也保证了良好的并发处理性能。</li></ul></li><li>结构组成：<ul><li>文件事件处理器由以下四个核心组件构成：</li><li>(1) 多个 Socket：与客户端的连接。</li><li>(2) I/O 多路复用器：负责监听所有 socket 上的 I/O 事件。</li><li>(3) 文件事件分派器：将就绪的 socket 事件分派给对应的事件处理器。</li><li>(4) 具体事件处理器：包括连接应答处理器、命令请求处理器、命令回复处理器等<ul><li>如果是客户端要连接 Redis，那么会为 socket 关联连接应答处理器。</li><li>如果是客户端要写数据到 Redis，那么会为 socket 关联命令请求处理器。</li><li>如果是客户端要从 Redis 读数据，那么会为 socket 关联命令回复处理器。</li></ul></li></ul></li><li>处理流程：<ul><li>(1) 多个 socket 上可能同时发生各种 I/O 事件（如读、写、连接、断开等）。</li><li>(2) I/O 多路复用器会监听这些 socket 上的事件，并将就绪的 “socket + 事件类型”（即文件事件）放入事件队列。</li><li>(3) 文件事件分派器从事件队列中取出就绪事件，根据对应的 socket 和事件类型，选择合适的事件处理器进行处理。</li><li>(4) 当前事件处理完成后，继续处理队列中的下一个就绪事件。</li></ul></li><li>总结说明：<ul><li>这种模型实现了并发监听 + 串行处理的效果，避免了线程切换带来的开销，同时又具备处理大量连接的能力，是 Redis 高性能的重要保障之一。</li></ul></li></ul></li><li><p>文件事件</p><ul><li>当一个 socket 变得可读（例如客户端向 Redis 发送数据或关闭连接），或者有新的连接请求到来时，会触发一个 <code>AE_READABLE</code> 事件。</li><li>当 socket 可写（例如 Redis 需要向客户端发送响应数据）时，会触发一个 <code>AE_WRITABLE</code> 事件。</li><li>I/O 多路复用程序可以同时监听 <code>AE_READABLE</code> 和 <code>AE_WRITABLE</code> 两种事件。</li><li>如果同一个 socket 同时触发这两种事件，文件事件分派器会优先处理 <code>AE_READABLE</code>，再处理 <code>AE_WRITABLE</code>，以避免读数据延迟或粘包等问题。</li></ul></li></ul><p><img data-src="../../../asset/2025/07/redis-thread-model.png"></p><ul><li>客户端与 Redis 通信的一次完整流程<ul><li> (1) 在 Redis 启动初始化时，Redis 会将连接应答处理器与 <code>AE_READABLE</code> 事件绑定。</li><li>(2) 当客户端向 Redis 发起连接请求时，监听的 socket 会触发 <code>AE_READABLE</code> 事件，此时由连接应答处理器处理连接请求，建立连接并创建一个对应的客户端 socket。随后，Redis 会将该客户端 socket 的 <code>AE_READABLE</code> 事件与命令请求处理器关联，用于处理后续的命令请求。</li><li>(3) 当客户端发送命令请求（无论是读还是写），客户端 socket 上会再次触发 <code>AE_READABLE</code> 事件，命令请求处理器被调用，从 socket 中读取请求数据，并进行命令解析与执行。</li><li>(4) 当 Redis 执行完命令并准备好响应数据后，会将该 socket 的 <code>AE_WRITABLE</code> 事件与命令回复处理器关联。</li><li>(5) 当该 socket 变为可写（即内核缓冲区有空间）时，会触发 <code>AE_WRITABLE</code> 事件，由命令回复处理器将响应数据写入 socket，供客户端读取。</li><li>(6) 响应数据写入完成后，Redis 会解除该 socket 与 <code>AE_WRITABLE</code> 事件及命令回复处理器的绑定，避免持续监听写事件，提高资源利用效率。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>poll</code>、<code>epoll</code> 等 I/O 多路复用机制本身是系统调用接口，它们的底层实现由 Linux 操作系统内核负责管理。</li></ul></div><blockquote><p>面试题答案</p></blockquote><ul><li><strong>1. 纯内存操作，访问速度极快</strong><ul><li> Redis 是基于纯内存的数据存储系统，所有的读写操作都是在内存中完成的，不涉及磁盘 I/O，其数据访问速度远超传统基于磁盘的数据库。即使是单线程，也能在内存中完成每秒数万甚至十万级别的 QPS。</li></ul></li><li><strong>2. 采用高效的 I/O 多路复用机制（Reactor 模型）</strong><ul><li>Redis 使用了非阻塞的 I/O 多路复用机制（如 <code>poll</code>、<code>epoll</code>、<code>kqueue</code> 等）来监听多个 socket，通过单线程配合事件驱动模型，可以同时监听成千上万个连接请求，串行快速处理事件，实现高效处理能力。</li></ul></li><li><strong>3. 单线程反而避免了多线程的锁竞争与上下文切换开销</strong><ul><li>多线程编程中常见的问题包括：锁竞争、死锁、线程上下文切换、共享资源同步等。Redis 采用单线程模型，避免了这些问题，降低了系统复杂度，提高了执行效率与可控性。</li><li>Redis 在处理请求时，每次只处理一个连接的事件，不会出现资源竞争，因此执行路径更短、CPU 利用率更高。</li></ul></li><li><strong>4. 内部采用高效的数据结构和优化的实现方式</strong><ul><li> Redis 内部使用高度优化的 C 语言实现，所有核心操作都在极短时间内完成。同时使用了诸如哈希表、跳表、压缩列表、整数集合等高效的数据结构，加速了数据访问和存储效率。</li></ul></li><li><strong>5. 请求通常很轻量，执行耗时极短</strong><ul><li>大部分 Redis 请求（如 <code>GET</code>、<code>SET</code>、<code>INCR</code> 等）都非常简单，执行时间通常在微秒级，即使单线程处理，也足以满足大量请求的快速响应。</li></ul></li></ul><h2 id="Redis-使用误区"><a href="#Redis-使用误区" class="headerlink" title="Redis 使用误区"></a>Redis 使用误区</h2><h3 id="往-Redis-里写的数据怎么没了"><a href="#往-Redis-里写的数据怎么没了" class="headerlink" title="往 Redis 里写的数据怎么没了"></a>往 Redis 里写的数据怎么没了</h3><p>有同学问我：” 老师啊，我往 Redis 里写的数据怎么没了？我们生产环境的 Redis 经常会丢一些数据，明明写进去了，过一会儿就不见了。” 我说，同学啊，你问出这个问题就说明你对 Redis 的理解还不到位。Redis 是缓存，不是数据库，你把缓存当存储用了，当然会出问题。什么是缓存？缓存就是用内存来加速数据访问的中间层，内存访问速度快，但代价是容量有限，不能像磁盘一样存很多数据。比如一台机器可能只有几十个 G 的内存，但却有几个 T 的磁盘空间。Redis 就是用内存来做高性能、高并发读写的，所以 Redis 本质上是一个缓存系统。那你说内存有限，比如你配置 Redis 最多用 10 个 G 的数据，你却往里面写了 20 个 G 的数据，会发生什么？Redis 肯定只能保留 10 个 G 的数据，多出来的 10 个 G 数据会被清理掉。那清理哪些数据？当然是清理那些不常用的，保留常用的，这就叫淘汰策略。还有一种情况是你自己给某些键设置了过期时间，时间到了也会自动删除。所以 Redis 丢数据这件事，不是 Bug，而是它的本质设计决定的。总结一下：Redis 是缓存，缓存的数据是会丢的，要么是你自己设置了过期时间，要么是 Redis 内存满了触发了内存淘汰机制。想存持久数据，就用数据库，别让缓存干数据库的活。</p><h3 id="数据明明都过期了，怎么还占用着内存"><a href="#数据明明都过期了，怎么还占用着内存" class="headerlink" title="数据明明都过期了，怎么还占用着内存"></a>数据明明都过期了，怎么还占用着内存</h3><p>有一种情况是你设置了 Key 的过期时间，但你知道 Redis 是什么时候真正把这些过期 Key 删除掉的吗？如果你不知道，那就容易踩坑。之前有个同学就问过我：为啥我明明设置了很多 Key 1 小时后过期，但过了一小时再看，Redis 的内存占用还是很高？这就是你不清楚 Redis 是怎么处理过期 Key 导致的。比如你设置 Redis 最大内存是 10GB，现在写入了 5GB 数据，并且都设置了 1 小时后过期，结果一小时后你再看 Redis，发现内存还是占用了 5GB，感觉数据没被清除。你用命令去查那些 Key，确实查不到了，说明逻辑上确实过期了；但 Redis 的内存没立即释放，这是因为 Redis 并不会在过期时间一到就立刻删除这些 Key，它采用的是 “惰性删除 + 定期删除” 的策略，只有访问这些 Key 时或被后台任务随机扫描到才会被真正清除。如果没有访问，也没被扫描到，过期 Key 就会暂时留在内存里，占用内存空间。这种机制是为了性能优化，不然为每个 Key 设置定时器成本太高。所以 Redis 中设置了过期时间的 Key，不代表到期立刻释放内存，只有在真正被删除时，内存才会释放掉。</p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>惰性删除策略和定期删除策略都存在数据没有被抽到的情况，如果这些数据已经到了过期时间，不会被删除掉，这会导致大量过期的 Key 堆积在内存中，最终使 Redis 内存空间紧张或者很快耗尽。因此必须要有一个更好的兜底方案，那就是使用 Redis 的内存淘汰策略。</p></div><h3 id="主节点持久化对于主从架构的安全保障意义"><a href="#主节点持久化对于主从架构的安全保障意义" class="headerlink" title="主节点持久化对于主从架构的安全保障意义"></a>主节点持久化对于主从架构的安全保障意义</h3><p>在采用 Redis 主从架构的场景下，强烈建议开启 Master 节点的持久化机制（RDB 和 / 或 AOF），这是确保数据安全的关键手段。很多人误以为有了一个或多个 Slave 节点就等于做了数据备份，其实这是极其错误且危险的想法。如果关闭了 Master 节点的持久化机制，仅将数据保存在内存中，一旦 Master 节点宕机重启，可能导致灾难性后果（比如缓存数据丢失）。</p><ul><li><strong>为什么不能仅依赖 Slave 节点作为 Master 节点的 “热备”</strong><ul><li> 当 Master 节点关闭了 RDB 和 AOF 持久化，只将数据保存在内存中；</li><li>在某一时刻，Master 节点宕机了；</li><li>Master 节点重启后，由于本地没有任何持久化文件，Master 节点会认为自己的数据集为空；</li><li>Master 节点启动后会将空的数据集通过复制同步给所有 Slave 节点；</li><li>所有 Slave 节点中的数据随即都被清空；</li><li>最终导致 100% 的缓存数据丢失，从而造成缓存雪崩，导致大量请求打到数据库。</li></ul></li><li><strong>即使部署了 Redis Sentinel（哨兵） 或 Redis Cluster（集群），实现了高可用机制，也无法完全避免数据清空风险</strong><ul><li>如果 Sentinel（哨兵）还没有检测到 Master 节点出现故障，Master 节点就自动重启了；</li><li>此时 Master 节点没有持久化数据，重启后认为数据集为空；</li><li>然后将空的数据集通过复制同步给所有 Slave 节点，造成所有 Slave 节点的数据被清空。</li></ul></li><li><strong>生产环境中，Master 节点正确的做法</strong><ul><li> Master 节点必须启用持久化（建议同时开启 RDB 和 AOF）<ul><li>避免 Master 节点宕机重启后出现 “数据空同步”；</li><li>保证 Master 节点具备自恢复能力。</li></ul></li><li>建议定期备份 Master 节点的持久化文件（RDB/AOF）<ul><li>一旦本地数据文件损坏或丢失，可以从备份文件中恢复；</li><li>启动时加载备份文件，确保 Master 节点具备有效数据。</li></ul></li></ul></li></ul><h3 id="基于-RedLock-算法实现分布式锁"><a href="#基于-RedLock-算法实现分布式锁" class="headerlink" title="基于 RedLock 算法实现分布式锁"></a>基于 RedLock 算法实现分布式锁</h3><blockquote><p>RedLock 算法的核心思想</p></blockquote><p>RedLock 算法的核心思想是在多个独立的 Redis 实例（不存在主从、集群关系，彼此互相隔离）上同时获取锁，从而保证分布式锁的高可用性和可靠性。即使某些 Redis 实例出现故障，只要在大多数实例（至少 <code>N/2 + 1</code> 个）中成功获取到锁，整个系统仍然可以认为锁是成功获取的（有效）。</p><blockquote><p>RedLock 算法的实现步骤</p></blockquote><ul><li><p>(1) <strong>获取当前时间</strong>：</p><ul><li>客户端获取当前时间，用于计算获取锁的总耗时。</li></ul></li><li><p>(2) <strong>依次向 N 个实例请求锁</strong>：</p><ul><li>客户端依次向 N 个 Redis 实例（通常是 5 个）发送获取锁的请求。</li><li>请求锁的命令是 <code>SET key value NX PX milliseconds</code>，其中：<ul><li><code>key</code> 是锁的标识。</li><li><code>value</code> 是客户端的唯一标识（通常使用类似 UUID 这样的随机值）。</li><li><code>NX</code> 表示只有在键不存在时才进行设置。</li><li><code>PX</code> 表示设置键的过期时间（毫秒）。</li></ul></li></ul></li><li><p>(3) <strong>计算总耗时</strong>：</p><ul><li>客户端在每次请求锁后，立即获取当前时间，计算从开始请求到成功获取锁的总耗时。</li></ul></li><li><p>(4) <strong>验证锁获取成功</strong>：</p><ul><li>如果客户端在大多数（至少 <code>N/2 + 1</code> 个）实例上成功获取锁，并且获取锁的总耗时小于锁的过期时间，则认为锁获取成功。</li><li>如果锁获取失败，客户端应当立即释放在所有实例上已成功获取的锁。</li></ul></li><li><p>(5) <strong>使用锁</strong>：</p><ul><li>客户端在获取锁成功后，执行相关的业务逻辑。</li><li>为了防止锁提前被释放掉，业务逻辑应在锁的有效期内完成。</li></ul></li><li><p>(6) <strong>释放锁</strong>：</p><ul><li>客户端在所有实例上执行释放锁操作，确保释放所有持有的锁。</li><li>释放锁的操作通常是一个 Lua 脚本，用于原子性检查锁的值是否匹配客户端的唯一标识（防止误删其他客户端加的锁），然后再删除锁。</li></ul></li></ul><blockquote><p>RedLock 算法的优缺点</p></blockquote><ul><li><strong>优点</strong>：<ul><li>高可用性：通过在多个独立的 Redis 实例（没有主从、集群关系）上获取锁，RedLock 提高了锁的可用性和容错能力。</li><li>强一致性：RedLock 保证了分布式锁的一致性，只要大多数实例成功获取锁，即使部分实例发生故障，仍然可以正确获取和释放锁。</li><li>防止死锁：锁设置了过期时间，确保即使客户端崩溃或未能正常释放锁，锁也会在超时后自动释放，避免死锁问题。</li></ul></li><li><strong>缺点</strong>：<ul><li>实例独立性：要求每个 Redis 实例是独立且不会同时宕机，通常部署在不同的物理或虚拟机上。</li><li>时钟同步：客户端的系统时钟需要尽可能准确，以确保计算获取锁的总耗时和锁的过期时间准确无误。</li><li>网络延迟：在获取锁和释放锁的过程中，可能会受到网络延迟的影响，需要在系统设计时考虑这些因素。</li></ul></li></ul><blockquote><p>RedLock 算法的部署建议</p></blockquote><ul><li>Redis 官方建议针对 RedLock 算法至少部署 5 个相互独立的 Redis 实例（不存在主从、集群关系，彼此互相隔离），以容忍 2 个实例出现故障；若服务器资源不足，要求部署至少 3 个相互独立的 Redis 实例，以容忍 1 个实例出现故障。</li></ul><hr><blockquote><p>通过 Redisson 实现不同类型的 Redis 分布式锁</p></blockquote><p>Redisson 基于 Redis 提供了多种分布式锁 API，包括：<code>RLock</code>、<code>RedissonMultiLock</code> 和 <code>RedissonRedLock</code> 等，如下图所示：</p><p><img data-src="../../../asset/2025/08/redisson-locks-1.png"></p><ul><li><p><strong>RLock（可重入锁）</strong></p><ul><li>可以在单个 Redis 节点上加锁，也可在 Redis 集群的单个主节点上加锁。</li><li>局限性：存在单机故障问题，或者集群模式下如果主节点故障且锁数据未同步到从节点，主从切换完成后，新主节点可能重复授予锁，从而导致锁的互斥性失效。</li><li>主要实现类：<ul><li><code>RedissonLock</code> — 基于单个 Redis 节点（或 Redis 集群单个主节点）的普通可重入锁实现。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取可重入锁（基于 RLock 接口）</span></span><br><span class="line">RLock lock = redissonClient.getLock(<span class="string">"my_lock"</span>);</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 抢占锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="comment">// 执行业务逻辑</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 释放锁</span></span><br><span class="line">   lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><code>RedissonFairLock</code> — 公平锁，按请求顺序获取锁，避免 “插队”。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取公平锁（基于 RLock 接口）</span></span><br><span class="line">RLock lock = redissonClient.getFairLock(<span class="string">"my_lock"</span>);</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 抢占锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="comment">// 执行业务逻辑</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 释放锁</span></span><br><span class="line">   lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><code>RedissonReadLock</code> — 读写锁的读锁部分，支持读并发。</li><li><code>RedissonWriteLock</code> — 读写锁的写锁部分，互斥访问。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取读写锁</span></span><br><span class="line">RReadWriteLock rwLock = redissonClient.getReadWriteLock(<span class="string">"my_lock"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁（基于 RLock 接口）</span></span><br><span class="line">RLock readLock = rwLock.readLock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 抢占读锁</span></span><br><span class="line">   readLock.lock();</span><br><span class="line">   <span class="comment">// 执行读操作</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 释放读锁</span></span><br><span class="line">   readLock.unlock();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写锁（基于 RLock 接口）</span></span><br><span class="line">RLock writeLock = rwLock.writeLock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 抢占写锁</span></span><br><span class="line">   writeLock.lock();</span><br><span class="line">   <span class="comment">// 执行写操作</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 释放写锁</span></span><br><span class="line">   writeLock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><code>RedissonSpinLock</code> — 自旋锁，短时间内高频尝试获取锁，减少阻塞等待。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取自旋锁（基于 RLock 接口）</span></span><br><span class="line">RLock spinLock = redisson.getSpinLock(<span class="string">"my_lock"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="keyword">boolean</span> locked = spinLock.tryLock(<span class="number">5000</span>, <span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">if</span> (locked) {</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 执行业务逻辑</span></span><br><span class="line">   } <span class="keyword">finally</span> {</span><br><span class="line">      <span class="comment">// 释放锁</span></span><br><span class="line">      spinLock.unlock();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p><strong>‌RedissonMultiLock（联锁）</strong></p><ul><li>作用：一次性对多个独立的 <code>RLock</code> 加锁，所有锁都成功获取才算整体加锁成功。</li><li>锁资源类型：这些锁可以是同一个 Redis 节点上不同的 Key，也可以是不同 Redis 节点上的同一个 Key。</li><li>设计目的：侧重于跨资源的原子性加锁，而非 Redis 集群的容错与一致性保证。</li><li>应用场景：适用于需要同时锁定多个资源（如订单、库存等）的跨资源并发控制。</li><li>局限性：不符合 Redis 官方提出 RedLock 算法规范，在 Redis 集群场景下无法保证分布式锁的强一致性与安全性。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有需要加锁的资源</span></span><br><span class="line">RLock lock1 = redissonClient.getLock(<span class="string">"lock1"</span>);</span><br><span class="line">RLock lock2 = redissonClient.getLock(<span class="string">"lock2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建联锁</span></span><br><span class="line">RedissonMultiLock multiLock = <span class="keyword">new</span> RedissonMultiLock(lock1, lock2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 尝试获取多个锁资源的联锁，最多等待 5 秒，成功加锁后 10 秒自动释放，只有所有子锁都加锁成功才算获得锁</span></span><br><span class="line">   locked = multiLock.tryLock(<span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">if</span> (locked) {</span><br><span class="line">      <span class="comment">// 执行业务逻辑</span></span><br><span class="line">   } </span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 只在获取锁成功时解锁</span></span><br><span class="line">   <span class="keyword">if</span> (locked) {</span><br><span class="line">      multiLock.unlock();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>RedissonRedLock（红锁）</strong></p><ul><li>在多个独立 Redis 节点上（不存在主从、集群关系，彼此互相隔离）尝试加锁；</li><li>只有当超过半数（<code>N/2 + 1</code>）的节点加锁成功时，才认为锁获取成功，符合 RedLock 的多数派原则；</li><li>优势：严格实现 Redis 官方提出的 RedLock 算法。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直连第一个独立 Redis 节点</span></span><br><span class="line">Config config1 = <span class="keyword">new</span> Config();</span><br><span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直连第二个独立 Redis 节点</span></span><br><span class="line">Config config2 = <span class="keyword">new</span> Config();</span><br><span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6380"</span>);</span><br><span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直连第三个独立 Redis 节点</span></span><br><span class="line">Config config3 = <span class="keyword">new</span> Config();</span><br><span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6381"</span>);</span><br><span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个 Redis 节点上获取一个普通 RLock</span></span><br><span class="line">RLock lock1 = redissonClient1.getLock(<span class="string">"lock1"</span>);</span><br><span class="line">RLock lock2 = redissonClient2.getLock(<span class="string">"lock2"</span>);</span><br><span class="line">RLock lock3 = redissonClient3.getLock(<span class="string">"lock3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合成一个 RedLock</span></span><br><span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 尝试同时加锁（要求在大部分节点上加锁成功才算真正获得锁），等待最多 100 秒，加锁成功后 10 秒自动释放</span></span><br><span class="line">   isLocked = redLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">if</span> (isLocked) {</span><br><span class="line">      <span class="comment">// 执行业务逻辑</span></span><br><span class="line">   }</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">   <span class="comment">// 只在获取锁成功时解锁</span></span><br><span class="line">   <span class="keyword">if</span> (isLocked) {</span><br><span class="line">      redLock.unlock();</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">redissonClient1.shutdown();</span><br><span class="line">redissonClient2.shutdown();</span><br><span class="line">redissonClient3.shutdown();</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><div class="admonition warning"><p class="admonition-title">RedissonRedLock 的正确使用方法</p><ul><li>RedLock 算法的核心思想是在多个独立的 Redis 实例（不存在主从、集群关系，彼此互相隔离）上同时获取锁，从而保证分布式锁的高可用性和可靠性。即使某些 Redis 实例出现故障，只要在大多数实例（至少 <code>N/2 + 1</code> 个）中成功获取到锁，整个系统仍然可以认为锁是成功获取的（有效）。</li><li>因此，在使用 <code>RedissonRedLock</code> 时，强烈建议直接部署多个独立的 Redis 实例（不存在主从、集群关系，彼此互相隔离），或者多个独立 Redis 集群的 Master 节点，通常节点数量为奇数（比如 3 个或者 5 个），然后分别连接这些 Redis 节点，获取各自的 <code>RLock</code>，再组合成 <code>RedissonRedLock</code>。</li><li>使用 <code>RedissonRedLock</code> 时，千万不要依赖同一个 Redis 集群的多个 Maser 节点作为 RedLock 节点；因为同一个 Redis 集群的 Master 节点不是独立节点，由于使用分片存储方式，相同的 Key 永远只会落到同一个 Master 节点，因此不能满足 RedLock 的多数派原则，容易破坏分布式锁的强一致性。另一个更重要的原因是，集群内部发生故障转移（主从切换）期间可能会造成锁丢失。</li></ul></div><blockquote><p>在单个 Redis 集群中使用 <code>RedissonRedLock</code> 的问题</p></blockquote><p><strong>不建议在单个 Redis 集群中使用 <code>RedissonRedLock</code> 来保证强一致性和安全性，因为它无法达到设计目标，甚至可能比使用单个 Redis 节点或者 Redis 集群自身的锁机制（Redisson 的 <code>RLock</code>）更不安全。原因如下：</strong></p><ul><li><p>(1) RedLock 算法的核心前提是独立故障域：</p><ul><li>RedLock 的设计初衷是用于多个独立 Redis 节点的环境（例如，部署在不同物理机、不同机架、甚至不同数据中心的 3 个或 5 个单独的 Redis 实例，没有主从关系）。</li><li>它的安全性依赖于一个关键假设：这些节点是故障隔离的。一个节点失效（宕机、网络分区）不会立即或必然导致另一个节点也失效。</li></ul></li><li><p>(2) Redis 集群破坏了 “独立故障域” 的前提：</p><ul><li>比如，在 3 主 3 从 的 Redis 集群中：<ul><li>主节点之间是协作关系： 它们共同组成一个逻辑集群，通过 Gossip 协议通信共享集群状态。</li><li>主从节点是强关联的： 每个主节点都有对应的从节点。当主节点故障时，集群会自动进行故障转移，将其一个从节点提升为新的主节点，这个提升过程是自动且快速的。</li></ul></li><li>关键问题 - 故障转移期间的锁丢失（这是 RedLock 在集群环境下失效的核心原因）<ul><li>假设客户端 C1 成功使用 RedLock 在 3 个主节点（M1、M2、M3）上都获取了锁（满足 RedLock 的 <code>N/2 + 1</code> 原则）。</li><li>在 C1 持有锁期间，主节点 M1 发生故障。</li><li>集群检测到 M1 故障，触发故障转移。M1 的一个从节点（S1）被提升为新的主节点（称为 NewM1）。</li><li>问题在于：故障转移过程（特别是异步复制）可能导致 NewM1 上缺失 C1 在旧 M1 上设置的锁！<ul><li>如果 C1 在旧 M1 上设置的锁信息还没来得及复制到 S1，那么 NewM1 启动后就没有这个锁的记录。</li><li>即使旧 M1 上设置的锁复制到 NewM1 里面了，故障转移过程也可能导致短暂的数据不一致窗口。</li></ul></li><li>此时，另一个客户端 C2 尝试获取同一把锁。它使用 RedLock 向当前存活的主节点（NewM1、M2、M3）发起加锁请求。</li><li>C2 很可能在 NewM1（它上面没有旧锁记录）和另外两个节点中的至少一个（比如 M2）上成功获取锁，从而满足 RedLock 的 <code>N/2 + 1</code> 原则（例如 2/3）。这样，C1 和 C2 同时认为自己持有锁，导致分布式锁的互斥性被破坏！</li></ul></li></ul></li><li><p>(3) 集群网络分区（脑裂）问题加剧风险：</p><ul><li>如果发生网络分区，将集群分割成两个或多个无法通信的小分区。</li><li>每个小分区可能都认为自己拥有足够的主节点（满足 RedLock 的 <code>N/2 + 1</code> 原则），并允许客户端在不同分区内获取同一把锁，这种情况同样导致多个客户端同时获取到锁，导致分布式锁的互斥性被破坏。</li></ul></li><li><p>(4) 性能开销无意义：</p><ul><li>RedLock 需要在多个独立的 Redis 节点上顺序执行加锁操作，这本身就有显著性能开销。</li><li>在一个 Redis 集群内部使用 RedLock，这些操作本质上是跨节点通信，开销比在单个节点上加锁大很多，但却没有换来预期的安全性提升，得不偿失。</li></ul></li></ul><p><strong>Redis 集群自身的锁机制（Redisson 的 <code>RLock</code>）对比在单个 Redis 集群中使用 <code>RedissonRedLock</code>：</strong></p><ul><li>Redisson 的普通 <code>RLock</code> 对象（<code>redissonClient.getLock("myLock")</code>）在 Redis 集群模式下是安全可用的。</li><li>它的工作原理：<ul><li>(1) 客户端根据 Key 计算哈希槽。</li><li>(2) 将加锁请求发送到负责存储该哈希槽的主节点。</li><li>(3) 锁只存储在这个单个主节点上。</li><li>(4) 主节点会异步复制锁信息（<code>SET</code> 命令）给它的从节点。</li></ul></li><li>优点：简单、高效，利用了集群的分片和故障转移能力。</li><li>缺点：在极端故障场景下（主节点宕机且其锁信息未能复制到新提升的主节点），也存在短暂的锁丢失风险（与 RedLock 在集群下遇到的问题是类似的本质，但只发生在一个分片上）。然而，这种风险通常被认为是可接受的，并且比在单个 Redis 集群内错误使用 RedLock 导致必然的互斥性破坏要小得多、可控得多。</li><li>关键区别： Redis 集群模式下的 <code>RLock</code> 只依赖一个主节点，而在单个集群内使用的 RedLock 需要依赖多个主节点。但是，在单个 Redis 集群环境下，这多个主节点不是独立的故障域，故障转移机制使得依赖多个节点反而引入了额外的、更严重的失效点（即新主节点丢失旧锁）。</li></ul><p><strong>RedLock 算法的使用总结与建议：</strong></p><ul><li>绝对要避免在单个 Redis 集群内使用 <code>RedissonRedLock</code>：它无法提供比 Redis 集群自身的锁机制（Redisson 的 <code>RLock</code>）更好的安全性，反而会因为集群的自动故障转移特性，在高可用设计下引入更严重的锁互斥性破坏风险。</li><li>在单个 Redis 集群中，使用 Redisson 的普通 <code>RLock</code>（集群模式）： 这是正确且推荐的方式。它利用了 Redis 集群的分片和故障转移特性，提供了在集群环境下合理的高可用分布式锁。但需要理解并接受其在极端故障场景下（主节点崩溃 + 锁未被复制）存在理论上的短暂锁失效风险，但在实践中，结合合理的锁超时设置，这通常是可管理的风险。</li><li>RedLock 的正确使用场景：仅当拥有 N 个 (N 为奇数，通常 3 或 5) 完全独立部署、不存在主从关系、且物理 / 逻辑故障域隔离 的 Redis 节点 / 实例时，才应该考虑使用 RedLock。例如：<ul><li>3 个分别部署在独立虚拟机或物理机上的 Redis 单机实例。</li><li>3 个独立的 Redis Sentinel（比如，每个 Sentinel 都是一主多从，且都有自己的 Redis 主节点）。</li><li>3 个独立的 Redis Cluster（每个集群作为一个逻辑节点参与 RedLock，但这很复杂且通常不推荐，不如直接用独立实例）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">参考资料</p><ul><li><a target="_blank" rel="external nofollow" href="https://cloud.tencent.com/developer/article/2421423">使用 Redisson 实现分布式锁</a></li><li><a target="_blank" rel="external nofollow" href="https://cloud.tencent.com/developer/article/2376301">如何使用 Redisson 实现分布式锁</a></li><li><a target="_blank" rel="external nofollow" href="https://blog.51cto.com/universsky/6846798">Redis 实现分布式锁的方案和缺陷分析</a></li><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/cb1186512739/p/12802177.html">Redisson 的 RedissonRedLock（红锁）使用介绍</a></li></ul></div><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/6f36832d.html" title="Redis 开发随笔">https://www.techgrow.cn/posts/6f36832d.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/" rel="tag"><i class="fa fa-tag"></i> 开发随笔</a><a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"><i class="fa fa-tag"></i> 缓存</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/790c0b45.html" rel="prev" title="Gateway 入门教程 - 高级篇"><i class="fa fa-angle-left"></i> Gateway 入门教程 - 高级篇</a></div><div class="post-nav-item"> <a href="/posts/73a4d573.html" rel="next" title="各类开源项目推荐">各类开源项目推荐<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">2m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">30:42</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/6f36832d.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>