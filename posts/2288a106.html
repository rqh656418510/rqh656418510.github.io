<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 巩固进阶之二"><meta property="og:url" content="https://www.techgrow.cn/posts/2288a106.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-02-19T13:55:33.000Z"><meta property="article:modified_time" content="2025-02-19T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.techgrow.cn/posts/2288a106.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/2288a106.html","path":"posts/2288a106.html","title":"C++ 巩固进阶之二"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 巩固进阶之二 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">C++ 11 的右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E7%8E%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">重现模拟实现字符串类的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">解决模拟实现字符串类的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">左值引用和右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">案例代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-text">使用右值引用解决问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-text">案例代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-text">测试代码一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%BA%8C"><span class="nav-text">测试代码二</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%B8%89"><span class="nav-text">测试代码三</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-text">C++ 11 的移动语义与完美转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">基础案例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB"><span class="nav-text">自定义字符串类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="nav-text">自定义 Vector 容器类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E7%B1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">自定义 Vector 类存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#move-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-text">move 移动语义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#move-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">move 移动语义的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#move-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">move 移动语义的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forward-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-text">forward 完美转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#forward-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">forward 完美转发的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forward-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">forward 完美转发的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84-function-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">C++ 11 的 function 类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E8%AF%B4%E6%98%8E"><span class="nav-text">对比说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-text">案例代码一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C"><span class="nav-text">案例代码二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%89"><span class="nav-text">案例代码三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80-1"><span class="nav-text">案例代码一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C-1"><span class="nav-text">案例代码二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%89-1"><span class="nav-text">案例代码三</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84-bind-%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="nav-text">C++ 11 的 bind 绑定器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-2"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-1"><span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%80-2"><span class="nav-text">案例代码一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%BA%8C-2"><span class="nav-text">案例代码二</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">669</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/2288a106.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 巩固进阶之二 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 的巩固教程。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 巩固进阶之二</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-02-19 21:55:33" itemprop="dateCreated datePublished" datetime="2025-02-19T21:55:33+08:00">2025-02-19</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/2288a106.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/2288a106.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5.9k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>5 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-11-的右值引用"><a href="#C-11-的右值引用" class="headerlink" title="C++ 11 的右值引用"></a>C++ 11 的右值引用</h2><h3 id="重现模拟实现字符串类的问题"><a href="#重现模拟实现字符串类的问题" class="headerlink" title="重现模拟实现字符串类的问题"></a>重现模拟实现字符串类的问题</h3><p>下述代码模拟实现了 C++ 中的 <code>string</code> 类，但是 <code>main()</code> 函数调用 <code>getString()</code> 函数的效率会非常低。第一个原因是，<code>getString()</code> 函数在调用结束时，返回了一个 MyString 对象，这会调用一次拷贝构造函数来拷贝 <code>tmpStr</code> 对象。第二个原因是，在 <code>main()</code> 函数中，将 <code>getStriing()</code> 函数的返回值赋值了给 <code>str2</code> 对象，这会调用赋值运算符重载函数，也就是又拷贝了一次数据。<a href="../../../asset/2025/02/cxx-custom-string-1.png">点击</a> 查看完整分析图解。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString &amp;str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(const MyString &amp;str)           // getString() 函数返回执行结果值时，调用拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(const MyString &amp;str)          // main() 函数中，执行赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象，临时对象的生存周期是所在语句</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="解决模拟实现字符串类的问题"><a href="#解决模拟实现字符串类的问题" class="headerlink" title="解决模拟实现字符串类的问题"></a>解决模拟实现字符串类的问题</h3><p>为了解决上述模拟实现字符串类时，多次拷贝内存数据导致运行效率低的问题，可以使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来解决。</p><h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><ul><li><p>左值引用与右值引用的介绍</p><ul><li><code>左值</code>：有名称、有内存</li><li><code>右值</code>：没名称（临时量）、没内存</li></ul></li><li><p>左值引用与右值引用的区别</p><ul><li>左值引用和右值引用的主要区别在于它们可以绑定的值类别，左值引用只能绑定到左值，而右值引用只能绑定到右值。</li><li>右值引用引入了 <code>move</code> 移动语义，使得 C++ 可以更高效地处理临时对象。</li><li>在泛型编程中，可以通过函数模板的类型推导来同时处理左值引用和右值引用，从而实现参数的 <code>forward</code> 完美转发。</li></ul></li></ul><h5 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ......(省略)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;        <span class="comment">// 左值：有名称、有内存，右值：没名称（临时量）、没内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; b = a;        <span class="comment">// 可以将左值绑定到左值引用上</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; c = a;    // 无法将左值绑定到右值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; d = <span class="number">20</span>;      <span class="comment">// 可以将右值绑定到右值引用上</span></span><br><span class="line">    <span class="comment">// int&amp; c = 20;    // 无法将右值绑定到左值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp;&amp; f = d;    // 无法将左值绑定到右值引用上，因为右值引用变量本身就是左值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyString&amp; s = MyString("aaa");   // 错误写法</span></span><br><span class="line">    MyString&amp;&amp; s = <span class="built_in">MyString</span>(<span class="string">"aaa"</span>);     <span class="comment">// 正确写法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用右值引用解决问题"><a href="#使用右值引用解决问题" class="headerlink" title="使用右值引用解决问题"></a>使用右值引用解决问题</h4><div class="admonition note"><p class="admonition-title">提示</p><ul><li>(1) 右值引用参数常用于减少内存数据的拷贝，比如在带右值引用参数的拷贝构造函数和赋值运算符重载函数中使用。</li><li>(2) 在带右值引用参数的拷贝构造函数和赋值运算符重载函数中，该右值引用参数接收的都是临时对象。</li></ul></div><h5 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h5><p>这里使用带右值引用参数的拷贝构造函数和赋值运算符重载函数，来解决在模拟实现 C++ 字符串类时，多次拷贝内存数据导致运行效率低的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">		str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString&amp; str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码一"><a href="#测试代码一" class="headerlink" title="测试代码一"></a>测试代码一</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(MyString&amp;&amp; str)                // getString() 函数返回执行结果值时，调用带右值引用参数的拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(MyString&amp;&amp; str)               // main() 函数中，执行带右值引用参数的赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">================ test01() ================</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码二"><a href="#测试代码二" class="headerlink" title="测试代码二"></a>测试代码二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"Hello "</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">str2</span><span class="params">(<span class="string">"World!"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    MyString str3 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码三"><a href="#测试代码三" class="headerlink" title="测试代码三"></a>测试代码三</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    MyString str1 = <span class="string">"aaa"</span>;</span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(str1); <span class="comment">// 调用的是带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是带右值引用参数的拷贝构造函数 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 中，无论是 Debug 模式，还是 Release 模式，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的移动语义与完美转发"><a href="#C-11-的移动语义与完美转发" class="headerlink" title="C++ 11 的移动语义与完美转发"></a>C++ 11 的移动语义与完美转发</h2><h3 id="基础案例代码"><a href="#基础案例代码" class="headerlink" title="基础案例代码"></a>基础案例代码</h3><h4 id="自定义字符串类"><a href="#自定义字符串类" class="headerlink" title="自定义字符串类"></a>自定义字符串类</h4><p>自定义一个 MyString 字符串类，模拟实现　C++ 的 <code>string</code> 字符串类，主要使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来减少内存数据的拷贝次数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-容器类"><a href="#自定义-Vector-容器类" class="headerlink" title="自定义 Vector 容器类"></a>自定义 Vector 容器类</h4><p>自定义一个 Vector 容器类，模拟实现　C++ 的 <code>vector</code> 容器，主要实现了 <code>vector</code>　容器的空间分配器、迭代器。值得一提的是，由于篇幅有限，这里虽然解决迭代器失效的问题，但是并没有解决容器扩容（执行插入操作）后导致迭代器失效的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt; *pvec = <span class="literal">nullptr</span>, T *p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base *itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt; *_pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T *p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T *p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator *cur = <span class="literal">nullptr</span>, Iterator_Base *next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator *_cur;</span><br><span class="line">        Iterator_Base *_next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T *start, T *end)</span> </span>{</span><br><span class="line">        Iterator_Base *cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base *next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-类存在的问题"><a href="#自定义-Vector-类存在的问题" class="headerlink" title="自定义 Vector 类存在的问题"></a>自定义 Vector 类存在的问题</h4><p>使用上面自定义的 Vecotr 容器类执行以下测试代码后，发现执行 <code>vector.push_back(MyString("bbb"));</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，这会导致多拷贝一份内存数据，从而影响程序的执行效率。值得一提的是，这里希望调用的是 MyString 类带右值引用参数的拷贝构造函数，因为该带右值引用参数的拷贝构造函数使用的是浅拷贝，可以减少内存数据的拷贝次数。至于具体的解决方案，可以使用下面介绍的 C++ 移动语义（<code>move</code>）来实现。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="move-移动语义"><a href="#move-移动语义" class="headerlink" title="move 移动语义"></a>move 移动语义</h3><h4 id="move-移动语义的概念"><a href="#move-移动语义的概念" class="headerlink" title="move 移动语义的概念"></a>move 移动语义的概念</h4><p>C++ 中的移动语义是引入于 C++ 11 的一种特性，它通过引入移动构造函数和移动赋值运算符，允许程序以更高效的方式管理资源，尤其是在避免不必要的拷贝操作时。移动语义的核心是利用右值引用（<code>T&amp;&amp;</code>）和标准库中的 <code>std::move</code>，使对象的资源从一个对象转移到另一个对象（比如将左值类型强转为右值类型），而不是拷贝，从而提高程序性能。</p><ul><li><p>移动语义的主要作用</p><ul><li>高效资源转移：避免资源分配和释放的重复工作。</li><li>减少拷贝：通过转移所有权来减少对象的拷贝。</li><li>提高程序性能：尤其适用于内存密集型和资源管理复杂的程序。</li></ul></li><li><p>移动语义的使用场景</p><ul><li>减少临时对象的开销（如函数返回大对象）。</li><li>避免深拷贝（如容器中的数据转移）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a target="_blank" rel="external nofollow" href="https://blog.csdn.net/chenmi123321/article/details/144334601">C++ 的 移动语义 move</a></li><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/602543410">理解现代 C++ 中的移动语义</a></li></ul></div><h4 id="move-移动语义的使用"><a href="#move-移动语义的使用" class="headerlink" title="move 移动语义的使用"></a>move 移动语义的使用</h4><p>在<a href="/posts/e302ad63.html#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB">上面</a>自定义的 Vector 容器类中，为了解决执行 <code>vector.push_back(MyString("bbb"))</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题，可以使用 C++ 中的 <code>move</code> 移动语义来解决。</p><ul><li>更改的核心代码<ul><li>重载 <code>Allocator::construct()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型</li><li>重载 <code>Vector::push_back()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(<span class="built_in">move</span>(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, <span class="built_in">move</span>(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="forward-完美转发"><a href="#forward-完美转发" class="headerlink" title="forward 完美转发"></a>forward 完美转发</h3><p>虽然使用 C++ 11 提供的 <code>move</code> 移动语义，可以解决在执行 <code>vector.push_back(MyString("bbb"));</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题。但是，这样每次都需要定义两个重载函数来分别接收左值引用参数和右值引用参数，这就显得比较繁琐。为了使 C++ 代码更简洁，可以使用 C++ 11 提供的 <code>forward</code> 完美转发来实现同样的功能。</p><h4 id="forward-完美转发的概念"><a href="#forward-完美转发的概念" class="headerlink" title="forward 完美转发的概念"></a>forward 完美转发的概念</h4><p>完美转发（Perfect Forwarding）是 C++ 11 中引入的一种编程技巧，其目的是在编写泛型函数时能够保留参数的类型和值类别（左值或右值），从而实现更为高效且准确地传递参数。通过使用右值引用和模板类型推导，完美转发允许在函数中以原始参数的形式将参数传递给其他函数，而不会发生不必要的拷贝操作，从而提高性能。完美转发在很多场合都非常有用，尤其是在设计泛型库和需要高效参数传递的场景。以下是一些常见的完美转发应用场景：</p><ul><li>(1) 委托构造函数：完美转发可以在构造函数之间传递参数，避免不必要的拷贝操作，从而提高性能。</li><li>(2) 可变参数模板函数：完美转发可以用于实现可接受任意数量和类型参数的函数，如实现一个通用的元组或 <code>bind()</code> 函数。</li><li>(3) 智能指针：完美转发在智能指针的实现中也有重要作用，例如 <code>unique_ptr</code> 和 <code>shared_ptr</code> 中的构造函数和 <code>make()</code> 函数等。</li><li>(4) 函数包装器：完美转发可以用于实现函数包装器，使包装后的函数能够正确处理所有类型的参数，包括右值引用。例如 <code>function</code> 的实现。</li><li>(5) 资源管理类：通过完美转发，可以使资源管理类（如锁管理类、线程池等）能够更方便地处理各种资源。</li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a target="_blank" rel="external nofollow" href="https://blog.csdn.net/haokan123456789/article/details/134980411">C++ 之 forward 完美转发</a></li><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/5iedu/p/11324772.html">C++ 的 forward 完美转发</a></li><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/710953400">深度解析 C++ 完美转发的实现原理与应用</a></li></ul></div><h4 id="forward-完美转发的使用"><a href="#forward-完美转发的使用" class="headerlink" title="forward 完美转发的使用"></a>forward 完美转发的使用</h4><ul><li>在<a href="/posts/e302ad63.html#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB">上面</a>自定义的 Vector 容器类中，更改以下地方：<ul><li>更改 <code>Allocator::construct()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型。</li><li>重载 <code>Vector::push_back()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(forward&lt;Ty&gt;(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, forward&lt;Ty&gt;(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的-function-类模板"><a href="#C-11-的-function-类模板" class="headerlink" title="C++ 11 的 function 类模板"></a>C++ 11 的 function 类模板</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><p><code>function</code> 是 C++ 11 引入的一个类模板，用于存储任何可以调用的目标（如普通函数、函数指针、函数对象、Lambda 表达式等），并通过统一的接口进行调用。它能够封装和管理函数，允许将函数作为对象传递和存储，位于 <code>&lt;functional&gt;</code> 头文件中，常用于回调和高阶函数。</p><ul><li><p>使用说明</p><ul><li>用函数类型实例化 <code>function</code> 类模板</li><li>通过 <code>function</code> 类模板调用 <code>operator()</code> 函数的时候，需要根据函数类型传入相应的参数</li></ul></li><li><p>使用特点</p><ul><li>通过类型擦除技术存储任意可调用对象（普通函数、Lambda 表达式、仿函数、成员函数指针等），无需关心具体类型，仅需关注调用签名‌</li><li>编译时会检查参数和返回类型是否匹配，避免了传统函数指针的类型不安全问题‌</li></ul></li><li><p>使用场景</p><ul><li>事件回调</li><li>作为函数参数传递可调用对象</li><li>存储 Lambda 表达式</li></ul></li></ul><h3 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h3><p>C 语言中的函数指针与 C++ 的 <code>function</code> 类模板的对比如下：</p><table><thead><tr><th>特性</th><th>函数指针 (C 语言)</th><th><code>function</code> 类模板 (C++)</th></tr></thead><tbody><tr><td> 灵活性</td><td>只能指向具有匹配签名的函数</td><td>可以封装多种类型的可调用对象 (函数、Lambda、函数对象)</td></tr><tr><td> 状态管理</td><td>不支持状态封装</td><td>支持状态封装（如 Lambda 表达式和函数对象）</td></tr><tr><td>类型安全</td><td>不提供额外的类型安全</td><td>提供类型安全检查</td></tr><tr><td>性能开销</td><td>较低</td><td>可能有较高的内存和性能开销</td></tr><tr><td>多态性</td><td>不支持多态</td><td>支持多态</td></tr></tbody></table><p>C 语言中的函数指针与 C++ 的 <code>function</code> 类模板的区别如下：</p><ul><li><p>基本概念</p><ul><li>函数指针（C 语言）<ul><li>函数指针是一个变量，用于存储函数的地址。通过该指针，可以间接调用对应的函数。</li><li>C 语言中的函数指针需要显式指定函数签名（返回值类型和参数类型）。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 是 C++ 11 引入的类模板，提供了一种通用的、类型安全的方式来存储、传递和调用可调用对象（如普通函数、函数指针、Lambda 表达式、函数对象等）。</li><li>它可以封装多种不同类型的可调用对象，并且允许它们通过统一的接口被调用。</li></ul></li></ul></li><li><p>灵活性和类型支持</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针只能指向具有相同函数签名（参数类型和返回类型）的函数。</li><li>不支持封装函数对象、Lambda 表达式等其他类型的可调用对象。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 支持多种类型的可调用对象，包括普通函数、函数指针、Lambda 表达式、函数对象等。</li><li>它的模板参数可以适配任意函数签名，支持更加灵活的调用。</li><li>还支持捕获外部状态的 Lambda 表达式，或者包含状态的函数对象。</li></ul></li></ul></li><li><p>状态管理</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针无法封装额外的状态信息，指向的仅仅是一个函数。</li><li>如果需要管理状态（如在函数调用前后执行某些操作），必须依赖外部的代码来实现。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 可以封装状态信息。例如，Lambda 表达式和函数对象可以拥有成员变量和成员函数，允许在调用时使用封装的状态。</li><li>这种能力使得 <code>function</code> 在处理回调和事件处理时更具优势。</li></ul></li></ul></li><li><p>类型安全</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针本身类型是静态的，编译时要求函数签名必须匹配，但它不提供额外的类型安全检查，错误的使用可能导致未定义行为。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 是类型安全的，编译时会检查存储的可调用对象是否与声明的函数签名一致。</li><li>C++ 编译器提供了类型安全的保证，避免了函数签名不匹配带来的错误。</li></ul></li></ul></li><li><p>内存管理和性能</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针直接存储函数的地址，不涉及额外的内存分配，因此它的性能开销较小。</li><li>由于没有额外的封装，也没有多态或状态的管理，性能上较为高效。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 需要进行额外的内存分配和类型擦除（Type Erasure）。对于 Lambda 表达式和函数对象，它会封装一个通用的接口，这可能带来额外的性能开销。</li><li>但是，它的灵活性和类型安全是 <code>function</code> 的优势。</li></ul></li></ul></li><li><p>多态和扩展性</p><ul><li>函数指针（C 语言）:<ul><li> 函数指针没有多态性。它们只是简单地指向某个函数，无法支持运行时多态。</li></ul></li><li><code>function</code> 类模板（C++）:<ul><li><code>function</code> 支持通过函数对象、Lambda 表达式和虚拟函数等方式实现运行时多态，提供了更大的灵活性。</li><li>它可以封装复杂的行为，例如结合面向对象编程中的继承和多态来实现不同的回调机制。</li></ul></li></ul></li></ul><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello1</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello2</span><span class="params">(string str)</span> </span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// function 函数对象类型</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; function1 = hello1;</span><br><span class="line">    <span class="built_in">function1</span>();</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; function2 = hello2;</span><br><span class="line">    <span class="built_in">function2</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; function3 = sum;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="built_in">function3</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"total = "</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function 函数对象类型 + Lambda 表达式</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; function4 = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) {<span class="keyword">return</span> a + b; };</span><br><span class="line">    <span class="keyword">int</span> total2 = <span class="built_in">function4</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"total2 = "</span> &lt;&lt; total2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello peter</span><br><span class="line">total = 3</span><br><span class="line">total2 = 8</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 通过 function 函数对象类型，调用类的成员函数</span></span><br><span class="line">    Test t;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(Test*, string)&gt; function1 = &amp;Test::hello;</span><br><span class="line">    <span class="built_in">function1</span>(&amp;t, <span class="string">"peter"</span>);</span><br><span class="line">    <span class="built_in">function1</span>(&amp;<span class="built_in">Test</span>(), <span class="string">"peter"</span>);    <span class="comment">// 或者使用临时变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br><span class="line">hello peter</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码三"><a href="#案例代码三" class="headerlink" title="案例代码三"></a>案例代码三</h4><p>使用 <code>function</code> 函数对象类型来实现图书管理系统的菜单列表选择功能。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doShowAllBooks</span><span class="params">()</span> </span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"查看所有书籍"</span> &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBorrowBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"借书"</span> &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBackBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"还书"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doQueryBook</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"查询书籍"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoginOut</span><span class="params">()</span> </span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"注销"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="keyword">int</span>, function&lt;<span class="keyword">void</span>()&gt;&gt; actionMap;</span><br><span class="line">	actionMap.<span class="built_in">insert</span>({ <span class="number">1</span>, doShowAllBooks });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">2</span>, doBorrowBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">3</span>, doBackBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">4</span>, doQueryBook });</span><br><span class="line">    actionMap.<span class="built_in">insert</span>({ <span class="number">5</span>, doLoginOut });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"\n-------------------"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"1. 查看所有书籍"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"2. 借书"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"3. 还书"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"4. 查询书籍"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"5. 注销"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"-------------------"</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"请选择: "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测输入是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (!(cin &gt;&gt; choice)) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入数字无效，请重新输入!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 清除错误状态</span></span><br><span class="line">            cin.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="comment">// 丢弃错误输入</span></span><br><span class="line">            cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = actionMap.<span class="built_in">find</span>(choice);</span><br><span class="line">        <span class="keyword">if</span> (it == actionMap.<span class="built_in">end</span>()) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入数字无效，请重新输入!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        it-&gt;<span class="built_in">second</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有一个参数且不带返回值的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 模板类的特化，支持特定的函数签名 R(ARG)</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG 代表参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ARG&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg 传递给存储函数的参数</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG arg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 hello 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = hello;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 hello</span></span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有两个参数且带返回值的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG1, ARG2)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 模板类的特化，支持特定的函数签名 R(ARG1, ARG2)</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG1 代表第一个参数类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG2 代表第二个参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ARG1, <span class="keyword">typename</span> ARG2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG1, ARG2)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG1, ARG2) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG1, ARG2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line"><span class="comment">     * @param pfunc 指向函数的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg1 传递给存储函数的第一个参数</span></span><br><span class="line"><span class="comment">     * @param arg2 传递给存储函数的第二个参数</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG1 arg1, ARG2 arg2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg1, arg2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 sum 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func1 = sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 sum</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">func1</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: 8</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码三-1"><a href="#案例代码三-1" class="headerlink" title="案例代码三"></a>案例代码三</h4><p>模拟实现 <code>function</code> 类模板的功能，并调用拥有不同数量参数（可变参数列表）的函数，避免编写多个模板类的特例化。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板</span></span><br><span class="line"><span class="comment">// 这里的 Fty 代表任意函数签名，如 R(ARG...)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief myfunction 模板类的特化，支持可变长参数列表</span></span><br><span class="line"><span class="comment"> * @tparam R 代表返回值类型</span></span><br><span class="line"><span class="comment"> * @tparam ARG 代表参数列表（可以是任意数量的参数类型）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ... ARG&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;</span><span class="built_in">R</span>(ARG...)&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义函数指针类型，指向 R(ARG...) 类型的函数</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(ARG...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，接收一个函数指针，并存储起来</span></span><br><span class="line"><span class="comment">     * @param pfunc 指向函数的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重载小括号运算符，使对象可以像函数一样调用</span></span><br><span class="line"><span class="comment">     * @param arg 传递给存储函数的参数列表</span></span><br><span class="line"><span class="comment">     * @return 调用存储函数的返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(ARG... arg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg...);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储函数指针</span></span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"hello "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 hello 函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = hello;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func1 调用 hello</span></span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 myfunction 对象，并绑定 sum函数</span></span><br><span class="line">    myfunction&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func2 = sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 func2 调用 sum</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">func2</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result: "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello peter</span><br><span class="line">result: 7</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的-bind-绑定器"><a href="#C-11-的-bind-绑定器" class="headerlink" title="C++ 11 的 bind 绑定器"></a>C++ 11 的 bind 绑定器</h2><h3 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h3><p><code>bind</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的一个工具，用于创建可调用对象（Callable Object），它可以将函数与部分参数进行绑定，并返回一个新的可调用对象，方便后续调用。</p><ul><li><p>主要作用</p><ul><li>固定部分参数：可以预先绑定部分参数，简化后续调用的接口。</li><li>调整参数顺序：可以自定义参数的传递顺序，使函数调用更加灵活。</li><li>与标准库配合：可以与 <code>function</code>、<code>thread</code>、STL 算法等一起使用，提高程序的灵活性。</li></ul></li><li><p>关键点</p><ul><li><code>bind</code> 返回一个可调用对象（函数对象），类似于 Lambda 表达式。</li><li><code>placeholders::_1, placeholders::_2, ...</code> 代表占位符（最多可以有 20 个），表示绑定器调用时需要提供的参数。</li><li>适用于普通函数、类成员函数、仿函数（函数对象）等。</li></ul></li><li><p>使用场景</p><ul><li>配合 <code>function</code> 类模板使用，用于回调管理。</li><li>与 <code>thread</code> 配合，用于传递类成员函数。</li><li>在 STL 算法中自定义比较或筛选规则。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>尽管 <code>bind</code> 功能强大，但在 C++ 11 之后，Lambda 表达式在大多数情况下更加直观，建议优先使用 Lambda 表达式。</p></div><h3 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="案例代码一-2"><a href="#案例代码一-2" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>{</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 例子一，绑定拥有一个参数的普通函数</span></span><br><span class="line">    <span class="built_in">bind</span>(hello, <span class="string">"Hello Bind!"</span>)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子二，绑定拥有两个参数的普通函数</span></span><br><span class="line">    <span class="keyword">int</span> result1 = <span class="built_in">bind</span>(sum, <span class="number">3</span>, <span class="number">5</span>)();</span><br><span class="line">    cout &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子三，绑定类成员函数</span></span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="built_in">bind</span>(&amp;Test::sum, <span class="built_in">Test</span>(), <span class="number">5</span>, <span class="number">9</span>)();</span><br><span class="line">    cout &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子四，使用参数占位符绑定（最多可以有20个参数占位符）</span></span><br><span class="line">    <span class="built_in">bind</span>(hello, placeholders::_1)(<span class="string">"Hello Rust!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子五，使用 function 类模板实现 bind 绑定器的复用</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(string)&gt; func1 = <span class="built_in">bind</span>(hello, placeholders::_1);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"Hello Python"</span>);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">"Hello Golang"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例子六，使用参数占位符 + function 类模板进行绑定</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; func2 = <span class="built_in">bind</span>(sum, <span class="number">6</span>, placeholders::_1);    <span class="comment">// 绑定 6 作为第一个参数，第二个参数则手动传入</span></span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="built_in">func2</span>(<span class="number">5</span>);     <span class="comment">// 输出 11，相当于 sum(6, 5)</span></span><br><span class="line">    cout &lt;&lt; result3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hello Bind!</span><br><span class="line">8</span><br><span class="line">14</span><br><span class="line">Hello Rust!</span><br><span class="line">Hello Python</span><br><span class="line">Hello Golang</span><br><span class="line">11</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二-2"><a href="#案例代码二-2" class="headerlink" title="案例代码二"></a>案例代码二</h4><p>这里简单使用 C++ 11 的 <code>bind</code> 和 <code>function</code> 来模拟实现线程池。特别注意，<code>ThreadPool::startPool()</code> 会调用 <code>join()</code> 来阻塞等待所有子线程执行完成，即线程池运行一次后就会结束，不能重复使用，而且也没有使用到任务队列来优化线程池。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Thread</span>(function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; func, <span class="keyword">int</span> id) : _func(func), _id(id) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(_func, _id)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; _func;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程池</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() {</span><br><span class="line">        <span class="comment">// 释放堆上的资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _pool.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">delete</span> _pool[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        <span class="comment">// 创建自定义的线程对象，并放入容器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="comment">// 使用 bind 绑定器</span></span><br><span class="line">            _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="keyword">this</span>, placeholders::_1), i));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子线程执行完成</span></span><br><span class="line">        <span class="keyword">for</span> (thread &amp;t : _handler) {</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Thread *&gt; _pool;</span><br><span class="line">    vector&lt;thread&gt; _handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runInThread() 成员函数充当线程函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runInThread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call runInThread! id: "</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">startPool</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call runInThread! id: 0</span><br><span class="line">call runInThread! id: 2</span><br><span class="line">call runInThread! id: 5</span><br><span class="line">call runInThread! id: 9</span><br><span class="line">call runInThread! id: 6</span><br><span class="line">call runInThread! id: 8</span><br><span class="line">call runInThread! id: 1</span><br><span class="line">call runInThread! id: 7</span><br><span class="line">call runInThread! id: 4</span><br><span class="line">call runInThread! id: 3</span><br></pre></td></tr></tbody></table></figure><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/2288a106.html" title="C++ 巩固进阶之二">https://www.techgrow.cn/posts/2288a106.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/a19ep68d.html" rel="prev" title="Debian 12 安装 Docker 与 Docker-Compose"><i class="fa fa-angle-left"></i> Debian 12 安装 Docker 与 Docker-Compose</a></div><div class="post-nav-item"> <a href="/posts/bd9d2710.html" rel="next" title="C++ 巩固进阶之三">C++ 巩固进阶之三<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.7m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">25:07</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤 ICP 备 19024664 号</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035 号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/2288a106.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>