<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:type" content="article"><meta property="og:title" content="C++ 巩固进阶之二"><meta property="og:url" content="https://www.techgrow.cn/posts/2288a106.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 C++ 的巩固教程。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-02-19T13:55:33.000Z"><meta property="article:modified_time" content="2025-02-19T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.techgrow.cn/posts/2288a106.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/2288a106.html","path":"posts/2288a106.html","title":"C++ 巩固进阶之二"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++ 巩固进阶之二 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-text">C++ 11 的核心特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">C++ 11 的右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E7%8E%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">重现模拟实现字符串类的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">解决模拟实现字符串类的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">左值引用和右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-text">概念介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">案例代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-text">使用右值引用解决问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-text">案例代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-text">测试代码一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%BA%8C"><span class="nav-text">测试代码二</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%B8%89"><span class="nav-text">测试代码三</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-text">C++ 11 的移动语义与完美转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">基础案例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB"><span class="nav-text">自定义字符串类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="nav-text">自定义 Vector 容器类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E7%B1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">自定义 Vector 类存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#move-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-text">move 移动语义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#move-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">move 移动语义的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#move-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">move 移动语义的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forward-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-text">forward 完美转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#forward-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">forward 完美转发的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forward-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">forward 完美转发的使用</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">677</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/2288a106.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++ 巩固进阶之二 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 C++ 的巩固教程。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++ 巩固进阶之二</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-02-19 21:55:33" itemprop="dateCreated datePublished" datetime="2025-02-19T21:55:33+08:00">2025-02-19</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/2288a106.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/2288a106.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>3.9k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>4 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/2288a106.html">C++ 巩固进阶之二</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之三</a></li><li><a href="/posts/6e5acd18.html">C++ 巩固进阶之四</a></li></ul><span id="more"></span><h2 id="C-11-的核心特性"><a href="#C-11-的核心特性" class="headerlink" title="C++ 11 的核心特性"></a>C++ 11 的核心特性</h2><ul><li><p>关键字和语法</p><ul><li><code>auto</code>：可以根据右值推导出右值的类型，然后左边变量的类型就可以知道了。</li><li><code>nullptr</code>：空指针，给指针专用（能够和整数进行区别）。</li><li><code>foreach</code>：通过 <code>for (int num : arr) { }</code> 语法可以遍历数组、容器等。</li><li>右值引用（<code>T &amp;&amp;</code>），还有 <code>move()</code> 移动语义函数和 <code>forward()</code> 完美转发函数。</li><li>模板新特性：<code>type... A</code> 表示可变参数模板。</li></ul></li><li><p>绑定器和函数对象</p><ul><li><code>function</code>：函数类模板，用于存储任何可以调用的目标（如普通函数、函数指针、函数对象、Lambda 表达式等），并通过统一的接口进行调用。</li><li><code>bind</code>：绑定器，用于创建可调用对象，可以将函数与部分参数进行绑定，并返回一个新的可调用对象，方便后续调用。</li><li>Lambda 表达式：用于定义匿名函数对象的简洁语法，拥有强大的变量捕获、类型推导和灵活性，可以使得代码更加简洁、灵活。</li></ul></li><li><p>智能指针</p><ul><li><code>shared_ptr</code>：带引用计数的智能指针，允许多个指针共享同一资源。</li><li><code>weak_ptr</code>：通常用于避免 <code>shared_ptr</code> 智能指针之间的循环引用问题。</li></ul></li><li><p>容器</p><ul><li><code>array</code>：一个固定大小的数组封装，比原生 C 语言数组更安全，支持 STL 的特性，如迭代器、<code>size()</code> 等。</li><li><code>unordered_map</code>：基于哈希表的键值对存储，比 <code>map（基于红黑树）</code> 的查找速度更快，平均时间复杂度是 <code>O(1)</code>。</li><li><code>unordered_set</code>：基于哈希表的集合，插入、查找速度更快。</li><li><code>forward_list</code>：单向链表，比 <code>list（基于双向链表）</code> 更节省内存。</li></ul></li></ul><h2 id="C-11-的右值引用"><a href="#C-11-的右值引用" class="headerlink" title="C++ 11 的右值引用"></a>C++ 11 的右值引用</h2><h3 id="重现模拟实现字符串类的问题"><a href="#重现模拟实现字符串类的问题" class="headerlink" title="重现模拟实现字符串类的问题"></a>重现模拟实现字符串类的问题</h3><p>下述代码模拟实现了 C++ 中的 <code>string</code> 类，但是 <code>main()</code> 函数调用 <code>getString()</code> 函数的效率会非常低。第一个原因是，<code>getString()</code> 函数在调用结束时，返回了一个 MyString 对象，这会调用一次拷贝构造函数来拷贝 <code>tmpStr</code> 对象。第二个原因是，在 <code>main()</code> 函数中，将 <code>getStriing()</code> 函数的返回值赋值了给 <code>str2</code> 对象，这会调用赋值运算符重载函数，也就是又拷贝了一次数据。<a href="../../../asset/2025/02/cxx-custom-string-1.png">点击</a> 查看完整分析图解。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString &amp;str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(const MyString &amp;str)           // getString() 函数返回执行结果值时，调用拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(const MyString &amp;str)          // main() 函数中，执行赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象，临时对象的生存周期是所在语句</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="解决模拟实现字符串类的问题"><a href="#解决模拟实现字符串类的问题" class="headerlink" title="解决模拟实现字符串类的问题"></a>解决模拟实现字符串类的问题</h3><p>为了解决上述模拟实现字符串类时，多次拷贝内存数据导致运行效率低的问题，可以使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来解决。</p><h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><ul><li><p>左值引用与右值引用的介绍</p><ul><li><code>左值</code>：有名称、有内存</li><li><code>右值</code>：没名称（临时量）、没内存</li></ul></li><li><p>左值引用与右值引用的区别</p><ul><li>左值引用和右值引用的主要区别在于它们可以绑定的值类别，左值引用只能绑定到左值，而右值引用只能绑定到右值。</li><li>右值引用引入了 <code>move</code> 移动语义，使得 C++ 可以更高效地处理临时对象。</li><li>在泛型编程中，可以通过函数模板的类型推导来同时处理左值引用和右值引用，从而实现参数的 <code>forward</code> 完美转发。</li></ul></li></ul><h5 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ......(省略)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;        <span class="comment">// 左值：有名称、有内存，右值：没名称（临时量）、没内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; b = a;        <span class="comment">// 可以将左值绑定到左值引用上</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; c = a;    // 无法将左值绑定到右值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; d = <span class="number">20</span>;      <span class="comment">// 可以将右值绑定到右值引用上</span></span><br><span class="line">    <span class="comment">// int&amp; c = 20;    // 无法将右值绑定到左值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp;&amp; f = d;    // 无法将左值绑定到右值引用上，因为右值引用变量本身就是左值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyString&amp; s = MyString("aaa");   // 错误写法</span></span><br><span class="line">    MyString&amp;&amp; s = <span class="built_in">MyString</span>(<span class="string">"aaa"</span>);     <span class="comment">// 正确写法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用右值引用解决问题"><a href="#使用右值引用解决问题" class="headerlink" title="使用右值引用解决问题"></a>使用右值引用解决问题</h4><div class="admonition note"><p class="admonition-title">提示</p><ul><li>(1) 右值引用参数常用于减少内存数据的拷贝，比如在带右值引用参数的拷贝构造函数和赋值运算符重载函数中使用。</li><li>(2) 在带右值引用参数的拷贝构造函数和赋值运算符重载函数中，该右值引用参数接收的都是临时对象。</li></ul></div><h5 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h5><p>这里使用带右值引用参数的拷贝构造函数和赋值运算符重载函数，来解决在模拟实现 C++ 字符串类时，多次拷贝内存数据导致运行效率低的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">		str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString&amp; str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码一"><a href="#测试代码一" class="headerlink" title="测试代码一"></a>测试代码一</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(MyString&amp;&amp; str)                // getString() 函数返回执行结果值时，调用带右值引用参数的拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(MyString&amp;&amp; str)               // main() 函数中，执行带右值引用参数的赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">================ test01() ================</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码二"><a href="#测试代码二" class="headerlink" title="测试代码二"></a>测试代码二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"Hello "</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">str2</span><span class="params">(<span class="string">"World!"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    MyString str3 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码三"><a href="#测试代码三" class="headerlink" title="测试代码三"></a>测试代码三</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    MyString str1 = <span class="string">"aaa"</span>;</span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(str1); <span class="comment">// 调用的是带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是带右值引用参数的拷贝构造函数 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 中，无论是 Debug 模式，还是 Release 模式，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的移动语义与完美转发"><a href="#C-11-的移动语义与完美转发" class="headerlink" title="C++ 11 的移动语义与完美转发"></a>C++ 11 的移动语义与完美转发</h2><h3 id="基础案例代码"><a href="#基础案例代码" class="headerlink" title="基础案例代码"></a>基础案例代码</h3><h4 id="自定义字符串类"><a href="#自定义字符串类" class="headerlink" title="自定义字符串类"></a>自定义字符串类</h4><p>自定义一个 MyString 字符串类，模拟实现　C++ 的 <code>string</code> 字符串类，主要使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来减少内存数据的拷贝次数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-容器类"><a href="#自定义-Vector-容器类" class="headerlink" title="自定义 Vector 容器类"></a>自定义 Vector 容器类</h4><p>自定义一个 Vector 容器类，模拟实现　C++ 的 <code>vector</code> 容器，主要实现了 <code>vector</code>　容器的空间分配器、迭代器。值得一提的是，由于篇幅有限，这里虽然解决迭代器失效的问题，但是并没有解决容器扩容（执行插入操作）后导致迭代器失效的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt; *pvec = <span class="literal">nullptr</span>, T *p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base *itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt; *_pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T *p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T *p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator *cur = <span class="literal">nullptr</span>, Iterator_Base *next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator *_cur;</span><br><span class="line">        Iterator_Base *_next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T *start, T *end)</span> </span>{</span><br><span class="line">        Iterator_Base *cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base *next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-类存在的问题"><a href="#自定义-Vector-类存在的问题" class="headerlink" title="自定义 Vector 类存在的问题"></a>自定义 Vector 类存在的问题</h4><p>使用上面自定义的 Vecotr 容器类执行以下测试代码后，发现执行 <code>vector.push_back(MyString("bbb"));</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，这会导致多拷贝一份内存数据，从而影响程序的执行效率。值得一提的是，这里希望调用的是 MyString 类带右值引用参数的拷贝构造函数，因为该带右值引用参数的拷贝构造函数使用的是浅拷贝，可以减少内存数据的拷贝次数。至于具体的解决方案，可以使用下面介绍的 C++ 移动语义（<code>move</code>）来实现。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="move-移动语义"><a href="#move-移动语义" class="headerlink" title="move 移动语义"></a>move 移动语义</h3><h4 id="move-移动语义的概念"><a href="#move-移动语义的概念" class="headerlink" title="move 移动语义的概念"></a>move 移动语义的概念</h4><p>C++ 中的移动语义是引入于 C++ 11 的一种特性，它通过引入移动构造函数和移动赋值运算符，允许程序以更高效的方式管理资源，尤其是在避免不必要的拷贝操作时。移动语义的核心是利用右值引用（<code>T&amp;&amp;</code>）和标准库中的 <code>std::move</code>，使对象的资源从一个对象转移到另一个对象（比如将左值类型强转为右值类型），而不是拷贝，从而提高程序性能。</p><ul><li><p>移动语义的主要作用</p><ul><li>高效资源转移：避免资源分配和释放的重复工作。</li><li>减少拷贝：通过转移所有权来减少对象的拷贝。</li><li>提高程序性能：尤其适用于内存密集型和资源管理复杂的程序。</li></ul></li><li><p>移动语义的使用场景</p><ul><li>减少临时对象的开销（如函数返回大对象）。</li><li>避免深拷贝（如容器中的数据转移）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a target="_blank" rel="external nofollow" href="https://blog.csdn.net/chenmi123321/article/details/144334601">C++ 的 移动语义 move</a></li><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/602543410">理解现代 C++ 中的移动语义</a></li></ul></div><h4 id="move-移动语义的使用"><a href="#move-移动语义的使用" class="headerlink" title="move 移动语义的使用"></a>move 移动语义的使用</h4><p>在<a href="/posts/e302ad63.html#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB">上面</a>自定义的 Vector 容器类中，为了解决执行 <code>vector.push_back(MyString("bbb"))</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题，可以使用 C++ 中的 <code>move</code> 移动语义来解决。</p><ul><li>更改的核心代码<ul><li>重载 <code>Allocator::construct()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型</li><li>重载 <code>Vector::push_back()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(<span class="built_in">move</span>(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, <span class="built_in">move</span>(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="forward-完美转发"><a href="#forward-完美转发" class="headerlink" title="forward 完美转发"></a>forward 完美转发</h3><p>虽然使用 C++ 11 提供的 <code>move</code> 移动语义，可以解决在执行 <code>vector.push_back(MyString("bbb"));</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题。但是，这样每次都需要定义两个重载函数来分别接收左值引用参数和右值引用参数，这就显得比较繁琐。为了使 C++ 代码更简洁，可以使用 C++ 11 提供的 <code>forward</code> 完美转发来实现同样的功能。</p><h4 id="forward-完美转发的概念"><a href="#forward-完美转发的概念" class="headerlink" title="forward 完美转发的概念"></a>forward 完美转发的概念</h4><p>完美转发（Perfect Forwarding）是 C++ 11 中引入的一种编程技巧，其目的是在编写泛型函数时能够保留参数的类型和值类别（左值或右值），从而实现更为高效且准确地传递参数。通过使用右值引用和模板类型推导，完美转发允许在函数中以原始参数的形式将参数传递给其他函数，而不会发生不必要的拷贝操作，从而提高性能。完美转发在很多场合都非常有用，尤其是在设计泛型库和需要高效参数传递的场景。以下是一些常见的完美转发应用场景：</p><ul><li>(1) 委托构造函数：完美转发可以在构造函数之间传递参数，避免不必要的拷贝操作，从而提高性能。</li><li>(2) 可变参数模板函数：完美转发可以用于实现可接受任意数量和类型参数的函数，如实现一个通用的元组或 <code>bind()</code> 函数。</li><li>(3) 智能指针：完美转发在智能指针的实现中也有重要作用，例如 <code>unique_ptr</code> 和 <code>shared_ptr</code> 中的构造函数和 <code>make()</code> 函数等。</li><li>(4) 函数包装器：完美转发可以用于实现函数包装器，使包装后的函数能够正确处理所有类型的参数，包括右值引用。例如 <code>function</code> 的实现。</li><li>(5) 资源管理类：通过完美转发，可以使资源管理类（如锁管理类、线程池等）能够更方便地处理各种资源。</li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a target="_blank" rel="external nofollow" href="https://blog.csdn.net/haokan123456789/article/details/134980411">C++ 之 forward 完美转发</a></li><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/5iedu/p/11324772.html">C++ 的 forward 完美转发</a></li><li><a target="_blank" rel="external nofollow" href="https://zhuanlan.zhihu.com/p/710953400">深度解析 C++ 完美转发的实现原理与应用</a></li></ul></div><h4 id="forward-完美转发的使用"><a href="#forward-完美转发的使用" class="headerlink" title="forward 完美转发的使用"></a>forward 完美转发的使用</h4><ul><li>在<a href="/posts/e302ad63.html#%E8%87%AA%E5%AE%9A%E4%B9%89-Vector-%E5%AE%B9%E5%99%A8%E7%B1%BB">上面</a>自定义的 Vector 容器类中，更改以下地方：<ul><li>更改 <code>Allocator::construct()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型。</li><li>重载 <code>Vector::push_back()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(forward&lt;Ty&gt;(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, forward&lt;Ty&gt;(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/2288a106.html" title="C++ 巩固进阶之二">https://www.techgrow.cn/posts/2288a106.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/a19ep68d.html" rel="prev" title="Debian 12 安装 Docker 与 Docker-Compose"><i class="fa fa-angle-left"></i> Debian 12 安装 Docker 与 Docker-Compose</a></div><div class="post-nav-item"> <a href="/posts/bd9d2710.html" rel="next" title="C++ 巩固进阶之三">C++ 巩固进阶之三<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.7m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">25:43</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/2288a106.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>