<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css"><script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.techgrow.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Nginx 内存池的底层源码。"><meta property="og:type" content="article"><meta property="og:title" content="Nginx 内存池源码剖析"><meta property="og:url" content="https://www.techgrow.cn/posts/5bc5018f.html"><meta property="og:site_name" content="Clay 的技术空间"><meta property="og:description" content="本文主要介绍 Nginx 内存池的底层源码。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/nginx-memory-4.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/nginx-memory-pool-1.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/nginx-memory-pool-2.png"><meta property="og:image" content="https://www.techgrow.cn/asset/2025/04/nginx-memory-pool-3.png"><meta property="article:published_time" content="2025-04-18T13:55:33.000Z"><meta property="article:modified_time" content="2025-04-18T13:55:33.000Z"><meta property="article:author" content="Clay"><meta property="article:tag" content="C++"><meta property="article:tag" content="源码剖析"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techgrow.cn/asset/2025/04/nginx-memory-4.png"><link rel="canonical" href="https://www.techgrow.cn/posts/5bc5018f.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.techgrow.cn/posts/5bc5018f.html","path":"posts/5bc5018f.html","title":"Nginx 内存池源码剖析"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Nginx 内存池源码剖析 | Clay 的技术空间</title><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-135294383-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-135294383-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script class="next-config" data-name="baidu_analytics" type="application/json">"84c09b30349a65573c5c642ff336969b"</script><script src="/js/third-party/analytics/baidu-analytics.js"></script><link rel="dns-prefetch" href="https://waline.techgrow.cn"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.admonition{margin:1.5625em 0;padding:.6rem;overflow:hidden;font-size:.64rem;page-break-inside:avoid;border-left:.3rem solid #42b983;border-radius:.3rem;box-shadow:0 .1rem .4rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1);background-color:#fafafa}p.admonition-title{position:relative;margin:-.6rem -.6rem .8em -.6rem!important;padding:.4rem .6rem .4rem 2.5rem;font-weight:700;background-color:rgba(66,185,131,.1)}.admonition-title::before{position:absolute;top:.9rem;left:1rem;width:12px;height:12px;background-color:#42b983;border-radius:50%;content:' '}.info>.admonition-title,.todo>.admonition-title{background-color:rgba(0,184,212,.1)}.attention>.admonition-title,.caution>.admonition-title,.warning>.admonition-title{background-color:rgba(255,145,0,.1)}.error>.admonition-title,.fail>.admonition-title,.failure>.admonition-title,.missing>.admonition-title{background-color:rgba(255,82,82,.1)}.admonition.info,.admonition.todo{border-color:#00b8d4}.admonition.attention,.admonition.caution,.admonition.warning{border-color:#ff9100}.admonition.error,.admonition.fail,.admonition.failure,.admonition.missing{border-color:#ff5252}.info>.admonition-title::before,.todo>.admonition-title::before{background-color:#00b8d4;border-radius:50%}.attention>.admonition-title::before,.caution>.admonition-title::before,.warning>.admonition-title::before{background-color:#ff9100;border-radius:50%}.error>.admonition-title::before,.fail>.admonition-title::before,.failure>.admonition-title::before,.missing>.admonition-title::before{background-color:#ff5252;border-radius:50%}.admonition>:last-child{margin-bottom:0!important}</style><link rel="alternate" href="/atom.xml" title="Clay 的技术空间" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion"><script src="/lib/jquery/dist/jquery.min.js"></script><script data-pjax="">!function(){var t=window.location.host;if(-1==t.indexOf("127.0.0.1")&&-1==t.indexOf("localhost")){var o=document.createElement("script"),e=window.location.protocol.split(":")[0];o.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(o,n)}}()</script><link rel="stylesheet" href="/lib/aplayer/dist/APlayer.min.css"><div id="aplayer" style="display:none"></div><script src="/lib/aplayer/dist/APlayer.min.js"></script><script src="/lib/aplayer/dist/color-thief.js"></script><script src="/lib/aplayer-init.js"></script><script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script><script>function getTitle(){var t=jQuery("meta[property='og:title']");return t?t.attr("content"):""}function getDesc(){var t=jQuery("meta[property='og:description']");return t?t.attr("content"):""}function randomString(t){for(var e="ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678",n=e.length,i="",r=0;r<t;++r)i+=e.charAt(Math.floor(Math.random()*n));return i}function initWx(t){wx.config({debug:!1,appId:t.appId,nonceStr:t.nonceStr,signature:t.signature,timestamp:t.timestamp,jsApiList:["checkJsApi","onMenuShareTimeline","onMenuShareAppMessage","onMenuShareQQ"]}),wx.ready(function(){wx.onMenuShareTimeline({title:t.title,link:t.link,imgUrl:t.imgUrl,success:function(){}}),wx.onMenuShareAppMessage({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,type:"link",dataUrl:"",success:function(){}}),wx.onMenuShareQQ({title:t.title,desc:t.desc,link:t.link,imgUrl:t.imgUrl,success:function(){},cancel:function(){}})}),wx.error(function(t){})}jQuery(function(){var e=getDesc(),n=getTitle(),i=randomString(16),r=(new Date).getTime(),a=window.location.href,t="https://open.techgrow.cn/api/wechat/js/signature?url="+a+"&noncestr="+i+"&timestamp="+r;jQuery.getJSON(t,function(t){initWx({desc:e,title:n,link:a,nonceStr:i,timestamp:r,signature:t.data,appId:"wx1fcf69355af43d41",imgUrl:"https://www.techgrow.cn/img/wx_share.jpg"})})})</script><div style="display:none"><img src="https://www.techgrow.cn/img/wx_share.jpg" alt=""></div><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Clay 的技术空间</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">用进废退 | 艺不压身</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li><li class="menu-item menu-item-links"><a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-readingnotes"><a href="https://www.techgrow.cn/reading/" rel="section"><i class="fa fa-book-open-reader fa-fw"></i>读书笔记</a></li><li class="menu-item menu-item-commentmanage"><a href="https://waline.techgrow.cn/" rel="external nofollow" target="_blank"><i class="fa fa-comment fa-fw"></i>评论管理</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E7%BA%B2"><span class="nav-text">大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-text">内存管理概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="nav-text">源码学习目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx-%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-text">Nginx 内存池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-text">内存池的源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">重要类型和变量的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-text">重要的内存池函数接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="nav-text">内存池管理核心函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1"><span class="nav-text">内存池的底层设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">内存池结构设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ngx-pool-data-t"><span class="nav-text">ngx_pool_data_t</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ngx-pool-large-t"><span class="nav-text">ngx_pool_large_t</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ngx-pool-t"><span class="nav-text">ngx_pool_t</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">内存池的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">内存池的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="nav-text">内存分配机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="nav-text">内存分配流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E9%94%80%E6%AF%81"><span class="nav-text">内存池的销毁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E6%BA%90%E7%A0%81%E6%B5%8B%E8%AF%95"><span class="nav-text">内存池的源码测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-Nginx-%E6%BA%90%E7%A0%81"><span class="nav-text">编译 Nginx 源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">编写测试代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">运行测试代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E6%BA%90%E7%A0%81%E7%A7%BB%E6%A4%8D"><span class="nav-text">内存池的源码移植</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="nav-text">核心代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">测试代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81"><span class="nav-text">下载代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FAQ"><span class="nav-text">FAQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Clay" src="/img/head.jpg"></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <span class="site-state-item-count">710</span> <span class="site-state-item-name">文章</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/rqh656418510" title="GitHub → https://github.com/rqh656418510" rel="external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:rong656418510@gmail.com" title="E-Mail → mailto:rong656418510@gmail.com" rel="external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i> RSS</a></span><span class="links-of-author-item"><a href="/sitemap.xml" title="SiteMap → /sitemap.xml" rel="noopener me"><i class="fa fa-sitemap fa-fw"></i> SiteMap</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.techgrow.cn/posts/5bc5018f.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/head.jpg"><meta itemprop="name" content="Clay"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Clay 的技术空间"><meta itemprop="description" content="专注于 Java 后端、分布式、微服务、云原生、数据库、系统架构、大数据、云计算、虚拟化、人工智能学习的技术博客。"></span><span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Nginx 内存池源码剖析 | Clay 的技术空间"><meta itemprop="description" content="本文主要介绍 Nginx 内存池的底层源码。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Nginx 内存池源码剖析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-04-18 21:55:33" itemprop="dateCreated datePublished" datetime="2025-04-18T21:55:33+08:00">2025-04-18</time></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">评论数：</span><a title="waline" href="/posts/5bc5018f.html#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/5bc5018f.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.9k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 ≈</span> <span>4 分钟</span></span></div></div></header><div class="post-body post-container" itemprop="articleBody" id="readmore-container"><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/712a574b.html">SGI STL 内存池源码剖析</a></li><li><a href="/posts/5bc5018f.html">Nginx 内存池源码剖析</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将剖析 Nginx 内存池的源码，并介绍内存池的底层设计和工作原理，最后基于 C++ 移植 Nginx 内存池的核心源码。值得一提的是，移植后的 C++ 代码兼容 Windows 和 Linux 平台。</p><div class="admonition note"><p class="admonition-title">C++ 常见的池</p><p>在 C++ 中，常见的池有对象池、内存池、连接池、协程池、线程池、进程池。</p></div><span id="more"></span><h3 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h3><p>内存管理，是指软件运行时对计算机内存资源的分配和使用的技术。<strong>其最主要的目的是如何高效、快速地分配内存，并且在适当的时候释放和回收内存资源。</strong></p><h3 id="源码学习目标"><a href="#源码学习目标" class="headerlink" title="源码学习目标"></a>源码学习目标</h3><p>在剖析 Nginx 内存管理的源码之前，先思考以下几个问题：</p><ul><li>(1) Nginx 为什么要进行内存管理？</li><li>(2) Nginx 如何进行内存管理？</li><li>(3) Nginx 的内存管理解决了哪些问题？</li></ul><h2 id="Nginx-内存池"><a href="#Nginx-内存池" class="headerlink" title="Nginx 内存池"></a>Nginx 内存池</h2><h3 id="内存池的源码剖析"><a href="#内存池的源码剖析" class="headerlink" title="内存池的源码剖析"></a>内存池的源码剖析</h3><p>这里剖析的 Nginx 版本是 <code>1.12.2</code>，Nginx 内存池的核心源码主要位于 <code>ngx_palloc.h</code> 和 <code>ngx_palloc.c</code> 源文件中。</p><h4 id="重要类型和变量的定义"><a href="#重要类型和变量的定义" class="headerlink" title="重要类型和变量的定义"></a>重要类型和变量的定义</h4><ul><li>Nginx 内存池的粒度信息</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NGX_MAX_ALLOC_FROM_POOL should be (ngx_pagesize - 1), i.e. 4095 on x86. On Windows NT it decreases a number of locked pages in a kernel.</span></span><br><span class="line"><span class="comment">// 小块内存池单次分配的最大内存大小，不能超过 ngx_pagesize - 1，超过这个大小的内存不会从内存池中分配，而是通过 malloc() 之类的方式单独分配内存。</span></span><br><span class="line"><span class="comment">//ngx_pagesize 是系统页面大小（例如 x86 平台是 4096 字节），减 1 是为了确保对齐且不会跨页，最终小块内存池单次分配的最大内存大小为 4095 字节（x86 平台）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池的默认初始大小为 16KB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_DEFAULT_POOL_SIZE (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池分配时的对齐字节数为 16 字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_POOL_ALIGNMENT 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存的最小可接受大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MIN_POOL_SIZE ngx_align ((sizeof (ngx_pool_t) + 2 * sizeof (ngx_pool_large_t)), NGX_POOL_ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存分配时的对齐字节数，通常是 4 字节（32 位系统）或者 8 字节（64 位系统）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_ALIGNMENT sizeof (unsigned long)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Nginx 内存池的主结构体类型</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;         <span class="comment">// 小块内存池的数据头</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;       <span class="comment">// 小块内存分配的最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;   <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;     <span class="comment">// 该指针挂接一个 ngx_chain_t 结构</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;     <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;   <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *log;       <span class="comment">// 内存分配相关的日志记录</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>小块内存的数据头信息</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">   u_char               *last;      <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">   u_char               *end;       <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">   <span class="keyword">ngx_pool_t</span>           *next;      <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">   <span class="keyword">ngx_uint_t</span>            failed;    <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">} <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>大块内存的类型定义</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">   <span class="keyword">ngx_pool_large_t</span>     *next;      <span class="comment">// 下一个大块内存</span></span><br><span class="line">   <span class="keyword">void</span>                 *alloc;     <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>清理操作的类型定义，包括一个清理回调函数、传给回调函数的数据和下一个清理操作的地址</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;    <span class="comment">// 清理回调函数的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>  <span class="title">ngx_pool_cleanup_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> {</span></span><br><span class="line">   ngx_pool_cleanup_pt   handler;   <span class="comment">// 函数指针，指向内存清理操作的回调函数</span></span><br><span class="line">   <span class="keyword">void</span>                 *data;      <span class="comment">// 传递给回调函数的参数</span></span><br><span class="line">   <span class="keyword">ngx_pool_cleanup_t</span>   *next;      <span class="comment">// 指向下一个清理操作</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="重要的内存池函数接口"><a href="#重要的内存池函数接口" class="headerlink" title="重要的内存池函数接口"></a>重要的内存池函数接口</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span> *<span class="title">ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span>;   <span class="comment">// 创建内存池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;    <span class="comment">// 销毁内存池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;      <span class="comment">// 重置内存池</span></span><br></pre></td></tr></tbody></table></figure><h4 id="内存池管理核心函数"><a href="#内存池管理核心函数" class="headerlink" title="内存池管理核心函数"></a>内存池管理核心函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> * <span class="title">ngx_palloc_small</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span>   <span class="comment">// 内存池分配小块内存的入口函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">ngx_palloc_block</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span>     <span class="comment">// 内存池分配新小块内存（在小块内存块空间不足时）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">ngx_palloc_large</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span>     <span class="comment">// 内存池分配大块内存的入口函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">ngx_int_t</span> <span class="title">ngx_pfree</span> <span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span>     <span class="comment">// 内存池释放大块内存的入口函数</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="内存池的底层设计"><a href="#内存池的底层设计" class="headerlink" title="内存池的底层设计"></a>内存池的底层设计</h3><p>Nginx 中所有请求都单独对应一个内存池，在这个请求的过程中，所有涉及到内存分配的地方，都到该请求相关的内存池中处理，而中间不会去释放内存，内存池的生命周期与请求一样，请求完毕则直接回收内存。这样的好处在于：统一分配和统一释放，降低了内存泄露问题的出现。Nginx 的内存池设计分为两个部分：</p><ul><li>大块内存：超过 <code>max</code> 大小（默认 4095 字节）的内存分配，走大块内存分配，这部分内存管理由 <code>ngx_pool_large_t</code> 结构体负责。</li><li>小块内存：在 <code>ngx_pool_t</code> 链表中遍历符合要求的 <code>ngx_pool_t</code> 结构体，找到符合要求大小的 <code>pool</code> 直接返回，否则就申请新的小块内存 <code>pool</code>。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>小块内存在分配后不会被单独释放，而是在整个内存池销毁（<code>ngx_destroy_pool()</code>）时，通过 <code>free()</code> 一次性释放。</li><li>大块内存会在整个内存池重置（<code>ngx_reset_pool()</code>）或者整个内存池销毁（<code>ngx_destroy_pool()</code>）时被 <code>free()</code> 释放，但还可以手动调用 <code>ngx_pfree()</code> 单独释放。</li><li>小块内存的重用机制：Nginx 也有机制尝试在链表中查找可用内存块（并非永远只分配不回收），但它不做碎片整理或回收，只是简单地继续分配新的小块内存。</li></ul></div><h4 id="内存池结构设计"><a href="#内存池结构设计" class="headerlink" title="内存池结构设计"></a>内存池结构设计</h4><p>Nginx 采用内存池的结构设计来管理内存，而内存池是由若干固定大小的内存块组成的单向链表（如下图所示）。从图中可以看出来，内存池的头结点维护着内存池的总体信息，从头结点开始，可以访问内存池的小块内存（单向链表，由 <code>ngx_pool_data_t</code> 结构特维护），大块内存（单向链表，由 <code>ngx_pool_large_t</code> 结构特维护），以及抽象内存数据（单向链表，由 <code>ngx_pool_chain_t</code> 结构体维护）。</p><p><img data-src="../../../asset/2025/04/nginx-memory-4.png"></p><h4 id="ngx-pool-data-t"><a href="#ngx-pool-data-t" class="headerlink" title="ngx_pool_data_t"></a>ngx_pool_data_t</h4><p><code>ngx_pool_data_t</code> 结构体负责存储每个 <code>ngx_pool_t</code> 结构体的元数据：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">   u_char               *last;      <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">   u_char               *end;       <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">   <span class="keyword">ngx_pool_t</span>           *next;      <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">   <span class="keyword">ngx_uint_t</span>            failed;    <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">} <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/04/nginx-memory-pool-1.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p><code>failed</code> 成员的引入是为了避免某个 <code>pool</code> 虽然还有可用的内存空间，但是由于内存空间很小了，导致经常性的分配内存空间失败，当累计失败的次数达到某个阈值时，下一次再次查找内存就直接跳过这个 <code>pool</code>，直接去寻找内存池链表中的下一个 <code>pool</code>。在 <code>ngx_pool_s</code> 结构体中，<code>current</code> 指针会随着 <code>failed</code> 的增加而发生改变，如果 <code>current</code> 指向的内存池的 <code>failed</code> 达到了 <code>4</code> 的话，<code>current</code> 就会指向下一个内存池。</p></div><h4 id="ngx-pool-large-t"><a href="#ngx-pool-large-t" class="headerlink" title="ngx_pool_large_t"></a>ngx_pool_large_t</h4><p><code>ngx_pool_large_t</code> 结构体用于存储大内存块，这一块就比较简单粗暴了，直接调用 <code>malloc()</code> 分配一块大内存来使用，多个大内存块之间也是以链表形式来组织数据。正常情况下，这些大块内存会在整个内存池销毁时统一释放，比如在请求处理完毕后、连接断开后、Worker 进程（子进程）退出后会释放大块内存。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">   <span class="keyword">ngx_pool_large_t</span>     *next;      <span class="comment">// 下一个大块内存</span></span><br><span class="line">   <span class="keyword">void</span>                 *alloc;     <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>大块内存的分配请求不会直接在内存池上分配内存来满足，而是直接向操作系统申请一大块内存（底层直接调用 <code>malloc()</code> 分配内存），然后将这块内存挂到内存池头部的 <code>large</code> 指针下。内存池的作用在于解决小块内存池的频繁申请问题，对于这种大块内存，是可以忍受直接申请的。为什么大块内存分配后是挂在链表头部而不是尾部呢？根据程序局部性原理，最近分配的内存一般经常使用，挂在头部可以提高空闲内存块的查找效率。</p></div><h4 id="ngx-pool-t"><a href="#ngx-pool-t" class="headerlink" title="ngx_pool_t"></a>ngx_pool_t</h4><p><code>ngx_pool_t</code> 结构体用于表示一个内存池，内存池的内部以链表形式来组织数据。如下图：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;         <span class="comment">// 小块内存池的数据头</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;       <span class="comment">// 小块内存分配的最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;   <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;     <span class="comment">// 该指针挂接一个 ngx_chain_t 结构</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;     <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;   <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *log;       <span class="comment">// 内存分配相关的日志记录</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img data-src="../../../asset/2025/04/nginx-memory-pool-2.png"></p><p>需要注意的是：</p><ul><li>内存池内部以链表形式组织起来的，完成这个工作的就是前面的 <code>ngx_pool_data_t</code> 结构体的 <code>next</code> 成员。</li><li><code>current</code> 指针，用于表示当前该内存池在使用的 <code>pool</code> 指针。除了内存池链表的头结点之外，内存池链表其他节点的该指针无效。之所以需要这个指针，就是前面提到的，在某个内存池多次失效的情况下，下一次直接跳过该内存池查找内存空间，<code>current</code> 指针保存当前在内存池链表的哪一个内存池上面查找内存空间。</li><li><code>large</code> 指针，指向 <code>ngx_pool_large_t</code> 结构体，用于管理大块内存。</li></ul><h3 id="内存池的工作原理"><a href="#内存池的工作原理" class="headerlink" title="内存池的工作原理"></a>内存池的工作原理</h3><h4 id="内存池的创建"><a href="#内存池的创建" class="headerlink" title="内存池的创建"></a>内存池的创建</h4><ul><li>经过测试，Nginx 会为每个 Http 连接（Connection）创建大小为 <code>256</code> 字节的 <code>pool</code>，为每个请求（Request）创建大小为 <code>4096</code> 的 <code>pool</code>。</li><li>当客户端使用长连接向服务器请求资源时，Nginx 处理完 Request 后会释放 Request 对应的 <code>pool</code>，但不会立即释放 Connection 对应的 <code>pool</code>，而是等连接超时后再释放。</li><li>在一次简单的会话中（比如请求首页），从连接建立到连接关闭，至少有约 30 次的内存分配（调用 <code>ngx_palloc()</code>）。</li></ul><h4 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h4><ul><li><p><strong>小块内存的分配</strong></p><ul><li>对于小块内存的分配，Nginx 会首先尝试在当前小块内存池中查找是否存在足够的空闲内存空间。</li><li>如果当前小块内存池的可用内存不足以满足需求，Nginx 会尝试遍历该小块内存池的链表（即多个小块内存池），寻找可用的内存空间。</li><li>如果仍然找不到可用的内存空间，则会创建一个新的小块内存块，并将其添加到该小块内存池链表的尾部。</li><li><strong>小块内存的分配是按顺序进行的，不会进行回收，因此分配效率很高，适合频繁分配和释放内存的场景（比如 Web 服务器处理大量短连接）。</strong></li></ul></li><li><p><strong>大块内存的分配</strong></p><ul><li>对于大块内存的分配，当分配的内存大小超过小块内存分配的阈值（一般是 <code>4095</code> 字节，根据平台决定），Nginx 会直接调用 <code>malloc()</code> 申请一块大内存，并将该大块内存封装成一个 <code>ngx_pool_large_t</code> 节点，挂载到内存池的大块内存链表的头部。</li><li>这类内存块比较大、分配成本比较高，通常用于缓存大数据或模块中临时需要的较大资源。</li><li>由于<strong>小块内存使用的是顺序分配模型，而大块内存是从系统申请分配的</strong>，因此两者的管理方式不同，但最终都会在内存池销毁时（比如处理完 HTTP 请求、HTTP 连接关闭等）统一释放，确保资源不会泄漏。</li></ul></li></ul><h4 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h4><p>Nginx 从内存池分配内存的流程如下图所示：</p><p><img data-src="../../../asset/2025/04/nginx-memory-pool-3.png"></p><h4 id="内存池的销毁"><a href="#内存池的销毁" class="headerlink" title="内存池的销毁"></a>内存池的销毁</h4><ul><li><p>一个 Web Server 通常会持续不断地接收 Connection 和 Request，因此 Nginx 将内存池划分为不同的层级，包括进程级内存池、Connection 级内存池以及 Request 级内存池。具体来说，当创建一个 Worker 进程时，系统会为该 Worker 分配一个独立的内存池；当有新的 Connection 到来时，又会在该 Worker 的内存池基础上为该 Connection 分配一个新的内存池；当该 Connection 上接收到一个新的 Request 时，再在 Connection 的内存池中为该 Request 创建一个新的内存池。</p></li><li><p>这种分层次的内存池管理方式，使得在处理完一个 Request 后，可以一次性释放该 Request 的整个内存池；当 Connection 关闭时，可以释放该 Connection 对应的内存池；而当 Worker 进程退出时，其对应的内存池也会整体释放。通过这种机制，确保了内存既有分配，也能及时回收，避免了内存泄漏的问题。</p></li><li><p>从内存的分配与释放策略可以看出，Nginx 内存池的核心作用在于将多个小块内存的分配操作集中处理，并在适当的时机统一释放，从而避免频繁的小内存申请，降低内存碎片的产生，提升了系统的内存管理效率和性能。</p></li></ul><h3 id="内存池的源码测试"><a href="#内存池的源码测试" class="headerlink" title="内存池的源码测试"></a>内存池的源码测试</h3><p>这里将介绍如何编写代码测试 Nginx 内存池的 <code>ngx_destroy_pool()</code> 接口，并编译运行自定义的测代码。</p><h4 id="编译-Nginx-源码"><a href="#编译-Nginx-源码" class="headerlink" title="编译 Nginx 源码"></a>编译 Nginx 源码</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.12.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码</span></span><br><span class="line">tar -xvf nginx-1.12.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建文件</span></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make -j4</span><br></pre></td></tr></tbody></table></figure><h4 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><p>在 Nginx 的源码目录下（比如 <code>nginx-1.12.2</code>），创建 C 源文件 <code>ngx_testpool.c</code>，其测试代码的内容如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nginx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_palloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误日志处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span> <span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc1</span> <span class="params">(<span class="keyword">char</span> *p)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"free ptr mem!\n"</span>);</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc2</span> <span class="params">(FILE *pf)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"close file!\n"</span>);</span><br><span class="line">    fclose (pf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span> *pool = ngx_create_pool (<span class="number">512</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_create_pool fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小块内存池分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = ngx_palloc (pool, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_palloc 128 bytes fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大块内存池分配内存</span></span><br><span class="line">    stData *p2 = ngx_palloc (pool, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"ngx_palloc 512 bytes fail...\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p2-&gt;ptr = <span class="built_in">malloc</span> (<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (p2-&gt;ptr, <span class="string">"hello world"</span>);</span><br><span class="line">    p2-&gt;pfile = fopen (<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *c1 = ngx_pool_cleanup_add (pool, <span class="keyword">sizeof</span> (<span class="keyword">char</span> *));</span><br><span class="line">    c1-&gt;handler = cleanFunc1;</span><br><span class="line">    c1-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *c2 = ngx_pool_cleanup_add (pool, <span class="keyword">sizeof</span> (FILE *));</span><br><span class="line">    c2-&gt;handler = cleanFunc2;</span><br><span class="line">    c2-&gt;data = p2-&gt;pfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池，步骤：(1) 调用所有的预置的清理函数 (2) 释放所有大块内存 (3) 释放小块内存池所有内存</span></span><br><span class="line">    ngx_destroy_pool (pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="运行测试代码"><a href="#运行测试代码" class="headerlink" title="运行测试代码"></a>运行测试代码</h4><ul><li>编译测试代码</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译测试代码（生成目标文件）</span></span><br><span class="line">gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接测试代码（生成可执行文件）</span></span><br><span class="line">gcc -o ngx_testpool ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行文件</span></span><br><span class="line">./ngx_testpool</span><br></pre></td></tr></tbody></table></figure><ul><li>测试代码运行的输出结果</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close file!</span><br><span class="line">free ptr mem!</span><br></pre></td></tr></tbody></table></figure><h3 id="内存池的源码移植"><a href="#内存池的源码移植" class="headerlink" title="内存池的源码移植"></a>内存池的源码移植</h3><p>这里将介绍如何基于 C++ 11 移植 Nginx 内存池的核心源码，其中移植的代码主要位于 Nginx（版本是 <code>1.12.2</code>）的 <code>ngx_palloc.h</code> 和 <code>ngx_palloc.c</code> 源文件中。</p><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><ul><li><code>ngx_mem_pool.h</code> 头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 d 调整为临近数值 a 的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align (d, a) (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 p 调整为临近数值 a 的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr (p, a) (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的内存全部初始化为 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero (buf, n) (void) memset (buf, 0, n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义</span></span><br><span class="line"><span class="keyword">using</span> u_char = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ngx_uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理函数（回调函数）的类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理操作的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> {</span></span><br><span class="line">    ngx_pool_cleanup_pt handler;     <span class="comment">// 函数指针，指向内存清理操作的回调函数</span></span><br><span class="line">    <span class="keyword">void</span> *data;                      <span class="comment">// 传递给回调函数的参数</span></span><br><span class="line">    ngx_pool_cleanup_s *next;        <span class="comment">// 下一个清理函数，最终形成单向链表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大块内存的内存池的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> {</span></span><br><span class="line">    ngx_pool_large_s *next;      <span class="comment">// 下一个大块内存，最终形成单向链表</span></span><br><span class="line">    <span class="keyword">void</span> *alloc;                 <span class="comment">// 记录分配的大块内存的起始地址</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小块内存的内存池的头部信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_data_t</span> {</span></span><br><span class="line">    u_char *last;           <span class="comment">// 可分配内存的开始位置，即当前内存分配结束位置</span></span><br><span class="line">    u_char *end;            <span class="comment">// 可分配内存的末尾位置</span></span><br><span class="line">    ngx_pool_s *next;       <span class="comment">// 链接到下一个内存池，内存池的很多块内存就是通过该指针连接成链表的</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span> failed;      <span class="comment">// 记录当前内存池分配内存失败的次数，当失败次数大于指定值时，current 指向下一内存池单元</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池的主结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> {</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span> d;              <span class="comment">// 小块内存池的头部信息</span></span><br><span class="line">    <span class="keyword">size_t</span> max;                     <span class="comment">// 小块内存分配的最大空间</span></span><br><span class="line">    ngx_pool_s *current;            <span class="comment">// 指向内存池中的可用内存块</span></span><br><span class="line">    ngx_pool_large_s *large;        <span class="comment">// 大块内存分配入口指针，大块内存分配直接采用标准系统接口 malloc()</span></span><br><span class="line">    ngx_pool_cleanup_s *cleanup;    <span class="comment">// 清理函数 handler 的入口指针，用于指定内存释放时需要清理资源的一些必要操作</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个物理页面的默认大小（4KB）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_PAGESIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// 小块内存可分配的最大空间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MAX_ALLOC_FROM_POOL = NGX_PAGESIZE - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 内存池的默认初始大小（16KB）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_DEFAULT_POOL_SIZE = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// 内存池分配时的对齐字节数（16 字节）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_POOL_ALIGNMENT = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 小块内存的最小可接受大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MIN_POOL_SIZE = <span class="built_in">ngx_align</span> ((<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s) + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_large_s)), NGX_POOL_ALIGNMENT);</span><br><span class="line"><span class="comment">// 小块内存分配时的对齐字节数，通常是 4 字节（32 位系统）或者 8 字节（64 位系统）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_ALIGNMENT = <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ngx_mem_pool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span> (<span class="keyword">int</span> size = NGX_DEFAULT_POOL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ngx_mem_pool</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span> (<span class="keyword">const</span> ngx_mem_pool &amp;pool) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止赋值</span></span><br><span class="line">    ngx_mem_pool &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ngx_mem_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 从内存池中申请指定大小的内存，并考虑内存字节对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存池中申请指定大小的内存，不考虑内存字节对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_pnalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 ngx_palloc 实现内存分配，并将内存初始化为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_pcalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_pfree</span> <span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作（回调）函数</span></span><br><span class="line">    <span class="function">ngx_pool_cleanup_s *<span class="title">ngx_pool_cleanup_add</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 创建指定大小的内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配小块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_small</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配大块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_large</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的小块内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc_block</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指向内存池的入口指针</span></span><br><span class="line">    ngx_pool_s *_pool;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ngx_mem_pool.cpp</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ngx_mem_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ngx_mem_pool::<span class="built_in">ngx_mem_pool</span> (<span class="keyword">int</span> size) {</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">ngx_create_pool</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (_pool == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span> (<span class="string">"create memory pool fail..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ngx_mem_pool::~<span class="built_in">ngx_mem_pool</span> () {</span><br><span class="line">    <span class="comment">// 销毁内存池</span></span><br><span class="line">    <span class="keyword">if</span> (_pool != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">ngx_destroy_pool</span> ();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定大小的内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_create_pool</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt; NGX_MIN_POOL_SIZE) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"create memory pool fail, pool size too small"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">    _pool = (ngx_pool_s *) <span class="built_in">malloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (_pool == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存池的头部信息</span></span><br><span class="line">    _pool-&gt;d.last = (u_char *) _pool + <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    _pool-&gt;d.end = (u_char *) _pool + size;</span><br><span class="line">    _pool-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    _pool-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存分配的最大空间</span></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    _pool-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    _pool-&gt;current = _pool;</span><br><span class="line">    _pool-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">    _pool-&gt;cleanup = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内存池中申请指定大小的内存，并考虑内存字节对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="keyword">this</span>-&gt;_pool-&gt;max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span> (size, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内存池中申请指定大小的内存，不考虑内存字节对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_pnalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="keyword">this</span>-&gt;_pool-&gt;max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span> (size, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ngx_palloc 实现内存分配，并将内存初始化为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_pcalloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">ngx_palloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (p) {</span><br><span class="line">        <span class="built_in">ngx_memzero</span> (p, size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配小块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_small</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span> </span>{</span><br><span class="line">    u_char *m;</span><br><span class="line">    ngx_pool_s *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">this</span>-&gt;_pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历小块内存池链表，查找有可用空间的小块内存</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align) {</span><br><span class="line">            m = <span class="built_in">ngx_align_ptr</span> (m, NGX_ALIGNMENT);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) {</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当找不到有可用空间的小块内存，则直接分配新的小块内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span> (size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配大块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_large</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span> n;</span><br><span class="line">    ngx_pool_large_s *large;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的大块内存</span></span><br><span class="line">    p = <span class="built_in">malloc</span> (size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历大块内存池链表，将新的大块内存添加到链表中</span></span><br><span class="line">    <span class="keyword">for</span> (large = <span class="keyword">this</span>-&gt;_pool-&gt;large; large; large = large-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">nullptr</span>) {</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    large = (ngx_pool_large_s *) <span class="built_in">ngx_palloc_small</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_large_s), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">free</span> (p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = <span class="keyword">this</span>-&gt;_pool-&gt;large;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配新的小块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_mem_pool::ngx_palloc_block</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    u_char *m;</span><br><span class="line">    <span class="keyword">size_t</span> psize;</span><br><span class="line">    ngx_pool_s *p, *_new;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的小块内存的大小</span></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (<span class="keyword">this</span>-&gt;_pool-&gt;d.end - (u_char *) <span class="keyword">this</span>-&gt;_pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的小块内存</span></span><br><span class="line">    m = (u_char *) <span class="built_in">malloc</span> (psize);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _new = (ngx_pool_s *) m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的小块内存的头部信息</span></span><br><span class="line">    _new-&gt;d.end = m + psize;</span><br><span class="line">    _new-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    _new-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="built_in">ngx_align_ptr</span> (m, NGX_ALIGNMENT);</span><br><span class="line">    _new-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="keyword">this</span>-&gt;_pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) {</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = _new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放大块内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_pfree</span> <span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_reset_pool</span> <span class="params">()</span> </span>{</span><br><span class="line">    ngx_pool_s *p;</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置小块内存池链表中的第一块内存，实现后续小块内存的复用</span></span><br><span class="line">    p = <span class="keyword">this</span>-&gt;_pool;</span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_s);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置小块内存池链表中的第二块到最后一块内存，实现后续小块内存的复用</span></span><br><span class="line">    <span class="keyword">for</span> (p = p-&gt;d.next; p; p = p-&gt;d.next) {</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;current = <span class="keyword">this</span>-&gt;_pool;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_destroy_pool</span> <span class="params">()</span> </span>{</span><br><span class="line">    ngx_pool_s *p, *n;</span><br><span class="line">    ngx_pool_large_s *l;</span><br><span class="line">    ngx_pool_cleanup_s *c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用所有清理操作（回调）函数</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="keyword">this</span>-&gt;_pool-&gt;cleanup; c; c = c-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) {</span><br><span class="line">            c-&gt;<span class="built_in">handler</span> (c-&gt;data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放大块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="keyword">this</span>-&gt;_pool-&gt;large; l; l = l-&gt;next) {</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) {</span><br><span class="line">            <span class="built_in">free</span> (l-&gt;alloc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放小块内存池链表中的所有内存</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="keyword">this</span>-&gt;_pool, n = <span class="keyword">this</span>-&gt;_pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) {</span><br><span class="line">        <span class="built_in">free</span> (p);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加资源清理操作（回调）函数</span></span><br><span class="line"><span class="function">ngx_pool_cleanup_s *<span class="title">ngx_mem_pool::ngx_pool_cleanup_add</span> <span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    ngx_pool_cleanup_s *c;</span><br><span class="line"></span><br><span class="line">    c = (ngx_pool_cleanup_s *) <span class="built_in">ngx_palloc</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (ngx_pool_cleanup_s));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) {</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span> (size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到资源清理操作链表中（头插法）</span></span><br><span class="line">    c-&gt;next = <span class="keyword">this</span>-&gt;_pool-&gt;cleanup;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_pool-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><ul><li><code>test.cpp</code> 源文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ngx_mem_pool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc1</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) arg;</span><br><span class="line">    cout &lt;&lt; <span class="string">"free ptr memory!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义资源清理操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFunc2</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    FILE *p = (FILE *) arg;</span><br><span class="line">    cout &lt;&lt; <span class="string">"close file!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fclose</span> (p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建内存池</span></span><br><span class="line">    <span class="function">unique_ptr&lt;ngx_mem_pool&gt; <span class="title">pool</span> <span class="params">(<span class="keyword">new</span> ngx_mem_pool (<span class="number">256</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小块内存池分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = pool-&gt;<span class="built_in">ngx_palloc</span> (<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"ngx_palloc 128 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大块内存池分配内存</span></span><br><span class="line">    Data *p2 = (Data *) pool-&gt;<span class="built_in">ngx_palloc</span> (<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"ngx_palloc 512 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p2-&gt;ptr = (<span class="keyword">char</span> *) <span class="built_in">malloc</span> (<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2-&gt;ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"malloc 12 bytes fail..."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span> (p2-&gt;ptr, <span class="string">"hello world"</span>);</span><br><span class="line">    p2-&gt;pfile = <span class="built_in">fopen</span> (<span class="string">"data.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    ngx_pool_cleanup_s *c1 = pool-&gt;<span class="built_in">ngx_pool_cleanup_add</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">char</span> *));</span><br><span class="line">    c1-&gt;handler = cleanFunc1;</span><br><span class="line">    c1-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源清理操作</span></span><br><span class="line">    ngx_pool_cleanup_s *c2 = pool-&gt;<span class="built_in">ngx_pool_cleanup_add</span> (<span class="built_in"><span class="keyword">sizeof</span></span> (FILE *));</span><br><span class="line">    c2-&gt;handler = cleanFunc2;</span><br><span class="line">    c2-&gt;data = p2-&gt;pfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存池由智能指针管理，程序运行结束后会自动销毁内存池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>程序运行的输出结果：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close file!</span><br><span class="line">free ptr memory!</span><br></pre></td></tr></tbody></table></figure><h4 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h4><p>Nginx 内存池移植后的完整案例代码可以从 <a target="_blank" rel="external nofollow" href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-projects/c%2B%2B-project-nginx-memory-pool">这里</a> 下载得到。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><p>Nginx 为什么要进行内存管理？</p></blockquote><ul><li><p>Nginx 作为高性能 Web 服务器，在各个环节都必须考虑如何提高性能的问题，比如使用 <code>malloc()</code> 申请内存是很耗时的，这时候就需要优化内存的分配。</p></li><li><p>在使用系统的 <code>malloc()</code> 和 <code>free()</code> 面临几个问题：Web 服务器对内存的需求有大有小，系统运行久了会产生大量的内存碎片，最终造成内存操作更加耗时直到无可用内存，导致服务器宕机。</p></li></ul><blockquote><p>Nginx 如何进行内存管理？</p></blockquote><ul><li><p>Nginx 首先将内存池进行分级管理：包括进程级、连接级和请求级三个层次；随后再根据内存使用情况的不同，将内存池细分为三类：小块内存、大块内存以及自定义资源内存。</p></li><li><p>进程级内存池在通过 <code>Fork()</code> 创建 Worker 子进程时完成初始化。由于 <code>Fork()</code> 会复制父进程的数据段和堆栈段，因此每个子进程拥有独立的内存空间。根据 Web Server 的运行特点，当客户端建立连接时，会在函数 <code>void ngx_event_accept (ngx_event_t *ev)</code> 中创建连接级的内存池；当客户端发起请求时，会在函数 <code>void ngx_http_init_connection (ngx_connection_t *c)</code> 中创建请求级的内存池。</p></li><li><p>在处理 HTTP 请求的过程中，所有与该请求相关的内存分配操作都在对应连接的内存池中完成。根据实际需要的内存大小及资源类型，Nginx 会采用不同的分配策略：对于较小的内存块，采用顺序分配以提高效率；对于较大的内存块或特殊资源，则使用独立分配方式以便于管理。</p></li><li><p>当请求处理完成后，请求级的内存池会被整体释放；当连接超时或者断开时，连接级的内存池随之释放；当进程退出时，系统会释放进程占用的全部内存池资源。通过这种分级且分类型的内存管理机制，Nginx 有效提升了内存分配效率，降低了内存碎片率，同时确保了资源的可控释放和系统的高性能运行。</p></li></ul><blockquote><p>Nginx 的内存管理解决了哪些问题？</p></blockquote><ul><li><strong>简化了内存操作</strong>：程序员不必担心何时释放内存，当连接释放时，就回收该连接对应的内存池。</li><li><strong>避免了内存碎片</strong>：从外部内存碎片来看，采用一次性申请一个内存页，避免了外部内存碎片；从内部内存碎片来看，对大小内存申请分别管理，提高了内存利用率，避免了内部内存碎片。</li><li><strong>避免了内存泄露</strong>：在同一内存池上进行内存申请和回收，当连接关闭后，不存在没有被回收的内存，即可以避免内存泄漏问题。</li><li><strong>提高了内存访问效率</strong>：充分利用程序局部性原理，结合内存对齐和内存分页机制，有效提高了 CPU 访存的 Cache 命中率。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a target="_blank" rel="external nofollow" href="https://www.kancloud.cn/digest/understandingnginx/202588">Nginx 内存池管理详解</a></li><li><a target="_blank" rel="external nofollow" href="https://www.cnblogs.com/didiaoxiong/p/nginx_memory.html">Nginx 1.4.0 内存管理详解</a></li><li><a target="_blank" rel="external nofollow" href="https://heapdump.cn/article/4444830">Nginx 内存分配与释放 — 堆 (内存池) 源码与原理</a></li></ul><div id="readmore-expansion" class="pjax"></div><link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"><script data-pjax="" src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script><script data-pjax="">var isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),allowMobile=!1;if(!isMobile||isMobile&&allowMobile)try{var plugin=new ReadmorePlugin;plugin.init({type:"hexo",id:"readmore-container",name:"全栈技术驿站",blogId:"96641-5333172926158-056",qrcode:"https://www.techgrow.cn/img/wx_mp_qr.png",keyword:"Tech",random:"1",height:"auto",expires:"365",lockToc:"yes",interval:"30",baseUrl:"",execute:"yes",tocSelector:""})}catch(e){console.warn("readmore plugin occurred error: "+e.name+" | "+e.message)}</script></div><footer class="post-footer"><div class="reward-container"><div>支持一根棒棒糖！</div> <button> 赞赏</button><div class="post-reward"><div> <img src="/img/pay_wx.png" alt="Clay 微信"> <span>微信</span></div><div> <img src="/img/pay_zfb.png" alt="Clay 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Clay</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.techgrow.cn/posts/5bc5018f.html" title="Nginx 内存池源码剖析">https://www.techgrow.cn/posts/5bc5018f.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="contactme"><div class="social-list"><div class="social-item"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">欢迎添加博主微信，请备注 "博客"，届时会邀请您加入百人微信群</span><br> <img src="/img/wx_account_qr.png"></div></div></div><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a><a href="/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> 源码剖析</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/73b8af5d.html" rel="prev" title="C++ 算法入门教程之一"><i class="fa fa-angle-left"></i> C++ 算法入门教程之一</a></div><div class="post-nav-item"> <a href="/posts/585aa296.html" rel="next" title="基于 C++ 手写线程池">基于 C++ 手写线程池<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> Copyright © 2018 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Clay</span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>站点总字数：</span> <span title="站点总字数">1.9m</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>站点阅读时长 ≈</span> <span title="站点阅读时长">28:30</span></span></div><div id="site-runtime"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span><span id="runtime"></span></div><script language="javascript">function isPC(){for(var e=navigator.userAgent,t=["Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"],n=0;n<t.length;n++)if(0<e.indexOf(t[n]))return!1;return!0}function siteTime(e,t){window.setTimeout("siteTime(openOnPC, start)",1e3);var n=36e5,o=24*n;t=new Date("2018-12-27 08:00:00");var i=new Date,r=(i.getFullYear(),i.getMonth(),i.getDate(),i.getHours(),i.getMinutes(),i.getSeconds(),i-t),a=Math.floor(r/31536e6),s=Math.floor(r/o-365*a),d=Math.floor((r-(365*a+s)*o)/n),l=Math.floor((r-(365*a+s)*o-d*n)/6e4),u=Math.floor((r-(365*a+s)*o-d*n-6e4*l)/1e3);document.getElementById("runtime").innerHTML="Powered by Hexo & Docker | "+a+" 年 "+s+" 日 "+d+" 小时 "+l+" 分钟 "+u+" 秒 "}var showOnMobile=!1,openOnPC=isPC(),start=new Date;siteTime(openOnPC,start),openOnPC||showOnMobile||(document.getElementById("site-runtime").style.display="none")</script><div class="beian"> <span><img src="/img/gonganbeian.png" alt=""></span> <span><a href="https://beian.miit.gov.cn/" rel="external nofollow" target="_blank">粤ICP备 19024664号-1</a></span> <span>|&nbsp;</span> <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302004035" rel="external nofollow" target="_blank">粤公网安备 44011302004035号</a></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div> <a href="https://github.com/rqh656418510" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="200" alpha="0.5" zindex="-1" src="/lib/ribbon.js/dist/ribbon.min.js"></script><script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script><script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://www.techgrow.cn/lib/darkmode/darkmode@1.5.7.min.js"></script><script>
var options = {
  bottom: '64px',
  right: '30px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#282828',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script><script src="https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js"></script><script>
    var qiniu_domain = "https://oss.techgrow.cn";
    var qiniu_token_url = "https://open.techgrow.cn/api/oss/qiniu/token/upload";
    var qiniu_debug = "true" === "false";

    // date format
    Date.prototype.format = function (fmt) {
      var o = {
        "M+": this.getMonth() + 1,
        "d+": this.getDate(),
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds(),
        "q+": Math.floor((this.getMonth() + 3) / 3),
        "S": this.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (var k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(
            RegExp.$1,
            (RegExp.$1.length == 1)
              ? (o[k])
              : (("00" + o[k]).substr(("" + o[k]).length))
          );
        }
      }
      return fmt;
    }

    // generate uuid
    function uuid() {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = "4";
      s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";
      var uuid = s.join("");
      return uuid;
    }

    // sync get request
    function syncGet(url) {
      var xhr = null;
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open('GET', url, false);
      xhr.send();
      return xhr;
    }

    // get upload file path
    function getUploadFilePath() {
      var now = new Date();
      var name = uuid().replace(/-/g, "");
      var nowStr = now.format("/yyyy/MM/dd/");
      return "uploads" + nowStr + name;
    }

    // get qiniu upload token
    function getUploadToken() {
      try {
        var xhr = syncGet(qiniu_token_url);
        var responseStatus = xhr.status;
        var responseJson = JSON.parse(xhr.responseText);
        if (responseStatus === 200) {
          return responseJson.data;
        } else if (responseStatus === 403) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，非法请求来源！");
        } else if (responseStatus === 429) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，上传过于频繁！");
        } else if (responseStatus === 500) {
          alert(responseJson.msg || "图片上传失败，无法获取UploadToken，系统内部出错！");
        } else {
          alert("图片上传失败，无法获取UploadToken，未知Http响应状态码！");
        }
      } catch (err) {
        if (qiniu_debug) {
          console.error(err);
        }
        alert("图片上传失败，无法获取UploadToken，未知错误！");
      }
      return null;
    }

    // qiniu upload image
    async function qiniuUploadImage(file) {
      var image_path = null;
      await uploadImage(file).then(function onFulfilled(res) {
        image_path = res;
      }).catch(function onRejected(err) {
        if (qiniu_debug) {
          console.error(err);
        }
      });
      return image_path;
    }

    // upload image
    function uploadImage(file) {
      return new Promise((resolve, reject) => {
        var config = null;
        var putExtra = null;
        var token = getUploadToken();
        var key = getUploadFilePath();
        // upload init
        var observable = qiniu.upload(file, key, token, putExtra, config);
        // upload start
        observable.subscribe({
          next(res) {
            // upload progress
          },
          error(err) {
            // upload falied
            reject("falied to upload image for qiniu: " + err.name);
          },
          complete(res) {
            // upload successed
            resolve(qiniu_domain + "/" + key);
          }
        });
      });
    }
  </script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.techgrow.cn","cssUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css","commentCount":true,"pageview":false,"copyright":false,"allowUploadImage":true,"libUrl":"https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.js","locale":{"placeholder":"支持匿名评论啦，若希望及时收到博主的反馈，建议登录评论或者在上方的邮箱输入框留下邮箱地址哦 (๑•̀ㅂ•́)و✧"},"dark":"body.darkmode--activated","emoji":["https://www.techgrow.cn/lib/@waline/emojis/1.0.1/weibo"],"meta":["nick","mail","link"],"login":"enable","pageSize":10,"qiniuDebug":false,"qiniuDomain":"https://oss.techgrow.cn","qiniuTokenUrl":"https://open.techgrow.cn/api/oss/qiniu/token/upload","qiniuLibUrl":"https://www.techgrow.cn/lib/qiniu/qiniu@3.3.1.min.js","el":"#waline","comment":true,"path":"/posts/5bc5018f.html"}</script><link rel="stylesheet" href="https://www.techgrow.cn/lib/@waline/client/client@2.5.1.min.css"><script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.waline.allowUploadImage) {
    CONFIG.waline.imageUploader = false;
  }
  else if (CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl) {
    CONFIG.waline.imageUploader = qiniuUploadImage;
  } else {
   CONFIG.waline.imageUploader = true;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><div class="comments" id="waline-comments" style="display:none"></div><script>function isMobile(){var i=navigator.userAgent.toLowerCase(),e="ipad"==i.match(/ipad/i),a="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),n="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),r="ucweb"==i.match(/ucweb/i),c="android"==i.match(/android/i),l="windows ce"==i.match(/windows ce/i),d="windows mobile"==i.match(/windows mobile/i);return!!(e||a||o||n||r||c||l||d)}var openOnMobile=isMobile(),showOnMobile=!1,aplayerEnable=!0;jQuery(document).ready(function(){aplayerEnable&&(openOnMobile&&!showOnMobile||jQuery("#aplayer").css("display","block"))}),jQuery(window).on("load",function(){aplayerEnable&&jQuery(".aplayer\\-icon.aplayer\\-icon\\-lrc").trigger("click")})</script></body></html>