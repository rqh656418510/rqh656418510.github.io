<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术博客</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2021-12-28T14:25:49.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Centos7 升级 OpenSSL</title>
    <link href="https://www.techgrow.cn/posts/4ffdb5e1.html"/>
    <id>https://www.techgrow.cn/posts/4ffdb5e1.html</id>
    <published>2021-12-28T14:25:49.000Z</published>
    <updated>2021-12-28T14:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux clay 3.10.0-1160.49.1.el7.x86_64 <span class="comment">#1 SMP Tue Nov 30 15:51:32 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></tbody></table></figure><h2 id="升级-OpenSSL"><a href="#升级-OpenSSL" class="headerlink" title="升级 OpenSSL"></a>升级 OpenSSL</h2><ul><li>查看 OpenSSL 的版本 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl version</span></span><br><span class="line">OpenSSL 1.0.2k-fips  26 Jan 2017</span><br></pre></td></tr></tbody></table></figure><ul><li>备份旧版的 OpenSSL</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mv /usr/bin/openssl /usr/bin/openssl.bak</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mv /usr/include/openssl /usr/include/openssl-bak</span></span><br></pre></td></tr></tbody></table></figure><ul><li>安装依赖 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y perl perl-devel perl-Test-Simple gcc gcc-c++ make</span></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><ul><li>编译安装</li></ul><div class="admonition warning"><p class="admonition-title">注意事项</p><ol><li>建议从 <a href="https://www.openssl.org/source/">OpenSSL 官网</a> 下载源码包，最新的稳定版本是 <code>1.1.1</code> 系列</li><li><code>./config</code> 命令必须加上 <code>shared</code> 参数，否则生成的 <code>lib</code> 目录里面只有 <code>.a</code> 静态库文件， 没有 <code>.so</code> 动态链接库文件 </li></ol></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget https://www.openssl.org/<span class="built_in">source</span>/openssl-1.1.1m.tar.gz</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar -xvf openssl-1.1.1m.tar.gz</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入解压目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> openssl-1.1.1m</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./config shared zlib --prefix=/usr/<span class="built_in">local</span>/openssl</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make -j4</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加动态链接库的路径到系统配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"/usr/local/openssl/lib"</span> &gt;&gt; /etc/ld.so.conf</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使配置生效</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ldconfig -v</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -sf /usr/<span class="built_in">local</span>/openssl/bin/openssl /usr/bin/openssl</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -sf /usr/<span class="built_in">local</span>/openssl/include/openssl /usr/include/openssl</span></span><br></pre></td></tr></tbody></table></figure><ul><li>验证是否升级成功 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl version</span></span><br><span class="line">OpenSSL 1.1.1m  14 Dec 2021</span><br></pre></td></tr></tbody></table></figure><h2 id="升级后的维护"><a href="#升级后的维护" class="headerlink" title="升级后的维护"></a>升级后的维护</h2><p>更新 OpenSSL 后，需要排查系统的第三方服务是否以静态编译方式使用了 OpenSSL；如果第三方服务是静态编译的，则需要指定新的 OpenSSL 库重新进行编译，否则会影响服务的正常运行或者容易让其受到安全攻击。</p><div class="admonition note"><p class="admonition-title">提示</p><p>一般以静态编译方式使用了 OpenSSL 的第三方服务有：OpenSSH、Nginx、Apache，尤其当 Web 服务器支持 HTTPS 协议的时候</p></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/anqixiang/article/details/103458130">Ubuntu16.04.4 升级 OpenSSL</a></li><li><a href="https://blog.csdn.net/yiyihuazi/article/details/116000480">Centos8 OpenSSL 升级版本到最新</a></li><li><a href="https://www.4spaces.org/how-to-upgrade-openssl-on-centos-7/">CentOS 如何升级 openssl 到最新版本</a></li><li><a href="http://cn.voidcc.com/question/p-ohptpunv-to.html">OpenSSL 链接未定义的引用 ’EVP_MD_CTX_new’</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Centos7 如何升级 OpenSSL，包括通过源码编译安装 OpenSSL。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Centos" scheme="https://www.techgrow.cn/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Linux 实现 Windows 的 Event 事件机制</title>
    <link href="https://www.techgrow.cn/posts/c847598e.html"/>
    <id>https://www.techgrow.cn/posts/c847598e.html</id>
    <published>2021-12-25T13:55:33.000Z</published>
    <updated>2021-12-25T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><div class="admonition note"><p class="admonition-title">前言</p><p>Linux 中没有 Windows 系统中的 <code>CreateEvent()</code>、<code>WaitEvent()</code>、<code>SetEvent()</code>、<code>ResetEvent()</code> 等函数，本文将介绍如何使用 <a href="https://github.com/neosmart/pevents">pevents</a> 替代 Linux 缺失的函数。</p></div><h2 id="pevents-介绍"><a href="#pevents-介绍" class="headerlink" title="pevents 介绍"></a>pevents 介绍</h2><span id="more"></span><h3 id="pevents-的简介"><a href="#pevents-的简介" class="headerlink" title="pevents 的简介"></a>pevents 的简介</h3><p><a href="https://github.com/neosmart/pevents">pevents</a> 是一个跨平台的轻量级 C++ 库，旨在为 POSIX 系统提供 WIN32 事件的实现。<code>pevents</code> 提供了 Windows 平台手动和自动重置事件的大部分功能，最显著的是支持同时等待多个事件（<code>WaitForMultipleObjects</code>），而且支持 Windows、FreeBSD、Linux、macOS、iOS、Android 等平台。</p><h3 id="pevents-的-API"><a href="#pevents-的-API" class="headerlink" title="pevents 的 API"></a>pevents 的 API</h3><h4 id="API-函数"><a href="#API-函数" class="headerlink" title="API 函数"></a>API 函数</h4><p><code>pevents</code> 的 API 是根据 Windows 的 <code>CreateEvent（）</code>、<code>WaitEvent（）</code> 和 <code>WaitForMultipleObjects（）</code> 函数编写的，熟悉 WIN32 事件的开发人员应该可以将代码库切换到 <code>pevents</code> API。虚假唤醒是 Linux 下系统编程的正常部分，也是来自 Windows 世界的开发人员的常见陷阱，<code>pevents</code> 可以保证不存在虚假唤醒和等待返回的数据的正确性，其提供了如下的 API：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetEvent</span><span class="params">(<span class="keyword">neosmart_event_t</span> event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ResetEvent</span><span class="params">(<span class="keyword">neosmart_event_t</span> event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PulseEvent</span><span class="params">(<span class="keyword">neosmart_event_t</span> event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestroyEvent</span><span class="params">(<span class="keyword">neosmart_event_t</span> event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">neosmart_event_t</span> <span class="title">CreateEvent</span><span class="params">(<span class="keyword">bool</span> manualReset, <span class="keyword">bool</span> initialState)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WaitForEvent</span><span class="params">(<span class="keyword">neosmart_event_t</span> event, <span class="keyword">uint64_t</span> milliseconds)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WaitForMultipleEvents</span><span class="params">(<span class="keyword">neosmart_event_t</span> *events, <span class="keyword">int</span> count, <span class="keyword">bool</span> waitAll, <span class="keyword">uint64_t</span> milliseconds)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WaitForMultipleEvents</span><span class="params">(<span class="keyword">neosmart_event_t</span> *events, <span class="keyword">int</span> count, <span class="keyword">bool</span> waitAll, <span class="keyword">uint64_t</span> milliseconds, <span class="keyword">int</span> &amp;index)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="事件状态的类型"><a href="#事件状态的类型" class="headerlink" title="事件状态的类型"></a>事件状态的类型</h4><ul><li><code>CreateEvent()</code> 函数 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">neosmart_event_t CreateEvent(</span><br><span class="line">    // true：表示手动，在 WaitEvent 后需要手动调用 ResetEvent 清除事件信号。false：表示自动，在 WaitEvent 后，系统会自动清除事件信号</span><br><span class="line">    bool manualReset, </span><br><span class="line"></span><br><span class="line">    // 初始状态，false 为无信号，true 为有信号</span><br><span class="line">    bool initialState</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><ul><li><code>WaitForEvent()</code> 函数 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int WaitForEvent(</span><br><span class="line">    // 句柄对象</span><br><span class="line">    neosmart_event_t event,</span><br><span class="line">    // 等待的时间（毫秒）</span><br><span class="line">    uint64_t milliseconds</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><ul><li>事件状态的类型<ul><li><code>WAIT_TIMEOUT</code>：等待超时</li><li><code>WAIT_OBJECT_0</code>：句柄对象处于有信号状态</li><li><code>WAIT_FAILED</code>：出现错误，可通过 <code>GetLastError()</code> 函数得到错误码</li><li><code>WAIT_ABANDONED</code>：说明句柄代表的对象是个互斥对象，并且正在被其它线程占用</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">warning</p><p>在 Linux 平台，<code>pevents</code> 的事件状态只支持使用 <code>WAIT_TIMEOUT</code>，且有信号的时候 <code>WaitEvent()</code> 函数的返回值是 <code>0</code>，而在 Windows 平台则支持上述四种事件状态</p></div><h3 id="pevents-的项目结构"><a href="#pevents-的项目结构" class="headerlink" title="pevents 的项目结构"></a>pevents 的项目结构</h3><ul><li>核心代码在 <code>src/</code> 目录</li><li>单元测试代码（通过 Meson 构建）在 <code>test/</code> 目录</li><li>在 <code>examples/</code> 目录中可以找到演示 <code>pevents</code> 用法的跨平台应用示例程序</li></ul><h3 id="pevents-的编译构建"><a href="#pevents-的编译构建" class="headerlink" title="pevents 的编译构建"></a>pevents 的编译构建</h3><p><code>pevents</code> 使用的构建工具是 Meson，目前这仅用于支持 <code>pevents</code> 核心代码及其单元测试的自动化构建 / 测试。值得一提的是，开发人员不需要担心构建工具的差异性，<code>pevents</code> 是特意基于 C/C++ 标准编写的，避免了复杂的配置或依赖于平台的构建指令的需要。</p><h3 id="pevents-的编译参数"><a href="#pevents-的编译参数" class="headerlink" title="pevents 的编译参数"></a>pevents 的编译参数</h3><p>通过编译参数 <code>-DWFMO</code> 与 <code>-DPULSE</code>，可以在编译时让 <code>pevents</code> 启用不同的功能：</p><ul><li><code>WFMO</code>：启用 WFMO 功能，如果需要使用 <code>WaitForMultipleEvents()</code> 函数，建议仅使用 WFMO 进行编译，因为它会为所有事件对象增加开销（较小）。</li><li><code>PULSE</code>：启用 PulseEvent 功能，<code>PulseEvent()</code> 在 Windows 平台从根本上被破坏了，一般不应该被使用，当你调用它时，它几乎永远不会做你认为你正在做的事情。<code>pevents</code> 包含这个函数只是为了让现有的（有缺陷的）代码从 WIN32 移植到 Unix/Linux 平台更容易，并且这个函数默认没有编译到 <code>pevents</code> 中。</li></ul><h4 id="Meson-指定编译参数"><a href="#Meson-指定编译参数" class="headerlink" title="Meson 指定编译参数"></a>Meson 指定编译参数</h4><p>在 Meson 中，可以通过 <code>meson_options.txt</code> 配置文件指定编译参数，让 <code>pevents</code> 启用不同的功能</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">option('wfmo', type: 'boolean', value: true,</span><br><span class="line">description: 'Enable WFMO events')</span><br><span class="line">option('pulse', type: 'boolean', value: false,</span><br><span class="line">description: 'Enable PulseEvent() function')</span><br></pre></td></tr></tbody></table></figure><h4 id="CMake-指定编译参数"><a href="#CMake-指定编译参数" class="headerlink" title="CMake 指定编译参数"></a>CMake 指定编译参数</h4><p>在 CMake 中，可以通过 <code>CMakeLists.txt</code> 配置文件指定编译参数，让 <code>pevents</code> 启用不同的功能</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-std=c++11 -lpthread -DWFMO")</span><br></pre></td></tr></tbody></table></figure><h2 id="pevents-运行示例代码"><a href="#pevents-运行示例代码" class="headerlink" title="pevents 运行示例代码"></a>pevents 运行示例代码</h2><div class="admonition note"><p class="admonition-title">note</p><p>值得一提的是，<code>pevents</code> 的核心 C++ 源文件是 <code>pevents.h</code>、<code>pevents.cpp</code></p></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:clay-world/pevents.git</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入源码目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> pevents</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成构建的输出目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> meson build</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入构建的输出目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ninja</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行示例程序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sample</span></span><br></pre></td></tr></tbody></table></figure><h2 id="pevents-的实战案例"><a href="#pevents-的实战案例" class="headerlink" title="pevents 的实战案例"></a>pevents 的实战案例</h2><h3 id="编译说明"><a href="#编译说明" class="headerlink" title="编译说明"></a>编译说明</h3><p>下面给出的案例使用了 <code>pthread</code>，由于 <code>pthread</code> 不是 Linux 系统默认的库，因此链接时需要使用静态库 <code>libpthread.a</code>。简而言之，在使用 <code>pthread_create()</code> 创建线程，以及调用 <code>pthread_atfork()</code> 函数建立 <code>fork</code> 处理程序时，需要通过 <code>-lpthread</code> 参数链接该库，同时还需要在 C++ 源文件里添加头文件 <code>pthread.h</code>。</p><div class="admonition note"><p class="admonition-title">提示</p><p>为了可以正常编译使用了 <code>pthread</code> 的项目代码，不同构建工具的使用说明如下：</p></div><p>若使用 G++ 编译 C++ 项目，则编译命令的示例如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> g++ main.cpp -o main -lpthread</span></span><br></pre></td></tr></tbody></table></figure><p>若使用 CMake 构建 C++ 项目，则 <code>CMakeLists.txt</code> 配置文件的示例内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-std=c++11 -lpthread -DWFMO")</span><br><span class="line"></span><br><span class="line">add_executable(main main.cpp)</span><br></pre></td></tr></tbody></table></figure><h3 id="实战案例一"><a href="#实战案例一" class="headerlink" title="实战案例一"></a>实战案例一</h3><p><code>CreateEvent(true, true)</code> - 手动清除事件信号，初始状态为有信号，<a href="/downloads/2021/12/pevents-cmake-demo-1.zip">点击下载</a> 基于 CMake 构建的完整案例代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pevents.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> neosmart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">neosmart_event_t</span> g_hEvent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIds</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s pid %u tid %u (0x%x)\n"</span>, s, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) pid, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) tid, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) tid);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procFunc1</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>{</span><br><span class="line">    <span class="built_in">printIds</span>(<span class="string">"thread-1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WaitForEvent</span>(g_hEvent, <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"thread-1 is working..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procFunc2</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>{</span><br><span class="line">    <span class="built_in">printIds</span>(<span class="string">"thread-2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WaitForEvent</span>(g_hEvent, <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"thread-2 is working..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 手动清除事件信号，初始状态为有信号</span></span><br><span class="line">    g_hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> ntid1;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ntid1, <span class="literal">NULL</span>, procFunc1, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> ntid2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ntid2, <span class="literal">NULL</span>, procFunc2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread-1 pid 62705 tid 2336241408 (0x8b403700)</span><br><span class="line">thread-1 is working...</span><br><span class="line">thread-2 pid 62705 tid 2327848704 (0x8ac02700)</span><br><span class="line">thread-2 is working...</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">note</p><p>可以看到线程 1 和线程 2 都完整执行了，这是因为创建的事件是需手动 Reset 才会变为无信号的，所以执行完线程 1 后事件仍处于有信号的状态，所以线程 2 的逻辑才会被继续执行。</p></div><h3 id="实战案例二"><a href="#实战案例二" class="headerlink" title="实战案例二"></a>实战案例二</h3><p><code>CreateEvent(false, true)</code> - 自动清除事件信号，且初始状态为有信号，<a href="/downloads/2021/12/pevents-cmake-demo-2.zip">点击下载</a> 基于 CMake 构建的完整案例代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pevents.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> neosmart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">neosmart_event_t</span> g_hEvent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIds</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s pid %u tid %u (0x%x)\n"</span>, s, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) pid, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) tid, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) tid);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procFunc1</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>{</span><br><span class="line">    <span class="built_in">printIds</span>(<span class="string">"thread-1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WaitForEvent</span>(g_hEvent, <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"thread-1 is working..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procFunc2</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>{</span><br><span class="line">    <span class="built_in">printIds</span>(<span class="string">"thread-2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WaitForEvent</span>(g_hEvent, <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"thread-2 is working..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 自动清除事件信号，初始状态为有信号</span></span><br><span class="line">    g_hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> ntid1;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ntid1, <span class="literal">NULL</span>, procFunc1, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> ntid2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ntid2, <span class="literal">NULL</span>, procFunc2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread-1 pid 59685 tid 2245932800 (0x85de3700)</span><br><span class="line">thread-1 is working...</span><br><span class="line">thread-2 pid 59685 tid 2237540096 (0x855e2700)</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">note</p><p>可以看到只有线程 1 完整执行了，这是由于事件在执行完线程 1 后被系统自动重置为无信号，所以线程 2 中的逻辑没有被执行。</p></div><h3 id="实战案例三"><a href="#实战案例三" class="headerlink" title="实战案例三"></a>实战案例三</h3><p><code>CreateEvent(true, false)</code> - 手动清除事件信号，初始状态为无信号，包括 <code>SetEvent（）</code> 与 <code>ResetEvent()</code> 的使用，<a href="/downloads/2021/12/pevents-cmake-demo-3.zip">点击下载</a> 基于 CMake 构建的完整案例代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pevents.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> neosmart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">neosmart_event_t</span> g_hEvent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIds</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s pid %u tid %u (0x%x)\n"</span>, s, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) pid, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) tid, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) tid);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procFunc1</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>{</span><br><span class="line">    <span class="built_in">printIds</span>(<span class="string">"thread-1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WaitForEvent</span>(g_hEvent, <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"thread-1 is working..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 重置事件为无信号</span></span><br><span class="line">    <span class="built_in">ResetEvent</span>(g_hEvent);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procFunc2</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>{</span><br><span class="line">    <span class="built_in">printIds</span>(<span class="string">"thread-2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WaitForEvent</span>(g_hEvent, <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"thread-2 is working..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 手动清除事件信号，初始状态为有信号</span></span><br><span class="line">    g_hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> ntid1;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ntid1, <span class="literal">NULL</span>, procFunc1, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> ntid2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ntid2, <span class="literal">NULL</span>, procFunc2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 手动清除事件信号，初始状态为无信号</span></span><br><span class="line">    g_hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置事件为有信号</span></span><br><span class="line">    <span class="built_in">SetEvent</span>(g_hEvent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> ntid1;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ntid1, <span class="literal">NULL</span>, procFunc1, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> ntid2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;ntid2, <span class="literal">NULL</span>, procFunc2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread-1 pid 70368 tid 2745513728 (0xa3a53700)</span><br><span class="line">thread-1 is working...</span><br><span class="line">thread-2 pid 70368 tid 2737121024 (0xa3252700)</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">note</p><p>可以看到只有线程 1 完整执行了，这是因为线程 1 在执行之前事件是有信号的，执行完成后事件被手动重置为无信号，所以线程 2 中的逻辑没有被执行。</p></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/sinat_31608641/article/details/105399249">C++ 的 CreateEvent ()</a></li><li><a href="https://blog.csdn.net/u011507161/article/details/42462079">WaitForSingleObject 和 WaitForMultipleObject</a></li><li><a href="https://blog.csdn.net/u011394598/article/details/82981399">事件 SetEvent、ResetEvent、WaitForSingleObject 与 CreateEvent 详解</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Linux 如何实现 Windows 的 Event 事件机制，包括 CreateEvent、WaitEvent、SetEvent、ResetEvent 等函数的使用。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 移植 Windows 的 C++ 代码</title>
    <link href="https://www.techgrow.cn/posts/15f45d12.html"/>
    <id>https://www.techgrow.cn/posts/15f45d12.html</id>
    <published>2021-12-22T14:25:49.000Z</published>
    <updated>2021-12-22T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="conio-h-头文件"><a href="#conio-h-头文件" class="headerlink" title="conio.h 头文件"></a>conio.h 头文件</h2><h3 id="移植简述"><a href="#移植简述" class="headerlink" title="移植简述"></a>移植简述</h3><p><code>conio.h</code> 不是 C 标准库中的头文件，在 ISO 和 POSIX 标准中均没有定义。<code>conio</code> 是 Console Input/Output（控制台输入输出）的简写，其中定义了通过控制台进行数据输入和数据输出的函数，主要是一些用户通过按键盘产生的对应操作，比如 <code>getch()</code> 函数等等。大部分 DOS、Windows、Phar Lap、DOSX，OS/2 等平台上的 C 编译器提供了此头文件，UNIX 和 Linux 平台的 C 编译器本身通常不包含此头文件。另外在项目开发中，平时主要是使用 <code>conio.h</code> 这个头文件中的 <code>getch()</code> 函数，即读取键盘字符但是不显示出来（without echo)，但是含有 <code>conio.h</code> 的代码在 Linux 下无法直接编译通过，因为 Linux 没有这个头文件。但 Linux 平台下完全可以使用 <a href="http://en.wikipedia.org/wiki/Ncurses">ncurses</a> 替代 <code>conio.h</code> 头文件，<code>ncurses</code> 支持的 API 可以阅读 <a href="https://tldp.org/HOWTO/NCURSES-Programming-HOWTO/scanw.html#GETCHCLASS">官方文档</a>。值得一提的是，<code>ncurses</code> 在 Linux 平台实现了 <code>getch()</code>、<code>scanw()</code>、<code>getstr()</code> 等函数。</p><span id="more"></span><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><div class="admonition note"><p class="admonition-title">提示</p><p>由于 <code>ncurses</code> 不是 Linux 系统默认的库，因此需要安装后才能使用，不同平台的安装命令如下：</p></div><ul><li>CentOS/Fedora</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install -y ncurses ncurses-devel</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Debian/Ubuntu</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get install -y libncurses5-dev libncursesw5-dev</span></span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><div class="admonition note"><p class="admonition-title">提示</p><p><code>ncurses.h</code> 与 <code>curses.h</code> 这两个头文件是等价的</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ncurses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; (<span class="string">"Hello Wolrd!"</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getch</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="编译说明"><a href="#编译说明" class="headerlink" title="编译说明"></a>编译说明</h3><p>由于 <code>ncurses</code> 不是 Linux 系统默认的库，因此编译时需要链接到该库，同时还需要在 C++ 的源文件里添加头文件 <code>ncurses.h</code>，否则编译会失败。</p><div class="admonition note"><p class="admonition-title">提示</p><p>为了可以正常编译使用了 <code>ncurses</code> 的项目代码，不同构建工具的使用说明如下：</p></div><p>若使用 G++ 编译 C++ 项目，则编译命令的示例如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> g++ main.cpp -o main -lncurses</span></span><br></pre></td></tr></tbody></table></figure><p>若使用 CMake 构建 C++ 项目，则 <code>CMakeLists.txt</code> 配置文件的示例内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-std=c++11 -lncurses")</span><br><span class="line"></span><br><span class="line">add_executable(main main.cpp)</span><br></pre></td></tr></tbody></table></figure><h2 id="itoa-函数"><a href="#itoa-函数" class="headerlink" title="itoa() 函数"></a>itoa () 函数</h2><h3 id="移植简述-1"><a href="#移植简述-1" class="headerlink" title="移植简述"></a>移植简述</h3><p>在 Window 平台里，<code>itoa()</code> 函数可以将整数转换为字符串，其函数的原型如下。Linux 平台中只有 <code>atoi()</code> 函数，并没有对应的 <code>itoa()</code> 函数，但可以使用 <code>sprintf()</code> 或者 <code>snprintf()</code> 函数替代，建议使用更安全的 <code>snprintf()</code>。</p><div class="admonition info"><p class="admonition-title">itoa () 函数</p><p>函数原型：<code>char *itoa( int value, char *string,int radix)</code></p><p>函数功能：将整数 <code>value</code> 转换成字符串存入 <code>string</code> 指向的内存空间，<code>radix</code> 为转换时所用基数 (保存到字符串中的数据的进制基数)</p><p>函数的参数：<code>value</code>：转换的数据，<code>string</code>：目标字符串的地址，<code>radix</code>：转换后的进制数，可以是 10 进制、16 进制等，范围必须在 2-36 之间</p></div><div class="admonition info"><p class="admonition-title">snprintf () 函数</p><p>头文件：<code>#include &lt;stdio.h&gt;</code></p><p>函数原型：<code>int snprintf(char *str, size_t size, const char *format, ...)</code></p><p>函数功能：将可变参数 <code>...</code> 按照 <code>format</code> 格式化成字符串，然后将其复制到 <code>str</code> 中</p><p>函数参数：<code>str</code>：目标字符串，<code>size</code>：拷贝字节数（Bytes），<code>format</code>：格式化字符串，<code>...</code> 可变参数</p></div><h3 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">snprintf</span>(str, <span class="number">4</span>, <span class="string">"%d"</span>, num);</span><br><span class="line">    cout &lt;&lt; <span class="string">"str = "</span> &lt;&lt; str &lt;&lt; <span class="string">", size = "</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = 12, size = 2</span><br></pre></td></tr></tbody></table></figure><h2 id="strcpy-s-函数"><a href="#strcpy-s-函数" class="headerlink" title="strcpy_s() 函数"></a>strcpy_s () 函数</h2><div class="admonition info"><p class="admonition-title">相关站点</p><ul><li><a href="https://github.com/rurban/safeclib/releases">Safe C Library 的下载页面</a></li><li><a href="https://rurban.github.io/safeclib/doc/safec-3.6.0/index.html">Safe C Library 的官方文档</a></li><li><a href="https://rurban.github.io/safeclib/doc/safec-3.6.0/index.html">Safe C Library 的 GitHub 项目</a></li></ul></div><h3 id="移植简述-2"><a href="#移植简述-2" class="headerlink" title="移植简述"></a>移植简述</h3><p>在 Window 平台上，<code>strcpy_s()</code> 函数存在于 <code>#include &lt;cstring&gt;</code> 头文件中。Linux 平台没有该函数，但可以使用 <a href="https://github.com/rurban/safeclib">Safe C Library</a> 替代实现。<code>Safe C Library</code> 这个库是在 <code>libc</code> 的基础之上实现了安全的 C11 Annex K 函数，这些函数是它们所缺少的，可以帮助缓解不断增加的安全攻击，特别是缓冲区溢出。</p><h3 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li>由于 <code>Safe C Library</code> 不是 Linux 系统默认的库，因此需要安装后才能使用，其安装目录如下</li><li><code>/usr/local/lib/</code>：包含静态库和动态链接库文件</li><li><code>/usr/local/include/libsafec</code>：包所有含头文件 </li></ul></div><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件（这里下载的不是源码压缩包）</span></span><br><span class="line"><span class="comment"># wget https://github.com/rurban/safeclib/releases/download/v02092020/libsafec-02092020.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line"><span class="comment"># tar -xvf libsafec-02092020.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="comment"># cd libsafec-02092020.0-g6d921f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line"><span class="comment"># ./configure</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># make -j4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="comment"># make install</span></span><br></pre></td></tr></tbody></table></figure><p>值得一提的是，<code>Safe C Library</code> 编译后会单独生成静态库文件 <code>/usr/local/lib/libsafec-3.6.0.a</code> 和动态链接库文件 <code>/usr/local/lib/libsafec-3.6.0.so.3.0.6</code>，其中的 <code>3.6.0</code> 是指版本号。</p><h3 id="案例代码-2"><a href="#案例代码-2" class="headerlink" title="案例代码"></a>案例代码</h3><div class="admonition note"><p class="admonition-title">提示</p><ul><li><code>strcpy_s()</code> 函数在 <code>Safe C Library</code> 里的 <code>safe_str_lib.h</code> 头文件中声明 </li></ul></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libsafec/safe_str_lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">strcpy_s</span>(str, <span class="number">5</span>, <span class="string">"abcd"</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="编译说明-1"><a href="#编译说明-1" class="headerlink" title="编译说明"></a>编译说明</h3><p>由于 <code>Safe C Library</code> 不是 Linux 系统默认的库，因此编译时需要链接到该库，同时还需要在 C++ 的源文件里添加头文件 <code>&lt;libsafec/safe_str_lib.h&gt;</code>，否则编译会失败。</p><div class="admonition note"><p class="admonition-title">提示</p><ol><li>为了可以正常编译使用了 <code>Safe C Library</code> 的项目代码，不同构建工具的使用说明如下所示</li><li>可以将上面构建生成的 <code>libsafec-3.6.0.a</code> 静态库文件拷贝到项目里，这样就可以方便在不同的 Linux 系统编译和运行项目，不用每次切换系统时都要重新安装 <code>Safe C Library</code></li></ol></div><p>若使用 G++ 编译 C++ 项目，则编译命令的示例如下，请自行更改库文件的版本号：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> g++ main.cpp -o main -L/usr/<span class="built_in">local</span>/lib/ -l:libsafec-3.6.0.a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"-L"</span> 参数指定了库文件的目录路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"-l:"</span> 参数指定了库文件的文件名</span></span><br></pre></td></tr></tbody></table></figure><p>若使用 CMake 构建 C++ 项目，则 <code>CMakeLists.txt</code> 配置文件的示例内容如下，请自行更改库文件的版本号：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">link_libraries(/usr/local/lib/libsafec-3.6.0.a)</span><br><span class="line"></span><br><span class="line">add_executable(windows_to_linux main.cpp)</span><br></pre></td></tr></tbody></table></figure><h2 id="函数可变参数宏"><a href="#函数可变参数宏" class="headerlink" title="函数可变参数宏"></a>函数可变参数宏</h2><h3 id="移植简述-3"><a href="#移植简述-3" class="headerlink" title="移植简述"></a>移植简述</h3><p>在 Windows 平台与 Linux 平台，函数可变参数宏定义的语法是不一样的。</p><h3 id="案例代码-3"><a href="#案例代码-3" class="headerlink" title="案例代码"></a>案例代码</h3><ul><li>Windows 平台的函数可变参数宏定义的写法如下，使用的是 <code>__VA_ARGS__</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE* logfile = <span class="built_in">fopen</span>(<span class="string">"syslog.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(format, ...) fprintf(logfile, format, __VA_ARGS__); printf(format, __VA_ARGS__); fflush(logfile);</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Linux 平台的函数可变参数宏定义写法如下，使用的是 <code>##__VA_ARGS__</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE* logfile = <span class="built_in">fopen</span>(<span class="string">"syslog.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(format, ...) fprintf(logfile, format, ##__VA_ARGS__); printf(format, ##__VA_ARGS__); fflush(logfile);</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要记录 Linux 移植 Windows 的 C++ 代码时，遇到的常见问题。</summary>
    
    
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之六</title>
    <link href="https://www.techgrow.cn/posts/62e4578b.html"/>
    <id>https://www.techgrow.cn/posts/62e4578b.html</id>
    <published>2021-12-18T13:55:34.000Z</published>
    <updated>2021-12-20T13:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="string-容器的概念"><a href="#string-容器的概念" class="headerlink" title="string 容器的概念"></a>string 容器的概念</h2><p><code>string</code> 是 STL 的字符串类型，通常用来表示字符串。而在使用 <code>string</code> 之前，字符串通常是用 <code>char*</code> 表示的。<code>string</code> 与 <code>char*</code> 都可以用来表示字符串，两者的区别如下：</p><ul><li><code>string</code> 是一个类，<code>char*</code> 是一个指向字符的指针</li><li><code>string</code> 封装了 <code>char*</code> 来管理字符串，本质是一个 <code>char*</code> 类型的容器</li><li><code>string</code> 不用考虑内存释放和越界的问题</li><li><code>string</code> 负责管理 <code>char*</code> 所分配的内存。每一次 <code>string</code> 的复制，取值都由 <code>string</code> 类负责维护，不用担心复制越界和取值越界等问题</li><li><code>string</code> 提供了一系列的字符串操作函数，例如：查找（find）、拷贝（copy）、删除（erase）、替换（replace）、插入（insert）</li></ul><span id="more"></span><h2 id="stirng-容器的-API"><a href="#stirng-容器的-API" class="headerlink" title="stirng 容器的 API"></a>stirng 容器的 API</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>默认构造函数：<code>string();</code></li><li>带参数的构造函数：<ul><li><code>string(const char *s);</code>，用字符串 s 初始化</li><li><code>string(int n, char c);</code>，用 <code>n</code> 个字符 c 初始化</li></ul></li><li>拷贝构造函数：<code>string(const string &amp;str);</code></li></ul><h3 id="string-的长度"><a href="#string-的长度" class="headerlink" title="string 的长度"></a>string 的长度</h3><ul><li><code>size_t size() const</code>，返回当前字符串的长度，这里的长度不包括字符串的结尾的 <code>\0</code> 字符</li><li><code>size_t length() const;</code>，返回当前字符串的长度，这里的长度不包括字符串的结尾的 <code>\0</code> 字符</li><li><code>bool empty() const;</code>，判断当前字符串是否为空</li></ul><p>值得一提的是，<code>sizeof()</code> 返回的是对象所占用空间的字节数，<code>strlen()</code> 返回的是字符数组中第一个 <code>\0</code> 前的字节数，<code>string</code> 的成员函数 <code>size()</code> 和 <code>length()</code> 没有任何区别。</p><h3 id="string-的赋值"><a href="#string-的赋值" class="headerlink" title="string 的赋值"></a>string 的赋值</h3><ul><li><code>string &amp;operator=(const string &amp;s);</code>，把字符串 s 赋给当前的字符串</li><li><code>string &amp;assign(const char *s);</code>，把字符串 s 赋给当前的字符串</li><li><code>string &amp;assign(const char *s, int n);</code>，把字符串 s 的前 <code>n</code> 个字符赋给当前的字符串</li><li><code>string &amp;assign(const string &amp;s);</code>，把字符串 s 赋给当前字符串</li><li><code>string &amp;assign(int n, char c);</code>，用 <code>n</code> 个字符 c 赋值给当前字符串</li><li><code>string &amp;assign(const string &amp;s, int start, int n);</code>，把字符串 s 中从 start 开始的 <code>n</code> 个字符赋值给当前字符串</li></ul><h3 id="string-的子串"><a href="#string-的子串" class="headerlink" title="string 的子串"></a>string 的子串</h3><ul><li><code>string substr(int pos=0, int n=npos) const;</code>，返回由 <code>pos</code> 位置开始的 <code>n</code> 个字符组成的子字符串</li></ul><h3 id="string-的查找"><a href="#string-的查找" class="headerlink" title="string 的查找"></a>string 的查找</h3><ul><li><code>int find(char c, int pos=0) const;</code>，从 <code>pos</code> 位置开始查找字符 c 在当前字符串第一次出现的位置</li><li><code>int find(const char *s, int pos=0) const;</code>，从 <code>pos</code> 位置开始查找字符串 s 在当前字符串第一次出现的位置</li><li><code>int find(const string &amp;s, int pos=0) const;</code>，从 <code>pos</code> 位置开始查找字符串 s 在当前字符串第一次出现的位置</li><li><code>int rfind(char c, int pos=npos) const;</code>，从 <code>pos</code> 位置开始查找字符 c 在当前字符串中最后一次出现的位置</li><li><code>int rfind(const char *s, int pos=npos) const;</code>，从 <code>pos</code> 位置开始查找字符串 s 在当前字符串中最后一次出现的位置</li><li><code>int rfind(const string &amp;s, int pos=npos) const;</code>，从 <code>pos</code> 位置开始查找字符串 s 在当前字符串中最后一次出现的位置</li></ul><p>值得一提的是，当 <code>find()</code> 与 <code>rfind()</code> 函数查找不到时，都会返回 <code>-1</code>；两者不同的是 <code>find()</code> 是正向查找，而 <code>rfind()</code> 是逆向查找，但是最终两个函数返回的位置均是字符 / 字符串出现的正向位置；若有重复字符 / 字符串时，则 <code>rfind()</code> 返回的是逆向查找到的字符 / 字符串在正向的位置（即最后一次出现的正向位置）。</p><h3 id="string-的替换"><a href="#string-的替换" class="headerlink" title="string 的替换"></a>string 的替换</h3><ul><li><code>string &amp;replace(int pos, int n, const char *s);</code>，删除从 <code>pos</code> 位置开始的 <code>n</code> 个字符，然后在 <code>pos</code> 位置插入字符串 s</li><li><code>string &amp;replace(int pos, int n, const string &amp;s);</code>，删除从 <code>pos</code> 位置开始的 <code>n</code> 个字符，然后在 <code>pos</code> 位置插入字符串 s</li><li><code>void swap(string &amp;s2);</code>，交换当前字符串与字符串 s2 的值</li></ul><h3 id="string-的比较"><a href="#string-的比较" class="headerlink" title="string 的比较"></a>string 的比较</h3><ul><li><code>int compare(const string &amp;s) const;</code>，与字符串 s 比较</li><li><code>int compare(const char *s) const;</code>，与字符串 s 比较</li></ul><p><code>compare()</code> 函数的结果在 <code>&gt;</code> 时返回 1，<code>&lt;</code> 时返回 -1，<code>=</code> 时返回 0。字符串比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的 A（65） 比小写的 a（97） 小。</p><h3 id="string-的字符存储"><a href="#string-的字符存储" class="headerlink" title="string 的字符存储"></a>string 的字符存储</h3><ul><li><code>char &amp;at(int n);</code></li><li><code>char &amp;operator[] (int n);</code></li><li><code>operator[]</code> 和 <code>at()</code> 均返回当前字符串中的第 <code>n</code> 个字符，但二者是有区别的<ul><li><code>at()</code> 在越界时会抛出异常，<code>[]</code> 在刚好越界时会返回 <code>(char)0</code>，再继续越界时，程序异常终止</li><li>如果程序希望可以通过 <code>try catch</code> 捕获异常，则建议采用 <code>at()</code></li></ul></li></ul><h3 id="string-的区间插入"><a href="#string-的区间插入" class="headerlink" title="string 的区间插入"></a>string 的区间插入</h3><ul><li><code>string &amp;insert(int pos, const char *s);</code>，在 <code>pos</code> 位置插入字符串 s，返回修改后的字符串</li><li><code>string &amp;insert(int pos, const string &amp;s);</code>，在 <code>pos</code> 位置插入字符串 s，返回修改后的字符串</li><li><code>string &amp;insert(int pos, int n, char c);</code>，在 <code>pos</code> 位置插入 <code>n</code> 个字符 c，返回修改后的字符串</li></ul><h3 id="string-的区间删除"><a href="#string-的区间删除" class="headerlink" title="string 的区间删除"></a>string 的区间删除</h3><ul><li><code>string &amp;erase(int pos=0, int n=npos);</code>，删除从 <code>pos</code> 位置开始的 <code>n</code> 个字符，返回修改后的字符串</li></ul><h3 id="string-的字符串拼接"><a href="#string-的字符串拼接" class="headerlink" title="string 的字符串拼接"></a>string 的字符串拼接</h3><ul><li><code>string &amp;operator+=(const string &amp;s);</code>，把字符串 s 连接到当前字符串的结尾</li><li><code>string &amp;operator+=(const char *s);</code>，把字符串 s 连接到当前字符串的结尾</li><li><code>string &amp;append(const char *s);  </code>，把字符串 s 连接到当前字符串的结尾</li><li><code>string &amp;append(const char *s, int n);</code>，把字符串 s 的前 <code>n</code> 个字符连接到当前字符串的结尾</li><li><code>string &amp;append(const string &amp;s); </code>，把字符串 s 连接到当前字符串的结尾</li><li><code>string &amp;append(const string &amp;s, int pos, int n);</code>，把字符串 s 中从 <code>pos</code> 位置开始的 <code>n</code> 个字符连接到当前字符串的结尾</li><li><code>string &amp;append(int n, char c); </code>，在当前字符串的结尾添加 <code>n</code> 个字符 c</li></ul><h3 id="从-string-取得-char"><a href="#从-string-取得-char" class="headerlink" title="从 string 取得 char*"></a>从 string 取得 char*</h3><ul><li><code>const char *c_str() const;</code>，返回一个以 <code>\0</code> 结尾的字符串的首地址</li></ul><p>值得一提的是，<code>char *</code> 可以隐式转换为 <code>string</code> 类型，反过来则不可以，例如右边这种写法是合法的： <code>char *p = "abc"; string str = p;</code></p><h3 id="将-string-拷贝到-char-指向的内存空间"><a href="#将-string-拷贝到-char-指向的内存空间" class="headerlink" title="将 string 拷贝到 char* 指向的内存空间"></a>将 string 拷贝到 char* 指向的内存空间</h3><ul><li><code>int copy(char *s, int n, int pos=0) const;</code></li></ul><p>将当前串中以 <code>pos</code> 位置开始的 <code>n</code> 个字符拷贝到以 <code>s</code> 为起始位置的字符数组中，返回实际拷贝的字符数量。特别注意，要保证指针 <code>s</code> 所指向的内存空间足以容纳当前的字符串，不然可能会发生越界。</p><h2 id="string-容器的使用"><a href="#string-容器的使用" class="headerlink" title="string 容器的使用"></a>string 容器的使用</h2><details><summary>★点击显示完整的示例代码★</summary><code><ul><li>string 容器的构造与赋值</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    string str1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    string str2 = str1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="function">string <span class="title">str3</span><span class="params">(<span class="string">"abced"</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">str4</span><span class="params">(<span class="number">5</span>, <span class="string">'f'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本赋值</span></span><br><span class="line">    str1 = <span class="string">"123456"</span>;</span><br><span class="line">    str2 = str3;</span><br><span class="line">    str3.<span class="built_in">assign</span>(<span class="string">"mnopq"</span>, <span class="number">3</span>);</span><br><span class="line">    str4.<span class="built_in">assign</span>(<span class="string">"45678"</span>, <span class="number">1</span>, <span class="number">3</span>);     <span class="comment">// 从0开始索引，1表示第2个字符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"str2 = "</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = 123456</span><br><span class="line">str2 = abced</span><br><span class="line">str3 = mno</span><br><span class="line">str4 = 567</span><br></pre></td></tr></tbody></table></figure><ul><li>string 容器的 API</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 存储字符</span></span><br><span class="line">    string str1 = <span class="string">"abcde"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="comment">// 第一种方式</span></span><br><span class="line">        cout &lt;&lt; str1[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="comment">// 第二种方式</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; str1.at(i) &lt;&lt; " ";</span></span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串拼接</span></span><br><span class="line">    string str2 = <span class="string">"hello "</span>;</span><br><span class="line">    string str3 = <span class="string">"world "</span>;</span><br><span class="line">    str2 += str3;</span><br><span class="line">    str3.<span class="built_in">append</span>(<span class="string">"where"</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"str2 = "</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串查找</span></span><br><span class="line">    string str4 = <span class="string">"My name is Peter"</span>;</span><br><span class="line">    <span class="keyword">int</span> index1 = str4.<span class="built_in">find</span>(<span class="string">"name"</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"index1 = "</span> &lt;&lt; index1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> index2 = str4.<span class="built_in">rfind</span>(<span class="string">"e"</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"index2 = "</span> &lt;&lt; index2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串替换</span></span><br><span class="line">    string str5 = <span class="string">"abc123"</span>;</span><br><span class="line">    str5.<span class="built_in">replace</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="string">"def"</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"str5 = "</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">    string str6 = <span class="string">"123456"</span>;</span><br><span class="line">    string str7 = <span class="string">"654321"</span>;</span><br><span class="line">    str6.<span class="built_in">swap</span>(str7);</span><br><span class="line">    cout &lt;&lt; <span class="string">"str6 = "</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串比较</span></span><br><span class="line">    string str8 = <span class="string">"ABC"</span>;</span><br><span class="line">    string str9 = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">int</span> result = str8.<span class="built_in">compare</span>(str9);    <span class="comment">// 返回值小于等于-1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取子字符串</span></span><br><span class="line">    string str10 = <span class="string">"124abc"</span>;</span><br><span class="line">    string str11 = str10.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"str11 = "</span> &lt;&lt; str11 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串的区间插入</span></span><br><span class="line">    string str12 = <span class="string">"abcdef"</span>;</span><br><span class="line">    str12.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="string">"123"</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"str12 = "</span> &lt;&lt; str12 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串的区间删除</span></span><br><span class="line">    string str13 = <span class="string">"123456"</span>;</span><br><span class="line">    str13.<span class="built_in">erase</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"str13 = "</span> &lt;&lt; str13 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符串取得 char *</span></span><br><span class="line">    string str14 = <span class="string">"hijkl"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p1 = str14.<span class="built_in">c_str</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"p1 = "</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char * 隐式类型转换为 string</span></span><br><span class="line">    <span class="keyword">char</span> *p2 = <span class="string">"abc123"</span>;</span><br><span class="line">    string str15 = p2;</span><br><span class="line">    cout &lt;&lt; <span class="string">"str15 = "</span> &lt;&lt; str15 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 string 拷贝到 char* 指向的内存空间</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">    string str16 = <span class="string">"hello jim"</span>;</span><br><span class="line">    <span class="keyword">int</span> number = str16.<span class="built_in">copy</span>(p3, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"number = "</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"p3 = "</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] p3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a b c d e </span><br><span class="line">str2 = hello world </span><br><span class="line">str3 = world where</span><br><span class="line">index1 = 3</span><br><span class="line">index2 = 14</span><br><span class="line">str5 = abcdef</span><br><span class="line">str6 = 654321</span><br><span class="line">result = -32</span><br><span class="line">str11 = 24a</span><br><span class="line">str12 = ab123cdef</span><br><span class="line">str13 = 1256</span><br><span class="line">p1 = hijkl</span><br><span class="line">str15 = abc123</span><br><span class="line">number = 3</span><br><span class="line">p3 = llo</span><br></pre></td></tr></tbody></table></figure></code></details><h2 id="map-容器的使用"><a href="#map-容器的使用" class="headerlink" title="map 容器的使用"></a>map 容器的使用</h2><details><summary>★点击显示完整的示例代码★</summary><code><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 定义Map集合变量</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种数据插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 第二种数据插入方式（推荐）</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// 第三种数据插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// 第四种数据插入方式</span></span><br><span class="line">m[<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方式遍历Map集合</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" , "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式遍历Map集合</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" , value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定的Key</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator item = m.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; item-&gt;first &lt;&lt; <span class="string">" , value = "</span> &lt;&lt; item-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方式判断Key是否存在</span></span><br><span class="line"><span class="comment">// 如果Key存在，find()函数会返回Key对应的迭代器，如果Key不存在，find()函数会返回尾后迭代器end()</span></span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">find</span>(<span class="number">100</span>) == m.<span class="built_in">end</span>()) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key "</span> &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">" not exist"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式判断Key是否存在</span></span><br><span class="line"><span class="comment">// count()函数用于统计Key值在Map中出现的次数，Map的Key是不允许重复的，因此如果Key存在会返回1，不存在会返回0</span></span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">count</span>(<span class="number">5</span>) == <span class="number">1</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key "</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">" existed"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的Key</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" , value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">key = 1 , 2</span><br><span class="line">key = 3 , 4</span><br><span class="line">key = 5 , 6</span><br><span class="line">key = 7 , 8</span><br><span class="line"></span><br><span class="line">key = 1 , value = 2</span><br><span class="line">key = 3 , value = 4</span><br><span class="line">key = 5 , value = 6</span><br><span class="line">key = 7 , value = 8</span><br><span class="line"></span><br><span class="line">key = 5 , value = 6</span><br><span class="line"></span><br><span class="line">key 100 not exist</span><br><span class="line"></span><br><span class="line">key 5 existed</span><br><span class="line"></span><br><span class="line">key = 1 , value = 2</span><br><span class="line">key = 3 , value = 4</span><br><span class="line">key = 5 , value = 6</span><br></pre></td></tr></tbody></table></figure></code></details><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1176228">C++ 中 string 成员函数 length ()、size () 与 strlen () 的区别</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括 STL 几大容器的使用等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之五</title>
    <link href="https://www.techgrow.cn/posts/64fd9f88.html"/>
    <id>https://www.techgrow.cn/posts/64fd9f88.html</id>
    <published>2021-12-16T13:55:34.000Z</published>
    <updated>2021-12-16T13:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="模板的基本概念"><a href="#模板的基本概念" class="headerlink" title="模板的基本概念"></a>模板的基本概念</h3><p>模板是实现代码重用机制的一种重要工具，其<strong>本质是类型参数化，即把类型定义为参数</strong>。C++ 提供了类模板和函数模板，详细的使用可参考教程：<a href="/posts/779107de.html">C++ 进阶基础之二</a></p><h4 id="类模板的简介"><a href="#类模板的简介" class="headerlink" title="类模板的简介"></a>类模板的简介</h4><ul><li>类模板的本质就是建立一个通用类，其成员变量的类型、成员函数的返回类型和参数类型都可以不具体指定，而用虚拟的类型来替代</li><li>当使用类模板建立对象时，编译器会根据实参的类型取代类模板中的虚拟类型，从而实现不同类的功能</li></ul><h4 id="函数模板的简介"><a href="#函数模板的简介" class="headerlink" title="函数模板的简介"></a>函数模板的简介</h4><ul><li>函数模板就是建立一个通用的函数，其函数返回类型和形参类型不具体指定，而是用虚拟的类型来替代</li><li>凡是函数体相同的函数都可以用函数模板来代替，不必定义多个函数，只需在模板中定义一次即可</li><li>在调用函数时，编译器会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能</li></ul><span id="more"></span><h3 id="STL-的基本概念"><a href="#STL-的基本概念" class="headerlink" title="STL 的基本概念"></a>STL 的基本概念</h3><h4 id="STL-的简介"><a href="#STL-的简介" class="headerlink" title="STL 的简介"></a>STL 的简介</h4><p>STL（Standard Template Library，标准模板库）是惠普实验室开发的一系列软件的统称。现然主要出现在 C++ 中，但在被引入 C++ 之前该技术就已经存在了很长的一段时间。STL 的从广义上讲分为三类：Algorithm（算法）、Container（容器）和 Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的 STL 代码都采用了类模板和函数模板的方式编写，这相比于传统的由类和函数组成的库来说提供了更好的代码重用机会。从逻辑层次来看，在 STL 中体现了泛型化程序设计的思想（Generic Programming），在这种思想里，大部分的基本算法被抽象和被泛化，独立于与之对应的数据结构，用于以相同或相近的方式处理各种不同情形。从实现层次看，整个 STL 是以一种类型参数化（Type Parameterized）的方式实现的，本质是基于模板（Template）。在 C++ 标准中，STL 被组织为下面的 13 个头文件：<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator&gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;memory&gt;</code>、<code>&lt;numeric&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;stack&gt;</code> 、<code>&lt;utility&gt;</code>。</p><h4 id="STL-的优势"><a href="#STL-的优势" class="headerlink" title="STL 的优势"></a>STL 的优势</h4><ul><li>STL 是 C++ 的一部分，因此不用额外安装什么就可以直接使用，因为它被内建在编译器之内</li><li> STL 的一个重要特点是数据结构和算法的分离，尽管这是个简单的概念，但是这种分离使 STL 变得非常通用</li><li>开发人员一般可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就可以了，这样可以把精力放在程序开发的其他方面</li><li> STL 具有高可重用性、高性能、高移植性、跨平台的优点<ul><li>高移植性：如在项目 A 上使用 STL 编写的模块，可以直接移植到项目 B 上</li><li>跨平台：如用 Windows 的 Visual Studio 编写的代码，可以在 Mac OS 的 XCode 上直接编译</li><li>高性能：如 <code>map</code> 可以高效地从十万条记录里面查找出指定的记录，因为 <code>map</code> 是采用红黑树的变体实现的（红黑树是平横二叉树的一种）</li><li>高可重用性：STL 中几乎所有的代码都采用了类模板和函数模板的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会</li></ul></li></ul><h4 id="STL-的六大组件"><a href="#STL-的六大组件" class="headerlink" title="STL 的六大组件"></a>STL 的六大组件</h4><ul><li><code>容器（Containers）</code>：各种数据结构，如 <code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code> 用来存放数据，STL 容器是一种类模板。</li><li><code>算法（Algorithms）</code>：各种常用算法如 <code>sort</code>、<code>search</code>、<code>copy</code>、<code>erase</code>，从实现的角度来看，STL 算法是一种函数模板。</li><li><code>迭代器（Iterators）</code>：扮演容器与算法之间的胶合剂，是所谓的 <code>泛型指针</code>，共有五种类型，以及其它衍生变体。从实现的角度来看，迭代器是一种将 <code>Operators*</code>、<code>Operator-&gt;</code>、<code>Operator++</code>、<code>Operator--</code> 等相关操作予以重载的类模板。所有 STL 容器都附带有自己专属的迭代器，原生指针（Native pointer）也是一种迭代器。</li><li><code>仿函数（Functors）</code>： 行为类似函数，可作为算法的某种策略（Policy），从实现的角度来看，仿函数是一种重载了 <code>Operator()</code> 的类或者类模板。一般函数指针可视为狭义的仿函数。</li><li><code>适配器（Adapters）</code>：一种用来修饰容器（Containers）或仿函数（Functors）或迭代器（Iterators）接口的东西，例如：STL 提供的 Queue 和 Stack，虽然看似容器，但只能算是一种容器适配器，因为它们的底层完全借助 Deque，所有操作都由底层的 Deque 提供。改变 Functor 接口者，称为 Function Adapter；改变 Container 接口者，称为 Container Adapter；改变 Iterator 接口者，称为 Iterator Adapter。适配器的实现技术很难一言蔽之，必须逐一分析。</li><li><code>空间配置器（Allocators）</code>：负责空间配置与管理，从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的类模板。</li></ul><h3 id="容器的基本概念"><a href="#容器的基本概念" class="headerlink" title="容器的基本概念"></a>容器的基本概念</h3><p>在实际的开发过程中，数据结构本身的重要性不会逊于操作数据结构的算法的重要性，当程序中存在着对执行效率要求很高的部分时，数据结构的选择就显得更加重要。经典的数据结构数量有限，但是常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所不同。STL 容器为此提供了这样的方便，它允许重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模板，STL 容器对最常用的数据结构提供了支持，这些模板的参数允许指定容器中元素的数据类型，可以将许多重复而乏味的工作简化。容器部分主要由头文件 <code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;stack&gt;</code>、<code>&lt;queue&gt;</code> 组成。对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结不同容器与相应头文件的对应关系。</p><table><thead><tr><th>容器</th><th>描述</th><th>实现头文件</th></tr></thead><tbody><tr><td>向量 (vector)</td><td> 连续内存的元素</td><td><code>&lt;vector&gt;</code></td></tr><tr><td>列表 (list)</td><td> 由节点组成的双向链表，每个结点包含着一个元素</td><td><code>&lt;list&gt;</code></td></tr><tr><td>双队列 (deque)</td><td> 连续内存的指向不同元素的指针所组成的数组</td><td><code>&lt;deque&gt;</code></td></tr><tr><td>集合 (set)</td><td> 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序</td><td><code>&lt;set&gt;</code></td></tr><tr><td>多重集合 (multiset)</td><td> 允许存在两个次序相等的元素的集合</td><td><code>&lt;set&gt;</code></td></tr><tr><td>栈 (stack)</td><td> 先进后出的值的排列</td><td><code>&lt;stack&gt;</code></td></tr><tr><td>队列 (queue)</td><td> 先进先出的执的排列</td><td><code>&lt;queue&gt;</code></td></tr><tr><td>优先队列 (priority_queue)</td><td> 元素的次序是由作用于所内存的值对上的某种谓词决定的一种队列</td><td><code>&lt;queue&gt;</code></td></tr><tr><td>映射 (map)</td><td> 由 {键，值} 对组成的集合，以某种作用于键对上的谓词排列</td><td><code>&lt;map&gt;</code></td></tr><tr><td>多重映射 (multimap)</td><td> 允许键对有相等的次序的映射</td><td><code>&lt;map&gt;</code></td></tr></tbody></table><h4 id="容器的简介"><a href="#容器的简介" class="headerlink" title="容器的简介"></a>容器的简介</h4><p>容器可以用来管理一组元素，如下图所示：</p><p><img data-src="../../../asset/2021/12/c-plus-plus-stl-1.png" alt="c-plus-plus-stl-1"></p><h4 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h4><ul><li><code>序列式容器（Sequence Containers）</code>：每个元素都有固定的位置，取决于插入时机和地点，与元素的值无关，如 <code>vector</code>、<code>deque</code>、<code>list</code></li><li><code>关联式容器（Associated Containers）</code>：元素位置取决于特定的排序规则，与插入的顺序无关，如 <code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code></li></ul><h3 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h3><h4 id="算法的简介"><a href="#算法的简介" class="headerlink" title="算法的简介"></a>算法的简介</h4><p>函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而 C++ 通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL 就利用了这一点提供了相当多的算法。它是在一个有效的框架中完成这些算法的 —— 可以将所有的类型划分为少数的几类，然后就可以在模板的参数中使用一种类型替换掉同一种类中的其他类型。</p><h4 id="算法的头文件"><a href="#算法的头文件" class="headerlink" title="算法的头文件"></a>算法的头文件</h4><p>STL 提供了大约 100 个实现算法的函数模板，比如算法 <code>for_each</code> 将为指定序列中的每一个元素调用指定的函数，<code>stable_sort</code> 以调用者所指定的规则对序列进行稳定性排序等等。这样一来，只要熟悉了 STL 之后，许多代码可以被大大地简化，只需要通过调用一两个算法模板，就可以完成所需要的功能。算法主要由头文件 <code>&lt;algorithm&gt;</code>、<code>&lt;numeric&gt;</code>、<code>&lt;functional&gt;</code> 组成。<code>&lt;algorithm&gt;</code> 是所有 STL 头文件中最大的一个，它是由一大堆函数模板组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历、复制、修改、移除、反转、排序、合并操作等。<code>&lt;numeric&gt;</code> 的体积很小，只包括几个在序列上面进行简单数学运算的函数模板，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code> 中则定义了一些类模板，用来声明函数对象。</p><h3 id="迭代器的基本概念"><a href="#迭代器的基本概念" class="headerlink" title="迭代器的基本概念"></a>迭代器的基本概念</h3><p>迭代器从作用上来说是最基本的部分。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在 STL 中就是用迭代器来完成的。概括来说，迭代器在 STL 中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎 STL 提供的所有算法都是通过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。迭代器主要由头文件 <code>&lt;utility&gt;</code>、<code>&lt;iterator&gt;</code>、<code>&lt;memory&gt;</code> 组成。其中 <code>&lt;utility&gt;</code> 是一个很小的头文件，它包括了贯穿使用在 STL 中的几个模板的声明，<code>&lt;iterator&gt;</code> 中提供了迭代器 使用的许多方法，而对于 <code>&lt;memory&gt;</code> 描述起来则十分的困难，它以不同寻常的方式为容器中的元素分配内存空间，同时也为某些算法在执行期间产生的临时对象提供管理机制，<code>&lt;memory&gt;</code> 中最主要的是类模板 <code>allocator</code>，它负责产生所有容器的默认空间配置器（分配器）。</p><h2 id="初识容器的使用"><a href="#初识容器的使用" class="headerlink" title="初识容器的使用"></a>初识容器的使用</h2><h3 id="指针是一种迭代器"><a href="#指针是一种迭代器" class="headerlink" title="指针是一种迭代器"></a>指针是一种迭代器</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> array[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in"><span class="keyword">sizeof</span></span>(array) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">        cout &lt;&lt; *(p++) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 </span><br></pre></td></tr></tbody></table></figure><h3 id="容器存放基础数据类型"><a href="#容器存放基础数据类型" class="headerlink" title="容器存放基础数据类型"></a>容器存放基础数据类型</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m_print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义容器</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">12</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">13</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">14</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种方式：遍历容器</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = v.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (itBegin != itEnd) {</span><br><span class="line">        cout &lt;&lt; *(itBegin++) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式：遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种方式：遍历容器</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), m_print);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11 12 13 14 15 </span><br><span class="line">11 12 13 14 15 </span><br><span class="line">11 12 13 14 15 </span><br></pre></td></tr></tbody></table></figure><h3 id="容器存放自定义数据类型"><a href="#容器存放自定义数据类型" class="headerlink" title="容器存放自定义数据类型"></a>容器存放自定义数据类型</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age, string name) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">23</span>, <span class="string">"Jim"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">26</span>, <span class="string">"Tom"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">29</span>, <span class="string">"Peter"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义容器</span></span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; it-&gt;<span class="built_in">getAge</span>() &lt;&lt; <span class="string">", name = "</span> &lt;&lt; it-&gt;<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 或者</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; "age = " &lt;&lt; (*it).getAge() &lt;&lt; ", name = " &lt;&lt; (*it).getName() &lt;&lt; endl;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = 23, name = Jim</span><br><span class="line">age = 26, name = Tom</span><br><span class="line">age = 29, name = Peter</span><br></pre></td></tr></tbody></table></figure><h3 id="容器存放自定义数据类型的指针"><a href="#容器存放自定义数据类型的指针" class="headerlink" title="容器存放自定义数据类型的指针"></a>容器存放自定义数据类型的指针</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age, string name) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义容器</span></span><br><span class="line">    vector&lt;Person *&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Person</span>(<span class="number">23</span>, <span class="string">"Jim"</span>));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Person</span>(<span class="number">26</span>, <span class="string">"Tom"</span>));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Person</span>(<span class="number">29</span>, <span class="string">"Peter"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;Person *&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; (*it)-&gt;<span class="built_in">getAge</span>() &lt;&lt; <span class="string">", name = "</span> &lt;&lt; (*it)-&gt;<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 或者</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; "age = " &lt;&lt; (**it).getAge() &lt;&lt; ", name = " &lt;&lt; (**it).getName() &lt;&lt; endl;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = 23, name = Jim</span><br><span class="line">age = 26, name = Tom</span><br><span class="line">age = 29, name = Peter</span><br></pre></td></tr></tbody></table></figure><h3 id="容器之间的嵌套使用"><a href="#容器之间的嵌套使用" class="headerlink" title="容器之间的嵌套使用"></a>容器之间的嵌套使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义容器</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">6</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i + <span class="number">11</span>);</span><br><span class="line">    }</span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator it1 = v.<span class="built_in">begin</span>(); it1 != v.<span class="built_in">end</span>(); it1++) {</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it2 = (*it1).<span class="built_in">begin</span>(); it2 != (*it1).<span class="built_in">end</span>(); it2++) {</span><br><span class="line">            cout &lt;&lt; *it2 &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line">6 7 8 9 10 </span><br><span class="line">11 12 13 14 15 </span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括 STL 的简介、六大组件、容器的基础使用等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 屏幕截图和剪贴板命令行工具</title>
    <link href="https://www.techgrow.cn/posts/9eb6789a.html"/>
    <id>https://www.techgrow.cn/posts/9eb6789a.html</id>
    <published>2021-12-15T13:13:21.000Z</published>
    <updated>2021-12-15T13:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><ul><li><code>xclip</code>：0.13</li><li><code>gnome-screenshot</code>：3.26.0</li></ul><span id="more"></span><h2 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h2><p><code>gnome-screenshot</code> 是一款 GNOME 命令行工具，它是一款用来对整个屏幕、一个特定的窗口或者用户所定义一些其他区域进行捕获的工具。该工具提供了几个其他的功能，包括对所捕获的截图的边界进行美化的功能。值得一提的是，<code>gnome-screenshot</code> 不适用于 <code>KDE</code>、<code>Xfce</code> 等 Linux 桌面环境。</p><h3 id="截图工具的使用"><a href="#截图工具的使用" class="headerlink" title="截图工具的使用"></a>截图工具的使用</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 捕捉整个屏幕</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕捉当前Shell窗口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -w</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕捉指定区域</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 延迟捕捉屏幕</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -d 5</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕捉当前Shell窗口，并去除窗口的边框</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -w -b</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 区域截图，并将截图复制到剪贴板</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -acbp</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 区域截图，并将截图输出到指定的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -abpf screenshot.png</span></span><br></pre></td></tr></tbody></table></figure><h3 id="截图工具的参数说明"><a href="#截图工具的参数说明" class="headerlink" title="截图工具的参数说明"></a>截图工具的参数说明</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-c, --clipboard              将截图直接发送到剪贴板</span><br><span class="line">-w, --window                 截取窗口，而不是整个屏幕</span><br><span class="line">-a, --area                   截取屏幕的一个区域，而不是整个屏幕</span><br><span class="line">-b, --include-border         在截图中包含窗口边框</span><br><span class="line">-B, --remove-border          去除屏幕截图的窗口边框</span><br><span class="line">-p, --include-pointer        在截图中包含鼠标指针</span><br><span class="line">-d, --delay=秒               在指定延迟后截图[以秒计]</span><br><span class="line">-e, --border-effect=特效     添加到边框的特效（阴影、边框、老照片或无特效）</span><br><span class="line">-i, --interactive            交互设置选项</span><br><span class="line">-f, --file=文件名            将截图直接保存为该文件</span><br><span class="line">--version                    打印版本信息并退出</span><br><span class="line">--display=显示               要使用的 X 显示</span><br></pre></td></tr></tbody></table></figure><h2 id="xclip-的安装"><a href="#xclip-的安装" class="headerlink" title="xclip 的安装"></a>xclip 的安装</h2><h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><p><a href="https://github.com/astrand/xclip">xclip</a> 是一个剪贴板的命令行实用工具，它可以从标准文件或文件中读取数据（文本、图片）并将其放置在剪贴板里，也可以将剪贴板里的数据（文本、图片）输出到标准文件或文件中。xclip 详细的功能说明如下，适用于 Debian/Ubuntu/CentOS/Arch 等主流的 Linux 发行版。</p><ul><li>Accesses the <code>cut-buffers</code></li><li>Prints contents of selection to standard out</li><li>Waits for selection requests in the background</li><li>Supports the INCR mechanism for large transfers</li><li>Reads data piped to standard in or files given as arguments</li><li>Accesses the <code>XA_PRIMARY</code>, <code>XA_SECONDARY</code> or <code>XA_CLIPBOARD</code> selection</li><li>Connects to the X display in <code>$DISPLAY</code>, or specified with <code>-display host:0</code></li></ul><h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><p><strong>CentOS</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y libXmu libXmu-devel</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Debian/Ubuntu</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> apt-get install -y libx11-dev libxmu-headers libxt-dev libxmu-dev</span></span><br></pre></td></tr></tbody></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/astrand/xclip.git</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入源码目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> xclip</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 预配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> autoreconf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install.man</span></span><br></pre></td></tr></tbody></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -version</span></span><br><span class="line">xclip version 0.13</span><br><span class="line">Copyright (C) 2001-2008 Kim Saunders et al.</span><br><span class="line">Distributed under the terms of the GNU GPL</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看命令手册</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man xclip</span></span><br></pre></td></tr></tbody></table></figure><h2 id="xclip-的使用示例"><a href="#xclip-的使用示例" class="headerlink" title="xclip 的使用示例"></a>xclip 的使用示例</h2><h3 id="图片的使用示例"><a href="#图片的使用示例" class="headerlink" title="图片的使用示例"></a>图片的使用示例</h3><ul><li>将图片复制到剪贴板 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一步：区域截图，将截图输出到指定的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -abpf screenshot.png</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步：将指定的图片复制到剪贴板</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection clipboard -t image/png -i screenshot.png</span></span><br></pre></td></tr></tbody></table></figure><ul><li>将剪贴板的图片输出到指定的文件 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一步：区域截图，并将截图复制到剪贴板</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -acbp</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步：将剪贴板的图片输出到指定的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection clipboard -t image/png -o &gt; clipboard.png</span></span><br></pre></td></tr></tbody></table></figure><h3 id="完整的使用示例"><a href="#完整的使用示例" class="headerlink" title="完整的使用示例"></a>完整的使用示例</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Copy your uptime into the selection for pasting:</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> uptime | xclip</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Copy your password file for pasting:</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip /etc/passwd</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Save some text you have Edit | Copied in a web browser:</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -o -sel clip &gt; webpage.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Open a URL selected in an email client</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mozilla `xclip -o`</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Copy XA_PRIMARY to XA_CLIPBOARD</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -o | xclip -sel clip</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># In command mode in vim, select some lines of text, then press shift-:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># for an ex prompt, and use this command to copy the selected lines of</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># text to the primary X selection:</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> !xclip -f</span></span><br></pre></td></tr></tbody></table></figure><p>值得一提的是，<code>xclip</code> 自身还提供了 <code>xclip-copyfile</code>、<code>xclip-pastefile</code>、<code>xclip-cutfile</code> 命令行工具，支持在不同的目录和机器之间拷贝和移动文件，详见：<a href="https://github.com/astrand/xclip/blob/master/README">官方文档</a></p><h2 id="VS-Code-使用说明"><a href="#VS-Code-使用说明" class="headerlink" title="VS Code 使用说明"></a>VS Code 使用说明</h2><p>在 Linux 系统下，VS Code 的 MarkDown 粘贴插件，例如 <a href="https://github.com/telesoho/vscode-markdown-paste-image">Markdown Paste</a> 底层使用了 <code>xclip</code>，且版本必须大于等于 <code>0.13.0</code>，否则这类插件无法正常将剪贴板里的图片粘贴到 MarkDown 文件里。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://unix.stackexchange.com/questions/145131/copy-image-from-clipboard-to-file">Copy image from clipboard to file</a></li><li><a href="https://askubuntu.com/questions/1196914/gnome-screenshot-cant-copy-to-clipboard-in-ubuntu-18-04">GNOME Screenshot can’t copy to clipboard in Ubuntu 18.04</a></li><li><a href="https://superuser.com/questions/199285/how-to-copy-image-to-clipboard-to-paste-to-another-application/1098582#1098582">How to copy image to clipboard, to paste to another application</a></li><li><a href="https://askubuntu.com/questions/759651/how-to-copy-an-image-to-the-clipboard-from-a-file-using-command-line">How to copy an image to the clipboard from a file using command line</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Linux 如何安装 xclip, 并结合 gnome-screenshot 实现屏幕截图、剪贴板操作、图片粘贴等功能。</summary>
    
    
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++ 设计模式初探</title>
    <link href="https://www.techgrow.cn/posts/790d6d80.html"/>
    <id>https://www.techgrow.cn/posts/790d6d80.html</id>
    <published>2021-12-13T13:55:33.000Z</published>
    <updated>2021-12-13T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 常用的设计模式，包括单例模式等。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 开发常用代码块之一</title>
    <link href="https://www.techgrow.cn/posts/b84a96ac.html"/>
    <id>https://www.techgrow.cn/posts/b84a96ac.html</id>
    <published>2021-12-12T13:43:49.000Z</published>
    <updated>2021-12-12T13:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h2><h3 id="格式化当前时间"><a href="#格式化当前时间" class="headerlink" title="格式化当前时间"></a>格式化当前时间</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化当前时间</span></span><br><span class="line"><span class="comment">// 默认格式是: 2020-06-07 23:46:53</span></span><br><span class="line"><span class="function">string <span class="title">formatCurrentTime</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">time_t</span> rawtime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">time</span>(&amp;rawtime);</span><br><span class="line">info = <span class="built_in">localtime</span>(&amp;rawtime);</span><br><span class="line"><span class="built_in">strftime</span>(buffer, <span class="number">80</span>, <span class="string">"%Y-%m-%d %H:%M:%S"</span>, info);</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化当前时间</span></span><br><span class="line"><span class="comment">// format: 格式字符串，例如 %Y-%m-%d %H:%M:%S</span></span><br><span class="line"><span class="function">string <span class="title">formatCurrentTime</span><span class="params">(string format)</span> </span>{</span><br><span class="line"><span class="keyword">time_t</span> rawtime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">time</span>(&amp;rawtime);</span><br><span class="line">info = <span class="built_in">localtime</span>(&amp;rawtime);</span><br><span class="line"><span class="built_in">strftime</span>(buffer, <span class="number">80</span>, format.<span class="built_in">c_str</span>(), info);</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; formatCurrentTime() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; formatCurrentTime(<span class="string">"%Y-%m-%d"</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-11-22 22:52:43</span><br><span class="line">2021-11-22</span><br></pre></td></tr></tbody></table></figure><h3 id="计算两个日期之间的天数"><a href="#计算两个日期之间的天数" class="headerlink" title="计算两个日期之间的天数"></a>计算两个日期之间的天数</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个年份是否为闰年</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算特定年份的天数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysOfYear</span><span class="params">(<span class="keyword">int</span> year)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">isLeap</span>(year) ? <span class="number">366</span> : <span class="number">365</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定的日期，计算它在该年的第几天</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dayInYear</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> DAY[<span class="number">12</span>] = { <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> };</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLeap</span>(year)) {</span><br><span class="line">DAY[<span class="number">1</span>] = <span class="number">29</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; month - <span class="number">1</span>; ++i) {</span><br><span class="line">day += DAY[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> day;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断日期字符串是否合法，并分别取出日期中的年月日</span></span><br><span class="line"><span class="comment">// date: 日期字符串，格式是: 20211201</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stringToDate</span><span class="params">(string date, <span class="keyword">int</span>&amp; year, <span class="keyword">int</span>&amp; month, <span class="keyword">int</span>&amp; day)</span> </span>{</span><br><span class="line">year = <span class="built_in">atoi</span>(date.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">4</span>).<span class="built_in">c_str</span>());</span><br><span class="line">month = <span class="built_in">atoi</span>(date.<span class="built_in">substr</span>(<span class="number">4</span>, <span class="number">2</span>).<span class="built_in">c_str</span>());</span><br><span class="line">day = <span class="built_in">atoi</span>(date.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">2</span>).<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">int</span> DAY[<span class="number">12</span>] = { <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> };</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLeap</span>(year)) {</span><br><span class="line">DAY[<span class="number">1</span>] = <span class="number">29</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> year &gt;= <span class="number">0</span> &amp;&amp; month &lt;= <span class="number">12</span> &amp;&amp; month &gt; <span class="number">0</span> &amp;&amp; day &lt;= DAY[month - <span class="number">1</span>] &amp;&amp; day &gt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个日期之间的天数</span></span><br><span class="line"><span class="comment">// date1: 日期字符串，格式是: 20211201</span></span><br><span class="line"><span class="comment">// date2: 日期字符串，格式是: 20211201</span></span><br><span class="line"><span class="comment">// 当返回值为 -1 时，说明日期的格式不正确</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysBetween2Date</span><span class="params">(string date1, string date2)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> year1, month1, day1;</span><br><span class="line"><span class="keyword">int</span> year2, month2, day2;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">stringToDate</span>(date1, year1, month1, day1) || !<span class="built_in">stringToDate</span>(date2, year2, month2, day2)) {</span><br><span class="line">cout &lt;&lt; <span class="string">"输入的日期格式不正确"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (year1 == year2 &amp;&amp; month1 == month2) {</span><br><span class="line"><span class="keyword">return</span> day1 &gt; day2 ? day1 - day2 : day2 - day1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (year1 == year2) {</span><br><span class="line"><span class="keyword">int</span> d1, d2;</span><br><span class="line">d1 = <span class="built_in">dayInYear</span>(year1, month1, day1);</span><br><span class="line">d2 = <span class="built_in">dayInYear</span>(year2, month2, day2);</span><br><span class="line"><span class="keyword">return</span> d1 &gt; d2 ? d1 - d2 : d2 - d1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="comment">// 确保year1年份比year2早</span></span><br><span class="line"><span class="keyword">if</span> (year1 &gt; year2) {</span><br><span class="line"><span class="built_in">swap</span>(year1, year2);</span><br><span class="line"><span class="built_in">swap</span>(month1, month2);</span><br><span class="line"><span class="built_in">swap</span>(day1, day2);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 计算第一个日期在该年还剩多少天</span></span><br><span class="line"><span class="keyword">int</span> d1, d2, d3;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLeap</span>(year1)) {</span><br><span class="line">d1 = <span class="number">366</span> - <span class="built_in">dayInYear</span>(year1, month1, day1);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">d1 = <span class="number">365</span> - <span class="built_in">dayInYear</span>(year1, month1, day1);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 计算第二日期在当年中的第几天</span></span><br><span class="line">d2 = <span class="built_in">dayInYear</span>(year2, month2, day2);</span><br><span class="line"><span class="comment">// 计算两个年份相隔的天数</span></span><br><span class="line">d3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> year = year1 + <span class="number">1</span>; year &lt; year2; year++) {</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLeap</span>(year))</span><br><span class="line">d3 += <span class="number">366</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">d3 += <span class="number">365</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> d1 + d2 + d3;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days = <span class="built_in">daysBetween2Date</span>(<span class="string">"20101111"</span>, <span class="string">"20111111"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"相差 "</span> &lt;&lt; days &lt;&lt; <span class="string">" 天"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days2 = <span class="built_in">daysBetween2Date</span>(<span class="string">"20200202"</span>, <span class="string">"20200131"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"相差 "</span> &lt;&lt; days2 &lt;&lt; <span class="string">" 天"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days3 = <span class="built_in">daysBetween2Date</span>(<span class="string">"20230712"</span>, <span class="string">"20050619"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"相差 "</span> &lt;&lt; days3 &lt;&lt; <span class="string">" 天"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相差 365 天</span><br><span class="line">相差 2 天</span><br><span class="line">相差 6597 天</span><br></pre></td></tr></tbody></table></figure><h2 id="加载动态库"><a href="#加载动态库" class="headerlink" title="加载动态库"></a>加载动态库</h2><h3 id="加载动态库（-so）"><a href="#加载动态库（-so）" class="headerlink" title="加载动态库（.so）"></a>加载动态库（.so）</h3><p>下述示例代码，适用于 Linux 系统的 C++ 开发。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载动态库</span></span><br><span class="line">    <span class="keyword">void</span> *handle = <span class="built_in">dlopen</span>(<span class="string">"./libadd_c.so"</span>, RTLD_LAZY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!handle)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open lib error\n"</span>);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">dlerror</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">add_t</span>)</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用动态库</span></span><br><span class="line">    <span class="keyword">add_t</span> add = (<span class="keyword">add_t</span>) <span class="built_in">dlsym</span>(handle, <span class="string">"add"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!add)</span><br><span class="line">    {</span><br><span class="line">        cout&lt;&lt;<span class="built_in">dlerror</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">dlclose</span>(handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    a = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态库</span></span><br><span class="line">    <span class="built_in">dlclose</span>(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="加载动态链接库（-dll）"><a href="#加载动态链接库（-dll）" class="headerlink" title="加载动态链接库（.dll）"></a>加载动态链接库（.dll）</h3><p>下述示例代码，适用于 Windows 系统的 C++ 开发。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">HINSTANCE hInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载动态链接库</span></span><br><span class="line">hInstance = <span class="built_in">LoadLibrary</span>(<span class="string">"./socketclient.dll"</span>);</span><br><span class="line"><span class="keyword">if</span> (hInstance == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"LoadLibrary() 调用失败, ErrorCode: %d"</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数类型指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*CltSocketInit)</span><span class="params">(<span class="keyword">void</span>** handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用动态链接库</span></span><br><span class="line">CltSocketInit cltSocketInit = (CltSocketInit)<span class="built_in">GetProcAddress</span>(hInstance, <span class="string">"cltSocketInit"</span>);</span><br><span class="line"><span class="keyword">if</span> (cltSocketInit != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">void</span>* handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in">cltSocketInit</span>(&amp;handle);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"result = %d"</span>, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放动态链接库</span></span><br><span class="line"><span class="keyword">if</span> (hInstance != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hInstance);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>基于 C++ 11 实现等价于 Javascript 的 <code>setTimeout()</code> 和 <code>setInterval()</code> 函数。</p><ul><li>timer.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(TimerFunction)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(TimerFunction, <span class="keyword">long</span> delay)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInterval</span><span class="params">(TimerFunction, <span class="keyword">long</span> interval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">atomic&lt;<span class="keyword">bool</span>&gt; active{ <span class="literal">true</span> };</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer::setTimeout</span><span class="params">(TimerFunction function, <span class="keyword">long</span> delay)</span> </span>{</span><br><span class="line">active = <span class="literal">true</span>;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([=]() {</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (!active.load()) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">this_thread::sleep_for(chrono::milliseconds(delay));</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (!active.load()) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">function();</span></span></span><br><span class="line"><span class="params"><span class="function">})</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer::setInterval</span><span class="params">(TimerFunction function, <span class="keyword">long</span> interval)</span> </span>{</span><br><span class="line">active = <span class="literal">true</span>;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([=]() {</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (active.load()) {</span></span></span><br><span class="line"><span class="params"><span class="function">this_thread::sleep_for(chrono::milliseconds(interval));</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (!active.load()) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">function();</span></span></span><br><span class="line"><span class="params"><span class="function">}</span></span></span><br><span class="line"><span class="params"><span class="function">})</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer::stop</span><span class="params">()</span> </span>{</span><br><span class="line">active = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"timer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refreshConfig</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"execute refresh config ..."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 使用智能指针</span></span><br><span class="line"><span class="function">unique_ptr&lt;Timer&gt; <span class="title">timer</span><span class="params">(<span class="keyword">new</span> Timer())</span></span>;</span><br><span class="line">Timer::TimerFunction* refreshFunc = refreshConfig;</span><br><span class="line">timer-&gt;<span class="built_in">setInterval</span>(refreshConfig, <span class="number">3000</span>);</span><br><span class="line">timer-&gt;<span class="built_in">setTimeout</span>(refreshConfig, <span class="number">5000</span>);</span><br><span class="line">_getch();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execute refresh config ...</span><br><span class="line">execute refresh config ...</span><br><span class="line">execute refresh config ...</span><br><span class="line">execute refresh config ...</span><br><span class="line">execute refresh config ...</span><br></pre></td></tr></tbody></table></figure><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p><code>sleep()</code> 函数的功能是让程序的执行挂起一段时间，也就是等待一段时间再继续往下执行。</p><div class="admonition warning"><p class="admonition-title">不同平台和不同编译器的区别</p><ul><li><code>sleep()</code> 函数在 Linux 平台的头文件是 <code>unistd.h</code></li><li><code>sleep()</code> 函数在 Windows 平台的头文件是 <code>windows.h</code></li><li><code>sleep()</code> 函数的名称是区分大小写的，有的编译器是大写，有的是小写</li><li><code>sleep()</code> 函数休眠的时间，在 Windows 平台下是以 <code>毫秒</code> 为单位，而在 Linux 平台是以 <code>秒</code> 为单位 </li></ul></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Windows平台的写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (a)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to songjiahao's blog\n"</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要记录 C++ 开发常用的代码块。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="代码块" scheme="https://www.techgrow.cn/tags/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之四</title>
    <link href="https://www.techgrow.cn/posts/791ffdcd.html"/>
    <id>https://www.techgrow.cn/posts/791ffdcd.html</id>
    <published>2021-12-08T13:55:33.000Z</published>
    <updated>2021-12-08T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="标准-I-O-流的介绍"><a href="#标准-I-O-流的介绍" class="headerlink" title="标准 I/O 流的介绍"></a>标准 I/O 流的介绍</h2><h3 id="I-O-流的概念"><a href="#I-O-流的概念" class="headerlink" title="I/O 流的概念"></a>I/O 流的概念</h3><p>程序的输入指的是从输入文件将数据传送给程序，程序的输出指的是从程序将数据传送给输出文件。C++ 的输入输出包含以下三个方面的内容：</p><ul><li><code>对系统指定的标准设备的输入和输出</code>：即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称 <code>标准 I/O</code>。</li><li><code>以外存磁盘文件为对象进行输入和输出</code>：即从磁盘文件输入数据，数据输出到磁盘文件。以外存文件为对象的输入输出称为文件的输入输出，简称 <code>文件 I/O</code>。</li><li><code>对内存中指定的空间进行输入和输出</code>：通常指定一个字符数组作为存储空间（实际上可以利用该内存空间存储任何信息）。这种输入和输出称为字符串输入输出，简称 <code>串 I/O</code>。</li></ul><h3 id="I-O-流类库的结构"><a href="#I-O-流类库的结构" class="headerlink" title="I/O 流类库的结构"></a>I/O 流类库的结构</h3><p>在 C 语言中，用 <code>printf</code> 和 <code>scanf</code> 进行输入输出，往往不能保证所输入输出的数据是可靠的安全的。在 C++ 的输入输出中，编译系统对数据类型进行严格的检查，凡是类型不正确的数据都不可能通过编译。因此 C++ 的 I/O 操作是类型安全（Type Safe）的。C++ 的 I/O 操作是可扩展的，不仅可以用来输入输出标准类型的数据，也可以用于用户自定义类型的数据。C++ 通过 I/O 类库来实现丰富的 I/O 功能。这样使 C++ 的输人输出明显地优于 C 语言中的 <code>printf</code> 和 <code>scanf</code>，但是也为之付出了代价，C++ 的 I/O 系统因此变得比较复杂，要掌握许多使用细节。C++ 编译系统提供了用于输入输出的 <code>iostream</code> 类库。<code>iostream</code> 这个单词是由 3 个部分组成的，即 <code>i-o-stream</code>，意为输入输出流。在 <code>iostream</code> 类库中包含许多用于输入输出的类，如下图所示：</p><span id="more"></span><p><img data-src="../../../asset/2021/12/cplus-plus-io-1.png" alt="cplus-plus-io-1"></p><p><code>ios</code> 是抽象基类，由它派生出 <code>istream</code> 类和 <code>ostream</code> 类，两个类名中第 1 个字母 i 和 o 分别代表输入（input）和输出（output）。<code>istream</code> 类支持输入操作，<code>ostream</code> 类支持输出操作，<code>iostream</code> 类支持输入输出操作。<code>iostream</code> 类是从 <code>istream</code> 类和 <code>ostream</code> 类通过多重继承而派生的类，其继承层次如下图所示：</p><p><img data-src="../../../asset/2021/12/cplus-plus-io-2.png" alt="cplus-plus-io-2"></p><p><code>iostream</code> 类库中不同的类的声明被放在不同的头文件中，用户在自己的程序中用 <code>#include</code> 命令包含了有关的头文件，这就相当于在本程序中声明了所需要用到的类。可以换 — 种说法：头文件是程序与类库的接口。<code>iostream</code> 类库的接口分别由不同的头文件来实现，常用的头文件如下：</p><ul><li><code>strstream</code>：用于字符串流 I/O</li><li><code>fstream</code>：用于实现文件的 I/O 操作</li><li><code>iomanip</code>：在使用格式化 I/O 时，应包含此头文件</li><li><code>iostream</code>：包含了对输入输出流进行操作所需的基本信息</li><li><code>stdiostream</code>：用于混合使用 C 语言和 C++ 的 I/O 机制，例如希望将 C 语言程序转变为 C++ 程序</li></ul><p>在 <code>iostream</code> 头文件中定义的类有 <code>ios，istream，ostream，iostream，istream_withassign，ostream_withassign，iostream_withassign</code> 等。在 <code>iostream</code> 头文件中不仅定义了相关的类，还定义了 4 种标准 I/O 对象，如下所示：</p><p><img data-src="../../../asset/2021/12/cplus-plus-io-3.png" alt="cplus-plus-io-3"></p><p><code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 本来在 C++ 中是被定义为左位移运算符和右位移运算符的，由于在 <code>iostream</code> 头文件中对它们进行了重载，使它们能用作标准类型数据的输入和输出运算符。所以，在使用到它们的程序中必须用 <code>#include &lt;iostream&gt;</code> 命令将其包含到程序中。在 <code>iostream</code> 中只对 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出进行重载。如果用户声明了新的类型，并希望用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符对其进行输入输出，则需要按照 C++ 的运算符重载规则来做。</p><h2 id="标准-I-O-流的使用"><a href="#标准-I-O-流的使用" class="headerlink" title="标准 I/O 流的使用"></a>标准 I/O 流的使用</h2><h3 id="标准输入流的简单使用"><a href="#标准输入流的简单使用" class="headerlink" title="标准输入流的简单使用"></a>标准输入流的简单使用</h3><p>标准输入流对象 <code>cin</code> 的常用函数如下：</p><ul><li><code>cin.get()</code>，一次只能读取一个字符</li><li><code>cin.get(一个参数)</code>，读一个字符</li><li><code>cin.get(多个参数)</code>，可以读字符串</li><li><code>cin.getline()</code>，读取整行字符串，包括读取空格字符</li><li><code>cin.ignore()</code>，用于忽略或清除输入缓冲区中的一个或多个字符</li><li><code>cin.putback()</code>，将数据放回缓冲区</li><li><code>cin.peek()</code>，返回值是一个 <code>char</code> 型的字符，即指针指向的当前字符，但它只是观测指针停留在当前的位置并不后移；如果要访问的字符是文件结束符，则函数的返回值是 <code>EOF</code> 或者 <code>-1</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input1</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入一个数字: "</span>;</span><br><span class="line">cin &gt;&gt; number;</span><br><span class="line">cout &lt;&lt; <span class="string">"输入的数字是: "</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input2</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串: "</span>;</span><br><span class="line">cin &gt;&gt; buf;<span class="comment">// 当遇到空格符时，会停止接收数据输入</span></span><br><span class="line">cout &lt;&lt; <span class="string">"输入的字符串: "</span>;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input3</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串: "</span>;</span><br><span class="line"><span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)<span class="comment">// 如果缓冲区没有数据，则程序会阻塞</span></span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input4</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> a, b, c;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串: "</span>;</span><br><span class="line">cin.<span class="built_in">get</span>(a);<span class="comment">// 如果缓冲区没有数据，则程序会阻塞</span></span><br><span class="line">cin.<span class="built_in">get</span>(b);</span><br><span class="line">cin.<span class="built_in">get</span>(c);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input5</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串: "</span>;</span><br><span class="line">cin.<span class="built_in">getline</span>(buf, <span class="number">256</span>);<span class="comment">// 当遇到空格符时，不会停止接收数据输入</span></span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input6</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> buf1[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">256</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串:"</span>;  <span class="comment">// 例如输入：abc  efghi</span></span><br><span class="line">cin &gt;&gt; buf1;</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">2</span>);<span class="comment">// 忽略缓冲区的数据</span></span><br><span class="line">cin.<span class="built_in">getline</span>(buf2, <span class="number">256</span>);</span><br><span class="line">cout &lt;&lt; buf1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input7</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> buf1[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">256</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串:"</span>;  <span class="comment">// 例如输入：abc  efghi</span></span><br><span class="line">cin &gt;&gt; buf1;</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> num = cin.<span class="built_in">peek</span>();<span class="comment">// 查看缓冲区是否有数据</span></span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">cin.<span class="built_in">getline</span>(buf2, <span class="number">256</span>);</span><br><span class="line">cout &lt;&lt; buf1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input8</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 分开处理输入的整数和字符</span></span><br><span class="line">cout &lt;&lt; <span class="string">"Please, enter a number or a word: "</span>;</span><br><span class="line"><span class="keyword">char</span> c = std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((c &gt;= <span class="string">'0'</span>) &amp;&amp; (c &lt;= <span class="string">'9'</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin.<span class="built_in">putback</span>(c);<span class="comment">// 将数据放回缓冲区</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="string">"You entered a number: "</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">cin.<span class="built_in">putback</span>(c);<span class="comment">// 将数据放回缓冲区</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch);</span><br><span class="line">cout &lt;&lt; <span class="string">"You entered a character: "</span> &lt;&lt; ch &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="标准输出流的简单使用"><a href="#标准输出流的简单使用" class="headerlink" title="标准输出流的简单使用"></a>标准输出流的简单使用</h3><p>标准输出流对象 <code>cout</code> 的常用函数如下：</p><ul><li><code>cout.flush()</code></li><li><code>cout.put()</code></li><li><code>cout.write()</code></li><li><code>cout.width()</code></li><li><code>cout.fill()</code></li><li><code>cout.setf()</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">()</span> </span>{</span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">'h'</span>).<span class="built_in">put</span>(<span class="string">'e'</span>).<span class="built_in">put</span>(<span class="string">'l'</span>).<span class="built_in">put</span>(<span class="string">'l'</span>).<span class="built_in">put</span>(<span class="string">'o'</span>).<span class="built_in">put</span>(<span class="string">'\n'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output2</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"hello world\n"</span>;</span><br><span class="line">cout.<span class="built_in">write</span>(str, <span class="built_in">strlen</span>(str));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output3</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 第一种方式：使用流对象的成员函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"&lt;Start&gt;"</span>;</span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">30</span>);</span><br><span class="line">cout.<span class="built_in">fill</span>(<span class="string">'*'</span>);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::showbase);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::internal);</span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">"&lt;End&gt;\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output4</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 第二种方式：使用控制符</span></span><br><span class="line">cout &lt;&lt; <span class="string">"&lt;Start&gt;"</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">30</span>)</span><br><span class="line">&lt;&lt; <span class="built_in">setfill</span>(<span class="string">'*'</span>)</span><br><span class="line">&lt;&lt; <span class="built_in">setiosflags</span>(ios::showbase)</span><br><span class="line">&lt;&lt; <span class="built_in">setiosflags</span>(ios::internal)</span><br><span class="line">&lt;&lt; hex</span><br><span class="line">&lt;&lt; <span class="number">123</span></span><br><span class="line">&lt;&lt; <span class="string">"&lt;End&gt;\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="built_in">output1</span>();</span><br><span class="line"><span class="built_in">output2</span>();</span><br><span class="line"><span class="built_in">output3</span>();</span><br><span class="line"><span class="built_in">output4</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello world</span><br><span class="line">&lt;Start&gt;0x**************************7b&lt;End&gt;</span><br><span class="line">&lt;Start&gt;0x**************************7b&lt;End&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="文件-I-O-流的简单使用"><a href="#文件-I-O-流的简单使用" class="headerlink" title="文件 I/O 流的简单使用"></a>文件 I/O 流的简单使用</h3><h4 id="以普通的方式读写文件"><a href="#以普通的方式读写文件" class="headerlink" title="以普通的方式读写文件"></a>以普通的方式读写文件</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="keyword">char</span>* fname = <span class="string">"D:/file.txt"</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(fname)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (fout) {</span><br><span class="line">fout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl;</span><br><span class="line">fout.<span class="built_in">flush</span>();</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">char</span>* fname = <span class="string">"D:/file.txt"</span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(fname)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (fin) {</span><br><span class="line"><span class="keyword">while</span> (fin.<span class="built_in">get</span>(ch)) {</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">}</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFileApp</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 以追加的方式打开文件</span></span><br><span class="line"><span class="keyword">char</span>* fname = <span class="string">"D:/file.txt"</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(fname, ios::app)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (fout) {</span><br><span class="line">fout &lt;&lt; <span class="string">"What"</span> &lt;&lt; endl;</span><br><span class="line">fout.<span class="built_in">flush</span>();</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="built_in">writeFile</span>();</span><br><span class="line"><span class="built_in">readFile</span>();</span><br><span class="line"><span class="built_in">writeFileApp</span>();</span><br><span class="line"><span class="built_in">readFile</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">What</span><br></pre></td></tr></tbody></table></figure><h4 id="以二进制的方式读写文件"><a href="#以二进制的方式读写文件" class="headerlink" title="以二进制的方式读写文件"></a>以二进制的方式读写文件</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Teacher</span>()</span><br><span class="line">{</span><br><span class="line">age = <span class="number">33</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Teacher</span>(<span class="keyword">int</span> _age, <span class="keyword">char</span>* _name)</span><br><span class="line">{</span><br><span class="line">age = _age;</span><br><span class="line"><span class="built_in">strcpy</span>(name, _name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"age:"</span> &lt;&lt; age &lt;&lt; <span class="string">", name:"</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span>age;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span>* fname = <span class="string">"D:/file.dat"</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(fname, ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!fout) {</span><br><span class="line">cout &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将类对象写入二进制文件（序列化）</span></span><br><span class="line"><span class="function">Teacher <span class="title">t1</span><span class="params">(<span class="number">23</span>, <span class="string">"Jim"</span>)</span></span>;</span><br><span class="line"><span class="function">Teacher <span class="title">t2</span><span class="params">(<span class="number">26</span>, <span class="string">"Tom"</span>)</span></span>;</span><br><span class="line">fout.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;t1, <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">fout.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;t2, <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">fout.<span class="built_in">flush</span>();</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(fname)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!fin) {</span><br><span class="line">cout &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从二进制文件读取类对象（反序列化）</span></span><br><span class="line">Teacher tmp;</span><br><span class="line">fin.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">tmp.<span class="built_in">print</span>();</span><br><span class="line">fin.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">tmp.<span class="built_in">print</span>();</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age:23, name:Jim</span><br><span class="line">age:23, name:Jim</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括标准输入输出流的使用等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之三</title>
    <link href="https://www.techgrow.cn/posts/35cd91d3.html"/>
    <id>https://www.techgrow.cn/posts/35cd91d3.html</id>
    <published>2021-12-06T13:55:33.000Z</published>
    <updated>2021-12-06T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="类型转换的语法"><a href="#类型转换的语法" class="headerlink" title="类型转换的语法"></a>类型转换的语法</h3><ul><li><p>C 语言风格的强制类型转换（Type Cast）很简单，不管什么类型的转换，语法都是：<code>TYPE b = (TYPE) a</code></p></li><li><p>C++ 风格的类型转换，提供了 4 种类型转换操作符来应对不同场合的应用</p><ul><li><code>const_cast</code>：去除变量的 <code>const</code> 只读属性</li><li><code>reinterpreter_cast</code>：重新解释类型（强制类型转换）</li><li><code>static_cast</code>：静态类型转换，如 <code>int</code> 转换成 <code>char</code></li><li><code>dynamic_cast</code>：动态类型转换，如父类和子类之间的多态类型转换</li></ul></li><li><p> C++ 4 种类型转换的语法：<code>TYPE B = static_cast&lt;TYPE&gt; (a)</code></p></li></ul><span id="more"></span><h3 id="类型转换的一般性介绍"><a href="#类型转换的一般性介绍" class="headerlink" title="类型转换的一般性介绍"></a>类型转换的一般性介绍</h3><p>一般性介绍：</p><ul><li>a) <code>const_cast&lt;&gt;()</code>：去除变量的 <code>const</code> 只读属性</li><li> b) <code>reinterpret_cast&lt;&gt;()</code>：重新解释类型，不同类型之间会进行强制类型转换</li><li> c) <code>dynamic_cast&lt;&gt;()</code>：动态类型转换，安全的基类和派生类之间转换，运行时会做类型检查</li><li> d) <code>static_cast&lt;&gt;()</code>：静态类型转换，编译的时候 C++ 编译器会做类型检查，基本类型都能转换，但是不能转换指针类型（多态除外）</li></ul><p>一般性结论：</p><ul><li>a) 在 C 语言中，不能隐式类型转换的，在 C++ 中可以用 <code>reinterpret_cast&lt;&gt;()</code> 进行强行类型解释</li><li> b) 在 C 语言中，能隐式类型转换的，在 C++ 中可用 <code>static_cast&lt;&gt;()</code> 进行类型转换，因为 C++ 编译器在编译的时候，一般都可以顺利通过类型检查</li><li> c) <code>static_cast&lt;&gt;()</code> 和 <code>reinterpret_cast&lt;&gt;()</code> 基本上把 C 语言中的强制类型转换功能给覆盖了，但 <code>reinterpret_cast&lt;&gt;()</code> 很难保证代码的移植性</li></ul><h3 id="类型转换的简单使用案例"><a href="#类型转换的简单使用案例" class="headerlink" title="类型转换的简单使用案例"></a>类型转换的简单使用案例</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"dog cry ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">watchHome</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"dog watch home"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"cat cry ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playBall</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"cat play ball ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playAnimal</span><span class="params">(Animal *animal)</span> </span>{</span><br><span class="line">    animal-&gt;<span class="built_in">cry</span>();</span><br><span class="line">    <span class="comment">// 动态类型转换，将父类转换为子类，运行时会做类型检查</span></span><br><span class="line">    Dog *dog = <span class="keyword">dynamic_cast</span>&lt;Dog *&gt;(animal);</span><br><span class="line">    <span class="keyword">if</span> (dog != <span class="literal">NULL</span>) {</span><br><span class="line">        dog-&gt;<span class="built_in">watchHome</span>();</span><br><span class="line">    }</span><br><span class="line">    Cat *cat = <span class="keyword">dynamic_cast</span>&lt;Cat *&gt;(animal);</span><br><span class="line">    <span class="keyword">if</span> (cat != <span class="literal">NULL</span>) {</span><br><span class="line">        cat-&gt;<span class="built_in">playBall</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span> </span>{</span><br><span class="line">    <span class="comment">// const_cast 去除变量的 const 只读属性</span></span><br><span class="line">    <span class="keyword">char</span> *m_buf = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(buf);</span><br><span class="line">    m_buf[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m_buf &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBuf2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义指针指向一个常量，这里的常量的内存空间不可以更改</span></span><br><span class="line">    <span class="keyword">char</span>* buf = <span class="string">"aaaaa"</span>;</span><br><span class="line">    <span class="comment">// const_cast 去除变量的 const 只读属性</span></span><br><span class="line">    <span class="keyword">char</span>* m_buf = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(buf);</span><br><span class="line">    <span class="comment">// 此时若更改指针所指向的内存空间，会带来灾难性的后果</span></span><br><span class="line">    m_buf[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m_buf &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态类型转换，编译的时候 C++ 编译器会做类型检查</span></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pi);</span><br><span class="line">    cout &lt;&lt; <span class="string">"num1 = "</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态类型转换，基本类型都能转换，但是不能转换指针类型（多态除外）</span></span><br><span class="line">    <span class="comment">// int* p2 = static_cast&lt;int*&gt;(p1);  // 错误写法，C++ 编译器编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新解释类型，不同类型之间会进行强制类型转换，包括转换指针类型</span></span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">"p2 = "</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除变量的 const 只读属性</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"aaaaa"</span>;</span><br><span class="line">    <span class="built_in">printBuf</span>(buf);</span><br><span class="line">    <span class="comment">// printBuf2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态类型转换，基类和派生类之间转换，运行时会做类型检查</span></span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">playAnimal</span>(&amp;dog);</span><br><span class="line">    <span class="built_in">playAnimal</span>(&amp;cat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多态的其他使用场景</span></span><br><span class="line">    Animal *pAnimal = <span class="literal">NULL</span>;</span><br><span class="line">    pAnimal = &amp;dog;</span><br><span class="line">    pAnimal = <span class="keyword">static_cast</span>&lt;Animal *&gt;(&amp;dog); <span class="comment">// 编译通过</span></span><br><span class="line">    pAnimal-&gt;<span class="built_in">cry</span>();</span><br><span class="line">    pAnimal = <span class="keyword">reinterpret_cast</span>&lt;Animal *&gt;(&amp;dog); <span class="comment">// 编译通过</span></span><br><span class="line">    pAnimal-&gt;<span class="built_in">cry</span>();</span><br><span class="line"></span><br><span class="line">    Tree tree;</span><br><span class="line">    <span class="comment">// pAnimal = static_cast&lt;Animal*&gt;(&amp;tree); // 错误写法，C++ 编译器编译失败</span></span><br><span class="line">    pAnimal = <span class="keyword">reinterpret_cast</span>&lt;Animal *&gt;(&amp;tree); <span class="comment">// 编译通过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num1 = 3</span><br><span class="line">p2 = 005661B8</span><br><span class="line">baaaa</span><br><span class="line">baaaa</span><br><span class="line">dog cry ...</span><br><span class="line">dog watch home</span><br><span class="line">cat cry ...</span><br><span class="line">cat play ball ...</span><br><span class="line">dog cry ...</span><br><span class="line">dog cry ...</span><br></pre></td></tr></tbody></table></figure><p>使用总结：</p><ul><li>一般情况下，不建议进行类型转换，应该避免进行类型转换</li><li>要清楚地知道：要转换的变量，类型转换前是什么类型，类型转换后是什么类型，转换后有什么后果</li></ul><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><ul><li>异常的介绍：<ul><li>异常是一种程序控制机制，与函数机制独立和互补</li><li>函数是一种以栈结构展开的上下函数衔接的程序控制系统，而异常是另一种控制结构，它依附于栈结构，却可以同时设置多个异常类型作为捕获条件，从而实现以类型匹配在栈机制中跳跃回馈</li></ul></li><li>异常设计目的：<ul><li>栈机制是一种高度节律性的控制机制，面向对象编程却要求对象之间有方向、有目的的控制传动，从一开始，异常就是冲着改变程序控制结构，以适应面向对象程序更有效地工作这个主题，而不是仅为了进行错误处理</li><li>异常设计出来之后，却发现在错误处理方面获得了最大的好处</li></ul></li></ul><h3 id="异常处理的基本思想"><a href="#异常处理的基本思想" class="headerlink" title="异常处理的基本思想"></a>异常处理的基本思想</h3><h4 id="传统错误处理机制"><a href="#传统错误处理机制" class="headerlink" title="传统错误处理机制"></a>传统错误处理机制</h4><p>传统的程序错误处理机制，是通过函数返回值来处理错误。</p><h4 id="异常处理的基本思想-1"><a href="#异常处理的基本思想-1" class="headerlink" title="异常处理的基本思想"></a>异常处理的基本思想</h4><p><img data-src="../../../asset/2021/12/cplus-plus-exception-1.png" alt="cplus-plus-exception-1"></p><ul><li>异常跨越了函数，并超脱于函数机制，决定了其对函数的跨越式回跳</li><li> C++ 的异常处理机制使得异常的引发和异常的处理不必在同一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理，上层调用者可以在适当的位置设计对不同类型异常的处理</li><li>异常是专门针对抽象编程中的一系列错误进行处理的，C++ 中不能借助函数机制，因为栈结构的本质是先进后出，依次访问，无法进行跳跃，但错误处理的特征却是遇到错误信息就想要转到若干级之上进行重新尝试，如图所示：</li></ul><p><img data-src="../../../asset/2021/12/cplus-plus-exception-2.png" alt="cplus-plus-exception-2"></p><h3 id="C-异常的基础使用"><a href="#C-异常的基础使用" class="headerlink" title="C++ 异常的基础使用"></a>C++ 异常的基础使用</h3><h4 id="异常的基本语法"><a href="#异常的基本语法" class="headerlink" title="异常的基本语法"></a>异常的基本语法</h4><p><img data-src="../../../asset/2021/12/cplus-plus-exception-3.png" alt="cplus-plus-exception-3"></p><ul><li>a) 若有异常则通过 <code>throw</code> 操作创建一个异常对象并抛掷</li><li> b) 将可能抛出异常的程序段嵌在 <code>try</code> 块之中，控制通过正常的顺序执行到达 <code>try</code> 语句，然后执行 <code>try</code> 代码块内的保护段</li><li> c) 如果在保护段执行期间没有引起异常，那么跟在 <code>try</code> 代码块后的 <code>catch</code> 子句就不会执行，程序从 <code>try</code> 代码块后跟随的最后一个 <code>catch</code> 子句后面的语句将继续执行下去</li><li> d) <code>catch</code> 子句按其在 <code>try</code> 代码块后出现的顺序被检查，匹配到的 <code>catch</code> 子句将捕获并处理异常（或继续抛掷异常）</li><li>e) 如果匹配的异常处理器未被找到，则函数 <code>terminate()</code> 将被自动调用，其缺省功能是调用函数 <code>abort()</code> 终止程序的运行</li><li> f) 处理不了的异常，可以在 <code>catch</code> 子句的最后一个分支，使用 <code>throw</code> 语法，向上抛掷异常</li></ul><h4 id="异常的简单使用案例一"><a href="#异常的简单使用案例一" class="headerlink" title="异常的简单使用案例一"></a>异常的简单使用案例一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == y) {</span><br><span class="line"><span class="keyword">throw</span> y;<span class="comment">// 抛出 int 类型的异常</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> x / y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in">divide</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span> e) {</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">", 被除数不能为零"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 会捕获所有未被捕获的异常，必须最后出现</span></span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"发生未知的异常 ..."</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"程序正常结束运行"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0, 被除数不能为零</span><br><span class="line">程序正常结束运行</span><br></pre></td></tr></tbody></table></figure><h4 id="异常的简单使用案例二"><a href="#异常的简单使用案例二" class="headerlink" title="异常的简单使用案例二"></a>异常的简单使用案例二</h4><p>异常机制与函数机制互不干涉，但捕捉的方式是基于类型匹配。异常捕捉相当于函数返回类型的匹配，而不是函数参数的匹配，所以异常捕捉不用考虑一个抛掷中的多种数据类型匹配问题。异常捕捉是严格按照类型匹配的，它的类型匹配之苛刻程度可以和模板的类型匹配相媲美。它不允许相容类型的隐式转换，比如，抛掷 <code>char</code> 类型的异常，用 <code>int</code> 类型就捕捉不到对应的异常。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.3</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"Please input a exception number: "</span>;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (a) {</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">throw</span> i;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">throw</span> d;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">throw</span> str;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">B</span>();</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">"No exception throws here.\n"</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"int exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">double</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"double exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>*) {</span><br><span class="line">cout &lt;&lt; <span class="string">"char* exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (A) {</span><br><span class="line">cout &lt;&lt; <span class="string">"class A exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (B) {</span><br><span class="line">cout &lt;&lt; <span class="string">"class B exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"That's ok.\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please input a exception number: 3</span><br><span class="line">char* exception.</span><br><span class="line">That's ok.</span><br></pre></td></tr></tbody></table></figure><h4 id="异常在继承中的使用案例"><a href="#异常在继承中的使用案例" class="headerlink" title="异常在继承中的使用案例"></a>异常在继承中的使用案例</h4><ul><li>MyException.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeException</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printErr</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NegativeException</span> :</span> <span class="keyword">public</span> SizeException {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NegativeException</span>(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printErr</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"数组大小不能小于零, 当前大小为 "</span> &lt;&lt; <span class="keyword">this</span>-&gt;size &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TooBigException</span> :</span> <span class="keyword">public</span> SizeException {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TooBigException</span>(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printErr</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"数组大小太大, 当前大小为 "</span> &lt;&lt; <span class="keyword">this</span>-&gt;size &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroException</span> :</span> <span class="keyword">public</span> SizeException {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroException</span>(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printErr</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"数组大小不允许为零"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>MyArray.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyException.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="comment">// 数组初始化大小检查，大小不合法则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">NegativeException</span>(size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">ZeroException</span>(size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; <span class="keyword">this</span>-&gt;m_max_size) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">TooBigException</span>(size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_size = size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="keyword">const</span> MyArray&amp; obj) {</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyArray</span>() {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用类成员函数，重载运算符 "[]"</span></span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用类成员函数，重载运算符 "="</span></span><br><span class="line">    MyArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp; obj) {</span><br><span class="line">        <span class="comment">// 释放原本的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyArray&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m_size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_space;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">    <span class="keyword">int</span> m_max_size = <span class="number">1000</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyArray&amp; obj) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">        out &lt;&lt; obj.m_space[i] &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyArray.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用构造函数</span></span><br><span class="line">        <span class="function">MyArray <span class="title">array1</span><span class="params">(<span class="number">-6</span>)</span></span>;</span><br><span class="line">        <span class="comment">// MyArray array1(5);</span></span><br><span class="line">        <span class="comment">// MyArray array1(0);</span></span><br><span class="line">        <span class="comment">// MyArray array1(2000);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载运算符 "[]"</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">getsize</span>(); i++) {</span><br><span class="line">            array1[i] = <span class="number">20</span> + i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载运算符 "&lt;&lt;"</span></span><br><span class="line">        cout &lt;&lt; array1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">        MyArray array2 = array1;</span><br><span class="line">        cout &lt;&lt; array2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="function">MyArray <span class="title">array3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        array3[<span class="number">0</span>] = <span class="number">43</span>;</span><br><span class="line">        array3[<span class="number">1</span>] = <span class="number">56</span>;</span><br><span class="line">        array3[<span class="number">2</span>] = <span class="number">79</span>;</span><br><span class="line">        cout &lt;&lt; array3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载运算符 "="</span></span><br><span class="line">        array3 = array2;</span><br><span class="line">        cout &lt;&lt; array3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用引用捕获异常（多态）</span></span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SizeException&amp; e) {</span><br><span class="line">        e.<span class="built_in">printErr</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"发生未知异常"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组大小不能小于零, 当前大小为 -6</span><br></pre></td></tr></tbody></table></figure><h3 id="C-异常的进阶使用"><a href="#C-异常的进阶使用" class="headerlink" title="C++ 异常的进阶使用"></a>C++ 异常的进阶使用</h3><h4 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h4><p>异常被抛出后，从进入 <code>try</code> 代码块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构，析构的顺序与构造的顺序相反。这一过程称为 <code>栈解旋（unwinding）</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">        cout &lt;&lt; <span class="string">"构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>, <span class="title">t2</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == y) {</span><br><span class="line">        <span class="keyword">throw</span> y;    <span class="comment">// 抛出 int 类型的异常</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// divide(5, 0);  如果 divide() 函数的调用写在 try 代码块之外，那么 Test 类的析构函数不会自动被调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">divide</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span> e) {</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; <span class="string">", 被除数不能为零"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"发生未知的异常"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数被调用</span><br><span class="line">构造函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">0, 被除数不能为零</span><br></pre></td></tr></tbody></table></figure><h4 id="异常接口的声明"><a href="#异常接口的声明" class="headerlink" title="异常接口的声明"></a>异常接口的声明</h4><ul><li>a) 为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，例如：<code>void func() throw (A, B, C , D) {}</code>，这个函数 <code>func（）</code> 能够且只能抛出类型 A、B、C、D 及其子类型的异常</li><li> b) 如果一个函数抛出了它的异常接口声明所不允许抛出的异常，<code>unexpected()</code> 函数会被调用，该函数的默认行为是调用 <code>terminate()</code> 函数中止程序</li><li> c) 如果在函数声明中没有包含异常接口声明，则此函数可以抛掷任何类型的异常，例如：<code>void func() {}</code></li><li>d) 一个不抛掷任何类型异常的函数，可以声明为：<code>void func() throw() {}</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> {</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能够且只能抛出类型 A、B、C、D 及其子类型的异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(A, B, C, D)</span> </span>{</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">A</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能抛出任何类型的异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以抛出任何类型的异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcC</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">B</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="built_in">funcA</span>();</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">cout &lt;&lt; <span class="string">"发生异常 ..."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发生异常 ...</span><br></pre></td></tr></tbody></table></figure><h4 id="默认的异常处理器"><a href="#默认的异常处理器" class="headerlink" title="默认的异常处理器"></a>默认的异常处理器</h4><h5 id="terminate-函数"><a href="#terminate-函数" class="headerlink" title="terminate() 函数"></a>terminate () 函数</h5><p>在 C++ 中，异常是不可以忽略的，当异常找不到匹配的 <code>catch</code> 子句时，会调用系统的库函数 <code>terminate()</code>（在头文件中）；默认情况下，<code>terminate（）</code> 函数会调用标准 C 库函数 <code>abort（）</code> 使程序终止而退出。当调用 <code>abort()</code> 函数时，程序不会调用正常的终止函数，也就是说，全局对象和静态对象的析构函数不会执行，这就可能会导致内存泄漏。<strong>值得一提的是，在多线程程序中，各个 <code>terminate()</code> 函数是互相独立的，每个线程都有自己的 <code>terminate()</code> 函数。</strong></p><h5 id="set-terminate-函数"><a href="#set-terminate-函数" class="headerlink" title="set_terminate() 函数"></a>set_terminate () 函数</h5><p>在 C++ 中，通过使用标准的 <code>set_terminate()</code> 函数，可以设置自己的 <code>terminate（)</code> 函数。自定义的 <code>terminate()</code> 函数不能有参数，而且返回值类型必须为 <code>void</code>。另外，<code>terminate()</code> 函数不能抛出异常，它必须终止程序。如果 <code>terminate()</code> 函数被调用，这就意味着问题已经无法解决了。</p><h5 id="设置默认的异常处理器"><a href="#设置默认的异常处理器" class="headerlink" title="设置默认的异常处理器"></a>设置默认的异常处理器</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 terminate() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTerminate</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"函数 myTerminate() 被 terminate() 调用!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置默认的异常处理器</span></span><br><span class="line">    <span class="built_in">set_terminate</span>(myTerminate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">0</span>, result;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"被除数为零!"</span>;   <span class="comment">//抛出异常，由 terminate() 函数捕获</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            result = x / y;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 不会被整型异常捕获</span></span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span> e) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"捕获到整型异常!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"程序正常结束运行!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数 myTerminate() 被 terminate() 调用!</span><br></pre></td></tr></tbody></table></figure><h4 id="C-提供的标准异常库"><a href="#C-提供的标准异常库" class="headerlink" title="C++ 提供的标准异常库"></a>C++ 提供的标准异常库</h4><h5 id="标准异常库的介绍"><a href="#标准异常库的介绍" class="headerlink" title="标准异常库的介绍"></a>标准异常库的介绍</h5><p><img data-src="../../../asset/2021/12/cplus-plus-exception-4.png" alt="cplus-plus-exception-4"><br><img data-src="../../../asset/2021/12/cplus-plus-exception-5.png" alt="cplus-plus-exception-5"></p><h5 id="标准异常库的使用案例"><a href="#标准异常库的使用案例" class="headerlink" title="标准异常库的使用案例"></a>标准异常库的使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>(<span class="keyword">int</span> age) {</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">100</span>) {</span><br><span class="line">            <span class="comment">// 抛出标准库内的异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">"年龄太大"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承标准库内的异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> exception {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_p = p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">what</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyException 类型的异常 : "</span> &lt;&lt; m_p &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *m_p;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// Teacher teacher(105);</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">"发生自定义异常!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (out_of_range e) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"out_of_range 类型的异常 : "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (MyException &amp;e) {</span><br><span class="line">        e.<span class="built_in">what</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"发生未知类型的异常!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyException 类型的异常 : 发生自定义异常!</span><br></pre></td></tr></tbody></table></figure><h4 id="异常类型和异常变量的生命周期"><a href="#异常类型和异常变量的生命周期" class="headerlink" title="异常类型和异常变量的生命周期"></a>异常类型和异常变量的生命周期</h4><ul><li><code>throw</code> 异常是有类型的，可以使用数字、字符串、类对象，<code>catch</code> 严格按照类型进行匹配</li><li><code>throw</code> 类对象类型的异常时：<ul><li>如果捕获异常的时候，使用一个异常变量，则拷贝构造该异常变量</li><li>如果捕获异常的时候，使用了引用，则会使用 <code>throw</code> 时候的那个对象</li><li>捕获异常的时候，指针可以和引用 / 元素同时出现，但是引用与元素不能同时出现</li><li><strong>结论：如果抛出的是类对象类型的异常，则使用引用进行异常捕获比较合适 </strong></li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadSrcType</span> {</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadDestType</span> {</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadProcessType</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BadProcessType</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"BadProcessType的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">BadProcessType</span>(<span class="keyword">const</span> BadProcessType&amp; obj) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"BadProcessType的拷贝构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BadProcessType</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"BadProcessType的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStrcpy</span><span class="params">(<span class="keyword">char</span>* to, <span class="keyword">char</span>* from)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (to == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">BadDestType</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (from == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">BadSrcType</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*from == <span class="string">'a'</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">BadProcessType</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (*from == <span class="string">'b'</span>) {</span><br><span class="line">        <span class="comment">// 不建议使用这种写法</span></span><br><span class="line">        <span class="keyword">throw</span>&amp; (<span class="built_in">BadProcessType</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (*from == <span class="string">'c'</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadProcessType;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*from != <span class="string">'\0'</span>) {</span><br><span class="line">        *to = *from;</span><br><span class="line">        to++;</span><br><span class="line">        from++;</span><br><span class="line">    }</span><br><span class="line">    *to = <span class="string">'\0'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf1[] = <span class="string">"cbbcdefg"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">1024</span>] = { <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="built_in">myStrcpy</span>(buf2, buf1);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (BadSrcType e) {</span><br><span class="line">        cout &lt;&lt; <span class="string">" BadSrcType 类型异常"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (BadDestType e) {</span><br><span class="line">        cout &lt;&lt; <span class="string">" BadDestType 类型异常"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 结论1: 如果接收异常的时候，使用一个异常变量，则拷贝构造该异常变量</span></span><br><span class="line"><span class="comment">    catch (BadProcessType e)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; " BadProcessType 类型异常" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 结论2: 如果接收异常的时候，使用了引用，则会使用throw时候的那个对象</span></span><br><span class="line"><span class="comment">    catch (BadProcessType&amp; e)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; " BadProcessType 类型异常" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 结论3: 接收异常的时候，指针可以和引用/元素同时出现，但是引用与元素不能同时出现</span></span><br><span class="line"><span class="comment">    catch (BadProcessType* e)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; " BadProcessType 类型异常" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        delete e;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 结论4: 如果抛出的是类对象类型的异常，则使用引用进行异常捕获比较合适</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未知 类型异常"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括类型转换、异常机制、标准异常库的使用等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之二</title>
    <link href="https://www.techgrow.cn/posts/779107de.html"/>
    <id>https://www.techgrow.cn/posts/779107de.html</id>
    <published>2021-11-29T13:55:33.000Z</published>
    <updated>2021-11-29T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="函数模板和类模板"><a href="#函数模板和类模板" class="headerlink" title="函数模板和类模板"></a>函数模板和类模板</h2><p>C++ 提供了函数模板（function template）。<strong>所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表，这个通用函数就称为函数模板</strong>。凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时，系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。</p><p><img data-src="../../../asset/2021/12/cplus-plus-template-1.png" alt="cplus-plus-template-1"></p><span id="more"></span><p>C++ 提供两种模板机制：函数模板、类模板</p><ul><li>模板又称之为 <code>泛型编程</code></li><li>模板把函数或类要处理的数据类型参数化，表现为参数的多态性，称为类属</li><li>模板用于表达逻辑结构相同，但具有数据元素类型不同的数据对象的通用行为</li><li>类属 —— 类型参数化，又称参数模板，使得程序（算法）可以从逻辑功能上抽象，把被处理的对象（数据）类型作为参数传递</li></ul><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="函数模板的定义"><a href="#函数模板的定义" class="headerlink" title="函数模板的定义"></a>函数模板的定义</h4><p><img data-src="../../../asset/2021/12/cplus-plus-template-2.png" alt="cplus-plus-template-2"></p><ul><li>模板声明的语法为：<code>template &lt; 类型形式参数表 &gt;</code>，例如 <code>template &lt;typename T&gt;</code></li><li>类型形式参数表的语法为：<code>typename T1 ,  typename T2 , …… , typename Tn</code> 或者 <code>class T1 ,  class T2 , …… , class Tn</code></li></ul><h4 id="函数模板的调用"><a href="#函数模板的调用" class="headerlink" title="函数模板的调用"></a>函数模板的调用</h4><ul><li><code>myswap(a, b);</code>：自动数据类型推导</li><li><code>myswap&lt;float&gt;(a, b);</code>：显示类型调用（推荐）</li></ul><h4 id="函数模板的简单使用"><a href="#函数模板的简单使用" class="headerlink" title="函数模板的简单使用"></a>函数模板的简单使用</h4><p><img data-src="../../../asset/2021/12/cplus-plus-template-3.png" alt="cplus-plus-template-3"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>{</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动数据类型推导</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d, y = %d\n"</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动数据类型推导</span></span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">0.5</span>, m = <span class="number">0.8</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(n, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %f, m = %f\n"</span>, n, m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示类型调用（推荐）</span></span><br><span class="line">    <span class="keyword">char</span> i = <span class="string">'h'</span>, j = <span class="string">'e'</span>;</span><br><span class="line">    myswap&lt;<span class="keyword">char</span>&gt;(i, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %c, m = %c\n"</span>, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 2, y = 1</span><br><span class="line">n = 0.800000, m = 0.500000</span><br><span class="line">n = e, m = h</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板做函数参数"><a href="#函数模板做函数参数" class="headerlink" title="函数模板做函数参数"></a>函数模板做函数参数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数模板，实现数组排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arraySort</span><span class="params">(T1* array, <span class="keyword">int</span> size, <span class="keyword">bool</span> asc = <span class="literal">true</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">NULL</span> || size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T1 tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) {</span><br><span class="line">            <span class="comment">// 升序排序（从小到大）</span></span><br><span class="line">            <span class="keyword">if</span> (asc) {</span><br><span class="line">                <span class="keyword">if</span> (array[i] &gt; array[j]) {</span><br><span class="line">                    tmp = array[i];</span><br><span class="line">                    array[i] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 降序排序（从大到小）</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; array[j]) {</span><br><span class="line">                    tmp = array[i];</span><br><span class="line">                    array[i] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数模板，打印数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T2* array, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        cout &lt;&lt; array[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> array[] = { <span class="number">32</span>, <span class="number">16</span>, <span class="number">29</span>, <span class="number">9</span>, <span class="number">43</span>, <span class="number">53</span>, <span class="number">23</span> };</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(array) / <span class="built_in"><span class="keyword">sizeof</span></span>(*array);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之前: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">int</span>&gt;(array, size);</span><br><span class="line"></span><br><span class="line">    arraySort&lt;<span class="keyword">int</span>&gt;(array, size, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之后: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">int</span>&gt;(array, size);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> array2[] = { <span class="string">'c'</span>, <span class="string">'z'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'q'</span>, <span class="string">'m'</span> };</span><br><span class="line">    <span class="keyword">int</span> size2 = <span class="built_in"><span class="keyword">sizeof</span></span>(array2) / <span class="built_in"><span class="keyword">sizeof</span></span>(*array2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之前: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">char</span>&gt;(array2, size2);</span><br><span class="line"></span><br><span class="line">    arraySort&lt;<span class="keyword">char</span>&gt;(array2, size2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之后: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">char</span>&gt;(array2, size2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">排序之前: 32 16 29 9 43 53 23</span><br><span class="line">排序之后: 53 43 32 29 23 16 9</span><br><span class="line">------------------------------</span><br><span class="line">排序之前: c z h i q m</span><br><span class="line">排序之后: c h i m q z</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板与普通函数"><a href="#函数模板与普通函数" class="headerlink" title="函数模板与普通函数"></a>函数模板与普通函数</h4><p>函数模板和普通函数的区别：</p><ul><li>a) 函数模板不允许自动类型转化</li><li> b) 普通函数能够进行自动类型转换</li></ul><p>函数模板和普通函数的调用规则：</p><ul><li>a) C++ 编译器优先考虑使用普通函数</li><li> b) 如果函数模板可以产生一个更好的匹配，那么编译器会选择函数模板 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>{</span><br><span class="line">T tmp;</span><br><span class="line">tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">cout &lt;&lt; <span class="string">"模板函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> b)</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"普通函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'z'</span>;</span><br><span class="line"><span class="built_in">myswap</span>(a, c); <span class="comment">// 调用普通函数</span></span><br><span class="line"><span class="built_in">myswap</span>(c, a); <span class="comment">// 调用普通函数，会进行隐式的类型转换</span></span><br><span class="line"><span class="built_in">myswap</span>(a, a); <span class="comment">// 调用函数模板（本质是类型参数化），将严格地按照类型进行匹配，不会进行隐式的类型转换</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 10, b = z</span><br><span class="line">普通函数被调用</span><br><span class="line">a = 122, b =</span><br><span class="line"></span><br><span class="line">普通函数被调用</span><br><span class="line">模板函数被调用</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板与函数重载"><a href="#函数模板与函数重载" class="headerlink" title="函数模板与函数重载"></a>函数模板与函数重载</h4><ul><li>a) 函数模板可以像普通函数一样被重载</li><li> b) 通过空模板实参列表的语法，可以限制编译器只使用函数模板匹配</li><li> c) 如果函数模板可以产生一个更好的匹配，那么编译器会选择函数模板 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"int Max(int a, int b)"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"T Max(T a, T b)"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板重载</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"T Max(T a, T b, T c)"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">Max</span>(a, b), c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Max</span>(a, b) &lt;&lt; endl; <span class="comment">// 当函数模板和普通函数都符合调用时,优先选择普通函数</span></span><br><span class="line">cout &lt;&lt; Max&lt;&gt;(a, b) &lt;&lt; endl; <span class="comment">//  通过空模板实参列表的语法，可以限制编译器只使用函数模板匹配</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Max</span>(<span class="number">3.0</span>, <span class="number">4.0</span>) &lt;&lt; endl; <span class="comment">// 如果函数模板产生更好的匹配 使用函数模板</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Max</span>(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>) &lt;&lt; endl; <span class="comment">// 函数模板的重载</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Max</span>(<span class="string">'a'</span>, <span class="number">100</span>) &lt;&lt; endl;  <span class="comment">// 调用普通函数，可以进行隐式类型转换 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Max(int a, int b)</span><br><span class="line">2</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">2</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">4</span><br><span class="line">T Max(T a, T b, T c)</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">7</span><br><span class="line">int Max(int a, int b)</span><br><span class="line">100</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板底层原理剖析"><a href="#函数模板底层原理剖析" class="headerlink" title="函数模板底层原理剖析"></a>函数模板底层原理剖析</h4><ul><li>编译器并不是根据函数模板，产生能够处理任意参数的函数</li><li>编译器本质上是根据具体的调用类型，从函数模板产生不同的函数</li><li><strong>编译器会对函数模板进行两次编译，在声明的地方对函数模板代码本身进行第一次编译，在调用的地方对参数替换后的函数模板代码进行第二次编译</strong></li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板与函数模板的定义和使用类似，在实际项目开发中，经常有两个或多个类，其功能是相同的，仅仅是数据类型不同，为了不重复定义功能相同的类，可以使用类模板来解决这类问题。</p><h4 id="类模板的定义"><a href="#类模板的定义" class="headerlink" title="类模板的定义"></a>类模板的定义</h4><p><img data-src="../../../asset/2021/12/cplus-plus-template-4.png"></p><ul><li>类模板用于实现类所需数据的类型参数化</li><li>类模板在表示如数组、表、图等数据结构显得特别重要，这些数据结构的表示和算法不受所包含的元素类型的影响</li><li>在下述的所有代码中，<code>template &lt;typename T&gt;</code> 等价于 <code>template &lt;class T&gt;</code></li></ul><h4 id="类模板的简单使用"><a href="#类模板的简单使用" class="headerlink" title="类模板的简单使用"></a>类模板的简单使用</h4><p>值得一提的是，在类模板中如果使用了构造函数，则必须遵守 C++ 类的构造函数的调用规则</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(T t) {</span><br><span class="line"><span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">getT</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T t;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板做函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">(A&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>{</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getT</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;<span class="comment">// 模板类是抽象的，需要声明具体的类型（模板参数列表），这里的 &lt;int&gt; 不能省略</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getT</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">printA</span>(a2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">50</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板与派生类的使用"><a href="#类模板与派生类的使用" class="headerlink" title="类模板与派生类的使用"></a>类模板与派生类的使用</h4><h5 id="普通类继承类模板"><a href="#普通类继承类模板" class="headerlink" title="普通类继承类模板"></a>普通类继承类模板</h5><p>在 C++ 中，类模板可以被普通类继承，普通类继承类模板时，需要声明父类具体的数据类型。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(T a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T a;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类继承类模板，需要声明具体的类型（模板参数列表），这里的 &lt;int&gt; 不能省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&lt;<span class="keyword">int</span>&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : A&lt;<span class="keyword">int</span>&gt;(a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">b.<span class="built_in">printB</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">a = 1, b = 3</span><br></pre></td></tr></tbody></table></figure><h5 id="类模板继承类模板"><a href="#类模板继承类模板" class="headerlink" title="类模板继承类模板"></a>类模板继承类模板</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(T a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T a;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板继承类模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&lt;T&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(T a, T b) : <span class="built_in">A</span>(a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">B&lt;<span class="keyword">double</span>&gt; <span class="title">b</span><span class="params">(<span class="number">3.2</span>, <span class="number">4.5</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; b.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b.<span class="built_in">getB</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3.2</span><br><span class="line">4.5</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板函数的三种写法"><a href="#类模板函数的三种写法" class="headerlink" title="类模板函数的三种写法"></a>类模板函数的三种写法</h4><p>值得一提的是，企业项目开发中，建议使用第一种或者第三种方式，STL 库一般都采用第一种方式。</p><h5 id="所有的类模板函数写在类的内部（第一种）"><a href="#所有的类模板函数写在类的内部（第一种）" class="headerlink" title="所有的类模板函数写在类的内部（第一种）"></a>所有的类模板函数写在类的内部（第一种）</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">Complex</span>(T a, T b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; c2) {</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c2.a, <span class="keyword">this</span>-&gt;b + c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&amp; c1) {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; c1.b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Complex <span class="title">sub</span><span class="params">(Complex&amp; c1, Complex&amp; c2)</span> </span>{</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(c1.a - c2.a, c1.b - c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T a;</span><br><span class="line">T b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">c1.<span class="built_in">print</span>();</span><br><span class="line">c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c4 = <span class="built_in">sub</span>(c1, c2);</span><br><span class="line">cout &lt;&lt; c4 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 1, b = 4</span><br><span class="line">a = 3, b = 6</span><br><span class="line">a = 4, b = 10</span><br><span class="line">a = -2, b = -2</span><br></pre></td></tr></tbody></table></figure><h5 id="所有的类模板函数写在类的外部（第二种）"><a href="#所有的类模板函数写在类的外部（第二种）" class="headerlink" title="所有的类模板函数写在类的外部（第二种）"></a>所有的类模板函数写在类的外部（第二种）</h5><p>所有的类模板函数写在类的外部（写在同一个 <code>.cpp</code> 文件），当使用友元函数重载了 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 运算符时，需要特别注意声明友元函数的写法 <code>friend ostream&amp; operator&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c1);</code>。<strong>特别注意，除了重载运算符 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 必须使用友元函数之外，其他运算符的重载尽量都使用类成员函数。千万不要滥用友元函数，尤其类模板与友元函数一起使用的时候，这是因为需要使用怪异的语法来解决 C++ 编译器出现的错误，且不同的 C++ 编译器表现行为不一定一致。</strong>假设在类模板中滥用了友元函数，解决 C++ 编译问题的语法详见 <a href="../../../asset/2021/12/cplus-plus-template-5.png">图解分析</a>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** START 解决类模板与友元函数滥用（非重载左移与右移运算符）时出现的编译问题 *********/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Complex</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">Complex&lt;T&gt; <span class="title">sub</span><span class="params">(Complex&lt;T&gt;&amp; c1, Complex&lt;T&gt;&amp; c2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** END 解决类模板与友元函数滥用（非重载左移与右移运算符）时出现的编译问题 *********/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">Complex</span>(T a, T b);</span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; c2);</span><br><span class="line"><span class="comment">// 友元函数（滥用友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> Complex sub&lt;T&gt;(Complex&amp; c1, Complex&amp; c2);</span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T a;</span><br><span class="line">T b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt;::<span class="built_in">Complex</span>(T a, T b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Complex&lt;T&gt;::<span class="built_in">print</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt; Complex&lt;T&gt;::<span class="keyword">operator</span>+(Complex&lt;T&gt;&amp; c2) {</span><br><span class="line"><span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c2.a, <span class="keyword">this</span>-&gt;b + c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&lt;T&gt;&amp; c1) {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; c1.b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数（滥用友元函数）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Complex&lt;T&gt; <span class="title">sub</span><span class="params">(Complex&lt;T&gt;&amp; c1, Complex&lt;T&gt;&amp; c2)</span> </span>{</span><br><span class="line"><span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(c1.a - c2.a, c1.b - c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">3</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">9</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">c1.<span class="built_in">print</span>();</span><br><span class="line">c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c4 = <span class="built_in">sub</span>(c1, c2);</span><br><span class="line">cout &lt;&lt; c4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 3, b = 8</span><br><span class="line">a = 9, b = 5</span><br><span class="line">a = 12, b = 13</span><br><span class="line">a = -6, b = 3</span><br></pre></td></tr></tbody></table></figure><h5 id="所有的类模板函数写在类的外部（第三种）"><a href="#所有的类模板函数写在类的外部（第三种）" class="headerlink" title="所有的类模板函数写在类的外部（第三种）"></a>所有的类模板函数写在类的外部（第三种）</h5><p>所有的类模板函数写在类的外部（分开写在 <code>.h</code> 和 <code>.cpp</code> 中），这里除了重载运算符 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 必须使用友元函数之外，千万不要滥用友元函数；因为 C++ 编译器会出现编译错误，且没有很好的解决方法。</p><ul><li>complex.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(T a, T b);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; c2);</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T a;</span><br><span class="line">T b;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>complex.hpp，这里的 <code>.hpp</code> 文件与 <code>.cpp</code> 文件本质上没有区别，为了方便区分意图，只是文件的后缀不一样而已 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complex.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt;::<span class="built_in">Complex</span>(T a, T b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Complex&lt;T&gt;::<span class="built_in">print</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt; Complex&lt;T&gt;::<span class="keyword">operator</span>+(Complex&lt;T&gt;&amp; c2) {</span><br><span class="line"><span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c2.a, <span class="keyword">this</span>-&gt;b + c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&lt;T&gt;&amp; c1) {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; c1.b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp，特别注意，这里引入的是 <code>.hpp</code> 或者 <code>.cpp</code> 文件，而不是 <code>.h</code> 头文件，否则 C++ 编译器会编译失败 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complex.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">6</span>, <span class="number">13</span>)</span></span>;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">23</span>, <span class="number">34</span>)</span></span>;</span><br><span class="line">c1.<span class="built_in">print</span>();</span><br><span class="line">c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 6, b = 13</span><br><span class="line">a = 23, b = 34</span><br><span class="line">a = 29, b = 47</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板中的-static-关键字"><a href="#类模板中的-static-关键字" class="headerlink" title="类模板中的 static 关键字"></a>类模板中的 static 关键字</h4><ul><li>从类模板实例化的每种数据类型模板类都有自己的类模板数据成员，该数据类型的模板类的所有对象共享同一个 <code>static</code> 数据成员</li><li>和非模板类的 <code>static</code> 数据成员一样，模板类的 <code>static</code> 数据成员也应该在源文件范围内定义和初始化</li><li>每种数据类型的模板类都有自己单独一份的类模板的 <code>static</code> 数据成员副本，详见 <a href="../../../asset/2021/12/cplus-plus-template-6.png">图解分析</a></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Circle</span>(T radius = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_radius = radius;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_total++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(T radius)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;m_radius = radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">getRadius</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getGirth</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * pi * <span class="keyword">this</span>-&gt;m_radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> pi * <span class="keyword">this</span>-&gt;m_radius * <span class="keyword">this</span>-&gt;m_radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> m_total;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_radius;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的静态数据成员</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_total;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类模板的静态数据成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Circle&lt;T&gt;::m_total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 每种数据类型的模板类都有自己单独一份的类模板的 static 数据成员副本</span></span><br><span class="line"></span><br><span class="line"><span class="function">Circle&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">4</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"m_total = "</span> &lt;&lt; Circle&lt;<span class="keyword">int</span>&gt;::<span class="built_in">getTotal</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c1.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c1.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c1.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c2.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c2.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c2.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle&lt;<span class="keyword">float</span>&gt; <span class="title">c3</span><span class="params">(<span class="number">3.2</span>)</span>, <span class="title">c4</span><span class="params">(<span class="number">4.3</span>)</span>, <span class="title">c5</span><span class="params">(<span class="number">6.2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"m_total = "</span> &lt;&lt; Circle&lt;<span class="keyword">float</span>&gt;::<span class="built_in">getTotal</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c3.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c3.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c3.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c4.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c4.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c4.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c5.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c5.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c5.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m_total = 2</span><br><span class="line">radius = 4, girth = 25.12, area = 50.24</span><br><span class="line">radius = 6, girth = 37.68, area = 113.04</span><br><span class="line">m_total = 3</span><br><span class="line">radius = 3.2, girth = 20.096, area = 32.1536</span><br><span class="line">radius = 4.3, girth = 27.004, area = 58.0586</span><br><span class="line">radius = 6.2, girth = 38.936, area = 120.702</span><br></pre></td></tr></tbody></table></figure><h3 id="数组模板类的实战案例"><a href="#数组模板类的实战案例" class="headerlink" title="数组模板类的实战案例"></a>数组模板类的实战案例</h3><p>下面将编写数组模板类，模拟 STL 容器的实现，同时贯穿上面所讲的 C++ 模板知识点。</p><details><summary>★点击显示完整的案例代码★</summary><code><ul><li>MyVector.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="keyword">int</span> size = <span class="number">0</span>);</span><br><span class="line">~<span class="built_in">MyVector</span>();</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">MyVector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&amp; obj);</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt;(ostream&amp; out, MyVector&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_space; <span class="comment">// 指向数组的指针</span></span><br><span class="line"><span class="keyword">int</span> m_size;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>MyVector.hpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyVector.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;::<span class="built_in">MyVector</span>(<span class="keyword">int</span> size) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = size;</span><br><span class="line"><span class="comment">// 分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> T[size];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;::~<span class="built_in">MyVector</span>() {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;::<span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&lt;T&gt;&amp; obj) {</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> T[obj.m_size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> MyVector&lt;T&gt;::<span class="built_in">getSize</span>() {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数，重载运算符 "[]"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; MyVector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数，重载运算符 "="</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;&amp; MyVector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&lt;T&gt;&amp; obj) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line"><span class="comment">// 释放原本的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> T[obj.m_size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyVector&lt;T&gt;&amp; obj) {</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">cout &lt;&lt; obj.m_space[i] &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Teacher.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Teacher</span>();</span><br><span class="line"><span class="built_in">Teacher</span>(<span class="keyword">int</span> age, <span class="keyword">const</span> <span class="keyword">char</span>* name);</span><br><span class="line"><span class="built_in">Teacher</span>(<span class="keyword">const</span> Teacher&amp; obj);</span><br><span class="line">~<span class="built_in">Teacher</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Teacher&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Teacher&amp; obj);</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Teacher&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_age;</span><br><span class="line"><span class="keyword">char</span>* m_name;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>Teacher.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Teacher.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>() {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="keyword">int</span> age, <span class="keyword">const</span> <span class="keyword">char</span>* name) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="keyword">const</span> Teacher&amp; obj) {</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = obj.m_age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(obj.m_name) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, obj.m_name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Teacher::~<span class="built_in">Teacher</span>() {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数，重载运算符 "="</span></span><br><span class="line">Teacher&amp; Teacher::<span class="keyword">operator</span>=(<span class="keyword">const</span> Teacher&amp; obj) {</span><br><span class="line"><span class="comment">// 释放原本的内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_name);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = obj.m_age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(obj.m_name) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, obj.m_name);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Teacher&amp; obj) {</span><br><span class="line">cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; obj.m_age &lt;&lt; <span class="string">" name = "</span> &lt;&lt; obj.m_name;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Teacher::getAge</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Teacher::getName</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>{</span><br><span class="line"><span class="comment">// 释放原本的内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_name);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, name);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp，值得一提的是，这里需要引入 <code>Teacher.cpp</code> 和 <code>MyVector.hpp</code>，而不是 <code>Teacher.h</code> 和 <code>MyVector.h</code> 头文件，否则 C++ 编译器会编译失败，本质原因是由于 C++ 编译器会对模板进行两次编译导致的，详见  <a href="https://blog.csdn.net/big_bit/article/details/52289162">C++ 模板的编译错误分析</a>。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Teacher.cpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyVector.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用构造函数</span></span><br><span class="line"><span class="function">MyVector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符 "[]"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">v[i] = i + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符 "&lt;&lt;"</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用拷贝构造函数</span></span><br><span class="line">MyVector&lt;<span class="keyword">int</span>&gt; v2 = v;</span><br><span class="line">cout &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符 "="</span></span><br><span class="line"><span class="function">MyVector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">v3 = v2;</span><br><span class="line">cout &lt;&lt; v3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器存放类对象</span></span><br><span class="line"><span class="function">MyVector&lt;Teacher&gt; <span class="title">teachers</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teachers.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line"><span class="function">Teacher <span class="title">t</span><span class="params">(i + <span class="number">20</span>, <span class="string">"Jim"</span>)</span></span>;</span><br><span class="line">teachers[i] = t;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; teachers &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器存放指针</span></span><br><span class="line"><span class="function">MyVector&lt;Teacher*&gt; <span class="title">points</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">points[i] = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">25</span> + i, <span class="string">"Tom"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">Teacher* obj = points[i];</span><br><span class="line">cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; obj-&gt;<span class="built_in">getAge</span>() &lt;&lt; <span class="string">" name = "</span> &lt;&lt; obj-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5,</span><br><span class="line">1, 2, 3, 4, 5,</span><br><span class="line">1, 2, 3, 4, 5,</span><br><span class="line">age = 20 name = Jim, age = 21 name = Jim, age = 22 name = Jim,</span><br><span class="line">age = 25 name = Tom, age = 26 name = Tom, age = 27 name = Tom, age = 28 name = Tom,</span><br></pre></td></tr></tbody></table></figure></code></details><h3 id="函数模板与类模板的使用总结"><a href="#函数模板与类模板的使用总结" class="headerlink" title="函数模板与类模板的使用总结"></a>函数模板与类模板的使用总结</h3><ul><li>模板是 C++ 类型参数化的多态工具，C++ 为此提供了函数模板和类模板</li><li>模板定义以模板声明开始，类属参数必须在模板定义中至少出现一次</li><li>同一个类属参数可以用于多个模板</li><li>类属参数可用于函数的参数类型、返回值类型和声明函数中的变量</li><li>模板由编译器根据实际的数据类型进行实例化，生成可执行代码</li><li>模板中的函数称为模板函数，实例化的类模板称为模板类</li><li>类模板可以在类层次中使用（即可以被继承）</li><li>函数模板可以使用多种方式重载</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括函数模板、类模板等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之一</title>
    <link href="https://www.techgrow.cn/posts/dbff2af9.html"/>
    <id>https://www.techgrow.cn/posts/dbff2af9.html</id>
    <published>2021-11-25T13:55:33.000Z</published>
    <updated>2021-11-29T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="智能指针的入门案例"><a href="#智能指针的入门案例" class="headerlink" title="智能指针的入门案例"></a>智能指针的入门案例</h3><h4 id="unique-ptr-对象的介绍"><a href="#unique-ptr-对象的介绍" class="headerlink" title="unique_ptr 对象的介绍"></a>unique_ptr 对象的介绍</h4><p><code>unique_ptr</code> 是 C++ 11 提供的用于防止内存泄漏的智能指针中的一种实现，独享被管理对象指针所有权的智能指针。<code>unique_ptr</code> 对象包装了一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。<code>unique_ptr</code> 实现了 <code>-&gt;</code> 和 <code>*</code> 运算符的重载，因此它可以像普通指针一样使用。</p><h4 id="unique-ptr-对象的简单使用"><a href="#unique-ptr-对象的简单使用" class="headerlink" title="unique_ptr 对象的简单使用"></a>unique_ptr 对象的简单使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Task</span>(<span class="keyword">int</span> id) {</span><br><span class="line"><span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">cout &lt;&lt; <span class="string">"构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Task</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">23</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"id = "</span> &lt;&lt; taskPtr-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数被调用</span><br><span class="line">id = 23</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></tbody></table></figure><p><code>unique_ptr&lt;Task&gt;</code> 对象 <code>taskPtr</code> 接受原始指针作为参数。当 <code>main</code> 函数退出时，该对象超出作用范围就会自动调用自身的析构函数。在 <code>unique_ptr&lt;Task&gt;</code> 对象 <code>taskPtr</code> 的析构函数中，会删除关联的原始指针，这样就不用专门执行 Task 对象的 <code>delete</code> 操作了。以后不管函数正常退出还是异常退出（由于某些异常），也会始终调用 <code>taskPtr</code> 对象的析构函数。因此，原始指针将始终被删除并防止内存泄漏。</p><h4 id="unique-ptr-对象独享所有权"><a href="#unique-ptr-对象独享所有权" class="headerlink" title="unique_ptr 对象独享所有权"></a>unique_ptr 对象独享所有权</h4><p><code>unique_ptr</code> 对象始终是关联的原始指针的唯一所有者，因此开发者无法通过拷贝构造函数或赋值运算符复制 <code>unique_ptr</code> 对象的副本，只能移动它。由于每个 <code>unique_ptr</code> 对象都是原始指针的唯一所有者，因此在其析构函数中，它可以直接删除关联的指针，不需要任何参考计数。</p><h3 id="智能指针的基础操作"><a href="#智能指针的基础操作" class="headerlink" title="智能指针的基础操作"></a>智能指针的基础操作</h3><h4 id="获取被管理对象的原始指针"><a href="#获取被管理对象的原始指针" class="headerlink" title="获取被管理对象的原始指针"></a>获取被管理对象的原始指针</h4><p>在 <code>unique_ptr</code> 对象上调用 <code>get()</code> 函数，可以获取管理对象的原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task *p1 = taskPtr.<span class="built_in">get</span>();</span><br></pre></td></tr></tbody></table></figure><h4 id="检查-unique-ptr-对象是否为空"><a href="#检查-unique-ptr-对象是否为空" class="headerlink" title="检查 unique_ptr 对象是否为空"></a>检查 unique_ptr 对象是否为空</h4><p>有两种方法创建一个空的 <code>unique_ptr</code> 对象，因为没有与之关联的原始指针，所以它是空的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; ptr;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></tbody></table></figure><p>有两种方法可以检查 <code>unique_ptr</code> 对象是否为空或者是否有与之关联的原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ptr) {</span><br><span class="line">cout&lt;&lt;<span class="string">"ptr is empty"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>){</span><br><span class="line">cout&lt;&lt;<span class="string">"ptr is empty"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用原始指针创建-unique-ptr-对象"><a href="#使用原始指针创建-unique-ptr-对象" class="headerlink" title="使用原始指针创建 unique_ptr 对象"></a>使用原始指针创建 unique_ptr 对象</h4><p>要创建非空的 <code>unique_ptr</code> 对象，需要在创建对象时在其构造函数中传递原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">22</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr</span><span class="params">(<span class="keyword">new</span> unique_ptr&lt;Task&gt;::element_type(<span class="number">23</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>不能通过赋值的方法创建 <code>unique_ptr</code> 对象</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Task&gt; taskPtr = <span class="keyword">new</span> <span class="built_in">Task</span>();     <span class="comment">// 错误写法，编译失败</span></span><br></pre></td></tr></tbody></table></figure><h3 id="智能指针的进阶操作"><a href="#智能指针的进阶操作" class="headerlink" title="智能指针的进阶操作"></a>智能指针的进阶操作</h3><h4 id="重置-unique-ptr-对象"><a href="#重置-unique-ptr-对象" class="headerlink" title="重置 unique_ptr 对象"></a>重置 unique_ptr 对象</h4><p>在 <code>unique_ptr</code> 对象上调用 <code>reset()</code> 函数可以重置它，即它会 <code>delete</code> 已关联的原始指针，并将 <code>unique_ptr</code> 对象设置为空</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskPtr.<span class="built_in">reset</span>();</span><br></pre></td></tr></tbody></table></figure><h4 id="unique-ptr-对象不允许复制"><a href="#unique-ptr-对象不允许复制" class="headerlink" title="unique_ptr 对象不允许复制"></a>unique_ptr 对象不允许复制</h4><p>由于 <code>unique_ptr</code> 不可复制，只能移动。因此，无法通过拷贝构造函数或赋值运算符创建 <code>unique_ptr</code> 对象的副本</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr1</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">22</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr2</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">35</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;Task&gt; taskPtr4 = taskPtr1;  <span class="comment">// 错误写法，编译失败</span></span><br><span class="line"></span><br><span class="line">taskPtr2 = taskPtr1;    <span class="comment">// 错误写法，编译失败</span></span><br></pre></td></tr></tbody></table></figure><h4 id="转移-unique-ptr-对象的所有权"><a href="#转移-unique-ptr-对象的所有权" class="headerlink" title="转移 unique_ptr 对象的所有权"></a>转移 unique_ptr 对象的所有权</h4><p>不允许复制 <code>unique_ptr</code> 对象，但可以转移它们。这意味着 <code>unique_ptr</code> 对象可以将自身关联的原始指针的所有权转移给另一个 <code>unique_ptr</code> 对象</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过原始指针创建taskPtr1</span></span><br><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr1</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">55</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把taskPtr1中关联指针的所有权转移给taskPtr2</span></span><br><span class="line">unique_ptr&lt;Task&gt; taskPtr2 = <span class="built_in">move</span>(taskPtr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// taskPtr1关联指针的所有权现在转移到了taskPtr2中，此时taskPtr1关联的指针为空</span></span><br><span class="line"><span class="keyword">if</span> (taskPtr1 == <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr1 is empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// taskPtr1关联指针的所有权现在转移到了taskPtr2中，此时taskPtr2关联的指针不为空</span></span><br><span class="line"><span class="keyword">if</span> (taskPtr2 != <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr2 is not empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; taskPtr2-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskPtr1 is  empty</span><br><span class="line">taskPtr2 is not empty</span><br><span class="line">55</span><br></pre></td></tr></tbody></table></figure><h4 id="释放-unique-ptr-对象关联的原始指针"><a href="#释放-unique-ptr-对象关联的原始指针" class="headerlink" title="释放 unique_ptr 对象关联的原始指针"></a>释放 unique_ptr 对象关联的原始指针</h4><p>在 <code>unique_ptr</code> 对象上调用 <code>release()</code> 函数，将释放其关联的原始指针的所有权，并返回原始指针，同时设置 <code>unique_ptr</code> 对象为空。特别注意，这里是释放其关联的原始指针的所有权，并没有 <code>delete</code> 原始指针，而调用 <code>reset()</code> 函数则会 <code>delete</code> 原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr1</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">55</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (taskPtr1 != <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr1 is not empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放关联指针的所有权</span></span><br><span class="line">Task* ptr = taskPtr1.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (taskPtr1 == <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr1 is empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"id = "</span> &lt;&lt; ptr-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskPtr1 is <span class="keyword">not</span> empty</span><br><span class="line">taskPtr1 is empty</span><br><span class="line">id = <span class="number">55</span></span><br></pre></td></tr></tbody></table></figure><h4 id="C-14-使用原始指针创建-unique-ptr-对象"><a href="#C-14-使用原始指针创建-unique-ptr-对象" class="headerlink" title="C++ 14 使用原始指针创建 unique_ptr 对象"></a>C++ 14 使用原始指针创建 unique_ptr 对象</h4><p>C++ 引入了新的语法，可以使用 <code>make_unique</code> 来创建 <code>unique_ptr</code> 对象，省去了 <code>new</code> 关键字的使用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Task&gt; taskPtr = make_unique&lt;Task&gt;(<span class="number">34</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="原子操作的使用"><a href="#原子操作的使用" class="headerlink" title="原子操作的使用"></a>原子操作的使用</h2><h3 id="原子操作简介"><a href="#原子操作简介" class="headerlink" title="原子操作简介"></a>原子操作简介</h3><p>所谓的原子操作，取的就是 “原子是最小的、不可分割的最小个体” 的意义，它表示在多个线程访问同一个全局资源的时候，能够确保在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。在以往的 C++ 标准中并没有对原子操作进行规定，开发人员往往是使用汇编语言，或者是借助第三方的线程库，例如 Intel 的 <code>pthread</code> 来实现。在新标准 C++ 11 中，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如 <code>atomic_bool</code>、<code>atomic_int</code> 等等。如果在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问；这样就可以保证多个线程访问这个共享资源的正确性，从而避免了锁的使用，提高了效率。在新标准 C++ 11 中，<code>atomic</code> 对 <code>int</code>、<code>char</code>、<code>bool</code> 等基础数据结构进行了原子性封装，在多线程环境中，对 <code>atomic</code> 对象的访问不会造成资源竞争，利用 <code>atomic</code> 可实现数据结构的无锁设计。</p><h3 id="atomic-的简介"><a href="#atomic-的简介" class="headerlink" title="atomic 的简介"></a>atomic 的简介</h3><p>在新标准 C++ 11 中，新增了 <code>atomic</code> 关键字，可以使用它定义一个原子类型，详见 <a href="https://zh.cppreference.com/w/cpp/atomic/atomic">C++ 参考手册一</a>、<a href="http://www.cplusplus.com/reference/atomic/">C++ 参考手册二</a>。</p><ul><li>成员函数</li></ul><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td> store</td><td> 原子地以非原子对象替换原子对象的值</td></tr><tr><td> load</td><td> 原子地获得原子对象的值</td></tr><tr><td> operator=</td><td> 存储值于原子对象</td></tr><tr><td> is_lock_free</td><td> 检查原子对象是否免锁</td></tr><tr><td> operator T</td><td> 从原子对象加载值</td></tr><tr><td> exchange</td><td> 原子地替换原子对象的值，并获得它先前持有的值</td></tr><tr><td> compare_exchange_weak、compare_exchange_strong</td><td> 原子地比较原子对象与非原子参数的值，若相等则进行交换，若不相等则进行加载</td></tr></tbody></table><ul><li>特化成员函数</li></ul><table><thead><tr><th>特化成员函数</th><th>说明</th></tr></thead><tbody><tr><td> fetch_add</td><td> 原子地将参数加到存储于原子对象的值，并返回先前保有的值</td></tr><tr><td> fetch_sub</td><td> 原子地从存储于原子对象的值减去参数，并获得先前保有的值</td></tr><tr><td> fetch_and</td><td> 原子地进行参数和原子对象的值的逐位与，并获得先前保有的值</td></tr><tr><td> fetch_or</td><td> 原子地进行参数和原子对象的值的逐位或，并获得先前保有的值</td></tr><tr><td> fetch_xor</td><td> 原子地进行参数和原子对象的值的逐位异或，并获得先前保有的值</td></tr><tr><td><code>operator++</code>、<code>operator++(int)</code>、<code>operator--</code>、<code>operator--(int)</code></td><td>令原子值增加或者减少一</td></tr><tr><td><code>operator+=</code>、<code>operator-=</code>、<code>operator&amp;=</code>、<code>operator^=</code></td><td>加、减，或者与原子值进行逐位与、异或</td></tr></tbody></table><p>值得一提的是，所谓特化函数，也就是 <code>atomic</code> 自身提供的，可以进行原子操作的函数。使用这些函数进行的操作，都是原子的。</p><h3 id="atomic-的使用案例"><a href="#atomic-的使用案例" class="headerlink" title="atomic 的使用案例"></a>atomic 的使用案例</h3><h4 id="加锁不使用-atomic"><a href="#加锁不使用-atomic" class="headerlink" title="加锁不使用 atomic"></a>加锁不使用 atomic</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="comment">// 加锁防止多个线程同时访问同一资源</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">total++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">clock_t</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个线程</span></span><br><span class="line">vector&lt;thread&gt; threads;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(threadFun));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thad : threads) {</span><br><span class="line">thad.<span class="built_in">join</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测total是否正确 10000*10 = 100000</span></span><br><span class="line">cout &lt;&lt; <span class="string">"total number:"</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"耗时："</span> &lt;&lt; end_time - start_time &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total number:10000000</span><br><span class="line">耗时：615ms</span><br></pre></td></tr></tbody></table></figure><h4 id="不加锁使用-atomic"><a href="#不加锁使用-atomic" class="headerlink" title="不加锁使用 atomic"></a>不加锁使用 atomic</h4><p>与加锁相比，使用原子操作（atomic）能大大地提高程序的运行效率。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">atomic&lt;<span class="keyword">size_t</span>&gt; <span class="title">total</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">total++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">clock_t</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个线程</span></span><br><span class="line">vector&lt;thread&gt; threads;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(threadFun));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thad : threads) {</span><br><span class="line">thad.<span class="built_in">join</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测total是否正确 10000*10 = 100000</span></span><br><span class="line">cout &lt;&lt; <span class="string">"total number:"</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"耗时："</span> &lt;&lt; end_time - start_time &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total number:10000000</span><br><span class="line">耗时：321ms</span><br></pre></td></tr></tbody></table></figure><h3 id="为什么要定义一个原子类型"><a href="#为什么要定义一个原子类型" class="headerlink" title="为什么要定义一个原子类型"></a>为什么要定义一个原子类型</h3><p>举个例子，<code>int64_t</code> 类型，在 32 位机器上为非原子操作。更新时该类型的值时，需要进行两步操作（高 32 位、低 32 位）。如果多线程操作该类型的变量，且在操作时未加锁，可能会出现读脏数据的情况。解决该问题的话，可以使用加锁，或者提供一种定义原子类型的方法。</p><ul><li>定义原子类型 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个"int64_t"的原子类型</span></span><br><span class="line">std::atomic&lt;<span class="keyword">int64_t</span>&gt; value;</span><br></pre></td></tr></tbody></table></figure><ul><li>自加操作（原子）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic提供的特化成员函数，已经重载了++运算符</span></span><br><span class="line">value++</span><br></pre></td></tr></tbody></table></figure><ul><li>读取变量值（原子）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处的原子操作，指的是读取value的值这一步，而不是将value的值赋给x</span></span><br><span class="line"><span class="keyword">int64_t</span> x = value.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br></pre></td></tr></tbody></table></figure><ul><li>更新变量（原子）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> x = <span class="number">10</span>;</span><br><span class="line">value.<span class="built_in">store</span>(x, std::memory_order_relaxed)</span><br></pre></td></tr></tbody></table></figure><h3 id="atomic-不能与-string-一起使用"><a href="#atomic-不能与-string-一起使用" class="headerlink" title="atomic 不能与 string 一起使用"></a>atomic 不能与 string 一起使用</h3><p>特别注意，<code>atomic</code> 关键字不能与 <code>string</code> 类型一起使用，因为 <code>string</code> 不是可简单复制的类型（TriviallyCopyable），详见 <a href="https://en.cppreference.com/w/cpp/atomic/atomic">C++ 参考文档</a>：</p><blockquote><p>The primary std::atomic template may be instantiated with any TriviallyCopyable type T satisfying both CopyConstructible and CopyAssignable.</p></blockquote><hr><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">std::atomic&lt;std::string&gt; str{ <span class="string">"Hello"</span> };</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码编译后，C++ 编译器会出现编译错误，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C2338: atomic&lt;T&gt; requires T to be trivially copyable, copy constructible, move constructible, copy assignable, and move assignable.</span><br></pre></td></tr></tbody></table></figure><p>关于 C++ 编译器为什么会对 <code>std::atomic&lt;std::string&gt;</code> 给出简单的可复制错误，在 <a href="https://stackoverflow.com/questions/58852618/">Stack Overflow</a> 上找到了一个类似的问题可供参考。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://www.cnblogs.com/taiyang-li/p/5914331.html">C++11 新特性之 atomic</a></li><li><a href="https://blog.csdn.net/shaosunrise/article/details/85158249">C++ 智能指针 unique_ptr 详解与示例</a></li><li><a href="https://zhuanlan.zhihu.com/p/91328039">为何优先选用 unique_ptr 而不是裸指针？</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括智能指针、atomic 原子操作的介绍等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 使用 API 连接 MySQL 数据库</title>
    <link href="https://www.techgrow.cn/posts/c942e1de.html"/>
    <id>https://www.techgrow.cn/posts/c942e1de.html</id>
    <published>2021-11-24T13:55:33.000Z</published>
    <updated>2021-11-24T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 C++ 如何使用 MySQL Connector/C++ 的 API 连接 MySQL 数据库，适用于 Windows 系统，MySQL Connector/C++ 的详细介绍可以看<a href="/posts/c942e1de.html#MySQL-Connector-C-%E4%BB%8B%E7%BB%8D">这里</a>。</p><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><table><thead><tr><th>软件</th><th>版本</th><th>默认安装路径</th></tr></thead><tbody><tr><td> MySQL Connector/C++</td><td>1.1.13</td><td>C:\Program Files\MySQL\MySQL Connector C++ 1.1.13</td></tr><tr><td>OpenSSL</td><td>v1.1.1L</td><td>C:\Program Files\OpenSSL-Win64</td></tr><tr><td>boost</td><td>1_77_0</td><td>C:\Program Files\boost_1_77_0</td></tr><tr><td>MySQL Server</td><td>5.7.33</td><td></td></tr><tr><td>C++</td><td>11</td><td></td></tr><tr><td>Visual Studio</td><td>2019</td><td></td></tr><tr><td>Windows System</td><td>Win 10</td><td></td></tr></tbody></table><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="OpenSSL-安装"><a href="#OpenSSL-安装" class="headerlink" title="OpenSSL 安装"></a>OpenSSL 安装</h3><h4 id="安装-OpenSSL"><a href="#安装-OpenSSL" class="headerlink" title="安装 OpenSSL"></a>安装 OpenSSL</h4><p>在 <a href="https://slproweb.com/products/Win32OpenSSL.html">OpenSSL 官网</a> 下载 <code>Win64 OpenSSL v1.1.1L</code> 版本的安装包，下载完成后直接安装，每一步安装步骤选择默认选项即可。OpenSSL 默认的安装路径是 <code>C:\Program Files\OpenSSL-Win64</code>。</p><h4 id="VS-项目添加-OpenSSL-的-库文件"><a href="#VS-项目添加-OpenSSL-的-库文件" class="headerlink" title="VS 项目添加 OpenSSL 的 库文件"></a>VS 项目添加 OpenSSL 的 库文件</h4><p>OpenSSL 安装完成之后，将其安装目录下的 <code>bin</code> 文件夹中的 <code>libssl-1_1-x64.dll</code> 和 <code>libcrypto-1_1-x64.dll</code> 库文件拷贝到 VS 项目的目录中，如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-mysql-5.png"></p><h4 id="VS-项目引入-OpenSSL-的-头文件"><a href="#VS-项目引入-OpenSSL-的-头文件" class="headerlink" title="VS 项目引入 OpenSSL 的 头文件"></a>VS 项目引入 OpenSSL 的 头文件</h4><p>右键项目，选择 <code>属性</code>，导航到 <code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code>，添加 OpenSSL 头文件所在的目录路径（如 <code>C:\Program Files\OpenSSL-Win64\include</code>），如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-mysql2.png"></p><h3 id="MySQL-Connector-C-安装"><a href="#MySQL-Connector-C-安装" class="headerlink" title="MySQL Connector/C++ 安装"></a>MySQL Connector/C++ 安装</h3><h4 id="安装-MySQL-Connector-C"><a href="#安装-MySQL-Connector-C" class="headerlink" title="安装 MySQL Connector/C++"></a>安装 MySQL Connector/C++</h4><p>在 <a href="https://dev.mysql.com/downloads/connector/cpp/">MySQL 官网</a> 上下载 <code>1.1.13</code> 版本的 MySQL Connector/C++，下载完成后直接安装即可。若已经本地已经安装过 MySQL Server，则不再需要手动安装 MySQL Connector/C++，因为默认已经安装过了，但需要留意 MySQL Connector/C++ 与 MySQL 的版本是否匹配 。值得一提的是，MySQL Connector/C++ 支持多个版本共存（同时安装不同的版本），其默认的安装路径为 <code>C:\Program Files\MySQL\Connector.C++ 1.x</code>。</p><h4 id="VS-项目添加-MySQL-Connector-C-的-库文件"><a href="#VS-项目添加-MySQL-Connector-C-的-库文件" class="headerlink" title="VS 项目添加 MySQL Connector/C++ 的 库文件"></a>VS 项目添加 MySQL Connector/C++ 的 库文件</h4><p>MySQL Connector/C++ 安装完成后，将其安装目录下 <code>lib/opt</code> 文件夹中的 <code>mysqlcppconn.dll</code> 与 <code>mysqlcppconn.lib</code> 库文件拷贝到 VS 项目的目录中，如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-mysql-1.png"></p><h4 id="VS-项目引入-MySQL-Connector-C-的头文件"><a href="#VS-项目引入-MySQL-Connector-C-的头文件" class="headerlink" title="VS 项目引入 MySQL Connector/C++ 的头文件"></a>VS 项目引入 MySQL Connector/C++ 的头文件</h4><p>右键项目，选择 <code>属性</code>，导航到 <code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code>，添加 MySQL Connector/C++ 头文件所在的目录路径（如 <code>C:\Program Files\MySQL\MySQL Connector C++ 1.1.13\include</code>），如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-mysql-2.png"></p><h2 id="C-连接-MySQL-的实战案例"><a href="#C-连接-MySQL-的实战案例" class="headerlink" title="C++ 连接 MySQL 的实战案例"></a>C++ 连接 MySQL 的实战案例</h2><h3 id="MySQL-数据库初始化"><a href="#MySQL-数据库初始化" class="headerlink" title="MySQL 数据库初始化"></a>MySQL 数据库初始化</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `t_shop`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `t_shop` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line">USE `t_shop`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `properties`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `properties` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `KEY` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="keyword">VALUE</span>` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `REMARK` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `key_unique_index` (`KEY`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">27</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 往数据库表插入数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_price'</span>, <span class="string">'30.5'</span>, <span class="string">'限制价格'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_number'</span>, <span class="string">'430'</span>, <span class="string">'限制数量'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_balance'</span>, <span class="string">'929.32'</span>, <span class="string">'限制余额'</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="C-连接-MySQL-的代码"><a href="#C-连接-MySQL-的代码" class="headerlink" title="C++ 连接 MySQL 的代码"></a>C++ 连接 MySQL 的代码</h3><ul><li>mysqldb.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql_connection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/driver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/exception.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/resultset.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/statement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/prepared_statement.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sql;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL数据库操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlDB</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MysqlDB</span>(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string database);</span><br><span class="line">~<span class="built_in">MysqlDB</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ExecuteUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">Query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* query, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string host;</span><br><span class="line">string username;</span><br><span class="line">string password;</span><br><span class="line">string database;</span><br><span class="line">Driver* driver;</span><br><span class="line">unique_ptr&lt;Connection&gt; connection;  <span class="comment">// 智能指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>mysqldb.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysqldb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MysqlDB::<span class="built_in">MysqlDB</span>(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string database) {</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化MySQL的连接信息</span></span><br><span class="line"><span class="keyword">this</span>-&gt;host = host;</span><br><span class="line"><span class="keyword">this</span>-&gt;username = username;</span><br><span class="line"><span class="keyword">this</span>-&gt;password = password;</span><br><span class="line"><span class="keyword">this</span>-&gt;database = database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">// 加载MySQL驱动</span></span><br><span class="line"><span class="keyword">this</span>-&gt;driver = <span class="built_in">get_driver_instance</span>();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;driver) {</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"failed to load mysql driver"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接MySQL实例</span></span><br><span class="line"><span class="keyword">this</span>-&gt;connection.<span class="built_in">reset</span>(driver-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;host.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;username.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;password.<span class="built_in">c_str</span>()));</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;connection) {</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"failed to connect mysql server"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="comment">// 设置默认数据库</span></span><br><span class="line"><span class="keyword">this</span>-&gt;connection-&gt;<span class="built_in">setSchema</span>(<span class="keyword">this</span>-&gt;database.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SQLException&amp; e) {</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: SQLException in "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">"("</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">") on line "</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MysqlDB::~<span class="built_in">MysqlDB</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行任何 SQL 语句，返回一个 bool 值，表明执行该 SQL 语句是否返回了 ResultSet</span></span><br><span class="line"><span class="comment">// 如果执行后第一个结果是 ResultSet，则返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlDB::Execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;connection) {</span><br><span class="line">unique_ptr&lt;Statement&gt; statement = <span class="literal">nullptr</span>;</span><br><span class="line">statement.<span class="built_in">reset</span>(<span class="keyword">this</span>-&gt;connection-&gt;<span class="built_in">createStatement</span>());</span><br><span class="line"><span class="keyword">if</span> (statement)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> statement-&gt;<span class="built_in">execute</span>(sql);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SQLException&amp; e) {</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: SQLException in "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">"("</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">") on line "</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE</span></span><br><span class="line"><span class="comment">// 函数的返回值是一个整数，指示受影响的行数，对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，返回值总为零</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MysqlDB::ExecuteUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;connection) {</span><br><span class="line">unique_ptr&lt;Statement&gt; statement = <span class="literal">nullptr</span>;</span><br><span class="line">statement.<span class="built_in">reset</span>(<span class="keyword">this</span>-&gt;connection-&gt;<span class="built_in">createStatement</span>());</span><br><span class="line"><span class="keyword">if</span> (statement)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> statement-&gt;<span class="built_in">executeUpdate</span>(sql);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SQLException&amp; e) {</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: SQLException in "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">"("</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">") on line "</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 SQL 的预编译机制，执行查询单个结果集（ResultSet）的 SQL 语句，例如 SELECT 语句</span></span><br><span class="line"><span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">MysqlDB::Query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span> </span>{</span><br><span class="line">unique_ptr&lt;ResultSet&gt; resultSet = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;connection) {</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">unique_ptr&lt;PreparedStatement&gt; statement = <span class="literal">nullptr</span>;</span><br><span class="line">statement.<span class="built_in">reset</span>(<span class="keyword">this</span>-&gt;connection-&gt;<span class="built_in">prepareStatement</span>(sql));</span><br><span class="line"><span class="keyword">if</span> (statement) {</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iterator = parameters.<span class="built_in">cbegin</span>(); iterator != parameters.<span class="built_in">cend</span>(); iterator++) {</span><br><span class="line">index++;</span><br><span class="line">statement-&gt;<span class="built_in">setString</span>(index, (*iterator).<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line">resultSet.<span class="built_in">reset</span>(statement-&gt;<span class="built_in">executeQuery</span>());</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SQLException&amp; e) {</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: SQLException in "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">"("</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">") on line "</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> resultSet;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysqldb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">unique_ptr&lt;MysqlDB&gt; <span class="title">db</span><span class="params">(<span class="keyword">new</span> MysqlDB(<span class="string">"tcp://127.0.0.1:3306"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>, <span class="string">"t_shop"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">string querySql = <span class="string">"select * from properties where `KEY` = ?"</span>;</span><br><span class="line">unique_ptr&lt;ResultSet&gt; result = db-&gt;<span class="built_in">Query</span>(querySql.<span class="built_in">c_str</span>(), { <span class="string">"test_limit_price"</span> });</span><br><span class="line"><span class="keyword">if</span> (result) {</span><br><span class="line">cout &lt;&lt; <span class="string">"Query: "</span> &lt;&lt; querySql &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (result-&gt;<span class="built_in">next</span>()) {</span><br><span class="line">cout &lt;&lt; result-&gt;<span class="built_in">getInt</span>(<span class="string">"ID"</span>) &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"KEY"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"VALUE"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"REMARK"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query: select * from properties where `KEY` = ?</span><br><span class="line">27 | test_limit_price | 30.5 | 限制价格 |</span><br></pre></td></tr></tbody></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="缺失-Boost-库"><a href="#缺失-Boost-库" class="headerlink" title="缺失 Boost 库"></a>缺失 Boost 库</h3><p>错误信息：</p><ul><li>项目执行编译操作后，VS 出现下述错误信息，这是本地缺失 <code>boost</code> 库导致的。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error C1083: 无法打开包括文件: “boost/shared_ptr.hpp”: No such file or directory</span><br></pre></td></tr></tbody></table></figure></li></ul><p>解决方法：</p><ul><li>a) 在 <a href="https://www.boost.org/users/download/">Boost 官网</a> 下载最新版本的 <code>Boost</code>，并解压到本地磁盘，例如解压路径为：<code>C:\Program Files\boost_1_77_0</code></li><li>b) 右键项目，选择 <code>属性</code>，导航到 <code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code>，添加 <code>Boost</code> 的安装路径（如 <code>C:\Program Files\boost_1_77_0</code>），如下图所示</li><li> c) 重新执行项目的编译操作</li></ul><p><img data-src="../../../asset/2021/11/cplusplus-mysql-3.png"></p><h3 id="缺失-libssl-1-1-64-dll-文件"><a href="#缺失-libssl-1-1-64-dll-文件" class="headerlink" title="缺失 libssl-1_1-64.dll 文件"></a>缺失 libssl-1_1-64.dll 文件</h3><p>错误信息：</p><ul><li>项目运行后，系统弹窗提示以下错误信息。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于找不到 libssl-1_1-64.dll，无法继续执行代码。重新安装程序可能会解决此问题。</span><br></pre></td></tr></tbody></table></figure></li></ul><p>解决方法：</p><ul><li>安装 OpenSSL，并拷贝 <code>libssl-1_1-64.dll</code> 库文件到 VS 项目的目录中，具体步骤可参考上面的 <a href="/posts/c942e1de.html#OpenSSL-%E5%AE%89%E8%A3%85">OpenSSL - 安装</a> 教程。</li></ul><h3 id="缺失-libcrypto-1-1-x64-dll-文件"><a href="#缺失-libcrypto-1-1-x64-dll-文件" class="headerlink" title="缺失 libcrypto-1_1-x64.dll 文件"></a>缺失 libcrypto-1_1-x64.dll 文件</h3><p>错误信息：</p><ul><li>项目运行后，系统弹窗提示以下错误信息。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于找不到 libcrypto-1_1-x64.dll，无法继续执行代码。重新安装程序可能会解决此问题。</span><br></pre></td></tr></tbody></table></figure></li></ul><p>解决方法：</p><ul><li>安装 OpenSSL，并拷贝 <code>libcrypto-1_1-x64.dll</code> 库文件到 VS 项目的目录中，具体步骤可参考上面的 <a href="/posts/c942e1de.html#OpenSSL-%E5%AE%89%E8%A3%85">OpenSSL - 安装</a> 教程。</li></ul><h2 id="MySQL-Connector-C-介绍"><a href="#MySQL-Connector-C-介绍" class="headerlink" title="MySQL Connector/C++ 介绍"></a>MySQL Connector/C++ 介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://dev.mysql.com/doc/connector-cpp/1.1/en/connector-cpp-introduction.html">MySQL Connector/C++</a> 是一个 MySQL 数据库连接器，包含了 C++ 连接 MySQL 服务器所需的头文件和库文件，支持开发使用基于 JDBC 的 API 的 C++ 应用程序。</p><h3 id="开发优势"><a href="#开发优势" class="headerlink" title="开发优势"></a>开发优势</h3><p>与 MySQL 客户端库提供的 MySQL C 语言 API 相比，MySQL Connector/C++ 为 C++ 用户提供以下好处：</p><ul><li>纯 C++ 开发的便利</li><li>支持基于 JDBC 4.0 的 API</li><li> 支持面向对象的编程范式</li><li>减少项目的开发时间</li><li>可根据要求获得商业许可证</li><li>根据 GPL 获得许可，但 FLOSS 许可除外</li></ul><h3 id="分发方式"><a href="#分发方式" class="headerlink" title="分发方式"></a>分发方式</h3><p>MySQL Connector/C++ 有二进制文件和源代码分发版以特定于平台的打包格式提供：</p><ul><li>二进制分发版可用于 Windows、Linux、Unix 和类 Unix 平台</li><li>源代码分发版可作为压缩的 <code>tar</code> 文件或 <code>zip</code> 文件提供，并可在任何受支持的平台上使用</li><li>源代码存储库使用 Git 存储，可在 <a href="https://github.com/mysql/mysql-connector-cpp">GitHub</a> 上获得。</li></ul><h3 id="与-JDBC-的兼容性"><a href="#与-JDBC-的兼容性" class="headerlink" title="与 JDBC 的兼容性"></a>与 JDBC 的兼容性</h3><p>MySQL Connector/C++ 与 JDBC 4.0 API 兼容，没有实现整个 JDBC 4.0 API，但具有以下类：Connection、DatabaseMetaData、Driver、PreparedStatement、ResultSet、ResultSetMetaData、Savepoint、Statement。JDBC 4.0 API 为刚才提到的类定义了大约 450 个方法，MySQL Connector/C++ 实现了其中的大约 80%。</p><h3 id="支持的平台和先决条件"><a href="#支持的平台和先决条件" class="headerlink" title="支持的平台和先决条件"></a>支持的平台和先决条件</h3><p>对于 MySQL Connector/C++ 1.1.11 及更高版本，商业和社区发行版需要 Visual C++ Redistributable for Visual Studio 2015 才能在 Windows 平台上运行。从 MySQL Connector/C++ 1.1.10 开始，社区（非商业）发行版需要适用于 Visual Studio 2013 的 Visual C++ Redistributable。可在 <a href="http://www.microsoft.com/en-us/download/default.aspx">Microsoft 下载中心</a>获取 Redistributable 的安装包，在安装 MySQL Connector/C++ 之前安装它。</p><ul><li><p>要运行带 MySQL Connector/C++ 的应用程序，需要 MySQL 5.6 或更高版本的数据库服务器</p></li><li><p>要构建带 MySQL Connector/C++ 的应用程序</p><ul><li>在 Windows 系统上，需要 Microsoft Visual Studio 2015</li></ul></li><li><p> 要从源代码构建 MySQL Connector/C++</p><ul><li>在 Windows 系统上，需要 Microsoft Visual Studio 2015</li><li>Building Connector/C++ 需要 MySQL 5.7（5.7.9 或更高版本）或 MySQL 8.0（8.0.11 或更高版本）的客户端库</li></ul></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/daelsepara/mysql-connector-demo">mysql-connector-demo</a></li><li><a href="https://dev.mysql.com/doc/connector-cpp/1.1/en/">MySQL Connector/C++ 官方文档</a></li><li><a href="https://github.com/mysql/mysql-connector-cpp">MySQL Connector/C++ Github 仓库</a></li><li><a href="https://dev.mysql.com/doc/connector-cpp/1.1/en/connector-cpp-getting-started-examples.html">MySQL Connector/C++ 官方 API 使用教程</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 如何使用 MySQL Connector/C++ 的 API 连接 MySQL 数据库。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之九</title>
    <link href="https://www.techgrow.cn/posts/f1a16291.html"/>
    <id>https://www.techgrow.cn/posts/f1a16291.html</id>
    <published>2021-11-19T13:55:33.000Z</published>
    <updated>2021-11-21T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h2><h3 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h3><ul><li>当类中声明了虚函数时，编译器会在类中生成一个虚函数表</li><li>虚函数表是一个存储类成员函数指针的数据结构</li><li>虚函数表是由编译器自动生成和维护的</li><li>虚函数（<code>virtual</code>）会被编译器放入虚函数表中</li><li>当存在虚函数时，每个对象中都有一个指向虚函数表的指针（C++ 编译器给父类对象、子类对象提前设置了 <code>VPTR</code> 虚函数表指针，因此 C++ 编译器不需要区分子类对象或者父类对象，只需要在 <code>base</code> 指针中，找 <code>VPTR</code> 指针即可）</li><li><code>VPTR</code> 虚函数表指针一般作为类对象的第一个成员</li></ul><span id="more"></span><h3 id="多态的实现原理图解"><a href="#多态的实现原理图解" class="headerlink" title="多态的实现原理图解"></a>多态的实现原理图解</h3><ul><li>a) 多态实现原理的图解 <a href="../../../asset/2021/11/cplusplus-virtual-1.png">如图</a> 所示</li><li> b) 通过 <code>VPTR</code> 虚函数表指针调用重写函数的过程是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数，而普通成员函数是在编译时就确定了调用的函数</li><li> c) 在效率上，虚函数的效率要低很多，因此出于效率考虑，没有必要将所有成员函数都声明为虚函数，即使 C++ 编译器允许这么做</li><li> d) 由于有了虚函数表，C++ 编译器不再需要知道是子类对象还是父类对象，这往往会给我们造成一种假象：C++ 编译器能识别子类对象或者父类对象</li></ul><h3 id="证明-VPTR-指针的存在"><a href="#证明-VPTR-指针的存在" class="headerlink" title="证明 VPTR 指针的存在"></a>证明 <code>VPTR</code> 指针的存在</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent1</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不声明虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent1"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent2</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent2"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 由于指针也是一种数据类型，由于在Parent2类中声明了虚函数，若Parent2类里存在VPTR指针，那么下面两个类的大小应该是不一样的</span></span><br><span class="line">cout &lt;&lt; <span class="string">"sizeof(Parent1): "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Parent1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"sizeof(Parent2): "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Parent2) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Parent1): 4</span><br><span class="line">sizeof(Parent2): 8</span><br></pre></td></tr></tbody></table></figure><h3 id="父类指针和子类指针的步长可能是不一样的"><a href="#父类指针和子类指针的步长可能是不一样的" class="headerlink" title="父类指针和子类指针的步长可能是不一样的"></a>父类指针和子类指针的步长可能是不一样的</h3><ul><li>a) 指针也只一种数据类型，对 C++ 类对象的指针执行 <code>++</code>、<code>--</code> 运算符仍然是合法的</li><li> b) <code>"多态是用父类的指针指向子类的对象"</code> 和 <code>"父类指针步长的自加（++）"</code> 是两个完全不同的概念</li><li> c) 当子类继承父类后，没有添加任何自己的成员变量和成员函数，那么此时父类指针和子类指针的步长才是一样的</li><li> d) 指针运算是按照指针所指的类型进行的，父类指针和子类指针的步长可能是不一样的，不要用父类指针自加（<code>++</code>）、自减（<code>--</code>）的方式来操作子类的对象数组 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a = <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> b, <span class="keyword">int</span> c) :<span class="built_in">Parent</span>(<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Parent* parent = <span class="literal">NULL</span>;</span><br><span class="line">Child* child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Child  array[] = { <span class="built_in">Child</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">Child</span>(<span class="number">3</span>,<span class="number">4</span>), <span class="built_in">Child</span>(<span class="number">5</span>, <span class="number">6</span>) };</span><br><span class="line">parent = array;</span><br><span class="line">child = array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针自加运算后运行可能会出错，这里父类指针和子类指针的步长是不一样的，不要用父类指针自加（`++`）、自减（`--`）的方式来操作子类的对象数组</span></span><br><span class="line">parent++;</span><br><span class="line">child++;</span><br><span class="line"></span><br><span class="line">parent++;</span><br><span class="line">child++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="在父类的构造函数中调用虚函数，不能实现多态"><a href="#在父类的构造函数中调用虚函数，不能实现多态" class="headerlink" title="在父类的构造函数中调用虚函数，不能实现多态"></a>在父类的构造函数中调用虚函数，不能实现多态</h3><p>子类的 <code>VPTR</code> 指针是分步完成初始化的，当执行父类的构造函数时，子类 的 <code>VPTR</code> 指针指向父类的虚函数表，当父类的构造函数执行完毕后，才会把子类的 <code>VPTR</code> 指针指向子类的虚函数表。因此，<strong>在父类的构造函数中调用虚函数，不能实现多态</strong>。</p><ul><li>a) 分析图解 <a href="../../../asset/2021/11/cplusplus-virtual-2.png">如图</a> 所示</li><li> b) 对象在创建的时，由编译器对 <code>VPTR</code> 指针进行初始化</li><li> c) 只有当对象的构造全部完成后，<code>VPTR</code> 指针的指向才能最终确定 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="comment">// 在父类的构造函数中调用虚函数</span></span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> c) : <span class="built_in">Parent</span>(a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">5</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I'm parent, a = 5</span><br></pre></td></tr></tbody></table></figure><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><h3 id="纯虚函数和抽象类的基本概念"><a href="#纯虚函数和抽象类的基本概念" class="headerlink" title="纯虚函数和抽象类的基本概念"></a>纯虚函数和抽象类的基本概念</h3><p>基本概念：</p><ul><li>a) 纯虚函数是一个在基类中说明的虚函数，且在基类中没有被定义，要求任何派生类都定义自己的版本</li><li> b) 纯虚函数为各派生类提供一个公共界面，可以实现接口的封装和设计、软件的模块功能划分</li><li> c) 纯虚函数的声明形式： <code>virtual  类型  函数名 ( 参数表 ) = 0;</code></li><li>d) 一个具有纯虚函数的基类称为抽象类</li></ul><p>使用限制：</p><ul><li>a) 可以声明抽象类的指针和引用</li><li> b) 抽象类不能创建对象（实例化）</li><li>c) 抽象类不能作为函数的参数类型和返回值类型</li></ul><p><img data-src="../../../asset/2021/11/cplusplus-virtual-3.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-virtual-4.png"></p><h3 id="纯虚函数和抽象类的应用案例"><a href="#纯虚函数和抽象类的应用案例" class="headerlink" title="纯虚函数和抽象类的应用案例"></a>纯虚函数和抽象类的应用案例</h3><p>定义一个图形抽象类 Figure，并声明了负责计算图形面积的纯虚函数 <code>getArea()</code>，然后再定义 Circle、Triangle、Squre 派生类，并各自实现了纯虚函数 <code>getArea()</code> 来计算不同图形的面积。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 声明纯虚函数，计算面积</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Circle</span>(<span class="keyword">double</span> r) {</span><br><span class="line"><span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算圆的面积</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">double</span> area = <span class="number">3.14</span> * r * r;</span><br><span class="line">cout &lt;&lt; <span class="string">"圆的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Triangle</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算三角形的面积</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">double</span> area = a * b / <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"三角形的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Square</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算四边形的面积</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">double</span> area = a * b;</span><br><span class="line">cout &lt;&lt; <span class="string">"四边形的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArea</span><span class="params">(Figure* base)</span> </span>{</span><br><span class="line">base-&gt;<span class="built_in">getArea</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// Figure f;// 错误写法，抽象类不能实例化</span></span><br><span class="line"></span><br><span class="line"><span class="function">Triangle <span class="title">Triangle</span><span class="params">(<span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">6.8</span>)</span></span>;</span><br><span class="line"><span class="function">Square <span class="title">square</span><span class="params">(<span class="number">50</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以声明抽象类的指针</span></span><br><span class="line">Figure* pBase = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">5.3</span>);</span><br><span class="line">pBase-&gt;<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以声明抽象类的引用</span></span><br><span class="line">Figure&amp; base = square;</span><br><span class="line">base.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printArea</span>(&amp;Triangle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">圆的面积: 88.2026</span><br><span class="line">四边形的面积: 3000</span><br><span class="line">三角形的面积: 300</span><br></pre></td></tr></tbody></table></figure><h3 id="纯虚函数和抽象类在多继承中的应用案例"><a href="#纯虚函数和抽象类在多继承中的应用案例" class="headerlink" title="纯虚函数和抽象类在多继承中的应用案例"></a>纯虚函数和抽象类在多继承中的应用案例</h3><p>C++ 中没有 Java 中的接口概念，但可以使用抽象类和纯虚函数模拟 Java 中的接口（代码如下）。值得一提的是，C++ 中的接口类只有函数原型定义，没有任何数据的定义，同时继承多个接口类不会带来二义性和复杂性等问题。C++ 面向抽象类编程（Java 面向接口编程）是项目开发中重要技能之一。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口类一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口类二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>() {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = <span class="number">8</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Parent</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类，首先继承父类，然后继承多个接口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent, <span class="keyword">public</span> Interface1, <span class="keyword">public</span> Interface2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"Child::print() 函数被执行"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Child child;</span><br><span class="line">child.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Parent* parent = &amp;child;</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; parent-&gt;<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Interface1* interface1 = &amp;child;</span><br><span class="line"><span class="keyword">int</span> result1 = interface1-&gt;<span class="built_in">add</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"2 + 5 = "</span> &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Interface2* interface2 = &amp;child;</span><br><span class="line"><span class="keyword">int</span> result2 = interface2-&gt;<span class="built_in">mult</span>(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"3 * 6 = "</span> &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 8</span><br><span class="line">2 + 5 = 7</span><br><span class="line">3 * 6 = 18</span><br></pre></td></tr></tbody></table></figure><h3 id="纯虚函数和抽象类在多继承中的使用总结"><a href="#纯虚函数和抽象类在多继承中的使用总结" class="headerlink" title="纯虚函数和抽象类在多继承中的使用总结"></a>纯虚函数和抽象类在多继承中的使用总结</h3><p>C++ 中没有 Java 中的接口概念：</p><ul><li>绝大多数面向对象语言都不支持多继承</li><li>绝大多数面向对象语言都支持接口的概念 </li><li>C++ 中没有 Java 中的接口概念，但可以使用抽象类和纯虚函数模拟 Java 中的接口</li><li> C++ 中的接口类只有函数原型定义，没有任何数据的定义（代码如下）<details><summary>★点击显示示例代码★</summary><code><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface</span>  </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>; </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></code></details></li></ul><p>工程上多继承的使用说明：</p><ul><li>a) 多继承已经被实际开发经验所抛弃</li><li> b) 工程开发中真正意义上的多继承是几乎不被使用的</li><li> c) 多继承带来的代码复杂性远多于其带来的便利</li><li> d) 多继承对代码维护性上的影响是灾难性的</li><li> e) 在设计方法上，任何多继承都可以使用单继承代替</li><li> f) 在多继承中，使用虚继承不能完全解决二义性的问题<ul><li><a href="/posts/4c2ae4c0.html#%E8%99%9A%E7%BB%A7%E6%89%BF">虚继承的使用与适用场景介绍</a></li><li>虚继承只适用于有共同基类（公共基类）的多继承场景（钻石菱形 ◇），如<a href="../../../asset/2021/11/cplusplus-extends-17.png">右图</a>所示</li><li>对于 <code>V</code> 字形的多继承场景，虚继承是没办法解决二义性问题的，如<a href="../../../asset/2021/11/cplusplus-extends-21.png">右图</a>所示</li></ul></li></ul><p>工程上继承多个接口类的使用说明：</p><ul><li>a) 继承多个接口类不会带来二义性和复杂性等问题</li><li> b) 多继承可以通过精心设计的单继承和接口类来代替</li><li> c) 接口类只是一个功能说明，而不是功能实现，子类需要根据功能说明定义功能实现</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括多态原理、纯虚函数与抽象类、VPTR 虚函数表指针的介绍等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之八</title>
    <link href="https://www.techgrow.cn/posts/4c2ae4c0.html"/>
    <id>https://www.techgrow.cn/posts/4c2ae4c0.html</id>
    <published>2021-11-17T13:55:33.000Z</published>
    <updated>2021-11-18T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><h3 id="多继承概念"><a href="#多继承概念" class="headerlink" title="多继承概念"></a>多继承概念</h3><ul><li><p>a) 一个类有多个直接基类（父类）的继承关系称为多继承</p></li><li><p>b) 类 C 可以根据访问控制同时继承类 A 和类 B 的成员，并添加自己的成员</p></li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-12.png"></p><span id="more"></span><ul><li>c) 多继承声明语法 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class  派生类名 : 访问控制  基类名1 ,  访问控制  基类名2 ,  … , 访问控制  基类名n</span><br><span class="line">{</span><br><span class="line">数据成员和成员函数声明</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="多继承的简单应用"><a href="#多继承的简单应用" class="headerlink" title="多继承的简单应用"></a>多继承的简单应用</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-13.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>(<span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : <span class="built_in">Base1</span>(a), <span class="built_in">Base2</span>(b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Base3 <span class="title">base</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">base.<span class="built_in">printA</span>();</span><br><span class="line">base.<span class="built_in">printB</span>();</span><br><span class="line">base.<span class="built_in">printC</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">c = 3</span><br></pre></td></tr></tbody></table></figure><h3 id="派生类的构造函数和成员访问"><a href="#派生类的构造函数和成员访问" class="headerlink" title="派生类的构造函数和成员访问"></a>派生类的构造函数和成员访问</h3><p>在多继承的派生类中，其构造函数和成员访问的特性如下：</p><ul><li>拥有多个基类的派生类的构造函数，可以用初始化列表调用基类构造函数来初始化数据成员。</li><li>执行顺序与单继承构造函数情况类似，多个直接基类构造函数执行顺序取决于定义派生类时指定的各个继承基类的顺序。</li><li>一个派生类对象拥有多个直接或间接基类的成员。不同名成员访问不会出现二义性，如果不同的基类有同名成员，那么派生类对象访问时应该加以识别。</li></ul><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><h3 id="虚继承的概念"><a href="#虚继承的概念" class="headerlink" title="虚继承的概念"></a>虚继承的概念</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-14.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-15.png"></p><p>总结：</p><ul><li>如果一个派生类从多个基类继承，而这些基类又有一个共同的基类（公共基类），则在对该基类中声明的成员进行访问时，可能会产生二义性。</li><li>如果在多条继承路径上有一个公共的基类，那么在继承路径的某处汇合点，这个公共基类就会在派生类的对象中产生多个基类子对象</li><li>要使这个公共基类在派生类中只产生一个子对象，必须对这个基类声明为虚继承，使这个基类成为 <code>虚基类</code>。</li><li>虚继承声明需要使用关键字：<code>virtual</code></li></ul><h3 id="虚继承的简单应用"><a href="#虚继承的简单应用" class="headerlink" title="虚继承的简单应用"></a>虚继承的简单应用</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-16.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>(<span class="keyword">int</span> x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">cout &lt;&lt; <span class="string">"Base 类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"x = "</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">virtual</span>  <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>(<span class="keyword">int</span> b, <span class="keyword">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 由于父类和虚基类没有默认的无参构造函数，所以这里的派生类需要在初始化列表中，显式调用父类、虚基类的有参构造函数</span></span><br><span class="line"><span class="built_in">Base3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> x) : <span class="built_in">Base1</span>(a, x), <span class="built_in">Base2</span>(b, x), <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Base3 <span class="title">base</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;  <span class="comment">// 虚基类Base的构造函数只会被调用一次</span></span><br><span class="line">base.<span class="built_in">printA</span>();</span><br><span class="line">base.<span class="built_in">printB</span>();</span><br><span class="line">base.<span class="built_in">printC</span>();</span><br><span class="line">base.<span class="built_in">printX</span>();<span class="comment">// 当不声明虚继承的时候，此写法会产生二义性，C++编译器会出现编译错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base 类的构造函数被调用</span><br><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">c = 3</span><br><span class="line">x = 4</span><br></pre></td></tr></tbody></table></figure><p>值得一提的是，如果虚基类声明了非默认形式的（即带参数的）构造函数，并且没有声明默认形式的（无参）构造函数，此时在整个继承关系中，直接或者间接继承虚基类的所有派生类，都必须在构造函数的成员初始化列表中列出对虚基类的初始化。因为涉及到多重继承和虚继承，为避免派生类因调用多个父类的构造函数后多次构造更上层虚基类，所以需要派生类自己显示调用继承而来的虚基类的构造函数，而继承链上其它所有对虚基类的构造函数调用将被忽略。简单一句话概况：<strong>父类不会帮子类调用虚基类的构造函数，子类在构造时必须自己初始化所有虚基类。</strong></p><h3 id="虚继承的适用场景"><a href="#虚继承的适用场景" class="headerlink" title="虚继承的适用场景"></a>虚继承的适用场景</h3><ul><li>虚继承只适用于有共同基类（公共基类）的多继承场景（钻石菱形 ◇），如<a href="../../../asset/2021/11/cplusplus-extends-17.png">右图</a>所示</li><li>对于 <code>V</code> 字形的多继承场景（代码如下），虚继承是没办法解决二义性问题的，如<a href="../../../asset/2021/11/cplusplus-extends-21.png">右图</a>所示 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>(<span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base1, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : <span class="built_in">Base1</span>(a), <span class="built_in">Base2</span>(b) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Base3 <span class="title">base</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承只适用于有共同基类（公共基类）的多继承场景（钻石菱形 ◇）</span></span><br><span class="line"><span class="comment">// 即使上面声明了虚继承，但此写法仍然会产生二义性，C++编译器会出现编译错误</span></span><br><span class="line"><span class="comment">// base.print();</span></span><br><span class="line"></span><br><span class="line">base.Base1::<span class="built_in">print</span>();</span><br><span class="line">base.Base2::<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = 2</span><br></pre></td></tr></tbody></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是面向对象的三大概念（如下）之一，按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会使用到多态。C++ 的多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。值得一提的是，多态是设计模式的基础，同时也是框架的基石。</p><ul><li><code>封装</code>：突破了 C 语言函数的概念。</li><li><code>继承</code>：提高了代码的可重用性。</li><li><code>多态</code>：多态是指在不同继承关系的类对象中，去调同一函数，产生了不同的行为。多态的一般使用方式，是使用一个父类的指针或引用去调用子类中被重写的方法。</li></ul><h3 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h3><h4 id="函数重写的概念"><a href="#函数重写的概念" class="headerlink" title="函数重写的概念"></a>函数重写的概念</h4><ul><li>函数重写是指在子类中定义与父类中原型相同的函数</li><li>父类中被重写的函数依然会继承给子类</li><li>默认情况下，在子类中重写的函数将隐藏父类中的函数</li><li>通过作用域分辨符 <code>::</code> 可以访问到父类中被隐藏的函数</li><li>函数重写只发生在父类与子类之间，而函数重载只发生在同一个类中</li></ul><h4 id="函数重写的应用"><a href="#函数重写的应用" class="headerlink" title="函数重写的应用"></a>函数重写的应用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> c) : <span class="built_in">Parent</span>(a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类重写父类中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">3</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行子类的函数，默认情况下子类中重写的函数将隐藏父类中的函数</span></span><br><span class="line">child.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行父类的函数，通过作用域分辨符"::"可以访问到父类中被隐藏的函数</span></span><br><span class="line">child.Parent::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I'm child, c = 7</span><br><span class="line">I'm parent, a = 3</span><br></pre></td></tr></tbody></table></figure><h4 id="函数重写与函数重载的区别"><a href="#函数重写与函数重载的区别" class="headerlink" title="函数重写与函数重载的区别"></a>函数重写与函数重载的区别</h4><ul><li><p>函数重载</p><ul><li>必须在同一个类中进行</li><li>子类无法重载父类的函数，父类同名函数将被子类的覆盖</li><li>重载是在编译期间根据参数类型、个数和顺序决定函数的调用</li></ul></li><li><p>函数重写</p><ul><li>必须发生于父类与子类之间</li><li>父类与子类中的函数必须有完全相同的原型</li><li>使用 <code>virtual</code> 关键字声明之后，能够产生多态（如果不使用 <code>virtual</code> 关键字声明，那叫重定义）</li></ul></li></ul><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h4 id="类型兼容原则遇上函数重写"><a href="#类型兼容原则遇上函数重写" class="headerlink" title="类型兼容原则遇上函数重写"></a>类型兼容原则遇上函数重写</h4><p>当 <a href="/posts/e4826e2c.html#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E5%8E%9F%E5%88%99">类型兼容原则</a> 遇上函数重写时，执行以下代码后会出现意外的现象，即被调用的永远是父类的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> c) : <span class="built_in">Parent</span>(c) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类重写父类中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Parent* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Parent <span class="title">parent</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行父类的函数</span></span><br><span class="line">p = &amp;parent;</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行父类的函数</span></span><br><span class="line">p = &amp;child;</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I'm parent, a = 6</span><br><span class="line">I'm parent, a = 5</span><br></pre></td></tr></tbody></table></figure><p>C/C++ 是静态编译型语言，在执行编译时，编译器会自动根据指针的类型判断指向的是一个什么样的对象。但在编译 <code>print()</code> 函数的时候，编译器不可能知道指针 <code>p</code> 究竟指向了什么对象，因为程序还没有运行。同时编译译器没有理由报错，于是编译器认为最安全的做法是编译到父类的 <code>print()</code> 函数，因为父类和子类肯定都有相同的 <code>print()</code> 函数。这就是所谓的 <code>静态多态</code> 或 <code>静态联编</code>，函数调用在程序执行之前就已经准备好了；有时候这也被称为 <code>早绑定</code>，因为 <code>print()</code> 函数在程序编译期间就已经设置好了。<strong>这就引出了面向对象新的需求，希望根据实际的对象类型来判断重写函数的调用；如果父类指针指向的是父类对象则调用父类中定义的函数，如果父类指针指向的是子类对象则调用子类中定义的重写函数，<a href="../../../asset/2021/11/cplusplus-extends-18.png">如图</a>所示。</strong></p><h4 id="虚函数的应用"><a href="#虚函数的应用" class="headerlink" title="虚函数的应用"></a>虚函数的应用</h4><p>C++ 中通过 <code>virtual</code> 关键字对多态进行支持，使用 <code>virtual</code> 关键字声明的函数被重写后即可展现多态特性，一般称之为 <code>虚函数</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 "virtual" 关键字声明父类的函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> c) : <span class="built_in">Parent</span>(c) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 "virtual" 关键字声明重写父类中的函数</span></span><br><span class="line"><span class="comment">// 只要父类中的函数有 "virtual" 关键字的声明，那么子类的 "virtual" 声明可写可不写，一般建议都写上</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Parent* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Parent <span class="title">parent</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行父类的函数</span></span><br><span class="line">p = &amp;parent;</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行子类的函数</span></span><br><span class="line">p = &amp;child;</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I'm parent, a = 6</span><br><span class="line">I'm child, c = 5</span><br></pre></td></tr></tbody></table></figure><p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 <code>Parent</code> 和 <code>Child</code> 类的对象的地址存储在 <code>*p</code> 中，所以会调用各自的 <code>print()</code> 函数。正如所看到的，父类 <code>Parent</code> 的每个子类都有一个 <code>print()</code> 函数的独立实现。<strong>这就是多态的一般使用方式，即使用一个父类的指针或引用去调用子类中被重写的方法。有了多态就可以有多个不同的实现类，它们都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</strong></p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>虚析构函数的作用：为了避免内存泄漏，通过父类的指针，可以将所有子类对象的析构函数都执行一遍（释放所有的子类资源）。即虚析构函数使得在删除指向子类对象的父类指针时，可以调用子类的析构函数来实现释放子类中堆内存的目的，从而防止内存泄漏。</p><ul><li>析构函数可以是虚的，虚析构函数用于指引 <code>delete</code> 运算符正确析构动态对象</li><li>构造函数不能是虚函数，因为建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数</li></ul><h4 id="虚析构函数的简单应用"><a href="#虚析构函数的简单应用" class="headerlink" title="虚析构函数的简单应用"></a>虚析构函数的简单应用</h4><p><img data-src="../../../asset/2021/11/cplusplus-extends-19.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-20.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() {</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"Hello A"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"A 类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">A</span>() {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">cout &lt;&lt; <span class="string">"A 类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>() {</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"Hello B"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"B 类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">B</span>() {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">cout &lt;&lt; <span class="string">"B 类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 此写法，如果上面不使用 "virtual" 修饰A类（基类）的析构函数，派生类与所有基类的析构函数依然都会被自动调用一次</span></span><br><span class="line">B* b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此写法，如果上面不使用 "virtual" 修饰A类（基类）的析构函数，那么只有A类（基类）的析构函数会被调用一次，B类（派生类）的析构函数不会被调用，这样就会造成内存泄漏</span></span><br><span class="line"><span class="comment">// 虚析构函数的作用是，通过父类的指针，可以将所有子类对象的析构函数都执行一遍（释放所有的子类资源）。</span></span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A 类的构造函数被调用</span><br><span class="line">B 类的构造函数被调用</span><br><span class="line">B 类的析构函数被调用</span><br><span class="line">A 类的析构函数被调用</span><br><span class="line"></span><br><span class="line">A 类的构造函数被调用</span><br><span class="line">B 类的构造函数被调用</span><br><span class="line">B 类的析构函数被调用</span><br><span class="line">A 类的析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h4 id="虚析构函数的作用总结"><a href="#虚析构函数的作用总结" class="headerlink" title="虚析构函数的作用总结"></a>虚析构函数的作用总结</h4><ul><li>a) 如果基类的析构函数不加 <code>virtual</code> 关键字修饰，那么就是普通析构函数<ul><li>当基类中的析构函数没有声明为虚析构函数时，派生类开始从基类继承，基类的指针指向派生类的对象时，<code>delete</code> 基类的指针时，只会调用基类的析构函数，不会调用派生类的析构函数</li></ul></li><li> b) 如果基类的析构函数加 <code>virtual</code> 关键字修饰，那么就是虚析构函数<ul><li>当基类中的析构函数声明为虚析构函数时，派生类开始从基类继承，基类的指针指向派生类的对象时，<code>delete</code> 基类的指针时，先调用派生类的析构函数，再调用基类中的析构函数</li></ul></li></ul><h3 id="多态的理论基础"><a href="#多态的理论基础" class="headerlink" title="多态的理论基础"></a>多态的理论基础</h3><ul><li><code>联编</code>：是指一个程序模块、代码之间互相关联的过程</li><li><code>静态联编</code>：是程序的匹配、连接在编译阶段实现，也称为早期联编（早绑定）<ul><li>函数重载属于静态联编</li></ul></li><li><code>动态联编</code>：是指程序联编推迟到运行时进行，所以又称为晚期联编（迟绑定）<ul><li>虚函数、<code>switch</code> 语句和 <code>if</code> 语句属于动态联编</li></ul></li></ul><p>多态理论联系实际应用（<a href="/posts/4c2ae4c0.html#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E5%8E%9F%E5%88%99%E9%81%87%E4%B8%8A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">代码示例</a>）：</p><ul><li>C++ 与 C 相同，是静态编译型语言</li><li>在编译时，编译器会自动根据指针的类型判断指向的是一个什么样的对象，所以编译器认为父类指针指向的是父类对象</li><li>由于程序没有运行，所以不可能知道父类指针指向的具体是父类对象还是子类对象</li><li>从程序安全的角度，编译器假设父类指针只指向父类对象，因此编译的结果为调用父类的成员函数，这种特性就是 <code>静态联编</code></li></ul><h3 id="多态成立的三个必要条件"><a href="#多态成立的三个必要条件" class="headerlink" title="多态成立的三个必要条件"></a>多态成立的三个必要条件</h3><ul><li>a) 要有继承</li><li> b) 要有虚函数重写</li><li> c) 父类指针或引用指向子类对象</li></ul><h3 id="C-11-的-override-和-final"><a href="#C-11-的-override-和-final" class="headerlink" title="C++ 11 的 override 和 final"></a>C++ 11 的 override 和 final</h3><p><code>override 关键字</code>：用来检查函数是否重写，在子类中的函数声明里加上该关键字 <code>virtual void fun() override {}</code>，编译器就会自动检查对应的函数是否重写了父类中的函数<br><code>final 关键字</code>：在类的声明中加上该关键字 <code>class A final {};</code>，目的是为了不让这个类被继承。或者，在一个函数后加上该关键字，表示这个函数不能被重写 <code>void fun() final {}</code></p>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括多继承、虚继承、函数重写、虚函数、多态、虚析构函数等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之七</title>
    <link href="https://www.techgrow.cn/posts/e4826e2c.html"/>
    <id>https://www.techgrow.cn/posts/e4826e2c.html</id>
    <published>2021-11-14T13:55:33.000Z</published>
    <updated>2021-11-15T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="继承概念"><a href="#继承概念" class="headerlink" title="继承概念"></a>继承概念</h2><p>面向对象程序设计有 4 个主要特点：抽象、封装、继承和多态性。面向对象程序设计的两个重要特征一数据抽象与封装，两者已经能够设计出基于对象的程序，这是面向对象程序设计的基础。要较好地进行面向对象程序设计，还必须了解面向对象程序设计另外两个重要特征 —— 继承性和多态性。继承性是面向对象程序设计最重要的特征，可以说，如果没有掌握继承性，就等于没有掌握类和对象的精华，就是没有掌握面向对象程序设计的真谛。</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>类之间一般有三种关系：<code>has-A</code>、<code>uses-A</code> 和 <code>is-A</code>：</p><ul><li><code>has-A</code>：包含关系，用以描述一个类由多个 “部件类” 构成。实现 <code>has-A</code> 关系可以用类成员表示，即一个类中的数据成员是另一种已经定义的类。</li><li><code>uses-A</code>：一个类部分地使用另一个类。类之间成员函数的联系，可以通过定义友元或者对象参数传递来实现。</li><li><code>is-A</code>：机制称为 “继承” 。关系具有传递性，不具有对称性。</li></ul><span id="more"></span><h3 id="继承关系举例"><a href="#继承关系举例" class="headerlink" title="继承关系举例"></a>继承关系举例</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-1.png"></p><h3 id="继承相关概念"><a href="#继承相关概念" class="headerlink" title="继承相关概念"></a>继承相关概念</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-2.png"></p><h3 id="派生类的定义"><a href="#派生类的定义" class="headerlink" title="派生类的定义"></a>派生类的定义</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-3.png"></p><p>值得一提的是，C++ 中的继承方式（public、private、protected）会影响子类的对外访问属性。</p><h3 id="继承重要说明"><a href="#继承重要说明" class="headerlink" title="继承重要说明"></a>继承重要说明</h3><ul><li>a) 子类拥有父类的所有成员变量和成员函数</li><li> b) 子类可以拥有父类没有的方法和属性</li><li> c) 子类就是一种特殊的父类</li><li> d) 子类对象可以当作父类对象使用</li></ul><h3 id="继承使用案例"><a href="#继承使用案例" class="headerlink" title="继承使用案例"></a>继承使用案例</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类（基类）（父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义派生类（子类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) {</span><br><span class="line"><span class="comment">// 直接访问父类（基类）（父类）的成员变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; <span class="string">", c="</span> &lt;&lt; <span class="keyword">this</span>-&gt;c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">child.<span class="built_in">print</span>();<span class="comment">// 直接调用父类（基类）（父类）的成员函数</span></span><br><span class="line">child.<span class="built_in">echo</span>();<span class="comment">// 直接调用派生类（子类）的成员函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1, b=2</span><br><span class="line">a=1, b=2, c=3</span><br></pre></td></tr></tbody></table></figure><h2 id="派生类的访问控制"><a href="#派生类的访问控制" class="headerlink" title="派生类的访问控制"></a>派生类的访问控制</h2><p>派生类（子类）继承了基类（父类）的全部成员变量和成员函数（除了构造函数和析构函数之外的成员函数），但是这些成员的访问属性，在派生过程中是可以调整的。</p><h3 id="单个类的访问控制"><a href="#单个类的访问控制" class="headerlink" title="单个类的访问控制"></a>单个类的访问控制</h3><p>在 C++ 中，类成员变量和类成员函数的访问级别为 <code>public</code>、<code>private</code>、<code>protected</code></p><ul><li><code>private</code>：修饰的成员变量和成员函数，只能在类的内部被访问</li><li><code>public</code>：修饰的成员变量和成员函数，可以在类的内部和类的外部被访问</li><li><code>protected</code>：修饰的成员变量和成员函数，可以在派生类的内部访问，不能在派生类的外部被访问</li><li>特别注意：若在类中没有声明访问控制级别的成员变量和成员函数，默认都是 <code>private</code> 访问级别的</li></ul><h3 id="继承成员的访问控制"><a href="#继承成员的访问控制" class="headerlink" title="继承成员的访问控制"></a>继承成员的访问控制</h3><p>在 C++ 中，不同的继承方式（<code>public</code>、<code>private</code>、<code>protected</code>）会改变继承成员的访问属性：</p><ul><li><code>public 继承</code>：父类成员在子类中保持原有的访问级别</li><li><code>private 继承</code>：父类成员在子类中都变为 <code>private</code> 成员</li><li><code>protected 继承</code>：父类中 <code>public</code> 成员会变成 <code>protected</code>，父类中 <code>private</code> 成员仍然为 <code>private</code>，父类中 <code>protected</code> 成员仍然为 <code>protected</code></li><li>特别注意：<code>private</code> 成员在子类中依然存在，但是无法访问到的，即不论使用哪种方式继承父类，子类都不能直接使用父类的私有成员</li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-4.png"></p><h3 id="继承成员访问控制的-“三看”-原则"><a href="#继承成员访问控制的-“三看”-原则" class="headerlink" title="继承成员访问控制的 “三看” 原则"></a>继承成员访问控制的 “三看” 原则</h3><p>在 C++ 中，不同的继承方式（<code>public</code>、<code>private</code>、<code>protected</code>）会改变继承成员的访问属性，最终可总结为以下三个原则（判断某一句话，是否可以被访问）：</p><ul><li>a) 看调用语句是写在子类的内部还是外部</li><li> b) 看子类如何从父类继承（<code>public</code>、<code>private</code>、<code>protected</code>）</li><li>c) 看父类中的访问级别（<code>public</code>、<code>private</code>、<code>protected</code>）</li></ul><h3 id="派生类成员访问级别控制的原则"><a href="#派生类成员访问级别控制的原则" class="headerlink" title="派生类成员访问级别控制的原则"></a>派生类成员访问级别控制的原则</h3><p>对于派生类自身的成员，访问级别控制的原则如下：</p><ul><li>a) 需要被外界访问的成员直接设置为 <code>public</code></li><li>b) 只能在当前类中访问的成员设置为 <code>private</code></li><li>c) 只能在当前类和子类中访问的成员设置为 <code>protected</code></li></ul><h2 id="继承中的构造和析构"><a href="#继承中的构造和析构" class="headerlink" title="继承中的构造和析构"></a>继承中的构造和析构</h2><h3 id="类型兼容原则"><a href="#类型兼容原则" class="headerlink" title="类型兼容原则"></a>类型兼容原则</h3><p>类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类<strong>（公有继承）</strong>的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。值得一提的是，在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承得到的成员，类型兼容规则是多态性的重要基础之一。类型兼容规则中所指的替代包括以下情况：</p><ul><li>子类对象可以当作父类对象使用</li><li>子类对象可以直接赋值给父类对象</li><li>子类对象可以直接初始化父类对象</li><li>父类指针可以直接指向子类对象</li><li>父类引用可以直接引用子类对象 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printParent</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类（公有继承）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printChild</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">howToPrint</span><span class="params">(Parent* p)</span> </span>{</span><br><span class="line">p-&gt;<span class="built_in">printParent</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">howToPrint</span><span class="params">(Parent&amp; p)</span> </span>{</span><br><span class="line">p.<span class="built_in">printParent</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Parent p1;</span><br><span class="line">p1.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line">Child c1;</span><br><span class="line">c1.<span class="built_in">printChild</span>();</span><br><span class="line">c1.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-1 父类指针可以直接指向子类对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">"1-1"</span> &lt;&lt; endl;</span><br><span class="line">Parent* p2 = <span class="literal">NULL</span>;</span><br><span class="line">p2 = &amp;c1;</span><br><span class="line">p2-&gt;<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-2 父类指针可以直接指向子类对象，指针做函数参数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"1-2"</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">howToPrint</span>(&amp;p1);</span><br><span class="line"><span class="built_in">howToPrint</span>(&amp;c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1 父类引用可以直接引用子类对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">"2-1"</span> &lt;&lt; endl;</span><br><span class="line">Parent&amp; p3 = c1;</span><br><span class="line">p3.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2 父类引用可以直接引用子类对象，引用做函数参数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"2-2"</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">howToPrint</span>(p1);</span><br><span class="line"><span class="built_in">howToPrint</span>(c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1 子类对象可以直接初始化父类对象，会自动调用父类的拷贝构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"3-1"</span> &lt;&lt; endl;</span><br><span class="line">Parent p4 = c1;</span><br><span class="line">p4.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4-1 子类对象可以直接赋值给父类对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">"4-1"</span> &lt;&lt; endl;</span><br><span class="line">Parent p5;</span><br><span class="line">p5 = c1;</span><br><span class="line">p5.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">I'm parent</span><br><span class="line">I'm child</span><br><span class="line">I'm parent</span><br><span class="line">1-1</span><br><span class="line">I'm parent</span><br><span class="line">1-2</span><br><span class="line">I'm parent</span><br><span class="line">I'm parent</span><br><span class="line">2-1</span><br><span class="line">I'm parent</span><br><span class="line">2-2</span><br><span class="line">I'm parent</span><br><span class="line">I'm parent</span><br><span class="line">3-1</span><br><span class="line">I'm parent</span><br><span class="line">4-1</span><br><span class="line">I'm parent</span><br></pre></td></tr></tbody></table></figure><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p>类在 C++ 编译器的内部可以理解为结构体，子类是由父类成员叠加子类新成员得到的。</p><p><img data-src="../../../asset/2021/11/cplusplus-extends-5.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-6.png"></p><p>父类与子类的构造函数、析构函数的关系如下：</p><ul><li>在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初始化</li><li>在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清理</li></ul><h3 id="继承中的构造与析构的调用原则"><a href="#继承中的构造与析构的调用原则" class="headerlink" title="继承中的构造与析构的调用原则"></a>继承中的构造与析构的调用原则</h3><ul><li>a) 子类对象在创建时，会首先调用父类的构造函数</li><li> b) 父类构造函数执行结束后，再执行子类的构造函数</li><li> c) 当父类只存在有参构造函数时，必须在子类的初始化列表中显示调用父类的构造函数</li><li> d) 析构函数调用的先后顺序与构造函数相反，即先调用子类的析构函数，再调用父类的析构函数 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">cout &lt;&lt; <span class="string">"父类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Parent</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"父类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printParent</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当父类只存在有参构造函数时，必须在子类的初始化列表中显示调用</span></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : <span class="built_in">Parent</span>(a, b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">cout &lt;&lt; <span class="string">"子类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Child</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"子类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printChild</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">c1.<span class="built_in">printParent</span>();</span><br><span class="line">c1.<span class="built_in">printChild</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类的构造函数被调用</span><br><span class="line">子类的构造函数被调用</span><br><span class="line">I'm parent, a = 1, b = 2</span><br><span class="line">I'm child, c = 3</span><br><span class="line">子类的析构函数被调用</span><br><span class="line">父类的析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h3 id="继承与组合混搭情况下，构造和析构的调用原则"><a href="#继承与组合混搭情况下，构造和析构的调用原则" class="headerlink" title="继承与组合混搭情况下，构造和析构的调用原则"></a>继承与组合混搭情况下，构造和析构的调用原则</h3><p>继承与组合对象混搭使用的情况下，构造函数与析构函数的调用原则如下：</p><ul><li><code>构造函数的调用</code>：先构造父类，再构造成员变量，最后构造自身</li><li><code>析构函数的调用</code>：先析构自身，再析构成员变量，最后析构父类 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Object</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">cout &lt;&lt; <span class="string">"Object类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Object</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"Object类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printObject</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm object, a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> :</span> <span class="keyword">public</span> Object {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过初始化列表，调用父类的构造函数</span></span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">char</span>* p) : <span class="built_in">Object</span>(<span class="number">1</span>, <span class="number">2</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">cout &lt;&lt; <span class="string">"Parent类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Parent</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"Parent类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printParent</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, p = "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过初始化列表，调用组合对象与父类的构造函数</span></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">char</span>* c) : <span class="built_in">obj1</span>(<span class="number">3</span>, <span class="number">4</span>), <span class="built_in">obj2</span>(<span class="number">5</span>, <span class="number">6</span>), <span class="built_in">Parent</span>(c) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">cout &lt;&lt; <span class="string">"Child类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Child</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"Child类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printChild</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, p = "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"><span class="comment">// 组合对象</span></span><br><span class="line">Object obj1;</span><br><span class="line">Object obj2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span>* str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'J'</span>;</span><br><span class="line">str[<span class="number">1</span>] = <span class="string">'i'</span>;</span><br><span class="line">str[<span class="number">2</span>] = <span class="string">'m'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Child <span class="title">c1</span><span class="params">(str)</span></span>;</span><br><span class="line">c1.<span class="built_in">printChild</span>();</span><br><span class="line">c1.<span class="built_in">printParent</span>();</span><br><span class="line">c1.<span class="built_in">printObject</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object类的构造函数被调用</span><br><span class="line">Parent类的构造函数被调用</span><br><span class="line">Object类的构造函数被调用</span><br><span class="line">Object类的构造函数被调用</span><br><span class="line">Child类的构造函数被调用</span><br><span class="line">I'm child, p = Jim</span><br><span class="line">I'm parent, p = Jim</span><br><span class="line">I'm object, a = 1, b = 2</span><br><span class="line">Child类的析构函数被调用</span><br><span class="line">Object类的析构函数被调用</span><br><span class="line">Object类的析构函数被调用</span><br><span class="line">Parent类的析构函数被调用</span><br><span class="line">Object类的析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h3 id="继承中的同名成员的处理方式"><a href="#继承中的同名成员的处理方式" class="headerlink" title="继承中的同名成员的处理方式"></a>继承中的同名成员的处理方式</h3><ul><li>当子类成员与父类成员同名时，子类依然可以从父类继承同名成员</li><li>在子类中通过作用域分辨符 <code>::</code> 进行同名成员的区分（在子类中使用父类的同名成员，需要显式地使用类名限定符），其作用类似 Java 中的 <code>super</code> 关键字</li><li>同名成员存储在内存中的不同位置 </li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-7.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-8.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : <span class="built_in">Parent</span>(a, b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b + <span class="number">5</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类访问自身的同名成员函数</span></span><br><span class="line">child.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类访问自身的同名成员变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">"child's a = "</span> &lt;&lt; child.a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"child's b = "</span> &lt;&lt; child.b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类访问父类的同名成员函数</span></span><br><span class="line">child.Parent::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类访问父类的同名成员变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">"parent's a = "</span> &lt;&lt; child.Parent::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"parent's b = "</span> &lt;&lt; child.Parent::b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I'm child, a = 6, b = 7</span><br><span class="line">child's a = 6</span><br><span class="line">child's b = 7</span><br><span class="line">I'm parent, a = 1, b = 2</span><br><span class="line">parent's a = 1</span><br><span class="line">parent's b = 2</span><br></pre></td></tr></tbody></table></figure><h3 id="派生类中的-static-关键字使用"><a href="#派生类中的-static-关键字使用" class="headerlink" title="派生类中的 static 关键字使用"></a>派生类中的 static 关键字使用</h3><p>在 C++ 的普通类中，<code>static</code> 关键字的使用可以看 <a href="/posts/a35089f6.html#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">这里</a>，而派生类中 <code>static</code> 关键字的使用说明如下：</p><ul><li>基类定义的静态成员，将被所有派生类共享</li><li>根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质（遵守派生类成员访问级别控制的原则）</li><li>在派生类中访问基类的静态成员，需要显式说明，对应的语法是：<code>类名 :: 成员</code> 或者通过对象访问：<code>对象名 . 成员</code></li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-10.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-11.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 声明公有的静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 声明公有的静态成员变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 声明私有的静态成员变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义私有的静态成员变量</span></span><br><span class="line"><span class="keyword">int</span> Parent::b = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义公有的静态成员变量，这里不是简单的变量赋值，更重要的是告诉C++编译器，给静态成员变量分配内存, 否则在派生类中用到该变量就会报错</span></span><br><span class="line"><span class="keyword">int</span> Parent::a = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 访问从基类继承得到的静态成员变量</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getA2</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 访问基类的静态成员变量</span></span><br><span class="line"><span class="keyword">return</span> Parent::a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// return b;  错误写法，基类中静态成员自身的访问特性遵守派生类的访问级别控制原则，因此这里不能访问基类中私有的静态成员变量b</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用从基类继承得到的静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用基类的静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>{</span><br><span class="line">Parent::<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外访问基类的静态成员变量和静态成员函数</span></span><br><span class="line">Parent::a++;</span><br><span class="line">Parent::<span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外访问派生类的静态成员变量和静态成员函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; Child::a &lt;&lt; endl;</span><br><span class="line">Child::<span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Child c1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.<span class="built_in">getA2</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.Parent::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">c1.<span class="built_in">print1</span>();</span><br><span class="line">c1.<span class="built_in">print2</span>();</span><br><span class="line">c1.Parent::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = 31, b = 50</span><br><span class="line"></span><br><span class="line">a = 31</span><br><span class="line">a = 31, b = 50</span><br><span class="line"></span><br><span class="line">a = 31</span><br><span class="line">a = 31</span><br><span class="line">a = 31</span><br><span class="line"></span><br><span class="line">a = 31, b = 50</span><br><span class="line">a = 31, b = 50</span><br><span class="line">a = 31, b = 50</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括继承、派生类的访问控制、继承中的构造函数和析构函数等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CTP 程序化交易基础之一</title>
    <link href="https://www.techgrow.cn/posts/d35e15f1.html"/>
    <id>https://www.techgrow.cn/posts/d35e15f1.html</id>
    <published>2021-11-12T13:55:33.000Z</published>
    <updated>2021-11-12T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="CTP-介绍"><a href="#CTP-介绍" class="headerlink" title="CTP 介绍"></a>CTP 介绍</h2><h3 id="CTP-简介"><a href="#CTP-简介" class="headerlink" title="CTP 简介"></a>CTP 简介</h3><p>综合交易平台（Comprehensive Transaction Platform，CTP）是专门为期货公司开发的一套期货经纪业务管理系统，由交易、风险控制和结算三大系统组成。其中，交易系统主要负责订单处理、行情转发及银期转账业务，结算系统负责交易管理、帐户管理、经纪人管理、资金管理、费率设置、日终结算、信息查询以及报表管理等，风控系统则主要在盘中进行高速的实时试算，以及时揭示并控制风险。系统能够同时连通国内四家期货交易所，支持国内商品期货和股指期货的交易结算业务，并能自动生成、报送保证金监控文件和反洗钱监控文件。</p><h3 id="CTP-架构"><a href="#CTP-架构" class="headerlink" title="CTP 架构"></a>CTP 架构</h3><p>综合交易平台是基于全内存的交易系统，采用创新的完全精确重演的分布式体系架构，支持 7x24 小时连续交易，运维人员不必每日启停系统，可以做到 “一键运维”，该特性使得综合交易平台新增交易中心以扩展业务规模时不用增加运维人力的成本。支持 FENS 机制的 “一键切换” 多活交易中心也是目前市场上只有 CTP 系统实现了的特性。该机制使得交易系统可在某个交易中心宕机的情况下立即切换到另一个备用交易中心，得以实现真真正正的连续交易。综合交易平台公开并对外开放交易系统接口，使用该接口可以接收交易所的行情数据和执行交易指令。该接口采用开放接口（API）的方式接入，早已在期货界已经形成事实上的行业标准。</p><span id="more"></span><h3 id="CTP-API"><a href="#CTP-API" class="headerlink" title="CTP API"></a>CTP API</h3><p>从 <a href="http://www.sfit.com.cn/">CTP 官网</a>（非交易时段禁止访问）可以了解到，CTP API 从 <code>v6.3.15</code> 版开始引入强制看穿式认证规则，CTP 不再兼容之前的 API 版本。目前，CTP API 最新版是 <code>v6.6.1</code>，与 <code>v6.3.15</code> 相比较最大的改动是，<code>InstrumentID</code> 由最长 30 个字节增加到 80 个字节。CTP 生产系统兼容 <code>v6.3.15</code> 及以上版本。但是，大部分期货公司做看穿式认证的仿真系统要求使用新版 API 才能接入。所以，新用户做看穿式认证时首先要确认 API 的版本号。</p><p><img data-src="../../../asset/2021/12/ctp-1.png"></p><h2 id="CTP-仿真系统"><a href="#CTP-仿真系统" class="headerlink" title="CTP 仿真系统"></a>CTP 仿真系统</h2><h3 id="SimNow-仿真系统"><a href="#SimNow-仿真系统" class="headerlink" title="SimNow 仿真系统"></a>SimNow 仿真系统</h3><p><a href="https://www.simnow.com.cn/product.action">SimNow</a> 是上期技术为广大投资者打造的一个最接近真实市场环境的仿真平台，主要面向期货经纪公司和投资者服务，提供整套期货交易的信息化技术平台。<a href="http://www.simnow.com.cn/">SimNow 官网</a>（非交易时段禁止访问），交易者注册 SimNow 仿真账户后，可以使用从 CTP 官网下载 API 接入这套仿真交易系统。开发、测试完成之后，只需要更换用户名、密码、前置地址等信息就可以接入期货公司生产系统进行实盘交易。SimNow 要求 CTP API 的版本是 <code>v6.3.15</code> 及以上才能够接入。</p><h4 id="认证信息"><a href="#认证信息" class="headerlink" title="认证信息"></a>认证信息</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BrokerID = "9999"</span><br><span class="line">AppID = "SimNow_client_test"</span><br><span class="line">AuthCode = "0000000000000000"</span><br></pre></td></tr></tbody></table></figure><p>值得一提的是，默认的 <code>BrokerID</code> 为 <code>9999</code>，<code>AppID</code> 为 <code>SimNow_client_test</code>，<code>AuthCode</code> 为 <code>0000000000000000（16个0）</code>，默认不会开终端认证，程序化用户可以选择不开终端认证接入。</p><h4 id="生产仿真环境"><a href="#生产仿真环境" class="headerlink" title="生产仿真环境"></a>生产仿真环境</h4><p>以下的前置地址，交易时段与真实生产环境（实盘）一致。</p><ul><li>电信 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://180.168.146.187:10201</span><br><span class="line">FrontMdAddr=tcp://180.168.146.187:10211</span><br></pre></td></tr></tbody></table></figure><ul><li>电信 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://180.168.146.187:10202</span><br><span class="line">FrontMdAddr=tcp://180.168.146.187:10212</span><br></pre></td></tr></tbody></table></figure><ul><li>移动 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://218.202.237.33:10203</span><br><span class="line">FrontMdAddr=tcp://218.202.237.33:10213</span><br></pre></td></tr></tbody></table></figure><h4 id="测试仿真环境"><a href="#测试仿真环境" class="headerlink" title="测试仿真环境"></a>测试仿真环境</h4><ul><li>支持全天交易（7x24），不间断轮播某天行情</li><li> SimNow 新注册用户，需要等到第三个交易日才能使用</li><li>交易时段：交易日 16：00 ～ 次日 09：00；非交易日 16：00 ～ 次日 15：00</li><li> 仅服务于 CTP API 开发爱好者，仅为用户提供 CTP API 测试需求，不提供结算等其它服务 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://180.168.146.187:10130</span><br><span class="line">FrontMdAddr=tcp://180.168.146.187:10131</span><br></pre></td></tr></tbody></table></figure><h4 id="仿真成交规则"><a href="#仿真成交规则" class="headerlink" title="仿真成交规则"></a>仿真成交规则</h4><ul><li>期货交易按照交易所公布的买一卖一价对价成交</li><li>买入时：如果委托价大于等于卖一价，则成交，成交价为委托价、卖一价、最新价三价取中，如果委托价小于卖一价，不能成交，等待更优的行情才能成交</li><li>卖出时：如果委托价小于等于买一价，则成交，成交价为委托价、买一价、最新价三价取中，如果委托价大于买一价，不能成交，等待更优的行情才能成交</li></ul><h4 id="仿真交易时间"><a href="#仿真交易时间" class="headerlink" title="仿真交易时间"></a>仿真交易时间</h4><p><img data-src="../../../asset/2021/12/ctp-3.png"></p><h3 id="NSight-仿真系统"><a href="#NSight-仿真系统" class="headerlink" title="NSight 仿真系统"></a>NSight 仿真系统</h3><p>交易者在 <a href="http://www.n-sight.com.cn/">NSight 官网</a> 注册仿真账户后，可以使用从 CTP 官网下载的 API <code>v6.3.15</code> 接入这套仿真交易系统。开发、测试完成之后，只需要更换用户名、密码、前置地址等信息就可以接入期货公司生产系统进行实盘交易。</p><h4 id="认证信息-1"><a href="#认证信息-1" class="headerlink" title="认证信息"></a>认证信息</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BrokerID = "10010"</span><br><span class="line">AppID = ""</span><br><span class="line">AuthCode = ""</span><br></pre></td></tr></tbody></table></figure><p>值得一提的是，默认的 <code>BrokerID</code> 为 <code>10010</code>，<code>AppID</code> 与 <code>AuthCode</code> 均为空字符串。</p><h4 id="生产仿真环境-1"><a href="#生产仿真环境-1" class="headerlink" title="生产仿真环境"></a>生产仿真环境</h4><p>以下的前置地址，交易时段与真实生产环境（实盘）一致。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://210.14.72.12:4600</span><br><span class="line">FrontMdAddr=tcp://210.14.72.12:4602</span><br></pre></td></tr></tbody></table></figure><h2 id="期货交易终端"><a href="#期货交易终端" class="headerlink" title="期货交易终端"></a>期货交易终端</h2><p>市面上主流的期货交易终端可以在 <a href="https://www.simnow.com.cn/static/softwareDownload.action">SimNow 官网</a>（非交易时段禁止访问）下载。</p><h3 id="快期期货交易终端"><a href="#快期期货交易终端" class="headerlink" title="快期期货交易终端"></a>快期期货交易终端</h3><p>对于量化交易者，在没有自主开发监控客户端之前，快期是一个很不错的选择。这里以 <code>快期 v2</code> 版本举例，若使用快期登录 SimNow 的模拟账户，则只需要在快期的登录界面选择服务器 <code>上期技术-xx</code> 即可，下拉列表里不同的服务器分别使用了不同的前置地址，而 <code>用户代码</code> 直接填写 <code>InvestorID</code>。</p><p><img data-src="../../../asset/2021/12/ctp-2.png"></p><h2 id="CTP-开放平台"><a href="#CTP-开放平台" class="headerlink" title="CTP 开放平台"></a>CTP 开放平台</h2><ul><li><a href="https://github.com/krenx1983/openctp">CTP 开放平台</a></li><li><a href="https://zhuanlan.zhihu.com/p/366725237">CTP 接口兼容模拟交易平台 - 类似 SimNow</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 CTP 程序化交易的基础内容，包括 CTP、SimNow、NSight 的介绍。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="量化交易" scheme="https://www.techgrow.cn/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之六</title>
    <link href="https://www.techgrow.cn/posts/a54941f5.html"/>
    <id>https://www.techgrow.cn/posts/a54941f5.html</id>
    <published>2021-11-06T13:55:33.000Z</published>
    <updated>2021-11-12T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>类的友元函数是定义在类的外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型在类的声明中出现过，但是友元函数并不是类的成员函数，而是普通函数（全局函数）。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <code>friend</code>。</p><h3 id="友元函数的规则"><a href="#友元函数的规则" class="headerlink" title="友元函数的规则"></a>友元函数的规则</h3><p>为什么要引入友元函数：</p><p>C++ 利用 <code>friend</code> 修饰符，可以让一些设定的函数能够对一些保护数据进行访问，避免把类的成员全部设置成 <code>public</code>，最大限度的保护数据成员的安全。同时友元函数可以实现类之间的数据共享，减少系统开销，提高效率。由于友元函数破环了封装机制，因此推荐尽量使用成员函数，除非不得已的情况下才使用友元函数。</p><p>什么时候使用友元函数：</p><ul><li>多个类要共享数据的时候</li><li>运算符重载的某些场合需要使用友元函数</li></ul><span id="more"></span><p>友元函数的参数：</p><p>因为友元函数没有 <code>this</code> 指针，所以参数会有三种情况：</p><ul><li>a) 要访问非 <code>static</code> 成员时，需要对象做参数</li><li> b) 要访问 <code>static</code> 成员或全局变量时，则不需要对象做参数</li><li> c) 如果做参数的对象是全局对象，则不需要对象做参数</li></ul><p>友元函数的位置：</p><ul><li>因为友元函数是类外的函数（普通函数），所以它的声明可以放在类的私有段（private）或公有段（public），两者都是没有区别的</li><li>一个函数可以是多个类的友元函数，只需要在各个类中分别声明即可</li></ul><p>友元函数的调用：</p><ul><li>可以直接调用友元函数，不需要通过对象或指针</li><li>友元函数的调用与普通函数（全局函数）的调用方式和原理一致</li></ul><h3 id="友元函数的使用"><a href="#友元函数的使用" class="headerlink" title="友元函数的使用"></a>友元函数的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">update2</span><span class="params">(A* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update1</span><span class="params">(A* p)</span> </span>{</span><br><span class="line"><span class="comment">// p-&gt;a = 30;  // 错误写法，在普通函数（全局函数）内，私有数据成员不能在类外被访问</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(A* p)</span> </span>{</span><br><span class="line">p-&gt;a = <span class="number">30</span>;<span class="comment">// 在友元函数内，可以通过对象参数访问私有数据成员</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">update2</span>(a);<span class="comment">// 调用友元函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a-&gt;<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 30</span><br></pre></td></tr></tbody></table></figure><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的私有（private）成员和保护（protected）成员。当希望一个类可以访问另一个类的保护数据时，可以将该类声明为另一类的友元类。定义友元类的语法格式为 <code>friend class 类名;</code>，其中类名必须是程序中的一个已定义过的类。值得一提的是，友元类通常设计为一种对数据操作或类之间传递消息的辅助类。</p><h3 id="友元类的规则"><a href="#友元类的规则" class="headerlink" title="友元类的规则"></a>友元类的规则</h3><ul><li>友元关系不能被继承</li><li>友元关系是单向的，不具有交换性。若类 B 是类 A 的友元，则类 A 不一定是类 B 的友元，要看在类 B 中是否有相应的声明</li><li>友元关系不具有传递性，若类 B 是类 A 的友元，类 C 是 类 B 的友元，则类 C 不一定是类 A 的友元，要看类 A 中是否有相应的声明</li></ul><h3 id="友元类的使用"><a href="#友元类的使用" class="headerlink" title="友元类的使用"></a>友元类的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明友元类 B</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">aObj.a = a;<span class="comment">// 类 B 是类 A 的友元类，因此 B 类的所有成员函数都可以访问 A 类的私有成员或者保护成员</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">aObj.<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A aObj;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">setValue</span>(<span class="number">100</span>);</span><br><span class="line">b.<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 100</span><br></pre></td></tr></tbody></table></figure><h2 id="运算符重载基础"><a href="#运算符重载基础" class="headerlink" title="运算符重载基础"></a>运算符重载基础</h2><p>所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是 <code>一名多用</code>。运算符也可以重载，实际上，开发者已经在不知不觉之中使用了运算符重载。例如，大家都已习惯于用加法运算符 <code>+</code> 对整数、单精度数和双精度数进行加法运算，如 <code>5 + 8，5.8 + 3.67</code> 等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的，但由于 C++ 已经对运算符 <code>+</code> 进行了重载，所以就能适用于 int、float、doUble 类型的运算。又如 <code>&lt;&lt;</code> 是 C++ 的位运算中的位移运算符（左移），但在输出操作中又是与流对象 <code>cout</code> 配合使用的流插入运算符。<code>&gt;&gt;</code> 也是位移运算符 (右移），但在输入操作中又是与流对象 <code>cin</code> 配合使用的流提取运算符。这就是运算符重载 (Operator Overloading)。C++ 系统对 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 进行了重载，用户在不同的场合下使用它们时，作用是不同的。对 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 的重载处理是放在头文件 <code>stream</code> 中的。因此，如果要在程序中用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 作流插入运算符和流提取运算符，必须在本文件模块中包含头文件 <code>stream</code>，当然还应当包括命名空间的使用声明 <code>using namespace std</code>。</p><h3 id="运算符重载的语法"><a href="#运算符重载的语法" class="headerlink" title="运算符重载的语法"></a>运算符重载的语法</h3><p><img data-src="../../../asset/2021/11/cplusplus-overload-1.png" alt="cplusplus-overload-1"></p><p>例如：</p><ul><li><code>使用类成员函数完成 "-" 运算符重载的语法</code>：Complex operator-(Complex &amp;c2)</li><li><code>使用友元函数完成 "+" 运算符重载的语法</code>：Complex operator+(Complex &amp;c1, Complex &amp;c2)</li></ul><h3 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><p><img data-src="../../../asset/2021/11/cplusplus-overload-6.png" alt="cplusplus-overload-6"><br><img data-src="../../../asset/2021/11/cplusplus-overload-2.png" alt="cplusplus-overload-2"></p><h3 id="运算符重载的两种方式"><a href="#运算符重载的两种方式" class="headerlink" title="运算符重载的两种方式"></a>运算符重载的两种方式</h3><p><img data-src="../../../asset/2021/11/cplusplus-overload-3.png" alt="cplusplus-overload-3"><br><img data-src="../../../asset/2021/11/cplusplus-overload-4.png" alt="cplusplus-overload-4"><br><img data-src="../../../asset/2021/11/cplusplus-overload-5.png" alt="cplusplus-overload-5"></p><h3 id="前置与后置运算符重载规则"><a href="#前置与后置运算符重载规则" class="headerlink" title="前置与后置运算符重载规则"></a>前置与后置运算符重载规则</h3><p>在 C++ 中是通过一个占位参数（<code>int</code>）来区分前置运算符和后置运算符的重载，例如 <code>++a</code>、<code>a++</code>、<code>--b</code>、<code>b--</code>。</p><p><img data-src="../../../asset/2021/11/cplusplus-overload-7.png" alt="cplusplus-overload-7"></p><h3 id="运算符重载的简单使用案例"><a href="#运算符重载的简单使用案例" class="headerlink" title="运算符重载的简单使用案例"></a>运算符重载的简单使用案例</h3><h4 id="二元运算符重载"><a href="#二元运算符重载" class="headerlink" title="二元运算符重载"></a>二元运算符重载</h4><p>在下述的案例中，演示了如何使用类成员函数和友元函数实现二元运算符的重载。值得一提的是，除了使用友元函数外，还可以使用全局函数（普通函数）来实现运算符的重载，不同的是使用友元函数更方便，可以直接访问类的所有私有（private）成员和保护（protected）成员。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数完成 "-" 运算符的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(Complex&amp; c2) {</span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(<span class="keyword">this</span>-&gt;a - c2.a, <span class="keyword">this</span>-&gt;b - c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> c3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明用于 "+" 运算符重载的友元函数</span></span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(Complex&amp; c1, Complex&amp; c2);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数完成 "+" 运算符的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; c1, Complex&amp; c2) {</span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(c1.a + c2.a, c1.b + c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> c3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用友元函数</span></span><br><span class="line">Complex c3 = <span class="keyword">operator</span>+(c1, c2);</span><br><span class="line">c3.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数完成 "+" 运算符的重载</span></span><br><span class="line">Complex c4 = c1 + c2;</span><br><span class="line">c4.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用类成员函数</span></span><br><span class="line">Complex c5 = c1.<span class="keyword">operator</span>-(c2);</span><br><span class="line">c5.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数完成 "-" 运算符的重载</span></span><br><span class="line">Complex c6 = c1 - c2;</span><br><span class="line">c6.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=4, b=6</span><br><span class="line">a=4, b=6</span><br><span class="line">a=-2, b=-2</span><br><span class="line">a=-2, b=-2</span><br></pre></td></tr></tbody></table></figure><h4 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h4><p>在下述的案例中，演示了如何使用类成员函数和友元函数实现一元运算符的重载。值得一提的是，除了使用友元函数外，还可以使用全局函数（普通函数）来实现运算符的重载，不同的是使用友元函数更方便，可以直接访问类的所有私有（private）成员和保护（protected）成员。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数完成 "前置--" 运算符的重载</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>--() {</span><br><span class="line"><span class="keyword">this</span>-&gt;a--;</span><br><span class="line"><span class="keyword">this</span>-&gt;b--;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数完成 "后置--" 运算符的重载</span></span><br><span class="line"><span class="comment">// 使用占位参数进行函数重载，是为了解决与 "前置--" 类成员函数冲突的问题</span></span><br><span class="line">Complex <span class="keyword">operator</span>--(<span class="keyword">int</span>) {</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a, <span class="keyword">this</span>-&gt;b)</span></span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;a--;</span><br><span class="line"><span class="keyword">this</span>-&gt;b--;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明用于 "前置++" 运算符重载的友元函数</span></span><br><span class="line"><span class="keyword">friend</span> Complex&amp; <span class="keyword">operator</span>++(Complex&amp; c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明用于 "后置++" 运算符重载的友元函数</span></span><br><span class="line"><span class="comment">// 使用占位参数进行函数重载，是为了解决与 "前置++" 友元函数冲突的问题</span></span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>++(Complex&amp; c1, <span class="keyword">int</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数完成 "前置++" 运算符的重载</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>++(Complex&amp; c1)</span><br><span class="line">{</span><br><span class="line">c1.a++;</span><br><span class="line">c1.b++;</span><br><span class="line"><span class="keyword">return</span> c1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数完成 "后置++" 运算符的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>++(Complex&amp; c1, <span class="keyword">int</span>) {</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(c1.a, c1.b)</span></span>;</span><br><span class="line">c1.a++;</span><br><span class="line">c1.b++;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">8</span>, <span class="number">9</span>)</span>, <span class="title">c3</span><span class="params">(<span class="number">15</span>, <span class="number">16</span>)</span>, <span class="title">c4</span><span class="params">(<span class="number">24</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数完成 "前置++" 运算符的重载</span></span><br><span class="line">++c1;</span><br><span class="line">c1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数完成 "前置--" 运算符的重载</span></span><br><span class="line">--c2;</span><br><span class="line">c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数完成 "后置++" 运算符的重载</span></span><br><span class="line">Complex c5 = c3++;</span><br><span class="line">c3.<span class="built_in">print</span>();</span><br><span class="line">c5.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数完成 "后置--" 运算符的重载</span></span><br><span class="line">Complex c6 = c4--;</span><br><span class="line">c4.<span class="built_in">print</span>();</span><br><span class="line">c6.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=2, b=3</span><br><span class="line">a=7, b=8</span><br><span class="line">a=16, b=17</span><br><span class="line">a=15, b=16</span><br><span class="line">a=23, b=24</span><br><span class="line">a=24, b=25</span><br></pre></td></tr></tbody></table></figure><h4 id="左移运算符的重载"><a href="#左移运算符的重载" class="headerlink" title="左移运算符的重载"></a>左移运算符的重载</h4><p>值得一提的是，<code>&lt;&lt;</code> 左移运算符和 <code>&gt;&gt;</code> 右移运算符的重载，只能使用友元函数或者全局函数，不能使用类成员函数，这也是友元函数的重要作用之一。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 声明友元函数实现 "&lt;&lt;" 左移运算符的重载</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&amp; c1);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数实现 "&lt;&lt;" 左移运算符的重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&amp; c1) {</span><br><span class="line">out &lt;&lt; <span class="string">"a="</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b="</span> &lt;&lt; c1.b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">6</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; c1 &lt;&lt; c2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1, b=2</span><br><span class="line">a=6, b=9</span><br></pre></td></tr></tbody></table></figure><h4 id="等号运算符的重载"><a href="#等号运算符的重载" class="headerlink" title="等号运算符的重载"></a>等号运算符的重载</h4><ul><li><code>=</code> 运算符的结合性是从右到左</li><li><code>=</code> 运算符的重载用于对象数据的复制</li><li>必须通过类成员函数重载 <code>=</code> 运算符，不能使用友元函数</li><li><code>=</code> 运算符重载的函数原型为：<code>类型  &amp;  类名  :: operator= ( const  类名 &amp; ) ;</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Name</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name) {</span><br><span class="line">cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">len = <span class="built_in">strlen</span>(name);</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝的实现</span></span><br><span class="line"><span class="built_in">Name</span>(<span class="keyword">const</span> Name&amp; name) {</span><br><span class="line">cout &lt;&lt; <span class="string">"拷贝构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">len = name.<span class="built_in">getLen</span>();</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, name.<span class="built_in">getP</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Name</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getP</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数实现 "=" 运算符的重载</span></span><br><span class="line">Name&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Name&amp; n) {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 重新分配内存空间</span></span><br><span class="line">len = n.<span class="built_in">getLen</span>();</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, n.<span class="built_in">getP</span>());</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Name <span class="title">obj1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line"><span class="function">Name <span class="title">obj2</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line"><span class="function">Name <span class="title">obj4</span><span class="params">(<span class="string">"Tim"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会自动调用拷贝构造函数（属于深拷贝）</span></span><br><span class="line">Name obj3 = obj1;</span><br><span class="line">cout &lt;&lt; <span class="string">"obj3.name: "</span> &lt;&lt; obj3.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj3.len:  "</span> &lt;&lt; obj3.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用拷贝构造函数（属于浅拷贝）</span></span><br><span class="line"><span class="comment">// 默认情况下，若这里不对 "=" 运算符进行重载，最终程序会异常终止运行（由于同一块内存空间被释放两次导致）</span></span><br><span class="line">obj4 = obj1;</span><br><span class="line">cout &lt;&lt; <span class="string">"obj4.name: "</span> &lt;&lt; obj4.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj4.len:  "</span> &lt;&lt; obj4.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">拷贝构造函数被调用了</span><br><span class="line">obj3.name: Peter, obj3.len:  5</span><br><span class="line">obj4.name: Peter, obj4.len:  5</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br></pre></td></tr></tbody></table></figure><h4 id="函数运算符的重载"><a href="#函数运算符的重载" class="headerlink" title="函数运算符的重载"></a>函数运算符的重载</h4><p>在下述的案例中，演示了如何使用类成员函数重载函数运算符 <code>()</code>，值得一提的是，不能用友元函数重载函数运算符 <code>()</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Test test;</span><br><span class="line">cout &lt;&lt; <span class="built_in">test</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></tbody></table></figure><h2 id="运算符重载进阶"><a href="#运算符重载进阶" class="headerlink" title="运算符重载进阶"></a>运算符重载进阶</h2><h3 id="为什么不要重载-amp-amp-和-操作符"><a href="#为什么不要重载-amp-amp-和-操作符" class="headerlink" title="为什么不要重载 &amp;&amp; 和 || 操作符"></a>为什么不要重载 &amp;&amp; 和 || 操作符</h3><ul><li>a) <code>&amp;&amp;</code> 和 <code>||</code> 是 C++ 中非常特殊的操作符</li><li> b) <code>&amp;&amp;</code> 和 <code>||</code> 内置实现了短路规则</li><li> c) 操作符重载是靠函数重载来完成的</li><li> d) 操作数作为函数参数传递</li><li> e) C++ 的函数参数都会被求值，无法实现短路规则</li></ul><h3 id="不同函数实现运算符重载的应用场景"><a href="#不同函数实现运算符重载的应用场景" class="headerlink" title="不同函数实现运算符重载的应用场景"></a>不同函数实现运算符重载的应用场景</h3><p>友元函数和类成员函数的选择方法：</p><ul><li>a) <code>=</code>、<code>[]</code>、<code>()</code> 和 <code>-&gt;</code> 运算符，只能通过类成员函数进行重载</li><li> b) 当无法修改左操作数的类时，只能通过友元函数进行重载，例如 <code>&lt;&lt;</code> 与 <code>&gt;&gt;</code> 运算符</li></ul><p>友元函数重载 <code>&lt;&lt;</code> 与 <code>&gt;&gt;</code> 运算符：</p><ul><li><code>istream</code> 和 <code>ostream</code> 是 C++ 的预定义流类</li><li><code>cin</code> 是 <code>istream</code> 的对象，<code>cout</code> 是 <code>ostream</code> 的对象</li><li>运算符 <code>&lt;&lt;</code> 由 <code>ostream</code> 重载为插入操作，用于输出基本类型数据</li><li>运算符 <code>&gt;&gt;</code> 由 <code>istream</code> 重载为提取操作，用于输入基本类型数据</li><li>只能使用友元函数或者全局函数重载 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符，输出和输入用户自定义的数据类型</li></ul><p>类成员函数与友元函数实现运算符重载的步骤：</p><ul><li>a) 要承认运算符重载是一个函数，写出函数名称，如 <code>operator +()</code></li><li>b) 根据操作数，写出函数参数</li><li> c) 根据业务，完善函数的返回值（看函数是返回引用、指针还是元素），及实现函数业务；例如当函数的返回值充当左值时，需要返回一个引用</li></ul><h3 id="使用友元函数重载运算符的注意事项"><a href="#使用友元函数重载运算符的注意事项" class="headerlink" title="使用友元函数重载运算符的注意事项"></a>使用友元函数重载运算符的注意事项</h3><ul><li>a) 友元函数重载运算符常用于运算符的左右操作数类型不相同的场景</li><li> b) 在函数的第一个参数需要隐式转换的情形下，使用友元函数重载运算符是正确的选择</li><li> c) 友元函数没有 <code>this</code> 指针，所需操作数都必须在函数的参数表中显式声明，很容易实现类型的隐式转换</li><li> d) 在 C++ 中不能用友元函数重载的运算符分别有：<code>=</code>、<code>[]</code>、<code>()</code> 和 <code>-&gt;</code></li><li>e) 在 C++ 中不要重载 <code>&amp;&amp;</code> 和 <code>||</code> 运算符</li><li> f) C++ 的运算符重载遵循函数重载的规则</li><li> g) 除了重载运算符 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 必须使用友元函数之外，其他运算符的重载尽量都使用类成员函数，千万不要滥用友元函数，尤其类模板与友元函数一起使用的时候</li></ul><h3 id="运算符重载的综合使用案例"><a href="#运算符重载的综合使用案例" class="headerlink" title="运算符重载的综合使用案例"></a>运算符重载的综合使用案例</h3><h4 id="重载自定义数组类的各种运算符"><a href="#重载自定义数组类的各种运算符" class="headerlink" title="重载自定义数组类的各种运算符"></a>重载自定义数组类的各种运算符</h4><p>在本案例中，自定义了数组类 <code>Array</code>，并使用类成员函数分别对 <code>Array</code> 类的 <code>[]</code>、<code>=</code>、<code>==</code>、<code>!=</code> 运算符进行重载。</p><details><summary>★点击显示完整的案例代码★</summary><code><ul><li>Array.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Array</span>(<span class="keyword">int</span> length);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 数组下标运算符，用于数组元素的赋值和取值</span></span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符，用于数组之间的赋值</span></span><br><span class="line">Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符，判断两个数组是否相同</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Array &amp; array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符，判断两个数组是否不相同</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_length;</span><br><span class="line"><span class="keyword">int</span>* m_space;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>Array.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">int</span> length) {</span><br><span class="line">cout &lt;&lt; <span class="string">"有参构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">0</span>) {</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line">cout &lt;&lt; <span class="string">"拷贝构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 深拷贝，单独分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = array.m_length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[array.m_length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.m_length; i++) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[i] = array.m_space[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Array::~<span class="built_in">Array</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 数组下标运算符，用于数组元素的赋值和取值</span></span><br><span class="line"><span class="keyword">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符，用于数组之间的赋值</span></span><br><span class="line">Array&amp; Array::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝，单独分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = array.m_length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[array.m_length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.m_length; i++) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[i] = array.m_space[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符，判断两个数组是否相同</span></span><br><span class="line"><span class="keyword">bool</span> Array::<span class="keyword">operator</span>==(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length != array.m_length) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_length; i++) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space[i] != array.m_space[i]) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符，判断两个数组是否不相同</span></span><br><span class="line"><span class="keyword">bool</span> Array::<span class="keyword">operator</span>!=(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == array);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Array::length</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用构造函数</span></span><br><span class="line"><span class="function">Array <span class="title">array1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">length</span>(); i++) {</span><br><span class="line">array1[i] = i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">length</span>(); i++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"array1["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array1[i] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用拷贝构造函数（属于深拷贝）</span></span><br><span class="line">Array array2 = array1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.<span class="built_in">length</span>(); i++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"array2["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array2[i] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用拷贝构造函数（属于深拷贝）</span></span><br><span class="line">Array array3 = array1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用拷贝构造函数（属于浅拷贝）</span></span><br><span class="line"><span class="comment">// 默认情况下，若这里不对 "=" 运算符进行重载，最终程序会异常终止运行（由于同一块内存空间被释放两次导致）</span></span><br><span class="line">array3 = array2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array3.<span class="built_in">length</span>(); i++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"array3["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array3[i] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个数组是否相同</span></span><br><span class="line"><span class="keyword">bool</span> result1 = array1 == array2;</span><br><span class="line">string strResult1 = result1 ? <span class="string">"="</span> : <span class="string">"!="</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"array1 "</span> &lt;&lt; strResult1 &lt;&lt; <span class="string">" array2 "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个数组是否不相同</span></span><br><span class="line"><span class="keyword">bool</span> result2 = array1 != array2;</span><br><span class="line">string strResult2 = result2 ? <span class="string">"!="</span> : <span class="string">"="</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"array1 "</span> &lt;&lt; strResult2 &lt;&lt; <span class="string">" array2 "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用</span><br><span class="line">array1[0] = 0</span><br><span class="line">array1[1] = 1</span><br><span class="line">array1[2] = 2</span><br><span class="line">array1[3] = 3</span><br><span class="line">array1[4] = 4</span><br><span class="line">拷贝构造函数被调用</span><br><span class="line">array2[0] = 0</span><br><span class="line">array2[1] = 1</span><br><span class="line">array2[2] = 2</span><br><span class="line">array2[3] = 3</span><br><span class="line">array2[4] = 4</span><br><span class="line">拷贝构造函数被调用</span><br><span class="line">array3[0] = 0</span><br><span class="line">array3[1] = 1</span><br><span class="line">array3[2] = 2</span><br><span class="line">array3[3] = 3</span><br><span class="line">array3[4] = 4</span><br><span class="line">array1 = array2</span><br><span class="line">array1 = array2</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></tbody></table></figure></code></details><h4 id="重载自定义字符串类的各种运算符"><a href="#重载自定义字符串类的各种运算符" class="headerlink" title="重载自定义字符串类的各种运算符"></a>重载自定义字符串类的各种运算符</h4><p>在本案例中，自定义了字符串类 <code>MyString</code>，并使用类成员函数和友元函数分别对 <code>MyString</code> 类的 <code>[]</code>、<code>=</code>、<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;&gt;</code>、<code>&lt;&lt;</code> 运算符进行重载。</p><details><summary>★点击显示完整的案例代码★</summary><code><ul><li>MyString.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyString</span>();</span><br><span class="line"><span class="built_in">MyString</span>(<span class="keyword">int</span> len);</span><br><span class="line"><span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p);</span><br><span class="line"><span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">MyString</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 运算符</span></span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* p);</span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&gt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&lt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&lt;&lt;" 运算符</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&gt;&gt;" 运算符</span></span><br><span class="line"><span class="keyword">friend</span> iostream&amp; <span class="keyword">operator</span>&gt;&gt;(iostream&amp; in, MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_length;</span><br><span class="line"><span class="keyword">char</span>* m_space;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>MyString.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>() {</span><br><span class="line"><span class="comment">// 初始化为空字符串</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">int</span> len) {</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) {</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 初始化为空字符串</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = len;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p) {</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line"><span class="comment">// 初始化为空字符串</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, p);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line"><span class="comment">// 深拷贝，重新分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = str.m_length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MyString::~<span class="built_in">MyString</span>() {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 运算符</span></span><br><span class="line"><span class="keyword">char</span>&amp; MyString::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符</span></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* p) {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝，重新分配内存空间</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line"><span class="comment">// 初始化为空字符串</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, p);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符</span></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝，重新分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = str.m_length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length == <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length != <span class="built_in">strlen</span>(p)) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>==(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length != str.m_length) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>!=(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == str);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&gt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(p, <span class="keyword">this</span>-&gt;m_space) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(str.m_space, <span class="keyword">this</span>-&gt;m_space) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&lt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, p) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&lt;&lt;" 运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyString&amp; str) {</span><br><span class="line">out &lt;&lt; str.m_space;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&gt;&gt;" 运算符</span></span><br><span class="line">iostream&amp; <span class="keyword">operator</span>&gt;&gt;(iostream&amp; in, MyString&amp; str)</span><br><span class="line">{</span><br><span class="line">in &gt;&gt; str.m_space;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyString::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">MyString::c_str</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用有参构造函数</span></span><br><span class="line"><span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line"><span class="function">MyString <span class="title">str2</span><span class="params">(<span class="literal">NULL</span>)</span></span>;</span><br><span class="line"><span class="function">MyString <span class="title">str3</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用拷贝构造函数</span></span><br><span class="line">MyString str4 = str1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "&lt;&lt;" 运算符</span></span><br><span class="line">cout &lt;&lt; <span class="string">"str2 = "</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用拷贝构造函数（属于浅拷贝）</span></span><br><span class="line"><span class="comment">// 重载 "=" 运算符，实现深拷贝</span></span><br><span class="line">str4 = str3;</span><br><span class="line">cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">str4 = <span class="string">"Jim"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">str4 = <span class="literal">NULL</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "[]" 运算符</span></span><br><span class="line"><span class="function">MyString <span class="title">str5</span><span class="params">(<span class="string">"David"</span>)</span></span>;</span><br><span class="line">str5[<span class="number">0</span>] = <span class="string">'F'</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"str5[0] = "</span> &lt;&lt; str5[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"str5 = "</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "==" 运算符</span></span><br><span class="line"><span class="function">MyString <span class="title">str6</span><span class="params">(<span class="string">"Aaron"</span>)</span></span>;</span><br><span class="line">MyString str7 = str6;</span><br><span class="line">cout &lt;&lt; str6 &lt;&lt; (str6 == str7 ? <span class="string">" = "</span> : <span class="string">" != "</span>) &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "!=" 运算符</span></span><br><span class="line">cout &lt;&lt; str6 &lt;&lt; (str6 != <span class="literal">NULL</span> ? <span class="string">" != "</span> : <span class="string">" = "</span>) &lt;&lt; <span class="string">" NULL"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "&lt;" 运算符</span></span><br><span class="line"><span class="function">MyString <span class="title">str8</span><span class="params">(<span class="string">"AAAA"</span>)</span></span>;</span><br><span class="line"><span class="function">MyString <span class="title">str9</span><span class="params">(<span class="string">"BBBB"</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str8 &lt;&lt; (str8 &lt; str9 ? <span class="string">" &lt; "</span> : <span class="string">" &gt; "</span>) &lt;&lt; str9 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str8 &lt;&lt; (str8 &lt; <span class="string">"CCCC"</span> ? <span class="string">" &lt; "</span> : <span class="string">" &gt; "</span>) &lt;&lt; <span class="string">"CCCC"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "&gt;" 运算符</span></span><br><span class="line">cout &lt;&lt; str9 &lt;&lt; (str9 &gt; str8 ? <span class="string">" &gt; "</span> : <span class="string">" &lt; "</span>) &lt;&lt; str8 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str9 &lt;&lt; (str9 &gt; <span class="string">"DDDD"</span> ? <span class="string">" &gt; "</span> : <span class="string">" &lt; "</span>) &lt;&lt; <span class="string">"DDDD"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "&gt;&gt;" 运算符</span></span><br><span class="line"><span class="function">MyString <span class="title">str11</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入长度为 5 的字符串："</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str11.<span class="built_in">c_str</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"str11 = "</span> &lt;&lt; str11 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyString str4 = NULL;   此写法，会自动调用有参构造函数 `MyString(const char* p);`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyString str1("AB");</span></span><br><span class="line"><span class="comment">// MyString str2 = str1;</span></span><br><span class="line"><span class="comment">// str2 = NULL:    此写法，会自动调用 "=" 运算符重载的函数 `bool operator==(const char* p) const;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">str2 =</span><br><span class="line">str4 = Tom</span><br><span class="line"></span><br><span class="line">str4 = Peter</span><br><span class="line">str4 = Jim</span><br><span class="line">str4 =</span><br><span class="line"></span><br><span class="line">str5[0] = F</span><br><span class="line">str5 = Favid</span><br><span class="line"></span><br><span class="line">Aaron = Aaron</span><br><span class="line">Aaron !=  NULL</span><br><span class="line"></span><br><span class="line">AAAA &lt; BBBB</span><br><span class="line">AAAA &lt; CCCC</span><br><span class="line">BBBB &gt; AAAA</span><br><span class="line">BBBB &lt; DDDD</span><br><span class="line"></span><br><span class="line">请输入长度为 5 的字符串：</span><br><span class="line">abcde</span><br><span class="line">str11 = abcde</span><br></pre></td></tr></tbody></table></figure></code></details><h2 id="C-运算符和结合性的附录"><a href="#C-运算符和结合性的附录" class="headerlink" title="C++ 运算符和结合性的附录"></a>C++ 运算符和结合性的附录</h2><p><img data-src="../../../asset/2021/11/cplusplus-overload-9.png" alt="cplusplus-overload-9"><br><img data-src="../../../asset/2021/11/cplusplus-overload-10.png" alt="cplusplus-overload-10"></p>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括友元函数、友元类、运算符重载等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解决 Windows 系统使用 NPM 时遇到的各种问题</title>
    <link href="https://www.techgrow.cn/posts/b53b9a77.html"/>
    <id>https://www.techgrow.cn/posts/b53b9a77.html</id>
    <published>2021-11-03T13:55:33.000Z</published>
    <updated>2021-11-03T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="pngquant-bin-模块安装失败"><a href="#pngquant-bin-模块安装失败" class="headerlink" title="pngquant-bin 模块安装失败"></a>pngquant-bin 模块安装失败</h2><ul><li><p>错误信息：</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! path E:\Workspaces_NodeJs\hexo\node_modules\pngquant-bin</span><br><span class="line">npm ERR! command failed</span><br><span class="line">npm ERR! command C:\WINDOWS\system32\cmd.exe /d /s /c node lib/install.js</span><br><span class="line">npm ERR! ‼ getaddrinfo ENOENT raw.githubusercontent.com</span><br><span class="line">npm ERR!   ‼ pngquant pre-build test failed</span><br><span class="line">npm ERR!   i compiling from source</span><br><span class="line">npm ERR!   × ErroE: pngquant failed to build, make sure that libpng-dev is installed</span><br><span class="line">npm ERR!     at E:\Workspaces_NodeJs\hexo\node_modules\bin-build\node_modules\execa\index.js:231:11</span><br><span class="line">npm ERR!     at runMicrotasks (&lt;anonymous&gt;)</span><br><span class="line">npm ERR!     at processTicksAndRejections (node:internal/process/task_queues:96:5)</span><br><span class="line">npm ERR!     at async Promise.all (index 0)</span><br></pre></td></tr></tbody></table></figure></li></ul><span id="more"></span><ul><li><p>解决方法一：使用 <code>系统管理员身份</code>，在 Windows 系统上执行 <code>npm install -g windows-build-tools</code> 命令，安装系统缺失的编译工具，然后执行 <code>npm install</code> 命令安装需要的 NPM 模块</p></li><li><p>解决方法二（推荐）：使用 CNPM 替代 NPM，然后执行 <code>cnpm install</code> 命令安装需要的 NPM 模块</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装CNPM</span><br><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></tbody></table></figure></li><li><p>解决方法三（推荐）：在 Windows 系统上挂载 VPN，然后执行 <code>npm install</code> 命令安装需要的 NPM 模块，这可以从根本上解决国内访问 <code>raw.githubusercontent.com</code> 域名时被墙的问题</p></li><li><p>解决方法四：更改 Host 文件 <code>C:\Windows\System32\drivers\etc\hosts</code>，在文件末尾添加以下内容，解决国内访问 <code>raw.githubusercontent.com</code> 域名时被墙的问题，然后执行 <code>npm install</code> 命令安装需要的 NPM 模块</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">199.232.28.133  raw.githubusercontent.com</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何解决 Windows 系统使用 NPM 时遇到的各种问题。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Windows系统" scheme="https://www.techgrow.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10 系统备份与还原常见错误解决</title>
    <link href="https://www.techgrow.cn/posts/490dddd2.html"/>
    <id>https://www.techgrow.cn/posts/490dddd2.html</id>
    <published>2021-11-02T13:55:33.000Z</published>
    <updated>2021-11-02T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows 10 中的备份和还原（Windows 7）作为 Microsoft Windows 组件，继承了 Windows 7 的功能，该功能使您可以备份与恢复文件以及创建系统映像。如果在 Windows 的早期版本中使用 <code>备份</code> 和 <code>还原</code> 来备份文件或创建系统映像，则仍可以在 Windows 10 中恢复这些备份。此外，Windows 10 还包括另一个备份与恢复工具 - <code>文件历史记录</code>，它只备份文档，音乐，图片，视频和桌面文件夹中文件的版本，以及 PC 上可用的 OneDrive 文件。如果要使用 <code>文件历史记录</code> 备份位于其他位置的其他文件，可以将其移至这些文件夹之一，然后再进行备份。保存备份的两个目标地址支持外部硬盘驱动器（例如 USB 闪存驱动器）和网络位置。</p><span id="more"></span><h2 id="系统备份常见错误"><a href="#系统备份常见错误" class="headerlink" title="系统备份常见错误"></a>系统备份常见错误</h2><h3 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h3><h4 id="错误提示信息"><a href="#错误提示信息" class="headerlink" title="错误提示信息"></a>错误提示信息</h4><p><code>无法创建卷影副本，请检查 vss 和 spp 应用程序事件日志更多信息（错误代码：0x81000019）</code></p><p>或者</p><p><code>由于内部错误，备份应用程序无法启动：卷影复制服务组件遇到意外错误（错误代码：0x80042302）</code></p><h4 id="错误解决方案一"><a href="#错误解决方案一" class="headerlink" title="错误解决方案一"></a>错误解决方案一</h4><p>这个错误可能是由于三方杀毒软件冲突或者一些 Windows 备份相关的服务被禁用导致的，具体解决步骤如下：</p><ul><li>a) 暂时关闭或卸载第三方杀毒软件</li><li> b) 使用快捷键 <code>windows + r</code>，输入 <code>services.msc</code>，打开服务控制台，并检查下列服务是否正常运行。如果服务被禁用，请将其启用，并将启动类型设置为 <code>自动</code>。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Volume Shadow Copy (VSS)</span><br><span class="line">Remote Procedure Call (RPCSS)</span><br><span class="line">COM+ Event System (eventsystem)</span><br><span class="line">System Event Notification Service (sens)</span><br><span class="line">Microsoft Software Shadow Copy Provider (SWPRV)</span><br></pre></td></tr></tbody></table></figure><ul><li>c) 重启 Windows 10 系统，然后再次尝试执行系统备份</li></ul><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-4014850419768221" data-ad-slot="7606918662"></ins><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><h4 id="错误解决方案二"><a href="#错误解决方案二" class="headerlink" title="错误解决方案二"></a>错误解决方案二</h4><ul><li>a) 使用快捷键 <code>windows + r</code>，输入 <code>msconfig</code></li></ul><p><img data-src="../../../asset/2021/11/windows-backup-3.png" alt="windows-backup-3"></p><ul><li>b) 点击 <code>服务</code> 标签卡，勾选 <code>隐藏所有的 Microsoft 服务</code> ，然后点击全部禁用并应用</li></ul><p><img data-src="../../../asset/2021/11/windows-backup-4.png" alt="windows-backup-4"></p><ul><li> c) 点击 <code>启动</code> 标签卡，点击 <code>打开任务管理器</code></li></ul><p><img data-src="../../../asset/2021/11/windows-backup-5.png" alt="windows-backup-5"></p><ul><li>d) 禁用全部开机启动项</li></ul><p><img data-src="../../../asset/2021/11/windows-backup-6.png" alt="windows-backup-6"></p><ul><li><p> e) 重启 Windows 10 系统，然后再次尝试执行系统备份</p></li><li><p>f) 系统成功备份后，重新启用在上面的步骤中禁用的服务和开机启动项，最后再次重启系统</p></li></ul><h3 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h3><h4 id="错误提示信息-1"><a href="#错误提示信息-1" class="headerlink" title="错误提示信息"></a>错误提示信息</h4><p><code>Windows 备份在源卷上创建共享保护点失败（错误代码：0×8078006B）</code></p><h4 id="错误解决方案"><a href="#错误解决方案" class="headerlink" title="错误解决方案"></a>错误解决方案</h4><p>这个错误一般是由程序冲突引起的，目前排查出是 <code>腾讯电脑管家</code> 的设置问题导致，具体解决步骤如下：</p><ul><li>a) 打开 <code>腾讯电脑管家</code> 的 <code>设置中心</code></li></ul><p><img data-src="../../../asset/2021/11/windows-backup-1.png" alt="windows-backup-1"></p><ul><li>b) 找到 <code>实时防护</code> 菜单下面的 <code>其他安全提示</code>，将 <code>开启卷影备份</code> 的勾选去掉</li></ul><p><img data-src="../../../asset/2021/11/windows-backup-2.png" alt="windows-backup-2"></p><ul><li> c) 如果上述设置仍然没办法解决问题，建议暂时关闭或卸载 <code>腾讯电脑管家</code></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Windows 10 系统备份与还原常见错误的解决方案。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Windows系统" scheme="https://www.techgrow.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
