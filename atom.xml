<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术空间</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2025-02-13T13:55:33.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ 巩固进阶之二</title>
    <link href="https://www.techgrow.cn/posts/bd9d2710.html"/>
    <id>https://www.techgrow.cn/posts/bd9d2710.html</id>
    <published>2025-02-13T13:55:33.000Z</published>
    <updated>2025-02-13T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之二</a></li></ul><span id="more"></span><h2 id="C-对象深入探索"><a href="#C-对象深入探索" class="headerlink" title="C++ 对象深入探索"></a>C++ 对象深入探索</h2><h3 id="对象的构造与析构"><a href="#对象的构造与析构" class="headerlink" title="对象的构造与析构"></a>对象的构造与析构</h3><h4 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">10</span>) : _a(a) {</span><br><span class="line">cout &lt;&lt; <span class="string">"Test(int)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t) : _a(t._a) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp; t) {</span><br><span class="line">cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = t._a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    Test t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Test t3 = t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `Test t4(30);`</span></span><br><span class="line">    <span class="comment">// Test(30) 通常会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 但是，如果用临时对象去拷贝构造新对象，那么临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化</span></span><br><span class="line">    Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 1 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用赋值运算符重载函数</span></span><br><span class="line">    t4 = t2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// Test(20) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    t4 = <span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 2 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// (Test)20 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t4 = Test(20);`，这里要求 Test 类拥有 int 类型的构造函数</span></span><br><span class="line">    t4 = (Test)<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 3 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// 会隐式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t4 = Test(20);`，这里要求 Test 类拥有 int 类型的构造函数</span></span><br><span class="line">    t4 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 4 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// (Test)20 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 当临时对象出了所在语句，会立刻被析构，同时指针 p 会成为野指针</span></span><br><span class="line">    <span class="comment">// 结论：使用指针变量指向临时对象是不安全的</span></span><br><span class="line">    Test* p = &amp;<span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// (Test)20 会显式生成临时对象，临时对象的生存周期是所在函数</span></span><br><span class="line">    <span class="comment">// 但是，这里的临时对象出了所在语句，不会立刻被析构，而是直到出了函数作用域才会被析构</span></span><br><span class="line">    <span class="comment">// 在函数作用域内，ref 引用会一直有效</span></span><br><span class="line">    <span class="comment">// 结论：使用引用变量指向临时对象是安全的</span></span><br><span class="line">    Test&amp; ref = <span class="built_in">Test</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 1 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--------- 1 ---------</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">Test(int)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test()</span><br><span class="line">--------- 2 ---------</span><br><span class="line">Test(int)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test()</span><br><span class="line">--------- 3 ---------</span><br><span class="line">Test(int)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test()</span><br><span class="line">--------- 4 ---------</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">Test(int)</span><br><span class="line">~Test()</span><br><span class="line">Test(int)</span><br><span class="line">--------- 1 ---------</span><br><span class="line">~Test()</span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h4><div class="admonition note"><p class="admonition-title">提示</p><p>在 C++ 中，对象最先析构的，往往都是最后析构的，即符合 "先构造后析构" 的规则（类似栈的 "先进后出"），这规则同样适用于类成员属性的构造和析构。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">5</span>, <span class="keyword">int</span> b = <span class="number">5</span>) : _a(a), _b(b) {</span><br><span class="line">cout &lt;&lt; <span class="string">"Test("</span> &lt;&lt; a &lt;&lt; <span class="string">", "</span> &lt;&lt; b &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"~Test("</span> &lt;&lt; <span class="keyword">this</span>-&gt;_a &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="keyword">this</span>-&gt;_b &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t) : _a(t._a), _b(t._b) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp; t) {</span><br><span class="line">cout &lt;&lt; <span class="string">"operator=(const Test&amp; t)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = t._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = t._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Test t3 = t2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 1 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `Test t4(30, 30);`</span></span><br><span class="line">    <span class="comment">// Test(30, 30) 通常会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 但是，如果用临时对象去拷贝构造新对象，那么临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化</span></span><br><span class="line">    <span class="comment">// 这里定义的局部静态变量，只在程序结束的时候才会被析构</span></span><br><span class="line">    <span class="keyword">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 2 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// Test(40, 40) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// (Test)(50, 50) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t2 = Test(50);`，这里要求 Test 类拥有对应的构造函数</span></span><br><span class="line">    t2 = (Test)(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用普通构造函数，然后再调用赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">// 60 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 执行效果相当于 `t2 = Test(60);`，这里要求 Test 类拥有对应的构造函数</span></span><br><span class="line">    t2 = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 3 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    Test* p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用（两次）普通构造函数</span></span><br><span class="line">    Test* p2 = <span class="keyword">new</span> Test[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 4 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// Test(80, 80) 会显式生成临时对象，临时对象的生存周期是所在语句</span></span><br><span class="line">    <span class="comment">// 当临时对象出了所在语句，会立刻被析构，同时指针 p 会成为野指针</span></span><br><span class="line">    <span class="comment">// 结论：使用指针变量指向临时对象是不安全的</span></span><br><span class="line">    Test* p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    <span class="comment">// Test(90, 90) 会显式生成临时对象，临时对象的生存周期是所在函数</span></span><br><span class="line">    <span class="comment">// 但是，这里的临时对象出了所在语句，不会立刻被析构，而是直到出了函数作用域才会被析构</span></span><br><span class="line">    <span class="comment">// 在函数作用域内，ref 引用会一直有效</span></span><br><span class="line">    <span class="comment">// 结论：使用引用变量指向临时对象是安全的</span></span><br><span class="line">    Test&amp; p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 5 ---------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用析构函数</span></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用（两次）析构函数</span></span><br><span class="line"><span class="keyword">delete</span>[] p2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------- 6 ---------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个执行（t1 是最先构造的，而且又是最后析构）</span></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ start main()============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ end main()============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个执行</span></span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Test(10, 10)</span><br><span class="line">Test(100, 100)</span><br><span class="line"></span><br><span class="line">============ start main()============</span><br><span class="line"></span><br><span class="line">============ test01() ============</span><br><span class="line">Test(20, 20)</span><br><span class="line">Test(const Test&amp; t)</span><br><span class="line">--------- 1 ---------</span><br><span class="line">Test(30, 30)</span><br><span class="line">--------- 2 ---------</span><br><span class="line">Test(40, 40)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test(40, 40)</span><br><span class="line">Test(50, 5)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test(50, 5)</span><br><span class="line">Test(60, 5)</span><br><span class="line">operator=(const Test&amp; t)</span><br><span class="line">~Test(60, 5)</span><br><span class="line">--------- 3 ---------</span><br><span class="line">~Test(20, 20)</span><br><span class="line">~Test(60, 5)</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">Test(70, 70)</span><br><span class="line">Test(5, 5)</span><br><span class="line">Test(5, 5)</span><br><span class="line">--------- 4 ---------</span><br><span class="line">Test(80, 80)</span><br><span class="line">~Test(80, 80)</span><br><span class="line">Test(90, 90)</span><br><span class="line">--------- 5 ---------</span><br><span class="line">~Test(70, 70)</span><br><span class="line">~Test(5, 5)</span><br><span class="line">~Test(5, 5)</span><br><span class="line">--------- 6 ---------</span><br><span class="line">~Test(90, 90)</span><br><span class="line"></span><br><span class="line">============ end main()============</span><br><span class="line">~Test(30, 30)</span><br><span class="line">~Test(100, 100)</span><br><span class="line">~Test(10, 10)</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固进阶之一</title>
    <link href="https://www.techgrow.cn/posts/e302ad63.html"/>
    <id>https://www.techgrow.cn/posts/e302ad63.html</id>
    <published>2025-02-08T13:55:33.000Z</published>
    <updated>2025-02-08T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/e302ad63.html">C++ 巩固进阶之一</a>、<a href="/posts/bd9d2710.html">C++ 巩固进阶之二</a></li></ul><span id="more"></span><h2 id="C-11-的右值引用"><a href="#C-11-的右值引用" class="headerlink" title="C++ 11 的右值引用"></a>C++ 11 的右值引用</h2><h3 id="重现模拟实现字符串类的问题"><a href="#重现模拟实现字符串类的问题" class="headerlink" title="重现模拟实现字符串类的问题"></a>重现模拟实现字符串类的问题</h3><p>下述代码模拟实现了 C++ 中的 <code>string</code> 类，但是 <code>main()</code> 函数调用 <code>getString()</code> 函数的效率会非常低。第一个原因是，<code>getString()</code> 函数在调用结束时，返回了一个 MyString 对象，这会调用一次拷贝构造函数来拷贝 <code>tmpStr</code> 对象。第二个原因是，在 <code>main()</code> 函数中，将 <code>getStriing()</code> 函数的返回值赋值了给 <code>str2</code> 对象，这会调用赋值运算符重载函数，也就是又拷贝了一次数据。<a href="../../../asset/2025/02/cxx-custom-string-1.png">点击</a> 查看完整分析图解。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString &amp;str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(const MyString &amp;str)           // getString() 函数返回执行结果值时，调用拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(const MyString &amp;str)          // main() 函数中，执行赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="解决模拟实现字符串类的问题"><a href="#解决模拟实现字符串类的问题" class="headerlink" title="解决模拟实现字符串类的问题"></a>解决模拟实现字符串类的问题</h3><p>为了解决上述模拟实现字符串类时，多次拷贝内存数据导致运行效率低的问题，可以使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来解决。</p><h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><ul><li><p>左值引用与右值引用的介绍</p><ul><li><code>左值</code>：有名称、有内存</li><li><code>右值</code>：没名称（临时量）、没内存</li></ul></li><li><p>左值引用与右值引用的区别</p><ul><li>左值引用和右值引用的主要区别在于它们可以绑定的值类别，左值引用只能绑定到左值，而右值引用只能绑定到右值。</li><li>右值引用引入了 <code>move</code> 移动语义，使得 C++ 可以更高效地处理临时对象。</li><li>在泛型编程中，可以通过函数模板的类型推导来同时处理左值引用和右值引用，从而实现参数的 <code>forward</code> 完美转发。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="https://blog.csdn.net/haokan123456789/article/details/134980411">C++ 之 forward 完美转发</a></li><li><a href="https://www.cnblogs.com/5iedu/p/11324772.html">C++ 的 forward 完美转发</a></li><li><a href="https://zhuanlan.zhihu.com/p/710953400">深度解析 C++ 完美转发的实现原理与应用</a></li></ul></div><h5 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ......(省略)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;        <span class="comment">// 左值：有名称、有内存，右值：没名称（临时量）、没内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; b = a;        <span class="comment">// 可以将左值绑定到左值引用上</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; c = a;    // 无法将左值绑定到右值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; d = <span class="number">20</span>;      <span class="comment">// 可以将右值绑定到右值引用上</span></span><br><span class="line">    <span class="comment">// int&amp; c = 20;    // 无法将右值绑定到左值引用上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp;&amp; f = d;    // 无法将左值绑定到右值引用上，因为右值引用变量本身就是左值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyString&amp; s = MyString("aaa");   // 错误写法</span></span><br><span class="line">    MyString&amp;&amp; s = <span class="built_in">MyString</span>(<span class="string">"aaa"</span>);     <span class="comment">// 正确写法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="解决实现字符串类的问题"><a href="#解决实现字符串类的问题" class="headerlink" title="解决实现字符串类的问题"></a>解决实现字符串类的问题</h4><div class="admonition note"><p class="admonition-title">提示</p><ul><li>(1) 右值引用参数常用于减少内存数据的拷贝，比如在带右值引用参数的拷贝构造函数和赋值运算符重载函数中使用。</li><li>(2) 在带右值引用参数的拷贝构造函数和赋值运算符重载函数中，该右值引用参数接收的都是临时对象。</li></ul></div><h5 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h5><p>这里使用带右值引用参数的拷贝构造函数和赋值运算符重载函数，来解决在模拟实现 C++ 字符串类时，多次拷贝内存数据导致运行效率低的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">getString</span><span class="params">(MyString&amp; str)</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tmpStr</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码一"><a href="#测试代码一" class="headerlink" title="测试代码一"></a>测试代码一</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"aaaaaaa"</span>)</span></span>;</span><br><span class="line">    MyString str2;</span><br><span class="line">    str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">    cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str1 对象</span><br><span class="line">MyString(const char *p = nullptr)       // main() 函数中构造 str2 对象</span><br><span class="line">MyString(const char *p = nullptr)       // getString() 函数中构造 tmpStr 对象</span><br><span class="line">MyString(MyString&amp;&amp; str)                // getString() 函数返回执行结果值时，调用带右值引用参数的拷贝构造函数来拷贝 tmpStr 对象给 main() 函数栈帧上的临时对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 getString() 函数中的 tmpStr 对象</span><br><span class="line">operator=(MyString&amp;&amp; str)               // main() 函数中，执行带右值引用参数的赋值运算符重载函数来将 main() 函数栈帧上的临时对象赋值给 str2 对象（使用浅拷贝提高运行效率）</span><br><span class="line">~MyString()                             // 析构 main() 函数栈帧上的临时对象</span><br><span class="line">aaaaaaa             </span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str2 对象</span><br><span class="line">~MyString()                             // 析构 main() 函数中的 str1 对象</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">================ test01() ================</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">operator=(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">aaaaaaa</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码二"><a href="#测试代码二" class="headerlink" title="测试代码二"></a>测试代码二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"Hello "</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">str2</span><span class="params">(<span class="string">"World!"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    MyString str3 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Release 模式下，由于编译器的优化，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">---------------------------------</span><br><span class="line">Hello World!</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h5 id="测试代码三"><a href="#测试代码三" class="headerlink" title="测试代码三"></a>测试代码三</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    MyString str1 = <span class="string">"aaa"</span>;</span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(str1); <span class="comment">// 调用的是带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是带右值引用参数的拷贝构造函数 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 中，无论是 Debug 模式，还是 Release 模式，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br><span class="line">~MyString()</span><br><span class="line"></span><br><span class="line">============ test02() ============</span><br><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h2 id="C-11-的移动语义与完美转发"><a href="#C-11-的移动语义与完美转发" class="headerlink" title="C++ 11 的移动语义与完美转发"></a>C++ 11 的移动语义与完美转发</h2><h3 id="基础案例代码"><a href="#基础案例代码" class="headerlink" title="基础案例代码"></a>基础案例代码</h3><h4 id="自定义字符串类"><a href="#自定义字符串类" class="headerlink" title="自定义字符串类"></a>自定义字符串类</h4><p>自定义一个 MyString 字符串类，模拟实现　C++ 的 <code>string</code> 字符串类，主要使用带右值引用参数的拷贝构造函数和赋值运算符重载函数来减少内存数据的拷贝次数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const char *p = nullptr)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~MyString()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyString(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(const MyString &amp;str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带右值引用参数的赋值运算符重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator=(MyString&amp;&amp; str)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝临时对象（可以提高代码执行效率，减少内存数据的拷贝次数）</span></span><br><span class="line">        _pstr = str._pstr;</span><br><span class="line">        str._pstr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; str1, <span class="keyword">const</span> MyString&amp; str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-容器类"><a href="#自定义-Vector-容器类" class="headerlink" title="自定义 Vector 容器类"></a>自定义 Vector 容器类</h4><p>自定义一个 Vector 容器类，模拟实现　C++ 的 <code>vector</code> 容器，主要实现了 <code>vector</code>　容器的空间分配器、迭代器。值得一提的是，由于篇幅有限，这里虽然解决迭代器失效的问题，但是并没有解决容器扩容（执行插入操作）后导致迭代器失效的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt; *pvec = <span class="literal">nullptr</span>, T *p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base *itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt; *_pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T *p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T *p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator *cur = <span class="literal">nullptr</span>, Iterator_Base *next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator *_cur;</span><br><span class="line">        Iterator_Base *_next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T *start, T *end)</span> </span>{</span><br><span class="line">        Iterator_Base *cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base *next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="自定义-Vector-类存在的问题"><a href="#自定义-Vector-类存在的问题" class="headerlink" title="自定义 Vector 类存在的问题"></a>自定义 Vector 类存在的问题</h4><p>使用上面自定义的 Vecotr 容器类执行以下测试代码后，发现执行 <code>vector.push_back(MyString("bbb"))</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，这会导致多拷贝一份内存数据，从而影响程序的执行效率。值得一提的是，这里希望调用的是 MyString 类带右值引用参数的拷贝构造函数，因为该带右值引用参数的拷贝构造函数使用的是浅拷贝，可以减少内存数据的拷贝次数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带左值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(const MyString &amp;str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="move-移动语义"><a href="#move-移动语义" class="headerlink" title="move 移动语义"></a>move 移动语义</h3><h4 id="move-移动语义的概念"><a href="#move-移动语义的概念" class="headerlink" title="move 移动语义的概念"></a>move 移动语义的概念</h4><p>C++ 中的移动语义是引入于 C++ 11 的一种特性，它通过引入移动构造函数和移动赋值运算符，允许程序以更高效的方式管理资源，尤其是在避免不必要的拷贝操作时。移动语义的核心是利用右值引用（<code>T&amp;&amp;</code>）和标准库中的 <code>std::move</code>，使对象的资源从一个对象转移到另一个对象（比如将左值类型强转为右值类型），而不是拷贝，从而提高程序性能。</p><ul><li><p>移动语义的主要作用</p><ul><li>高效资源转移：避免资源分配和释放的重复工作。</li><li>减少拷贝：通过转移所有权来减少对象的拷贝。</li><li>提高程序性能：尤其适用于内存密集型和资源管理复杂的程序。</li></ul></li><li><p>移动语义的使用场景</p><ul><li>减少临时对象的开销（如函数返回大对象）。</li><li>避免深拷贝（如容器中的数据转移）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="https://blog.csdn.net/chenmi123321/article/details/144334601">C++ 的 移动语义 move</a></li><li><a href="https://zhuanlan.zhihu.com/p/602543410">理解现代 C++ 中的移动语义</a></li></ul></div><h4 id="move-移动语义的使用"><a href="#move-移动语义的使用" class="headerlink" title="move 移动语义的使用"></a>move 移动语义的使用</h4><p>在上面自定义的 Vector 容器类中，为了解决执行 <code>vector.push_back(MyString("bbb"))</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题，可以使用 C++ 中的 <code>move</code> 移动语义来解决。</p><ul><li>更改的核心代码<ul><li>重载 <code>Allocator::construct()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型</li><li>重载 <code>Vector::push_back()</code> 函数，分别用于接收左值引用参数和右值引用参数，并使用 <code>move</code> 移动语义将左值类型强转为右值类型 </li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(<span class="built_in">move</span>(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收左值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// move 是移动语义，可以将左值类型强转为右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, <span class="built_in">move</span>(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure><h3 id="forward-完美转发"><a href="#forward-完美转发" class="headerlink" title="forward 完美转发"></a>forward 完美转发</h3><p>虽然使用 C++ 11 提供的 <code>move</code> 移动语义，可以解决在执行 <code>vector.push_back(MyString("bbb"))</code> 时，会调用 MyString 类带左值引用参数的拷贝构造函数，从而导致多拷贝一份内存数据的问题。但是，这样每次都需要定义两个重载函数来分别接收左值引用参数和右值引用参数，这就显得比较繁琐。为了使 C++ 代码更简洁，可以使用 C++ 11 提供的 <code>forward</code> 完美转发来实现同样的功能。</p><h4 id="forward-完美转发的概念"><a href="#forward-完美转发的概念" class="headerlink" title="forward 完美转发的概念"></a>forward 完美转发的概念</h4><p>完美转发（Perfect Forwarding）是 C++ 11 中引入的一种编程技巧，其目的是在编写泛型函数时能够保留参数的类型和值类别（左值或右值），从而实现更为高效且准确地传递参数。通过使用右值引用和模板类型推导，完美转发允许在函数中以原始参数的形式将参数传递给其他函数，而不会发生不必要的拷贝操作，从而提高性能。完美转发在很多场合都非常有用，尤其是在设计泛型库和需要高效参数传递的场景。以下是一些常见的完美转发应用场景：</p><ul><li>(1) 委托构造函数：完美转发可以在构造函数之间传递参数，避免不必要的拷贝操作，从而提高性能。</li><li>(2) 可变参数模板函数：完美转发可以用于实现可接受任意数量和类型参数的函数，如实现一个通用的元组或 <code>bind()</code> 函数。</li><li>(3) 智能指针：完美转发在智能指针的实现中也有重要作用，例如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 中的构造函数和 <code>make()</code> 函数等。</li><li>(4) 函数包装器：完美转发可以用于实现函数包装器，使包装后的函数能够正确处理所有类型的参数，包括右值引用。例如 <code>std::function</code> 的实现。</li><li>(5) 资源管理类：通过完美转发，可以使资源管理类（如锁管理类、线程池等）能够更方便地处理各种资源。</li></ul><h4 id="forward-完美转发的使用"><a href="#forward-完美转发的使用" class="headerlink" title="forward 完美转发的使用"></a>forward 完美转发的使用</h4><ul><li>更改的核心代码<ul><li>更改 <code>Allocator::construct()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型</li><li>重载 <code>Vector::push_back()</code> 函数，接收右值引用参数，并使用函数模板的类型推导 + 引用折叠 + <code>forward</code> 完美转发来识别左值类型和右值类型 </li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(forward&lt;Ty&gt;(val));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素（接收右值引用参数）</span></span><br><span class="line">    <span class="comment">// 基于函数模板的类型推导 + 引用折叠</span></span><br><span class="line">    <span class="comment">// T &amp; + Ty &amp;&amp;  = T &amp;</span></span><br><span class="line">    <span class="comment">// T &amp;&amp; + Ty &amp;&amp;  = T &amp;&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="comment">// forward 是完美转发，可以识别左值类型和右值类型</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, forward&lt;Ty&gt;(val));</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt;* pvec = <span class="literal">nullptr</span>, T* p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base* itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* _ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt;* _pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T* p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T* p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T* _last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* cur = <span class="literal">nullptr</span>, Iterator_Base* next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T* _ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* start, T* end)</span> </span>{</span><br><span class="line">        Iterator_Base* cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base* next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;MyString&gt; v1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">"bbb"</span>));  <span class="comment">// 调用的是 MyString 带右值引用参数的拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 的 Debug 模式下，程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line">MyString(const char *p = nullptr)</span><br><span class="line">MyString(MyString&amp;&amp; str)</span><br><span class="line">~MyString()</span><br><span class="line">----------------------------------</span><br><span class="line">~MyString()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 多线程编程之一</title>
    <link href="https://www.techgrow.cn/posts/a2a7ad9b.html"/>
    <id>https://www.techgrow.cn/posts/a2a7ad9b.html</id>
    <published>2025-02-07T13:55:33.000Z</published>
    <updated>2025-02-07T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者 - 消费者模型</h2><span id="more"></span><h3 id="重点知识"><a href="#重点知识" class="headerlink" title="重点知识"></a>重点知识</h3><blockquote><p>unique_lock 的作用</p></blockquote><p><code>unique_lock</code> 是 C++ 标准库 <code>mutex</code> 的 RAII（资源获取即初始化）封装，用于自动管理互斥锁。当执行 <code>unique_lock&lt;mutex&gt; lock(_mutex);</code> 时：</p><ul><li>当前线程尝试获取 <code>mutex</code> 锁（如果其他线程已经持有锁，则当前线程会阻塞等待，直到锁被释放）。</li><li>一旦成功获取锁，在 <code>lock</code> 对象的生命周期内，当前线程独占访问受保护的资源。</li><li>当 <code>lock</code> 对象销毁时（如作用域结束），<code>mutex</code> 会自动解锁，从而可以避免死锁或资源泄露。</li></ul><blockquote><p>unique_lock 与 lock_guard 的区别</p></blockquote><ul><li><p><code>unique_lock</code></p><ul><li>使用语法（<code>unique_lock&lt;mutex&gt; lock(_mutex);</code>）</li><li>可以手动解锁（<code>lock.unlock()</code>）。</li><li>可以延迟加锁（<code>unique_lock&lt;mutex&gt; lock(_mutex, defer_lock);</code>）。</li><li>可以移动赋值（<code>unique_lock</code> 可被转移，但 <code>lock_guard</code> 不能）。</li><li>通常与 <code>condition_variable</code> 搭配使用，因为 <code>condition_variable::wait()</code> 函数需要传入 <code>unique_lock</code> 参数（不能使用 <code>lock_guard</code>）。</li></ul></li><li><p><code>lock_guard</code></p><ul><li>使用语法（<code>lock_guard&lt;mutex&gt; lock(_mutex);</code>）</li><li>作用域结束时自动解锁，不可以手动解锁。</li><li>比 <code>unique_lock</code> 更轻量级，性能更好（因为没有 <code>unlock ()</code> 之类的额外操作）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><ul><li>如果只需要简单加锁 / 解锁，建议使用 <code>lock_guard</code>，效率更高。</li><li>如果需要手动控制解锁，建议使用 <code>unique_lock</code>。</li></ul></div><h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><p>模拟实现生产者线程生产一条数据，消费者线程就消费一条数据，两个线程一直交替执行。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex _mutex;                <span class="comment">// 互斥锁</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; _queue;           <span class="comment">// 共享数据队列</span></span><br><span class="line">condition_variable _cv;      <span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">atomic_bool</span> _finish(<span class="literal">false</span>);  <span class="comment">// 控制标志（用于终止程序）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!_finish) {</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到满足条件才继续往下执行（可以避免虚假唤醒）</span></span><br><span class="line">        _cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> _queue.<span class="built_in">empty</span>(); });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟生产时间</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">rand</span>() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        _queue.<span class="built_in">push</span>(item);</span><br><span class="line">        cout &lt;&lt; <span class="string">"生产: "</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者</span></span><br><span class="line">        _cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!_finish) {</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到满足条件才继续往下执行（可以避免虚假唤醒）</span></span><br><span class="line">        _cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> !_queue.<span class="built_in">empty</span>(); });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟消费时间</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> item = _queue.<span class="built_in">front</span>();</span><br><span class="line">        _queue.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"消费: "</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知生产者</span></span><br><span class="line">        _cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动生产者和消费者线程</span></span><br><span class="line">    <span class="function">thread <span class="title">producer</span><span class="params">(produce)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">consumer</span><span class="params">(consume)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程运行 60 秒</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">60</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置终止标志</span></span><br><span class="line">    _finish = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有线程，确保它们能结束</span></span><br><span class="line">    _cv.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待生产者和消费者线程结束</span></span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">生产: 98</span><br><span class="line">消费: 98</span><br><span class="line">生产: 635</span><br><span class="line">消费: 635</span><br><span class="line">生产: 318</span><br><span class="line">消费: 318</span><br><span class="line">生产: 513</span><br><span class="line">消费: 513</span><br><span class="line">生产: 413</span><br><span class="line">消费: 413</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的多线程编程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux系统编程" scheme="https://www.techgrow.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于 C++ 实现 MySQL 数据库连接池</title>
    <link href="https://www.techgrow.cn/posts/993ae2e0.html"/>
    <id>https://www.techgrow.cn/posts/993ae2e0.html</id>
    <published>2025-01-28T13:55:33.000Z</published>
    <updated>2025-01-28T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/c942e1de.html">C++ 使用 API 连接 MySQL 数据库</a></li><li><a href="/posts/993ae2e0.html">基于 C++ 实现 MySQL 数据库连接池</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了在 C/C++ 项目中，提高 MySQL Server 的访问效率，实现基于 C++ 的数据库连接池模块。</p><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>为了提高 MySQL 数据库 (基于 C/S 设计) 的访问瓶颈，除了在服务器端增加缓存服务器缓存常用的数据之外（例如 Redis），还可以增加连接池，来提高 MySQL Server 的访问效率。在高并发情况下，大量的 TCP 三次握手、MySQL Server 连接认证、MySQL Server 关闭连接回收资源和 TCP 四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的性能损耗。在市场上比较流行的连接池包括 C3P0、Apache DBCP、HikariCP、阿里巴巴的 Druid 连接池，它们对于短时间内大量的数据库增删改查操作性能的提升是很明显的，但是它们有一个共同点就是，全部都是由 Java 实现的。</p><span id="more"></span><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><ul><li>单例模式</li><li> Lambda 表达式</li><li>队列容器 <code>queue</code></li><li>智能指针 <code>shared_ptr</code></li><li>基于 CAS 的原子基础类型</li><li> MySQL 数据库编程（基于 MySQL Connector/C++）</li><li>C++ 11 的多线程编程，包括线程互斥、线程同步通信等</li><li>生产者 - 消费者线程模型的实现，基于 <code>mutex</code>、<code>unique_lock</code>、<code>condition_variable</code></li></ul><h2 id="开发平台的选型"><a href="#开发平台的选型" class="headerlink" title="开发平台的选型"></a>开发平台的选型</h2><p>有关 MySQL 数据库编程、多线程编程、线程互斥和同步通信操作、智能指针、设计模式、容器等等这些技术在 C++ 语言层面都可以直接实现，因此该项目选择直接在 Windows 平台上进行开发，当然项目代码在 Linux 平台下用 <code>g++</code> 也可以直接编译运行。</p><h3 id="Linux-平台开发"><a href="#Linux-平台开发" class="headerlink" title="Linux 平台开发"></a>Linux 平台开发</h3><p>由于 MySQL Connector/C++ 依赖了 <code>boost</code>，因此本地操作系统需要安装 <code>boost</code>。建议从 <a href="https://www.boost.org/users/download/">boost 官网</a> 下载 <code>boost</code> 的源码压缩包，然后使用 <code>root</code> 用户手动编译安装 <code>boost</code>，此方式适用于大多数 Linux 系统，如下所示：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">$ wget https://boostorg.jfrog.io/artifactory/main/release/1.78.0/<span class="built_in">source</span>/boost_1_78_0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line">$ tar -xvf boost_1_78_0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line">$ <span class="built_in">cd</span> boost_1_78_0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建</span></span><br><span class="line">$ sudo ./bootstrap.sh --prefix=/usr/<span class="built_in">local</span>/boost</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装（耗时非常长）</span></span><br><span class="line">$ sudo ./b2 install --prefix=/usr/<span class="built_in">local</span>/boost --with=all</span><br></pre></td></tr></tbody></table></figure><p>然后进入项目的根目录，通过 CMake 命令直接编译项目即可，比如：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置项目，生成构建文件（例如 Makefile 或 Ninja 文件）</span></span><br><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译项目，生成可执行文件</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></tbody></table></figure><h3 id="Windows-平台开发"><a href="#Windows-平台开发" class="headerlink" title="Windows 平台开发"></a>Windows 平台开发</h3><p>由于 MySQL Connector/C++ 依赖了 <code>boost</code>，因此本地操作系统需要先安装 <code>boost</code>，安装步骤如下：</p><ul><li>(1) 在 <a href="https://www.boost.org/users/download/">Boost 官网</a> 下载最新版本的 <code>Boost</code>，并解压到本地磁盘，例如解压路径为：<code>C:\Program Files\boost_1_77_0</code></li><li>(2) 在 Visual Studio 中右键项目，选择 <code>属性</code>，导航到 <code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code>，添加 <code>Boost</code> 的安装路径（如 <code>C:\Program Files\boost_1_77_0</code>），如下图所示</li></ul><p><img data-src="../../../asset/2025/02/cxx-mysql-connection-pool-boost.png"></p><p>然后进入项目的根目录，通过 CMake 命令直接编译项目即可，比如：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置项目，生成构建文件（例如 Makefile 或 Ninja 文件）</span></span><br><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译项目，生成可执行文件</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></tbody></table></figure><h2 id="连接池的功能介绍"><a href="#连接池的功能介绍" class="headerlink" title="连接池的功能介绍"></a>连接池的功能介绍</h2><p>连接池一般包含了数据库连接所用的 IP 地址、Port 端口号、用户名和密码以及其它的性能参数，例如初始连接数、最大连接数、最大空闲时间、连接超时时间等。本项目是基于 C++ 语言实现的连接池，主要也是实现以上几个所有连接池都支持的通用基础功能，其余连接池更多的扩展功能，可以自行实现。</p><ul><li><p>初始连接数（initSize）：</p><ul><li>表示连接池事先会和 MySQL Server 创建 initSize 个数的 connection 连接，当应用发起 MySQL 访问时，不用再创建和 MySQL Server 新的连接，直接从连接池中获取一个可用的连接就可以，使用完成后，并不去释放 connection，而是把当前 connection 再归还到连接池当中。</li></ul></li><li><p>最大连接数（maxSize）:</p><ul><li>当并发访问 MySQL Server 的请求增多时，初始连接数已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用，但是新创建的连接数量上限是 maxSize，不能无限制地创建连接，因为每一个连接都会占用一个 socket 资源。一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多的 socket 资源，那么服务器就不能接收太多的客户端请求了。当这些连接使用完成后，再次归还到连接池当中来维护。</li></ul></li><li><p>最大空闲时间（maxIdleTime）：</p><ul><li>当访问 MySQL 的并发请求多了以后，连接池里面的连接数量会动态增加，上限是 maxSize 个，当这些连接用完再次归还到连接池当中。如果在指定的 maxIdleTime 里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收掉，只需要保持初始连接数 initSize 个连接就可以了。</li></ul></li><li><p>连接超时时间（connectionTimeout）:</p><ul><li>当 MySQL 的并发请求量过大，连接池中的连接数量已经到达 maxSize 了，而此时没有空闲的连接可供使用，那么此时应用无法从连接池获取连接，它通过阻塞的方式获取连接的等待时间如果超过 connectionTimeout 时间，则获取连接失败，无法访问数据库。</li></ul></li></ul><h2 id="连接池的功能设计"><a href="#连接池的功能设计" class="headerlink" title="连接池的功能设计"></a>连接池的功能设计</h2><ul><li><p>C++ 源文件的功能划分</p><ul><li><code>MysqlConnection.h</code> 和 <code>MysqlConnection.cpp</code>：数据库增删改查的代码实现</li><li><code>MysqlConnectionPool.h</code> 和 <code>MysqlConnectionPool.cpp</code>：连接池的代码实现</li></ul></li><li><p>连接池的实现主要包含了以下功能</p><ul><li>(1) 连接池只需要一个实例，所以 ConnectionPool 以单例模式进行设计。</li><li>(2) 应用可以从 ConnectionPool 中获取 MySQL 的连接 Connection。</li><li>(3) 空闲连接 Connection 全部存储在一个线程安全的 Connection 队列中，使用互斥锁来保证队列的线程安全。</li><li>(4) 如果 Connection 队列为空，应用还需要再获取连接，此时需要动态创建连接，最大的连接数量是 maxSize。</li><li>(5) 当队列中空闲连接的存活时间超过 maxIdleTime 后，连接就要被释放掉，只保留初始的 initSize 个连接就可以，这个功能需要放在独立的线程中去完成（定时扫描连接）。</li><li>(6) 如果 Connection 队列为空，而且当前已创建的连接的数量已达到上限 maxSize，则应用需要等待 connectionTimeout 时间。如果应用还是获取不到空闲的连接，则获取连接失败；此处从 Connection 队列获取空闲连接时，可以使用带超时时间的 <code>mutex</code> 互斥锁来实现连接超时时间。</li><li>(7) 应用获取的连接用 <code>shared_ptr</code> 智能指针来管理，并用 Lambda 表达式定制连接释放的功能（不真正释放连接，而是将连接归还到 Connection 队列中）。</li><li>(8) 连接的生产和连接的消费采用生产者 - 消费者线程模型来设计，使用了线程间的同步通信机制、条件变量和互斥锁。</li></ul></li></ul><h2 id="连接池的代码实现"><a href="#连接池的代码实现" class="headerlink" title="连接池的代码实现"></a>连接池的代码实现</h2><h3 id="连接池的项目目录结构"><a href="#连接池的项目目录结构" class="headerlink" title="连接池的项目目录结构"></a>连接池的项目目录结构</h3><p><img data-src="../../../asset/2025/02/cxx-mysql-connection-pool-arch.png"></p><h3 id="连接池的-CMake-配置"><a href="#连接池的-CMake-配置" class="headerlink" title="连接池的 CMake 配置"></a>连接池的 CMake 配置</h3><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 CMake 的版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第三方库的目录路径</span></span><br><span class="line"><span class="keyword">set</span>(PATH_TO_BOOST /usr/local/boost)</span><br><span class="line"><span class="keyword">set</span>(PATH_TO_MYSQL_CONNECTOR ./libs/mysql-connector)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目信息</span></span><br><span class="line"><span class="keyword">project</span>(db_connection_pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 C++ 的版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定构建输出的目录</span></span><br><span class="line"><span class="keyword">set</span>(PROJECT_BINARY_DIR <span class="variable">${PROJECT_SOURCE_DIR}</span>/build)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">${PROJECT_SOURCE_DIR}</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义目标，每次编译之前清理可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(clean_bin ALL</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_COMMAND}</span> -E remove_directory <span class="variable">${EXECUTABLE_OUTPUT_PATH}</span></span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_COMMAND}</span> -E <span class="keyword">make_directory</span> <span class="variable">${EXECUTABLE_OUTPUT_PATH}</span></span><br><span class="line">        COMMENT <span class="string">"Cleaning bin directory before build"</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义命令，每次编译之前拷贝 MySQL 配置文件到可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">        <span class="keyword">TARGET</span> clean_bin</span><br><span class="line">        POST_BUILD</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">${CMAKE_COMMAND}</span> -E copy_if_different</span><br><span class="line">        <span class="variable">${CMAKE_SOURCE_DIR}</span>/config/mysql.ini</span><br><span class="line">        <span class="variable">${EXECUTABLE_OUTPUT_PATH}</span>/mysql.ini</span><br><span class="line">        COMMENT <span class="string">"Copying mysql.ini to bin directory before build"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入项目里的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${PROJECT_SOURCE_DIR}</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索项目里的源文件，并将文件名保存到 MAIN_SOURCES 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">${PROJECT_SOURCE_DIR}</span>/src MAIN_SOURCES)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入第三方库的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${PATH_TO_BOOST}</span>/<span class="keyword">include</span> <span class="variable">${PATH_TO_MYSQL_CONNECTOR}</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定项目里静态库和动态链接库的目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">${PATH_TO_BOOST}</span>/lib <span class="variable">${PATH_TO_MYSQL_CONNECTOR}</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的名称和项目里的所有源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${MAIN_SOURCES}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译参数，比如包括链接库文件：pthread、ssl、crypto、boost</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"-lpthread -lssl -lcrypto -lboost_system -lboost_filesystem"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接项目里的静态库和动态链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">${PROJECT_NAME}</span> ssl.so crypto.so mysqlcppconn.so)</span><br></pre></td></tr></tbody></table></figure><h3 id="连接池的-C-头文件"><a href="#连接池的-C-头文件" class="headerlink" title="连接池的 C++ 头文件"></a>连接池的 C++ 头文件</h3><ul><li><code>public.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LOG(format, ...) printf(format, __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LOG(format, ...) printf(format, ##__VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>MysqlConnection.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MySQL 增删改查操作的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql_connection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/driver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/exception.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/resultset.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/statement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/prepared_statement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> chrono::system_clock::time_point time_point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 数据库操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlConnection</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MysqlConnection</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MysqlConnection</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *query, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string dbname)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshAliveTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getAliveTime</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _host;                           <span class="comment">// MySQL 连接地址</span></span><br><span class="line">    string _username;                       <span class="comment">// MySQL 用户名</span></span><br><span class="line">    string _password;                       <span class="comment">// MySQL 密码</span></span><br><span class="line">    string _dbname;                         <span class="comment">// MySQL 数据库</span></span><br><span class="line">    Driver *_driver;                        <span class="comment">// MySQL 驱动</span></span><br><span class="line">    Connection *_connection;                <span class="comment">// MySQL 连接</span></span><br><span class="line">    time_point _aliveTime;                  <span class="comment">// 记录连接进入空闲状态后的起始存活时间点</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>MysqlConnectionPool.h</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MySQL 连接池的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"public.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 连接池类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlConnectionPool</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MysqlConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断连接池是否已关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isClosed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池中的连接数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池单例</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MysqlConnectionPool *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 MySQL 连接</span></span><br><span class="line">    <span class="function">shared_ptr&lt;MysqlConnection&gt; <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="built_in">MysqlConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝造函数私有化</span></span><br><span class="line">    <span class="built_in">MysqlConnectionPool</span>(<span class="keyword">const</span> MysqlConnectionPool &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loadConfigFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产 MySQL 连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描多余的空闲连接，并释放连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scanIdleConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">static</span> MysqlConnectionPool *INSTANCE;</span><br><span class="line"></span><br><span class="line">    string _host;             <span class="comment">// MySQL 连接地址</span></span><br><span class="line">    string _username;         <span class="comment">// MySQL 用户名</span></span><br><span class="line">    string _password;         <span class="comment">// MySQL 密码</span></span><br><span class="line">    string _dbname;           <span class="comment">// MySQL 数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _initSize;            <span class="comment">// 初始连接数</span></span><br><span class="line">    <span class="keyword">int</span> _maxSize;             <span class="comment">// 最大连接数</span></span><br><span class="line">    <span class="keyword">int</span> _maxIdleTime;         <span class="comment">// 最大空闲时间（单位秒）</span></span><br><span class="line">    <span class="keyword">int</span> _connectionTimeout;   <span class="comment">// 连接超时时间（单位毫秒）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_int</span> _connectionCount;                 <span class="comment">// MySQL 连接的总数量</span></span><br><span class="line">    queue&lt;MysqlConnection *&gt; _connectionQueue;   <span class="comment">// 存储 MySQL 连接的队列</span></span><br><span class="line">    mutex _queueMutex;                           <span class="comment">// 维护 MySQL 连接队列线程安全的互斥锁</span></span><br><span class="line">    condition_variable _cv;                      <span class="comment">// 条件变量，用于连接生产者线程和连接消费者线程之间的通信</span></span><br><span class="line">    <span class="keyword">atomic_bool</span> _closed;                         <span class="comment">// 连接池是否已关闭</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="连接池的-C-源文件"><a href="#连接池的-C-源文件" class="headerlink" title="连接池的 C++ 源文件"></a>连接池的 C++ 源文件</h3><ul><li><code>MysqlConnection.cpp</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MysqlConnection::<span class="built_in">MysqlConnection</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MysqlConnection::~<span class="built_in">MysqlConnection</span>() {</span><br><span class="line">    <span class="comment">// 关闭数据连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection &amp;&amp; !<span class="keyword">this</span>-&gt;_connection-&gt;<span class="built_in">isClosed</span>()) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;_connection-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// LOG("# DE<span class="doctag">BUG:</span> %s\n", "Closed mysql connection");</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行任何 SQL 语句，返回一个 bool 值，表明执行该 SQL 语句是否返回了 ResultSet</span></span><br><span class="line"><span class="comment">// 如果执行后第一个结果是 ResultSet，则返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnection::execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="function">unique_ptr&lt;Statement&gt; <span class="title">statement</span><span class="params">(<span class="keyword">this</span>-&gt;_connection-&gt;createStatement())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (statement) {</span><br><span class="line">                <span class="keyword">return</span> statement-&gt;<span class="built_in">execute</span>(sql);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE</span></span><br><span class="line"><span class="comment">// 函数的返回值是一个整数，指示受影响的行数，对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，返回值总为零</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MysqlConnection::executeUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="function">unique_ptr&lt;Statement&gt; <span class="title">statement</span><span class="params">(<span class="keyword">this</span>-&gt;_connection-&gt;createStatement())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (statement) {</span><br><span class="line">                <span class="keyword">return</span> statement-&gt;<span class="built_in">executeUpdate</span>(sql);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 SQL 的预编译机制，执行查询单个结果集（ResultSet）的 SQL 语句，例如 SELECT 语句</span></span><br><span class="line"><span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">MysqlConnection::query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span> </span>{</span><br><span class="line">    unique_ptr&lt;ResultSet&gt; resultSet = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="function">unique_ptr&lt;PreparedStatement&gt; <span class="title">statement</span><span class="params">(<span class="keyword">this</span>-&gt;_connection-&gt;prepareStatement(sql))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (statement) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> iterator = parameters.<span class="built_in">cbegin</span>(); iterator != parameters.<span class="built_in">cend</span>(); iterator++) {</span><br><span class="line">                    index++;</span><br><span class="line">                    statement-&gt;<span class="built_in">setString</span>(index, (*iterator).<span class="built_in">c_str</span>());</span><br><span class="line">                }</span><br><span class="line">                resultSet.<span class="built_in">reset</span>(statement-&gt;<span class="built_in">executeQuery</span>());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> resultSet;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接 MySQL 数据库</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnection::connect</span><span class="params">(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string dbname)</span> </span>{</span><br><span class="line">    <span class="comment">// 初始化MySQL的连接信息</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_host = <span class="string">"tcp://"</span> + host;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_username = username;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_password = password;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_dbname = dbname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 加载MySQL驱动</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_driver = <span class="built_in">get_driver_instance</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;_driver) {</span><br><span class="line">            <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to load mysql _driver"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接MySQL实例</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_connection = _driver-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;_host.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;_username.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;_password.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;_connection) {</span><br><span class="line">            <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to connect mysql server"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 设置默认数据库</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_connection-&gt;<span class="built_in">setSchema</span>(<span class="keyword">this</span>-&gt;_dbname.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="comment">// LOG("# DE<span class="doctag">BUG:</span> %s\n", "Inited mysql connection");</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SQLException &amp;e) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: SQLException in %s(%s) on line %d \n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: MySQL Error Code %d\n"</span>, e.<span class="built_in">getErrorCode</span>());</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnection::refreshAliveTime</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;_aliveTime = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接的空闲存活时间（单位毫秒）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">MysqlConnection::getAliveTime</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    chrono::milliseconds active_timestamp_ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(<span class="keyword">this</span>-&gt;_aliveTime.<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    chrono::milliseconds now_timestamp_ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    <span class="keyword">return</span> now_timestamp_ms.<span class="built_in">count</span>() - active_timestamp_ms.<span class="built_in">count</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>MysqlConnectionPool.cpp</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnectionPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = boost::filesystem;</span><br><span class="line"></span><br><span class="line">MysqlConnectionPool::<span class="built_in">MysqlConnectionPool</span>() : _connectionCount(<span class="number">0</span>), _closed(<span class="literal">false</span>) {</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">loadConfigFile</span>()) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to load config file mysql.ini"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始化数量的 MySQL 连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;_initSize; i++) {</span><br><span class="line">        MysqlConnection *connection = <span class="keyword">new</span> <span class="built_in">MysqlConnection</span>();</span><br><span class="line">        <span class="comment">// 连接数据库</span></span><br><span class="line">        <span class="keyword">bool</span> connected = connection-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;_host, <span class="keyword">this</span>-&gt;_username, <span class="keyword">this</span>-&gt;_password, <span class="keyword">this</span>-&gt;_dbname);</span><br><span class="line">        <span class="comment">// 判断是否连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (connected) {</span><br><span class="line">            <span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span><br><span class="line">            connection-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line">            <span class="comment">// 入队操作</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">push</span>(connection);</span><br><span class="line">            <span class="comment">// 计数器加一</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_connectionCount++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台启动 MySQL 连接的生产者线程</span></span><br><span class="line">    <span class="function">thread <span class="title">produce</span><span class="params">(bind(&amp;MysqlConnectionPool::produceConnection, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">    produce.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台启动一个扫描线程，定时扫描多余的空闲连接，并释放连接</span></span><br><span class="line">    <span class="function">thread <span class="title">scan</span><span class="params">(bind(&amp;MysqlConnectionPool::scanIdleConnection, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">    scan.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MysqlConnectionPool::<span class="built_in">MysqlConnectionPool</span>(<span class="keyword">const</span> MysqlConnectionPool &amp;pool) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Not support copy constructor"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MysqlConnectionPool::~<span class="built_in">MysqlConnectionPool</span>() {</span><br><span class="line">    <span class="comment">// 关闭连接池，释放所有连接</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">MysqlConnectionPool *<span class="title">MysqlConnectionPool::getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnectionPool::loadConfigFile</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 配置文件的路径</span></span><br><span class="line">    fs::path configPath = fs::<span class="built_in">current_path</span>().<span class="built_in">concat</span>(<span class="string">"/mysql.ini"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    FILE *file = <span class="built_in">fopen</span>(configPath.<span class="built_in">c_str</span>(), <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s %s\n"</span>, configPath.<span class="built_in">c_str</span>(), <span class="string">"file is not exist"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">"======== mysql.ini ========\n"</span>)</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">feof</span>(file)) {</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">fgets</span>(buffer, <span class="number">1024</span>, file);</span><br><span class="line">        string line = buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置格式：username=root</span></span><br><span class="line">        <span class="keyword">int</span> index = line.<span class="built_in">find</span>(<span class="string">'='</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无效配置项</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> endIndex = line.<span class="built_in">find</span>(<span class="string">'\n'</span>, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理配置项</span></span><br><span class="line">        string key = line.<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br><span class="line">        string value = line.<span class="built_in">substr</span>(index + <span class="number">1</span>, endIndex - index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="string">"host"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_host = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"username"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_username = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"password"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_password = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"dbname"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_dbname = value;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"initSize"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_initSize = <span class="built_in">stoi</span>(value);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"maxSize"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_maxSize = <span class="built_in">stoi</span>(value);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"maxIdleTime"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_maxIdleTime = <span class="built_in">stoi</span>(value);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"connectionTimeout"</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_connectionTimeout = <span class="built_in">stoi</span>(value);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"%s=%s\n"</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">"======== mysql.ini ========\n\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnectionPool::close</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 判断连接池是否已关闭</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关闭状态</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>())) {</span><br><span class="line">        <span class="comment">// 获取队头的连接</span></span><br><span class="line">        MysqlConnection *phead = <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 出队操作</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 计数器减一</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_connectionCount--;</span><br><span class="line">        <span class="comment">// 释放连接占用的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span> phead;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlConnectionPool::isClosed</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_closed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MysqlConnectionPool::getSize</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_connectionCount;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;MysqlConnection&gt; <span class="title">MysqlConnectionPool::getConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Connection pool has closed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 While 循环来避免线程虚假唤醒</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 如果连接队列为空，则等待指定的时间</span></span><br><span class="line">        cv_status status = <span class="keyword">this</span>-&gt;_cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(<span class="keyword">this</span>-&gt;_connectionTimeout));</span><br><span class="line">        <span class="keyword">if</span> (cv_status::timeout == status) {</span><br><span class="line">            <span class="comment">// 如果等待超时，再次判断连接队列是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="built_in">LOG</span>(<span class="string">"# ERR: %s\n"</span>, <span class="string">"Failed to get connection, queue is empty"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队头的连接，并返回智能指针，同时自定义智能指针释放资源的方式，将连接归还到队列中</span></span><br><span class="line">    <span class="function">shared_ptr&lt;MysqlConnection&gt; <span class="title">sp</span><span class="params">(<span class="keyword">this</span>-&gt;_connectionQueue.front(), [&amp;](MysqlConnection *pcon) -&gt; <span class="keyword">void</span> {</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 获取互斥锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        unique_lock&lt;mutex&gt; lock(<span class="keyword">this</span>-&gt;_queueMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span></span></span><br><span class="line"><span class="params"><span class="function">        pcon-&gt;refreshAliveTime();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 入队操作（将连接归还到队列中）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span>-&gt;_connectionQueue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 计数器加一</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span>-&gt;_connectionCount++;</span></span></span><br><span class="line"><span class="params"><span class="function">    })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器减一</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_connectionCount--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 如果连接队列为空，则通知生产线程生产连接</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnectionPool::produceConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 While 循环来避免线程虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (!(<span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">empty</span>())) {</span><br><span class="line">            <span class="comment">// 如果连接队列不为空，生产者线程进入等待状态</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当连接数量没有达到上限，继续创建新的连接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_connectionCount &lt; <span class="keyword">this</span>-&gt;_maxSize) {</span><br><span class="line">            MysqlConnection *connection = <span class="keyword">new</span> <span class="built_in">MysqlConnection</span>();</span><br><span class="line">            <span class="comment">// 连接数据库</span></span><br><span class="line">            <span class="keyword">bool</span> connected = connection-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;_host, <span class="keyword">this</span>-&gt;_username, <span class="keyword">this</span>-&gt;_password, <span class="keyword">this</span>-&gt;_dbname);</span><br><span class="line">            <span class="comment">// 判断是否连接成功</span></span><br><span class="line">            <span class="keyword">if</span> (connected) {</span><br><span class="line">                <span class="comment">// 刷新连接进入空闲状态后的起始存活时间点</span></span><br><span class="line">                connection-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line">                <span class="comment">// 入队操作</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">push</span>(connection);</span><br><span class="line">                <span class="comment">// 计数器加一</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionCount++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者线程可以消费连接了</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlConnectionPool::scanIdleConnection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>-&gt;_closed) {</span><br><span class="line">        <span class="comment">// 模拟定时扫描连接的效果</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="keyword">this</span>-&gt;_maxIdleTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;_queueMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 While 循环来避免线程虚假唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;_connectionCount &lt;= <span class="keyword">this</span>-&gt;_initSize) {</span><br><span class="line">            <span class="comment">// 如果当前的连接总数量小于等于初始连接数量，扫描线程进入等待状态</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前的连接总数量是否大于初始连接数量</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;_connectionCount &gt; <span class="keyword">this</span>-&gt;_initSize) {</span><br><span class="line">            <span class="comment">// 扫描队头的连接是否超过最大空闲时间</span></span><br><span class="line">            MysqlConnection *phead = <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (phead-&gt;<span class="built_in">getAliveTime</span>() &gt;= <span class="keyword">this</span>-&gt;_maxIdleTime) {</span><br><span class="line">                <span class="comment">// 出队操作</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 计数器减一</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;_connectionCount--;</span><br><span class="line">                <span class="comment">// 释放连接占用的内存空间</span></span><br><span class="line">                <span class="keyword">delete</span> phead;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 如果队头的连接没有超过最大空闲时间，那么其他连接肯定也没有超过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单例对象</span></span><br><span class="line">MysqlConnectionPool *MysqlConnectionPool::INSTANCE = <span class="keyword">new</span> <span class="built_in">MysqlConnectionPool</span>();</span><br></pre></td></tr></tbody></table></figure><h3 id="连接池的-C-测试代码"><a href="#连接池的-C-测试代码" class="headerlink" title="连接池的 C++ 测试代码"></a>连接池的 C++ 测试代码</h3><div class="admonition note"><p class="admonition-title">提示</p><p>本文的所有 C++ 代码都已经在 Linux 平台下编译并测试通过（基于 Clion 与 G++ 编译器），由于笔者的技术水平有限，暂时无法保证代码没有潜在的 Bug，因此所有 C++ 代码仅供学习参考。</p></div><ul><li>用于测试的数据库表结构 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `cxx_study`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `cxx_study` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line">USE `cxx_study`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `properties`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `properties` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `KEY` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="keyword">VALUE</span>` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `REMARK` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">27</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 往数据库表插入数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_number'</span>, <span class="string">'430'</span>, <span class="string">'Limit Number'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_balance'</span>, <span class="string">'929.32'</span>, <span class="string">'Limit Balance'</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>用于测试的 C++ 代码（<code>main.cpp</code>）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnection.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MysqlConnectionPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSqlQuery</span><span class="params">()</span> </span>{</span><br><span class="line">    MysqlConnection *connection = <span class="keyword">new</span> <span class="built_in">MysqlConnection</span>();</span><br><span class="line">    connection-&gt;<span class="built_in">connect</span>(<span class="string">"192.168.56.112:3307"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>, <span class="string">"cxx_study"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> string querySql = <span class="string">"select * from properties where `KEY` = ?"</span>;</span><br><span class="line">    unique_ptr&lt;ResultSet&gt; result = connection-&gt;<span class="built_in">query</span>(querySql.<span class="built_in">c_str</span>(), {<span class="string">"test_limit_number"</span>});</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Query: "</span> &lt;&lt; querySql &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span> (result-&gt;<span class="built_in">next</span>()) {</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getInt</span>(<span class="string">"ID"</span>) &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"KEY"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"VALUE"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"REMARK"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> connection;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testConnectionPoolSingleThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> string insertSql = <span class="string">"INSERT INTO `properties` (`KEY`, `VALUE`, `REMARK`) VALUES ('test_limit_price', '30.5', 'Limit Price')"</span>;</span><br><span class="line">    MysqlConnectionPool *pool = MysqlConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个线程插入多条记录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1500</span>; i++) {</span><br><span class="line">        shared_ptr&lt;MysqlConnection&gt; connection = pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">executeUpdate</span>(insertSql.<span class="built_in">c_str</span>());</span><br><span class="line">        cout &lt;&lt; <span class="string">"Insert "</span> &lt;&lt; i &lt;&lt; <span class="string">" record, current pool size: "</span> &lt;&lt; pool-&gt;<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>, milli&gt; elapsed_time = end_time - start_time;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Times: "</span> &lt;&lt; elapsed_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testConnectionPoolMultiThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num_threads = <span class="number">15</span>;</span><br><span class="line">    thread threads[num_threads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> string insertSql = <span class="string">"INSERT INTO `properties` (`KEY`, `VALUE`, `REMARK`) VALUES ('test_limit_price', '30.5', 'Limit Price')"</span>;</span><br><span class="line">    MysqlConnectionPool *pool = MysqlConnectionPool::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程插入多条记录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) {</span><br><span class="line">        threads[i] = <span class="built_in">thread</span>([&amp;, i]() {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">100</span>; n++) {</span><br><span class="line">                shared_ptr&lt;MysqlConnection&gt; connection = pool-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">                connection-&gt;<span class="built_in">executeUpdate</span>(insertSql.<span class="built_in">c_str</span>());</span><br><span class="line">                cout &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; i &lt;&lt; <span class="string">", current pool size: "</span> &lt;&lt; pool-&gt;<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) {</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_time = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>, milli&gt; elapsed_time = end_time - start_time;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Times: "</span> &lt;&lt; elapsed_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"Pool size: "</span> &lt;&lt; pool-&gt;<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// testSqlQuery();</span></span><br><span class="line">    <span class="comment">// testConnectionPoolSingleThread();</span></span><br><span class="line">    <span class="built_in">testConnectionPoolMultiThread</span>();</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3600</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="MySQL-编程调试技巧"><a href="#MySQL-编程调试技巧" class="headerlink" title="MySQL 编程调试技巧"></a>MySQL 编程调试技巧</h2><p>在开发数据库连接池项目的时候，会经常出现问题，也就是 MySQL API 调用出错，提示 Insert、Delete、Update 等操作执行失败，或者连接 MySQL Server 失败等，很多人不知道遇到这个问题该怎么办？</p><h3 id="MySQL-C-API-调试"><a href="#MySQL-C-API-调试" class="headerlink" title="MySQL C API 调试"></a>MySQL C API 调试</h3><p>当使用的是 MySQL C API（Connector/C）库，可以使用以下两个函数打印出错时的提示信息：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>int mysql_errno(MYSQL *)</code></td><td>返回上次调用的 MySQL 函数的错误编号。</td></tr><tr><td><code>const char* mysql_error(MYSQL *)</code></td><td>返回上次调用的 MySQL 函数的错误消息。</td></tr></tbody></table><p>无论是 Insert 错误还是其它错误，都可以在代码上通过添加 <code>mysql_error</code> 函数打印错误提示信息（如下所示）。一般通过查看提示就可以知道是什么错误了，例如权限问题，但大部分都是细节错误，比如字段不对、类型不对、表名不对等。</p><p><img data-src="../../../asset/2025/02/cxx-mysql-debug.png"></p><h3 id="MySQL-Connector-C-调试"><a href="#MySQL-Connector-C-调试" class="headerlink" title="MySQL Connector/C++ 调试"></a>MySQL Connector/C++ 调试</h3><p>当使用的是 MySQL Connector/C++（JDBC-Style API）库，可以通过异常来获取错误信息：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="function">unique_ptr&lt;sql::Connection&gt; <span class="title">conn</span><span class="params">(driver-&gt;connect(<span class="string">"tcp://127.0.0.1:3306"</span>, <span class="string">"user"</span>, <span class="string">"password"</span>))</span></span>;</span><br><span class="line">    conn-&gt;<span class="built_in">setSchema</span>(<span class="string">"test_db"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;sql::Statement&gt; <span class="title">stmt</span><span class="params">(conn-&gt;createStatement())</span></span>;</span><br><span class="line">    stmt-&gt;<span class="built_in">execute</span>(<span class="string">"INVALID SQL STATEMENT"</span>); <span class="comment">// 故意执行错误的 SQL</span></span><br><span class="line">} <span class="built_in"><span class="keyword">catch</span></span> (sql::SQLException &amp;e) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"Error Code: "</span> &lt;&lt; e.<span class="built_in">getErrorCode</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"SQL State: "</span> &lt;&lt; e.<span class="built_in">getSQLState</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Message: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过 <code>e.getErrorCode()</code> 获取错误码，<code>e.getSQLState()</code> 获取 SQL 状态码，而 <code>e.what()</code> 获取详细的错误信息。</p><div class="admonition note"><p class="admonition-title">提示</p><p>如果使用的是 MySQL X DevAPI，错误提示信息同样可以通过异常处理来获取得到。</p></div><h2 id="MySQL-的参数调整"><a href="#MySQL-的参数调整" class="headerlink" title="MySQL 的参数调整"></a>MySQL 的参数调整</h2><p>以下命令可以查看 MySQL Server 所支持的最大连接数，当超过 <code>max_connections</code> 数量的连接，MySQL Server 会直接拒绝，所以在使用连接池增加 MySQL 连接数量的时候，MySQL Server 的 <code>max_connections</code> 参数也要适当地进行调整，以适配连接池的最大连接数（<code>maxSize</code>）。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'max_connections'</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="连接池的压力测试"><a href="#连接池的压力测试" class="headerlink" title="连接池的压力测试"></a>连接池的压力测试</h2><p>验证数据库的插入操作所花费的时间，第一次测试使用普通的数据库访问操作，第二次测试使用带连接池的数据库访问操作，对比两次操作同样数据量所花费的时间，性能压力测试结果如下：</p><table><thead><tr><th>数据量</th><th>未使用连接池所花费时间</th><th>使用连接池所花费时间</th></tr></thead><tbody><tr><td> 1000</td><td> 单线程：1891ms 四线程：497ms</td><td> 单线程：1079ms 四线程：408ms</td></tr><tr><td>5000</td><td> 单线程：10033ms 四线程：2361ms</td><td> 单线程: 5380ms 四线程：2041ms</td></tr><tr><td>10000</td><td> 单线程：19403ms 四线程：4589ms</td><td> 单线程：10522ms 四线程：4034ms</td></tr></tbody></table><h2 id="连接池的代码下载"><a href="#连接池的代码下载" class="headerlink" title="连接池的代码下载"></a>连接池的代码下载</h2><ul><li>完整的连接池项目代码可以从 <a href="https://github.com/rqh656418510/c-cplusplus-study/tree/main/c%2B%2B-project-db-connection-pool">这里</a> 下载得到。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="/posts/a2a7ad9b.html">C++ 多线程编程之一</a></li><li><a href="/posts/841eca80.html">Linux 系统编程之四多线程编程</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 如何实现 MySQL 数据库连接池</summary>
    
    
    
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 通过 Shell 脚本实现磁盘监控报警</title>
    <link href="https://www.techgrow.cn/posts/503279b0.html"/>
    <id>https://www.techgrow.cn/posts/503279b0.html</id>
    <published>2025-01-15T13:55:33.000Z</published>
    <updated>2025-01-15T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 CentOS 系统如何使用 Shell 脚本，实现对磁盘使用率的监控，并发送告警邮件（支持腾讯企业邮箱或者 QQ 邮箱）。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><ul><li>检查当前防火墙状态 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status firewalld</span><br></pre></td></tr></tbody></table></figure><ul><li>如果防火墙未运行，可以启动它 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自动启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动防火墙</span></span><br><span class="line">sudo systemctl start firewalld</span><br></pre></td></tr></tbody></table></figure><ul><li>防火墙开放 465 端口 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --add-port=465/tcp</span><br></pre></td></tr></tbody></table></figure><ul><li>重新加载防火墙规则，使更改生效 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></tbody></table></figure><ul><li>验证端口是否已开放 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --list-ports</span><br></pre></td></tr></tbody></table></figure><h3 id="安装邮件服务"><a href="#安装邮件服务" class="headerlink" title="安装邮件服务"></a>安装邮件服务</h3><ul><li>安装邮件服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mailx -y</span><br></pre></td></tr></tbody></table></figure><ul><li>安装证书（普通用户或 root 用户都可以，这里使用 root 用户）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /root/.certs/</span><br><span class="line">sudo sh -c <span class="string">"echo -n | openssl s_client -connect smtp.qq.com:465 | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; /root/.certs/qq.crt"</span></span><br><span class="line">sudo certutil -A -n <span class="string">"GeoTrust SSL CA"</span> -t <span class="string">"C,,"</span> -d /root/.certs -i /root/.certs/qq.crt</span><br><span class="line">sudo certutil -A -n <span class="string">"GeoTrust Global CA"</span> -t <span class="string">"C,,"</span> -d /root/.certs -i /root/.certs/qq.crt</span><br><span class="line">sudo certutil -L -d /root/.certs</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>(1) 在安装证书时，要特别注意当前使用的是哪个用户进行操作。</li><li>(2) 当使用 root 用户安装证书，那么在测试邮件发送、测试监控脚本、添加定时任务（Crontab）的时候也必须使用 root 用户。</li><li>(3) 同理，当使用普通用户安装证书，那么在测试邮件发送、测试监控脚本、添加定时任务（Crontab）的时候也需要使用普通用户。</li></ul></div><ul><li>获取腾讯邮箱授权密码 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 获取授权码：</span><br><span class="line">   - 腾讯邮箱（包括腾讯企业邮箱和 QQ 邮箱）需要在邮箱设置中生成 SMTP 服务授权码。</span><br><span class="line">   - 登录邮箱，前往 设置 -&gt; 帐号设置 -&gt; SMTP 服务，生成授权码并使用它代替密码。</span><br><span class="line"></span><br><span class="line">2. 安全性设置：</span><br><span class="line">   - 确保已启用 SMTP 服务和客户端登录支持。</span><br><span class="line"></span><br><span class="line">3. SMTP 服务器地址：</span><br><span class="line">   - QQ 邮箱： smtp.qq.com</span><br><span class="line">   - 腾讯企业邮箱：smtp.exmail.qq.com</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑系统配置文件，追加以下内容（这里使用的是 QQ 邮箱）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份配置文件</span></span><br><span class="line">sudo cp /etc/mail.rc /etc/mail.rc.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">sudo vi /etc/mail.rc</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> from=clay@qq.com</span><br><span class="line"><span class="built_in">set</span> smtp=<span class="string">"smtps://smtp.qq.com:465"</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=clay@qq.com</span><br><span class="line"><span class="built_in">set</span> smtp-auth-password=kl8jbdvxla3wt5ag</span><br><span class="line"><span class="built_in">set</span> smtp-auth=login</span><br><span class="line"><span class="built_in">set</span> ssl-verify=ignore</span><br><span class="line"><span class="built_in">set</span> nss-config-dir=/root/.certs</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td><code>set from</code></td><td>设置发件人的邮箱地址，邮件的 “From” 字段会显示此地址。</td></tr><tr><td><code>set smtp</code></td><td>指定使用腾讯邮箱的 SMTP 服务器地址和端口号（465 为 SMTPS 加密端口）。若使用的是腾讯企业邮箱，那么应该配置为 <code>set smtp="smtps://smtp.exmail.qq.com:465"</code>。</td></tr><tr><td><code>set smtp-auth-user</code></td><td>指定用于 SMTP 身份验证的用户名，通常是发件人的完整邮箱地址。</td></tr><tr><td><code>set smtp-auth-password</code></td><td>指定用于 SMTP 身份验证的密码或授权码（QQ 邮箱需使用专用授权码）。</td></tr><tr><td><code>set smtp-auth</code></td><td>设置 SMTP 身份验证的模式为 <code>login</code>，常见的认证方式之一。</td></tr><tr><td><code>set ssl-verify</code></td><td>忽略 SSL 证书验证（适用于证书问题或调试环境，但不建议在生产环境中忽略验证）。</td></tr><tr><td><code>set nss-config-dir</code></td><td>指定 NSS（Network Security Services）库的证书配置目录，用于管理 SSL/TLS 证书和加密连接。</td></tr></tbody></table><ul><li>测试邮件发送（这里使用 root 用户）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">"echo 'TestMail~' | mail -s 'TestMail' xxx@qq.com 2&gt;/dev/null"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果邮件发送失败，可以通过查看日志文件来排查原因 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tail -f /var/<span class="built_in">log</span>/maillog</span><br></pre></td></tr></tbody></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>创建磁盘监控脚本文件，并添加以下内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /opt/disk_monitor.sh</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 告警阈值</span></span><br><span class="line">THRESHOLD=90</span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮件接收者（使用空格分割多个邮件接收者）</span></span><br><span class="line">EMAIL=<span class="string">"xxx@qq.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 磁盘设备</span></span><br><span class="line">DISK_DEVICE=/dev/sda1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">LOG_FILE=/tmp/disk_monitor.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建日志文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">"<span class="variable">$LOG_FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    touch <span class="string">"<span class="variable">$LOG_FILE</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取服务器的公网 IP</span></span><br><span class="line">IP_ADDRESS=$(curl -s https://checkip.amazonaws.com)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断服务器的公网 IP 是否为空</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$ip_address</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">   IP_ADDRESS=<span class="string">"0.0.0.0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定磁盘设备的使用率</span></span><br><span class="line">CURRENT_USAGE=$(df -h <span class="variable">$DISK_DEVICE</span> | awk <span class="string">'NR==2 {print $5}'</span> | sed <span class="string">'s/%//g'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入日志文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="subst">$(date '+%Y-%m-%d %H:%M:%S')</span> 检测磁盘设备: <span class="variable">$DISK_DEVICE</span>"</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="subst">$(date '+%Y-%m-%d %H:%M:%S')</span> 磁盘使用率: <span class="variable">$CURRENT_USAGE</span>%"</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断磁盘使用率是否超过阈值</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$CURRENT_USAGE</span>"</span> -ge <span class="string">"<span class="variable">$THRESHOLD</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 发送告警邮件</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"警告: 磁盘设备 <span class="variable">$DISK_DEVICE</span> 的空间使用率超过 <span class="variable">$CURRENT_USAGE</span>%, 请登录服务器 (<span class="variable">$IP_ADDRESS</span>) 及时清理文件."</span> | mail -s <span class="string">"磁盘空间告警"</span> <span class="variable">$EMAIL</span> 2&gt;/dev/null</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure><ul><li>脚本文件授权 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755 /opt/disk_monitor.sh</span><br></pre></td></tr></tbody></table></figure><ul><li>脚本测试执行（这里使用 root 用户）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash /opt/disk_monitor.sh</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>如果只希望监控根目录（<code>/</code>）的磁盘使用率，可以使用命令 <code>df -h / | awk 'NR==2 {print $5}' | sed 's/%//g'</code>。</li><li>如果有多个邮件接收者，可以将上述代码更改为 <code>EMAIL="example1@qq.com example2@qq.com</code>，邮箱地址之间使用空格分隔，<code>mail</code> 命令支持将邮件发送给 <code>EMAIL</code> 变量中的所有接收者。</li></ul></div><h2 id="定时检测"><a href="#定时检测" class="headerlink" title="定时检测"></a>定时检测</h2><ul><li>编辑用户的 crontab 文件（这里使用 root 用户）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -e</span><br></pre></td></tr></tbody></table></figure><ul><li>添加定时任务（比如每 30 分钟执行一次磁盘使用率检测）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/30 * * * * /opt/disk_monitor.sh</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/guowenrui/p/17220838.html">Linux 使用 mailx 发送腾讯邮件</a></li><li><a href="https://www.cnblogs.com/huangjiabobk/p/18302228">Linux Shell 脚本监控磁盘与邮件告警</a></li><li><a href="https://blog.csdn.net/WQZ_1998/article/details/108087371">Linux 使用 Shell 脚本监控磁盘与邮件告警</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 CentOS 如何使用 Shell 脚本实现磁盘空间监控报警。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Centos" scheme="https://www.techgrow.cn/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 Dubbo Admin 单机教程</title>
    <link href="https://www.techgrow.cn/posts/380adca4.html"/>
    <id>https://www.techgrow.cn/posts/380adca4.html</id>
    <published>2025-01-07T13:12:19.000Z</published>
    <updated>2025-01-07T13:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/d70c90c.html">Dubbo 管理与监控中心的安装部署</a></li><li><a href="/posts/380adca4.html">Docker 安装 Dubbo Admin 单机教程</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍如何使用 Docker + Docker Compose 安装 Dubbo Admin 单实例，包括 ZooKeeper 与 MySQL 的安装。</p><h3 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h3><ul><li><a href="https://github.com/apache/dubbo-admin/wiki">Dubbo Admin 的 Wiki 文档</a></li><li><a href="https://github.com/apache/dubbo-admin">Dubbo Admin 的 GitHub 项目</a></li><li><a href="https://github.com/apache/dubbo-admin/tree/develop/docker">Dubbo Admin 的 Docker 项目</a></li></ul><h3 id="Docker-资源"><a href="#Docker-资源" class="headerlink" title="Docker 资源"></a>Docker 资源</h3><ul><li><a href="https://hub.docker.com/_/mysql">MySQL 镜像地址</a></li><li><a href="https://hub.docker.com/_/zookeeper">ZooKeeper 镜像地址</a></li><li><a href="https://hub.docker.com/r/apache/dubbo-admin">Dubbo Admin 镜像地址</a></li></ul><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="ZooKeeper-安装"><a href="#ZooKeeper-安装" class="headerlink" title="ZooKeeper 安装"></a>ZooKeeper 安装</h3><p>这里使用 ZooKeeper 作为注册中心，Dubbo Admin 会从 ZooKeeper 中获取需要监控的 Dubbo 服务列表。</p><ul><li>创建数据目录，用于存放 ZooKeeper 的数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据目录</span></span><br><span class="line">$ sudo mkdir -p /data/zookeeper/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志目录</span></span><br><span class="line">$ sudo mkdir -p /data/zookeeper/datalog</span><br></pre></td></tr></tbody></table></figure><ul><li>创建 Docker Compose 的配置文件，并加入以下 ZooKeeper 容器的配置内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi docker-compose.yml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper:2888:3888;2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>核心配置</th><th>配置说明</th></tr></thead><tbody><tr><td><code>ZOO_MY_ID: 1</code></td><td>节点 ID，单机模式下可以固定为 1，如果是集群模式，必须全局唯一。</td></tr><tr><td><code>ZOO_SERVERS: server.1=zookeeper:2888:3888;2181</code></td><td>- 单机模式下的服务地址，如果是集群模式，可以指定多个服务地址（使用空格分隔开）。<br> - 这里的 <code>zookeeper</code> 是在 Docker Compose 中定义的 ZooKeeper 服务的名称，用作其他服务（如 Dubbo Admin）访问 ZooKeeper 的主机名，Docker Compose 会自动将这个名称解析为 ZooKeeper 容器的 IP 地址。</td></tr></tbody></table><ul><li>创建并启动 ZooKeeper 容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker compose up -d</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 ZooKeeper 容器的启动日志 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs zookeeper</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">参考教程</p><ul><li><a href="/posts/1b27acd0.html">Docker 安装 ZooKeeper 单机教程</a></li></ul></div><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><ul><li>在宿主机内创建 Dubbo Admin 的 <code>application.properties</code> 配置文件，并根据 Dubbo Admin 镜像的版本，从 <a href="https://github.com/apache/dubbo-admin/tree/develop/docker">这里</a> 获取 <code>application.properties</code> 配置文件对应的内容，比如 <a href="https://github.com/apache/dubbo-admin/blob/develop/docker/0.6.0/application.properties">0.6.0 版本</a></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建配置目录</span></span><br><span class="line">$ sudo mkdir -p /data/dubbo-admin/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line">$ sudo touch /data/dubbo-admin/conf/application.properties</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 Dubbo Admin 的 <code>application.properties</code> 配置文件，并写入相应的配置内容，以下配置内容对应是 Dubbo Admin 镜像的 <code>0.6.0</code> 版本 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /data/dubbo-admin/conf/application.properties</span><br></pre></td></tr></tbody></table></figure><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">38080</span></span><br><span class="line"><span class="meta">dubbo.protocol.port</span>=<span class="string">30880</span></span><br><span class="line"><span class="meta">dubbo.application.qos-port</span>=<span class="string">32222</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># centers in dubbo, if you want to add parameters, please add them to the url</span></span><br><span class="line"><span class="meta">admin.registry.address</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="meta">admin.config-center</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="meta">admin.metadata-report.address</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># nacos config, add parameters to url like username=nacos&amp;password=nacos</span></span><br><span class="line"><span class="comment">#admin.registry.address=nacos://zookeeper:8848?group=DEFAULT_GROUP&amp;namespace=public</span></span><br><span class="line"><span class="comment">#admin.config-center=nacos://zookeeper:8848?group=dubbo</span></span><br><span class="line"><span class="comment">#admin.metadata-report.address=nacos://zookeeper:8848?group=dubbo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#group (Deprecated it is recommended to use URL to add parameters,will be removed in the future)</span></span><br><span class="line"><span class="comment">#admin.registry.group=dubbo</span></span><br><span class="line"><span class="comment">#admin.config-center.group=dubbo</span></span><br><span class="line"><span class="comment">#admin.metadata-report.group=dubbo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#namespace used by nacos. (Deprecated it is recommended to use URL to add parameters,will be removed in the future)</span></span><br><span class="line"><span class="comment">#admin.registry.namespace=public</span></span><br><span class="line"><span class="comment">#admin.config-center.namespace=public</span></span><br><span class="line"><span class="comment">#admin.metadata-report.namespace=public</span></span><br><span class="line"></span><br><span class="line"><span class="meta">admin.root.user.name</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">admin.root.user.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#session timeout, default is one hour</span></span><br><span class="line"><span class="meta">admin.check.sessionTimeoutMilli</span>=<span class="string">3600000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># apollo config</span></span><br><span class="line"><span class="comment"># admin.config-center = apollo://localhost:8070?token=e16e5cd903fd0c97a116c873b448544b9d086de9&amp;app.id=test&amp;env=dev&amp;cluster=default&amp;namespace=dubbo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># (Deprecated it is recommended to use URL to add parameters,will be removed in the future)</span></span><br><span class="line"><span class="comment">#admin.apollo.token=e16e5cd903fd0c97a116c873b448544b9d086de9</span></span><br><span class="line"><span class="comment">#admin.apollo.appId=test</span></span><br><span class="line"><span class="comment">#admin.apollo.env=dev</span></span><br><span class="line"><span class="comment">#admin.apollo.cluster=default</span></span><br><span class="line"><span class="comment">#admin.apollo.namespace=dubbo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#compress</span></span><br><span class="line"><span class="meta">server.compression.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.compression.mime-types</span>=<span class="string">text/css,text/javascript,application/javascript</span></span><br><span class="line"><span class="meta">server.compression.min-response-size</span>=<span class="string">10240</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#token timeout, default is one hour</span></span><br><span class="line"><span class="meta">admin.check.tokenTimeoutMilli</span>=<span class="string">3600000</span></span><br><span class="line"><span class="comment">#Jwt signingKey</span></span><br><span class="line"><span class="meta">admin.check.signSecret</span>=<span class="string">86295dd0c4ef69a1036b0b0c15158d77</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#dubbo config</span></span><br><span class="line"><span class="meta">dubbo.application.name</span>=<span class="string">dubbo-admin</span></span><br><span class="line"><span class="meta">dubbo.registry.address</span>=<span class="string">${admin.registry.address}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># mysql</span></span><br><span class="line"><span class="comment">#spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#spring.datasource.url=jdbc:mysql://localhost:3306/dubbo-admin?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=10000&amp;autoReconnect=true</span></span><br><span class="line"><span class="comment">#spring.datasource.username=root</span></span><br><span class="line"><span class="comment">#spring.datasource.password=mysql</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># h2</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># id generate type</span></span><br><span class="line"><span class="meta">mybatis-plus.global-config.db-config.id-type</span>=<span class="string">none</span></span><br><span class="line"></span><br><span class="line"><span class="meta">dubbo.application.logger</span>=<span class="string">slf4j</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>核心配置</th><th>配置说明</th></tr></thead><tbody><tr><td><code>server.port=38080</code></td><td>Dubbo Admin 的 Web 服务端口</td></tr><tr><td><code>dubbo.protocol.port=30880</code></td><td>Dubbo 协议的端口</td></tr><tr><td><code>dubbo.application.qos-port=32222</code></td><td>Dubbo QOS 服务的端口</td></tr><tr><td><code>admin.root.user.name=root</code></td><td>Dubbo Admin 中 <code>root</code> 用户的名称，用于登录 Dubbo Admin 控制台</td></tr><tr><td><code>admin.root.user.password=root</code></td><td>Dubbo Admin 中 <code>root</code> 用户的密码，用于登录 Dubbo Admin 控制台</td></tr><tr><td><code>admin.registry.address</code></td><td>注册中心地址，当使用 ZooKeeper 作为注册中心，则必须指定为 <code>zookeeper://zookeeper:2181</code>。如果连接的是 ZooKeeper 集群，那么 <code>zookeeper://</code> 后面使用逗号分隔开多个集群节点的地址。</td></tr><tr><td><code>admin.config-center</code></td><td>配置中心地址，当使用 ZooKeeper 作为配置中心，则必须指定为 <code>zookeeper://zookeeper:2181</code>。如果连接的是 ZooKeeper 集群，那么 <code>zookeeper://</code> 后面使用逗号分隔开多个集群节点的地址。</td></tr><tr><td><code>admin.metadata-report.address</code></td><td>元数据中心地址，当使用 ZooKeeper 作为元数据中心，则必须指定为 <code>zookeeper://zookeeper:2181</code>。如果连接的是 ZooKeeper 集群，那么 <code>zookeeper://</code> 后面使用逗号分隔开多个集群节点的地址。</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">Dubbo Admin 官方文档</p><ul><li><a href="https://github.com/apache/dubbo-admin/wiki/Dubbo-Admin%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E">Dubbo Admin 官方配置说明</a></li></ul></div><h3 id="创建-Docker-容器"><a href="#创建-Docker-容器" class="headerlink" title="创建 Docker 容器"></a>创建 Docker 容器</h3><ul><li>编辑 Docker Compose 的配置文件，并加入以下 Dubbo Admin 容器的配置内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi docker-compose.yml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper:2888:3888;2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/dubbo-admin/conf:/config</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建并启动 Dubbo Admin 容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker compose up -d</span><br></pre></td></tr></tbody></table></figure><blockquote><p>若不希望指定 Dubbo Admin 的 <code>application.properties</code> 配置文件，而是想让 Docker Compose 通过环境变量来配置 Dubbo Admin，可以参考 <a href="https://github.com/apache/dubbo-admin/blob/develop/docker/stack.yml">这里</a> 的 YML 配置内容，配置示例如下：</p></blockquote><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line"></span><br><span class="line">  <span class="string">......</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.application.name=dubbo-admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.url=jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.username=sa</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><h3 id="验证-Docker-容器"><a href="#验证-Docker-容器" class="headerlink" title="验证 Docker 容器"></a>验证 Docker 容器</h3><p>浏览器通过 <code>http://192.168.1.235:38080</code> 访问 Dubbo Admin 的控制台页面，请自行将 IP 地址 <code>192.168.1.235</code> 更改为 Dubbo Admin 容器的真实 IP 地址，默认的登录用户名和密码是 <code>root /root</code>。</p><p><img data-src="../../../asset/2025/01/dubbo-admin-1.png"></p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>在默认情况下，Dubbo Admin 使用的是 H2 嵌入式数据库（内存模式），应用重启后会丢失监控数据，建议使用 MySQL 来存储 Dubbo Admin 的监控数据。</p><h3 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h3><ul><li>创建数据目录，用于存放 MySQL 的数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p /data/mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>创建 Jar 包目录，并下载 MySQL 的驱动包 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Jar 包目录</span></span><br><span class="line">$ sudo mkdir -p /data/dubbo-admin/opt-libs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 MySQL 驱动包</span></span><br><span class="line">$ sudo wget -P /data/dubbo-admin/opt-libs https://repo1.maven.org/maven2/com/mysql/mysql-connector-j/8.2.0/mysql-connector-j-8.2.0.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件授权访问</span></span><br><span class="line">$ sudo chmod -R 777 /data/dubbo-admin/opt-libs</span><br></pre></td></tr></tbody></table></figure><ul><li>编辑 Docker Compose 的配置文件，并加入以下 MySQL 容器的配置内容 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi docker-compose.yml</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.4.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"mysqld"</span>, <span class="string">"--mysql-native-password=ON"</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_HOST:</span> <span class="string">'%'</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/mysql:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper:2888:3888;2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/dubbo-admin/conf:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/dubbo-admin/opt-libs:/opt-libs</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>核心配置</th><th>配置说明</th></tr></thead><tbody><tr><td><code>MYSQL_ROOT_HOST: '%'</code></td><td>允许 root 用户远程访问</td></tr><tr><td><code>MYSQL_ROOT_PASSWORD: root</code></td><td>设置 root 用户的密码</td></tr><tr><td><code>MYSQL_DATABASE: dubbo-admin</code></td><td>容器启动时自动创建指定的数据库</td></tr><tr><td><code>command: ["mysqld", "--mysql-native-password=ON"]</code></td><td>启用 MySQL 传统的身份认证插件</td></tr></tbody></table><ul><li>编辑 Dubbo Admin 的 <code>application.properties</code> 配置文件，添加 MySQL 数据库的配置，并注释掉 H2 数据库的配置。<strong>特别注意，MySQL 8 的驱动类是 <code>com.mysql.cj.jdbc.Driver</code>，而不是 <code>com.mysql.jdbc.Driver</code>。</strong></li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://mysql:3306/dubbo-admin?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;rewriteBatchedStatements=true&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># h2</span></span><br><span class="line"><span class="comment"># spring.datasource.url=jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;</span></span><br><span class="line"><span class="comment"># spring.datasource.username=sa</span></span><br><span class="line"><span class="comment"># spring.datasource.password=</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>若不希望指定 Dubbo Admin 的 <code>application.properties</code> 配置文件，而是想让 Docker Compose 通过环境变量来配置 Dubbo Admin，可以参考 <a href="https://github.com/apache/dubbo-admin/blob/develop/docker/stack.yml">这里</a> 的 YML 配置内容，配置示例如下：</p></blockquote><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line"></span><br><span class="line">  <span class="string">......</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.application.name=dubbo-admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.url=jdbc:mysql://mysql:3306/dubbo-admin?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;rewriteBatchedStatements=true&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.username=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.password=root</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/dubbo-admin/opt-libs:/opt-libs</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建并启动 MySQL 容器 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker compose up -d</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 MySQL 容器的启动日志 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Dubbo Admin 容器的启动日志 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs dubbo-admin</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">参考教程</p><ul><li><a href="/posts/2669f243.html">Docker 安装 MySQL 8 教程</a></li></ul></div><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="连接-ZooKeeer-集群"><a href="#连接-ZooKeeer-集群" class="headerlink" title="连接 ZooKeeer 集群"></a>连接 ZooKeeer 集群</h3><p>若 Dubbo Admin 连接的是 ZooKeeper 集群，那么可以参考以下的 Docker Compose 配置内容：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper01</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">ruok</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper01/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper01/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper02</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper02</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">ruok</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper02/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper02/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper03</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper03</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">ruok</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper03/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/zookeeper/zookeeper03/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin:0.6.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38080</span><span class="string">:38080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">30880</span><span class="string">:30880</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">32222</span><span class="string">:32222</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=zookeeper://zookeeper01:2181,zookeeper02:2181,zookeeper03:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=zookeeper://zookeeper01:2181,zookeeper02:2181,zookeeper03:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=zookeeper://zookeeper01:2181,zookeeper02:2181,zookeeper03:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.application.name=dubbo-admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.registry.address=zookeeper://zookeeper01:2181,zookeeper02:2181,zookeeper03:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.url=jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.datasource.username=sa</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">zookeeper01:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper02:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper03:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">dubbo-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">参考教程</p><ul><li><a href="/posts/496af1ce.html">Docker 搭建 ZooKeeper 集群教程</a></li></ul></div><h3 id="无法加载-MySQL-驱动类"><a href="#无法加载-MySQL-驱动类" class="headerlink" title="无法加载 MySQL 驱动类"></a>无法加载 MySQL 驱动类</h3><p>Dubbo Admin 容器在启动时，抛出 <code>Cannot load driver class: com.mysql.cj.jdbc.Driver</code> 异常。解决方法如下：</p><ul><li>(1) 在宿主机中下载 MySQL 的驱动包，并将其挂载到 Dubbo Admin 容器内的 <code>/opt-libs</code> 目录下</li><li> (2) 如果还是加载不到 MySQL 的驱动类，只能更改 Dubbo Admin 项目源码中的 <code>dubbo-admin-server</code> 模块的 <a href="https://github.com/apache/dubbo-admin/blob/develop/dubbo-admin-server/pom.xml#L205">Maven 配置文件</a>，加入 MySQL 驱动的 Maven 依赖，然后通过 Dubbo Admin 项目的源码手动构建 Docker 镜像（构建步骤可以参考<a href="https://github.com/apache/dubbo-admin/tree/develop/docker">这里</a>）。</li></ul><h3 id="无法查看服务的元数据信息"><a href="#无法查看服务的元数据信息" class="headerlink" title="无法查看服务的元数据信息"></a>无法查看服务的元数据信息</h3><p>在 Dubbo Admin 控制台中，无法查看服务提供者的元数据信息，如下图所示：</p><p><img data-src="../../../asset/2025/01/dubbo-admin-metadata-error.png"></p><ul><li>(1) 首先确保 Dubbo Admin 配置了以下几个属性：</li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">admin.registry.address</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="meta">admin.config-center</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br><span class="line"><span class="meta">admin.metadata-report.address</span>=<span class="string">zookeeper://zookeeper:2181</span></span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 在服务提供者的代码中，添加元数据中心的配置（<code>&lt;dubbo:metadata-report/&gt;</code>），完整的配置示例如下：</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置服务应用名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-provider-application"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.enable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.port"</span> <span class="attr">value</span>=<span class="string">"22222"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.accept.foreign.ip"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 注册中心配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.2.235:2181"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 元数据中心配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:metadata-report</span> <span class="attr">address</span>=<span class="string">"zookeeper://192.168.2.235:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置服务协议 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启 Dubbo 的注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.clay.dubbo.producer"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://dubbo.apache.org/zh-cn/overview/tasks/deploy/deploy-on-docker/">Dubbo 官方文档</a></li><li><a href="https://blog.csdn.net/qq_43135259/article/details/130007208">Docker 安装 Dubbo Admin 与 Zookeeper</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Docker 如何安装 Dubbo Admin，包括 ZooKeeper 与 MySQL 的安装。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之六</title>
    <link href="https://www.techgrow.cn/posts/a4fe8225.html"/>
    <id>https://www.techgrow.cn/posts/a4fe8225.html</id>
    <published>2024-12-25T13:55:33.000Z</published>
    <updated>2024-12-25T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><span id="more"></span><h2 id="近容器"><a href="#近容器" class="headerlink" title="近容器"></a>近容器</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>在 C++ 中，常见的近容器有以下几种：</p><ul><li>数组</li><li> string</li><li>bitset</li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>在 C++ 中，常见的迭代器有以下几种：</p><ul><li><code>iterator</code> 和 <code>const_iterator</code></li><li><code>reverse_iterator</code> 和 <code>const_reverse_iterator</code></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>在 C++ 中，<code>iterator</code> 迭代器是从 <code>const_iterator</code> 迭代器继承而来的。</p></div><h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++) {</span><br><span class="line">        v1.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span>  + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>(); it!= v1.<span class="built_in">end</span>(); ++it){</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> ==<span class="number">0</span> ){</span><br><span class="line">            <span class="comment">// 可以赋值</span></span><br><span class="line">            *it = *it + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量的正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::const_iterator it = v1.<span class="built_in">begin</span>(); it!= v1.<span class="built_in">end</span>(); ++it){</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> ==<span class="number">0</span> ){</span><br><span class="line">            <span class="comment">// 错误写法，不可以赋值</span></span><br><span class="line">            <span class="comment">// *it = *it + 1;</span></span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = v1.<span class="built_in">rbegin</span>(); it!= v1.<span class="built_in">rend</span>(); ++it){</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> ==<span class="number">0</span> ){</span><br><span class="line">            <span class="comment">// 可以赋值</span></span><br><span class="line">            *it = *it + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量的反向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator it = v1.<span class="built_in">rbegin</span>(); it!= v1.<span class="built_in">rend</span>(); ++it){</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> ==<span class="number">0</span> ){</span><br><span class="line">            <span class="comment">// 错误写法，不可以赋值</span></span><br><span class="line">            <span class="comment">// *it = *it + 1;</span></span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">25 93 69 85 75 19 79 39 13 19</span><br><span class="line">25 93 69 85 75 19 79 39 13 19</span><br><span class="line">19 13 39 79 19 75 85 69 93 25</span><br><span class="line">19 13 39 79 19 75 85 69 93 25</span><br></pre></td></tr></tbody></table></figure><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><h3 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul><li>C++ 中的函数对象，其作用类似 C 语言中的函数指针。</li><li>在 C++ 中，将拥有 <code>operator()</code> 小括号运算符重载函数的对象称作 “函数对象”，或者称作 “仿函数”。</li><li>通过函数对象调用 <code>operator ()</code>，会产生内联的效果，其执行效率比较高，因为没有函数调用的开销。</li><li>由于函数对象是使用类生成的，因此函数对象可以拥有相关的成员变量，比如可以通过成员变量来记录函数对象的使用次数。</li><li>在 C++ 中，常见的函数对象有：<code>less</code>、<code>greater</code>。</li></ul><h3 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h3><p>这里主要演示 C++ 中函数指针的使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_greater</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_less</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compare 是 C++ 的库函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare func)</span> </span>{</span><br><span class="line">    <span class="comment">// 这里通过函数指针调用函数，是没办法实现内联的（即使通过 inline 关键字将目标函数声明为内联函数），执行效率较低，因为有函数调用的开销</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">3</span>, my_greater&lt;<span class="keyword">int</span>&gt;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">3</span>, my_less&lt;<span class="keyword">int</span>&gt;) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h3><p>这里主要演示 C++ 中函数对象的使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mygreater</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myless</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compare 是 C++ 的库函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare func)</span> </span>{</span><br><span class="line">    <span class="comment">// 这里调用函数对象，会产生内联，执行效率比较高，没有函数调用的开销</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">3</span>, mygreater&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">3</span>, myless&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码三"><a href="#案例代码三" class="headerlink" title="案例代码三"></a>案例代码三</h3><p>这里主要演示如何在 C++ 的 STL 中使用函数对象。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象，让优先级队列里的元素从小到大排序（默认从大到小排序）</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        q1.<span class="built_in">push</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; q1.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象，让有序集合里的元素从大到小排序（默认从小到大排序）</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; s1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        s1.<span class="built_in">insert</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">4 64 45 55 2 82 62 84 51 74 </span><br><span class="line">2 4 45 51 55 62 64 74 82 84 </span><br><span class="line">============ test02() ============</span><br><span class="line">40 8 50 65 100 26 48 34 43 43 </span><br><span class="line">100 65 50 48 43 40 34 26 8 </span><br></pre></td></tr></tbody></table></figure><h2 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h2><h3 id="概念介绍-3"><a href="#概念介绍-3" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul><li>C++ 泛型算法 = 模板（Template） + 迭代器 + 函数对象。</li><li>C++ 泛型算法的参数接收的都是迭代器，而且还可以接收函数对象。</li><li>C++ 常见的泛型算法有以下几种：<ul><li><code>sort</code>：排序算法</li><li><code>find</code>：查找算法</li><li><code>find_if</code>：条件查找算法</li><li><code>binary_search</code>：二分查找算法</li><li><code>for_each</code>：遍历算法</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>二分查找算法（<code>binary_search</code>）并不适用于降序排序（从大到小）的容器，只适用于升序排序（从小到大）的容器，因为它默认是按照升序排序来查找元素的。</p></div><h3 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> arr[] = {<span class="number">12</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">39</span>, <span class="number">25</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">58</span>};</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序算法（默认升序排序，即从小到大排序）</span></span><br><span class="line">    <span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者降序排序（从大到小）</span></span><br><span class="line">    <span class="comment">// sort(v1.begin(), v1.end(), greater&lt;int&gt;());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找算法（不要求容器按顺序存储元素）</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it1 = <span class="built_in">find</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span> (it1 != v1.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"found number 48"</span> &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not found 48"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找算法，只适用于升序排序（从小到大）的容器，如果容器的元素是按降序排序（从大到小），否则二分查找算法无法正常工作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binary_search</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="number">25</span>)) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"found number 25"</span> &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not found 25"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12 23 7 11 39 25 45 48 58 </span><br><span class="line">7 11 12 23 25 39 45 48 58 </span><br><span class="line">found number 48</span><br><span class="line">found number 25</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> arr[] = {<span class="number">22</span>, <span class="number">33</span>, <span class="number">8</span>, <span class="number">21</span>, <span class="number">59</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">70</span>};</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序算法（默认升序排序，即从小到大排序）</span></span><br><span class="line">    <span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件查找算法，将 48 按顺序插入到 vector 容器中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用绑定器（已过时的写法）</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it2 = <span class="built_in">find_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">48</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用绑定器（现代 C++ 的写法）</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator it2 = find_if(v1.begin(), v1.end(), bind(greater&lt;int&gt;(), placeholders::_1, 48));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用绑定器（Lambda 表达式的写法）</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator it2 = find_if(v1.begin(), v1.end(), [](int val) -&gt; bool { return val &gt; 48; });</span></span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">insert</span>(it2, <span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 21 22 33 35 55 59 63 70 </span><br><span class="line">8 21 22 33 35 48 55 59 63 70 </span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码三-1"><a href="#案例代码三-1" class="headerlink" title="案例代码三"></a>案例代码三</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        v1.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : v1) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历算法</span></span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), [](<span class="keyword">int</span> val) -&gt; <span class="keyword">void</span> {</span><br><span class="line">        <span class="comment">// 打印所有偶数</span></span><br><span class="line">        <span class="keyword">if</span> (val % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">46 81 98 43 35 60 61 68 77 96 </span><br><span class="line">46 98 60 68 96 </span><br></pre></td></tr></tbody></table></figure><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><div class="admonition note"><p class="admonition-title">提示</p><ul><li>下述面试题都来自 "商汤科技" 的一面，难度属于是简单级别。</li></ul></div><ul><li><p>(1) 程序的内存布局</p><ul><li>从下往上分别是：<code>.text</code> 、<code>.rodata</code>、<code>.data</code>、<code>.bss</code>、堆、栈、内核空间，<a href="../../../asset/2024/11/process-address.png">如图所示</a></li></ul></li><li><p> (2) 堆和栈的区别</p><ul><li>堆内存由用户分配（<code>new</code>），而栈内存由系统分配（函数调用时）</li><li>堆内存的数据结构通常是二叉堆、大根堆、小根堆，而栈内存的数据结构是栈</li></ul></li><li><p> (3) 函数调用的参数是怎样传递的</p><ul><li>通过汇编代码的分析，可以知道底层是通过压栈的方式来传递参数</li></ul></li><li><p> (4) 函数调用的参数是按什么顺序传递的</p><ul><li>函数调用是从右往左传递参数</li></ul></li><li><p> (5) 为什么函数调用的参数要从右往左压栈</p><ul><li>因为 C/C++ 需要支持可变参函数（即函数的参数数量不确定）</li><li>C 语言的可变参数函数，缺乏类型安全 <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统 C 语言风格的可变参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>{</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, num); <span class="comment">// 初始化 args，num 是可变参数的第一个参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) {</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">va_arg</span>(args, <span class="keyword">int</span>); <span class="comment">// 获取下一个参数</span></span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">va_end</span>(args); <span class="comment">// 清理</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">3</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);     <span class="comment">// 输出：10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C++ 可变模板参数函数，提供了类型安全，并且能更灵活地处理不同类型的参数 <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变模板参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(Args... args)</span> </span>{</span><br><span class="line">    <span class="comment">// 使用折叠表达式打印参数</span></span><br><span class="line">    ((cout &lt;&lt; args &lt;&lt; <span class="string">" "</span>), ...);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);       <span class="comment">// 输出：10 20 30</span></span><br><span class="line">    <span class="built_in">printNumbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);    <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>(6) 有以下一个函数 <code>func</code></p><ul><li>主函数里面通过 <code>string s = func(s1, s2);</code> 调用该函数，说一下调用了什么构造函数和调用顺序，以及析构函数的调用顺序<ul><li>关键考点：如果用临时对象去拷贝构造新对象，那么临时对象就不会产生，也就是直接构造新对象就行，这是任意 C++ 编译器都会做的优化，<a href="../../../asset/2025/02/cxx-interview-string.png">如图所示</a></li></ul></li><li>如果在 <code>func</code> 函数内写成 <code>return s1 + s2;</code>，这与原来的写法有什么区别<ul><li>省略了原来字符串对象 <code>tmp</code> 的构造函数和析构函数的调用 <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">func</span><span class="params">(string s1, string s2)</span> </span>{</span><br><span class="line">    string tmp = s1 + s2;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>(7) 在一个结构体里面定义一个 <code>char</code> 和 <code>double</code> 变量，它的内存布局是怎样的</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> {</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Data) &lt;&lt; endl;  <span class="comment">// 输出 16</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>char a</code> 占 1 字节</li><li><code>double b</code> 占 8 字节，并且通常需要 8 字节对齐。</li><li>由于 <code>char a</code> 只有 1 字节，而 <code>double b</code> 需要 8 字节对齐，因此编译器会在 <code>a</code> 之后填充 7 个字节，使 <code>b</code> 在 8 字节边界对齐，最终 <code>sizeof(Data) = 16</code>。</li></ul></li><li><p>(8) 空结构体占用多少个字节</p><ul><li>C++ 中，空结构体占用 1 个字节</li><li> C 语言中，空结构体占用 0 个字节</li></ul></li><li><p> (9) 如何防止指针使用带来的内存泄漏</p><ul><li>使用带引用计数的智能指针：<code>share_ptr</code></li><li>使用不带引用计数的智能指针：<code>auto_ptr</code>、<code>unique_ptr</code></li><li>使用特殊的智能指针：<code>weak_ptr</code>（不增加引用计数，但可用于观察 <code>shared_ptr</code> 管理的资源）</li></ul><table><thead><tr><th>智能指针</th><th>所有权</th><th>引用计数</th><th>适用场景</th></tr></thead><tbody><tr><td><code>unique_ptr</code></td><td>独占</td><td>❌</td><td>资源独占，生命周期明确</td></tr><tr><td><code>shared_ptr</code></td><td>共享</td><td>✅</td><td>资源共享，生命周期不固定</td></tr><tr><td><code>weak_ptr</code></td><td>观察 <code>shared_ptr</code></td><td>❌</td><td>避免 <code>shared_ptr</code> 循环引用</td></tr><tr><td><code>auto_ptr</code></td><td>独占（拷贝时转移）</td><td>❌</td><td>⚠ 已废弃，建议改用 <code>unique_ptr</code></td></tr></tbody></table></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之五</title>
    <link href="https://www.techgrow.cn/posts/52e74a26.html"/>
    <id>https://www.techgrow.cn/posts/52e74a26.html</id>
    <published>2024-12-21T13:55:33.000Z</published>
    <updated>2024-12-21T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><span id="more"></span><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h4><p>vector 底层所采用的数据结构是线性连续空间（单向开口的连续内存空间），可以理解为支持动态开辟内存空间的数组。vector 往尾部添加或移除元素的效率非常高，但是往头部或者中部插入元素或移除元素则比较耗时。<strong>特别注意，vector 一旦需要执行扩容操作，那么每次都会以原来空间大小的 2 倍进行扩容。</strong></p><p><img data-src="../../../asset/2025/01/cplusplus-vector-1.png"></p><ul><li><p>声明</p><ul><li><code>vector&lt;int&gt; vec;</code></li></ul></li><li><p>插入</p><ul><li><code>vec.push_back(20)</code>，往容器尾部插入元素，会导致容器扩容</li><li><code>vec.insert(iterator, 30)</code>，往迭代器指向的位置插入元素，会导致容器扩容</li></ul></li><li><p>删除</p><ul><li><code>vec.pop_back()</code>，删除容器尾部的元素</li><li><code>vec.erase(iterator)</code>，删除迭代器指向的元素</li></ul></li><li><p>查询</p><ul><li><code>vec[5]</code>，基于下标的随机访问</li><li><code>iterator</code>，迭代器遍历</li><li><code>for_each</code>，循环遍历</li><li><code>find</code>，查找元素</li></ul></li><li><p>其他</p><ul><li><code>vec.size()</code>，获取容器中元素数量</li><li><code>vec.empty()</code>，判断容器是否为空</li><li><code>vec.swap(vec2)</code>，交换两个容器的元素</li><li><code>vec.reserve(size)</code>，预留容器空间，只会给容器的底层开辟指定大小的内存空间，并不会添加新的元素，主要用于减少频繁扩容的次数</li><li><code>vec.resize(size)</code>，重新指定容器的大小，不仅会给容器的底层开辟指定大小的内存空间，还会以默认值填充新的位置</li><li><code>vec.resize(size, item)</code>，重新指定容器的大小，不仅会给容器的底层开辟指定大小的内存空间，还会以指定值填充新的位置</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>对 vector 容器进行连续的插入（<code>insert</code>）或者删除（<code>erase</code>）操作时，一定要更新迭代器；否则第一次插入或删除操作完成后，迭代器就会失效。</p></div><h4 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="comment">// 往容器尾部插入元素</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中元素数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于下标访问元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"vec[3] = "</span> &lt;&lt; vec[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"================================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中所有的偶数元素全部删除</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 连续删除元素后必须更新迭代器，否则迭代器会失效</span></span><br><span class="line">            it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        cout &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"================================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器中所有的奇数元素前面都添加一个偶数</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 连续插入元素后必须更新迭代器，否则迭代器会失效</span></span><br><span class="line">            it = vec.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        cout &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size: 10</span><br><span class="line">94 80 7 45 20 57 74 73 16 19 </span><br><span class="line">vec[3] = 45</span><br><span class="line">================================</span><br><span class="line">7 45 57 73 19 </span><br><span class="line">================================</span><br><span class="line">6 7 44 45 56 57 72 73 18 19 </span><br></pre></td></tr></tbody></table></figure><h4 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器的默认大小是 0，当插入元素时，容器大小会按照 0 1 2 4 8 16 ... 来扩容</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预留空间，只会给容器的底层开辟指定大小的内存空间，并不会添加新的元素，主要用于减少频繁扩容的次数</span></span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"================================"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器的默认大小是 0，当插入元素时，容器大小会按照 0 1 2 4 8 16 ... 来扩容</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec2;</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec2.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的大小，不仅会给容器的底层开辟指定大小的内存空间，还会填充新的位置</span></span><br><span class="line">    <span class="comment">// 若容器变大，则以默认值（0）填充新位置。如果容器变小，则末尾超出容器大小的元素会被删除</span></span><br><span class="line">    vec2.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec2.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        vec2.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (vec2.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">size: 0</span><br><span class="line">empty: true</span><br><span class="line">size: 0</span><br><span class="line">empty: true</span><br><span class="line">size: 10</span><br><span class="line">empty: false</span><br><span class="line">================================</span><br><span class="line">size: 0</span><br><span class="line">empty: true</span><br><span class="line">size: 10</span><br><span class="line">empty: false</span><br><span class="line">size: 20</span><br><span class="line">empty: false</span><br></pre></td></tr></tbody></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><h4 id="容器介绍-1"><a href="#容器介绍-1" class="headerlink" title="容器介绍"></a>容器介绍</h4><p><strong>deque 一种双向开口的连续线性空间（双端队列容器），底层的数据结构是支持动态开辟内存空间的二维数组。</strong>所谓双向开口，意思是可以在头尾两端分别进行元素的插入和移除操作。虽然 vector 也可以在头尾两端进行操作，但是其头部操作的效率非常低，无法被接受。deque 和 vector 的最大差异，一在于 deque 允许于常数项时间内对头端进行元素的插入或移除操作，二在于 <strong>deque 没有所谓容量 <code>capacity</code> 的观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</strong>换句话说，像 vector 那样因旧空间不足而重新配置一块更大的空间，然后拷贝元素，再释放旧空间这样的事情不会发生在 deque 身上，也因此 deque 没有必要提供所谓的空间保留（reserve）功能。虽然 deque 也提供了随机迭代器（Random Access Iterator），但是它的迭代器并不是普通的指针，其复杂度和 vector 不是一个量级，这会影响各个层面的运算效率。因此，除非有必要，应该尽可能的使用 vector，而不是 deque。对 deque 进行的排序操作，为了提高效率，可将 deque 先完整的复制到一个 vector 中，然后对 vector 容器进行排序，再复制回 deque。</p><p><img data-src="../../../asset/2025/01/cplusplus-deque-1.png"></p><p><strong>deque 本质上是由一段一段的定量连续空间（分段连续内存空间）构造而成，一旦有必要在 deque 的头端或尾端增加新空间，便会配置一段新的定量连续空间，然后串接在整个 deque 的头端或尾端。</strong>deque 最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口；这避开了重新配置空间、复制数据、释放空间的轮回，代价就是复杂的迭代器架构。既然 deque 使用的是分段连续内存空间，那么就必须有中央控制器，维持其整体连续的假象，这样也导致了数据结构的设计及迭代器的前进后退操作颇为繁琐，deque 底层实现的代码远比 vector 或 list 都多得多。</p><p><img data-src="../../../asset/2025/01/cplusplus-deque-2.png"></p><p><strong>deque 内部的中控器维护的是每个缓冲区的地址，而缓冲区则存放着真实的数据，目的是让 deque 使用起来像是一片连续的内存空间。</strong>deque 采取一块所谓的 <code>map</code>（注意，不是 STL 的 map 容器）作为主控，这里所谓的 <code>map</code> 是一小块连续的内存空间，其中每一个元素（节点）都是一个指针，指向另一段连续性内存空间，称作缓冲区，缓冲区才是 deque 的存储空间的主体。</p><ul><li><p>声明</p><ul><li><code>deque&lt;int&gt; deq;</code></li></ul></li><li><p>插入</p><ul><li><code>deq.push_back(20)</code>，往尾部插入元素</li><li><code>deq.push_front(20)</code>，往头部插入元素</li><li><code>deq.insert(iterator, 20)</code>，往迭代器指向的位置插入元素</li></ul></li><li><p>删除</p><ul><li><code>deq.pop_back()</code>，往尾部删除元素</li><li><code>deq.pop_front()</code>，往头部删除元素</li><li><code>deq.erase(it)</code>，删除迭代器指向的元素</li></ul></li><li><p>查询</p><ul><li><code>iterator</code>：迭代器遍历</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">deque 与 vector 的区别</p><ul><li>deque 对头部的元素插入与删除，其速度比 vector 快。</li><li>deque 对中间的元素插入与删除，其速度比 vector 慢。</li><li>vector 对于头部的插入与删除效率极低，数据量越大，效率越低。</li><li>vector 访问元素的速度会比 deque 快，这和两者的内部实现有关。</li></ul></div><h4 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"------ deque 大小操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    d1.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断容器是否为空</span></span><br><span class="line">    <span class="keyword">bool</span> empty = d1.<span class="built_in">empty</span>();</span><br><span class="line">    cout &lt;&lt; (empty ? <span class="string">"yes"</span> : <span class="string">"no"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中元素的个数</span></span><br><span class="line">    <span class="keyword">size_t</span> size = d1.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; size &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的大小为 num，若容器变大，则以默认值（0）填充新位置。如果容器变小，则末尾超出容器大小的元素会被删除</span></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的大小为 num，若容器变大，则以指定值填充新位置。如果容器变小，则末尾超出容器大小的元素会被删除</span></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ deque 读取操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引所指向的数据，如果索引越界，抛出 out_of_range 异常</span></span><br><span class="line">    <span class="keyword">int</span> num1 = d2.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"num1 = "</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引所指向的数据，如果索引越界，程序终止运行</span></span><br><span class="line">    <span class="keyword">int</span> num2 = d2[<span class="number">3</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">"num2 = "</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中第一个数据元素</span></span><br><span class="line">    <span class="keyword">int</span> font = d2.<span class="built_in">front</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"font = "</span> &lt;&lt; font &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中最后一个数据元素</span></span><br><span class="line">    <span class="keyword">int</span> back = d2.<span class="built_in">back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"back = "</span> &lt;&lt; back &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ deque 插入操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">3</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往迭代器指向的位置插入指定的元素</span></span><br><span class="line">    d3.<span class="built_in">insert</span>(d3.<span class="built_in">begin</span>(), <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往迭代器指向的位置插入 n 个指定的元素</span></span><br><span class="line">    d3.<span class="built_in">insert</span>(d3.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往迭代器指向的位置插入 [begin, end) 区间的数据</span></span><br><span class="line">    <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(<span class="number">2</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line">    d3.<span class="built_in">insert</span>(d3.<span class="built_in">begin</span>(), d4.<span class="built_in">begin</span>(), d4.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器头部插入一个数据</span></span><br><span class="line">    d4.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器尾部添加一个数据</span></span><br><span class="line">    d4.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ deque 删除操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d5;</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    d5.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定位置的数据，会返回下一个数据的位置</span></span><br><span class="line">    d5.<span class="built_in">erase</span>(d5.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器第一个数据</span></span><br><span class="line">    d5.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器最后一个数据</span></span><br><span class="line">    d5.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空容器的所有数据</span></span><br><span class="line">    d5.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">------ deque 大小操作 ------</span><br><span class="line">10 10 10 10 10 </span><br><span class="line">no</span><br><span class="line">5</span><br><span class="line">10 10 10 10 10 0 0 </span><br><span class="line">10 10 10 10 10 0 0 8 8 8 </span><br><span class="line">------ deque 读取操作 ------</span><br><span class="line">num1 = 3</span><br><span class="line">num2 = 4</span><br><span class="line">font = 1</span><br><span class="line">back = 5</span><br><span class="line">------ deque 插入操作 ------</span><br><span class="line">8 8 8 </span><br><span class="line">10 8 8 8 </span><br><span class="line">11 11 10 8 8 8 </span><br><span class="line">12 12 11 11 10 8 8 8 </span><br><span class="line">13 12 12 </span><br><span class="line">13 12 12 11 </span><br><span class="line">------ deque 删除操作 ------</span><br><span class="line">2 3 4 5 6 </span><br><span class="line">3 4 5 6 </span><br><span class="line">3 4 5 </span><br></pre></td></tr></tbody></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="容器介绍-2"><a href="#容器介绍-2" class="headerlink" title="容器介绍"></a>容器介绍</h4><p><strong>list 是一个双向链表容器，而且还是一个双向循环链表，可以高效地进行插入和删除元素。</strong>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的（如下图所示）。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。相较于 vector 的连续线性空间，list 就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list 对于空间的运用有绝对的精准，一点也不浪费。值得一提的是，对于任何位置的元素插入或元素的移除，list 永远是常数时间的耗时（效率较高）；但对于查询操作来说，list 的执行效率较低。</p><p><img data-src="../../../asset/2025/01/cplusplus-list-1.png"></p><ul><li><p>声明</p><ul><li><code>list&lt;int&gt; mylist;</code></li></ul></li><li><p>插入</p><ul><li><code>mylist.push_back(20)</code>，往尾部插入元素</li><li><code>mylist.push_front(20)</code>，往头部插入元素</li><li><code>mylist.insert(iterator, 20)</code>，往迭代器指向的位置插入元素</li></ul></li><li><p>删除</p><ul><li><code>mylist.pop_back()</code>，往尾部删除元素</li><li><code>mylist.pop_front()</code>，往头部删除元素</li><li><code>mylist.erase(it)</code>，删除迭代器指向的元素</li></ul></li><li><p>查询</p><ul><li><code>iterator</code>：迭代器遍历</li></ul></li></ul><div class="admonition note"><p class="admonition-title">链表的特性</p><ul><li>链表采用动态内存分配，不会造成内存浪费和溢出。</li><li>链表虽然灵活，但是空间和时间的额外耗费较大。</li><li>链表执行插入和删除操作都十分方便，仅修改指针即可实现，不需要移动大量元素。</li><li>链表的访问效率比数组要低，适合需要频繁插入、删除元素的场景（读少写多）。</li><li>链表不可以随机存取元素，所以不支持 <code>at.(pos)</code> 函数与 <code>[]</code> 操作符的使用。</li></ul></div><h4 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reversePrintList</span><span class="params">(list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>{</span><br><span class="line">    <span class="comment">// 逆向遍历</span></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = L.<span class="built_in">rbegin</span>(); it != L.<span class="built_in">rend</span>(); it++) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 插入操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; myList1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器的尾部插入元素</span></span><br><span class="line">    myList1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    myList1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    myList1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器的头部插入元素</span></span><br><span class="line">    myList1.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line">    myList1.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    myList1.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 pos 位置插入 elem 数据的拷贝，返回新数据的位置</span></span><br><span class="line">    myList1.<span class="built_in">insert</span>(myList1.<span class="built_in">begin</span>(), <span class="number">400</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 pos 位置插入 n 个 elem 数据，无返回值</span></span><br><span class="line">    myList1.<span class="built_in">insert</span>(myList1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">500</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 pos 位置插入 [begin, end) 区间的数据，无返回值</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; myList2;</span><br><span class="line">    myList2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    myList1.<span class="built_in">insert</span>(myList1.<span class="built_in">begin</span>(), myList2.<span class="built_in">begin</span>(), myList2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 删除操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器头部的数据</span></span><br><span class="line">    myList1.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器尾部的数据</span></span><br><span class="line">    myList1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 pos 位置的数据，返回下一个数据的位置</span></span><br><span class="line">    myList1.<span class="built_in">erase</span>(myList1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除容器中所有与 elem 值匹配的元素</span></span><br><span class="line">    myList1.<span class="built_in">remove</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 读取操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个元素</span></span><br><span class="line">    cout &lt;&lt; myList1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最后一个元素</span></span><br><span class="line">    cout &lt;&lt; myList1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 清空操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; myList3;</span><br><span class="line">    myList3.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    myList3.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    myList3.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printList</span>(myList3);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 大小操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size = "</span> &lt;&lt; myList1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断容器是否为空</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty = myList1.<span class="built_in">empty</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"isEmpty = "</span> &lt;&lt; (isEmpty ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的长度 num，若容器变长，则以默认值填充新位置，若容器变短，则末尾超出容器长度的元素会被删除</span></span><br><span class="line">    myList1.<span class="built_in">resize</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"size = "</span> &lt;&lt; myList1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定容器的长度 num，若容器变长，则以 elem 值填充新位置，若容器变短，则末尾超出容器长度的元素会被删除</span></span><br><span class="line">    myList1.<span class="built_in">resize</span>(<span class="number">9</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">printList</span>(myList1);</span><br><span class="line">    cout &lt;&lt; <span class="string">"size = "</span> &lt;&lt; myList1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------ list 逆向遍历操作 ------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; myList11;</span><br><span class="line">    myList11.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList11.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList11.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">reversePrintList</span>(myList11);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">------ list 插入操作 ------</span><br><span class="line">10 20 30 </span><br><span class="line">100 200 300 10 20 30 </span><br><span class="line">400 100 200 300 10 20 30 </span><br><span class="line">500 500 400 100 200 300 10 20 30 </span><br><span class="line">1 2 3 500 500 400 100 200 300 10 20 30 </span><br><span class="line">------ list 删除操作 ------</span><br><span class="line">2 3 500 500 400 100 200 300 10 20 30 </span><br><span class="line">2 3 500 500 400 100 200 300 10 20 </span><br><span class="line">3 500 500 400 100 200 300 10 20 </span><br><span class="line">3 500 500 400 200 300 10 20 </span><br><span class="line">------ list 读取操作 ------</span><br><span class="line">3</span><br><span class="line">20</span><br><span class="line">------ list 清空操作 ------</span><br><span class="line"></span><br><span class="line">------ list 大小操作 ------</span><br><span class="line">size = 8</span><br><span class="line">isEmpty = false</span><br><span class="line">size = 6</span><br><span class="line">3 500 500 400 200 300 11 11 11 </span><br><span class="line">size = 9</span><br><span class="line">------ list 逆向遍历操作 ------</span><br><span class="line">3 2 1 </span><br></pre></td></tr></tbody></table></figure><h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><p>在 C++ 中，无序关联容器的底层数据结构都是链式哈希表（也称为哈希链表），常用的无序关联容器有：</p><ul><li><code>unordered_set</code>: 一个无序容器，存储唯一键值（不允许重复），基于链式哈希表实现，提供快速的插入、删除和查找操作。  </li><li><code>unordered_multiset</code>: 一个无序容器，存储键值（允许重复），基于链式哈希表实现，提供快速的多键插入、删除和查找操作。  </li><li><code>unordered_map</code>: 一个无序的键值对容器（键不允许重复），基于链式哈希表实现，键唯一且与对应的值关联，提供高效的键查找。  </li><li><code>unordered_multimap</code>: 一个无序的键值对容器（键允许重复），基于链式哈希表实现，允许多个键相同的键值对，提供快速的键查找和多值存储。  </li></ul><p>在 C++ 中，无序关联容器有以下的常用操作：</p><ul><li><p>插入</p><ul><li><code>insert(val)</code>，往容器插入元素</li></ul></li><li><p>删除</p><ul><li><code>erase(val)</code>，删除元素</li><li><code>erase(iterator)</code>，删除迭代器指向的元素</li></ul></li><li><p>查询</p><ul><li><code>iterator</code>：迭代器遍历</li><li><code>for_each</code>，循环遍历</li><li><code>for</code>：循环遍历</li><li><code>find</code>：查找元素</li></ul></li><li><p>其他</p><ul><li><code>size()</code>：获取容器中元素数量</li><li><code>count(val)</code>：统计容器中某个元素的数量</li></ul></li></ul><h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><h5 id="案例代码-2"><a href="#案例代码-2" class="headerlink" title="案例代码"></a>案例代码</h5><p>本节将演示 <code>unordered_set</code> 容器的简单使用。值得一提的是，<code>unordered_multiset</code> 容器的使用跟 <code>unordered_set</code> 容器类似，这里不再累述。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储唯一键值（不允许重复）的无序容器</span></span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; set1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) {</span><br><span class="line">        set1.<span class="built_in">insert</span>(<span class="built_in">rand</span>() % <span class="number">20</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = set1.<span class="built_in">begin</span>(); it != set1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中的元素数量</span></span><br><span class="line">    cout &lt;&lt; set1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计容器中元素是 5 的个数</span></span><br><span class="line">    cout &lt;&lt; set1.<span class="built_in">count</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    set1.<span class="built_in">erase</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = set1.<span class="built_in">find</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterator != set1.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"find item : "</span> &lt;&lt; *iterator &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not find item"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: set1) {</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16 8 12 18 20 15 13 9 2 7 19 1 10 6 17 3 14 4 5 </span><br><span class="line">19</span><br><span class="line">1</span><br><span class="line">find item : 15</span><br><span class="line">16 8 12 18 15 13 9 2 7 19 1 10 6 17 3 14 4 5 </span><br></pre></td></tr></tbody></table></figure><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><h5 id="案例代码-3"><a href="#案例代码-3" class="headerlink" title="案例代码"></a>案例代码</h5><p>本节将演示 <code>unordered_map</code> 容器的简单使用。值得一提的是，<code>unordered_multimap</code> 容器的使用跟 <code>unordered_map</code> 容器类似，这里不再累述。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无序的键值对容器（键不允许重复）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, string&gt; map1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1001</span>, <span class="string">"Tom"</span>));</span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1002</span>, <span class="string">"Peter"</span>));</span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1003</span>, <span class="string">"David"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定键的值，如果 key 不存在，会自动插入一个键值对 [key, string()]</span></span><br><span class="line">    cout &lt;&lt; map1[<span class="number">1002</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或者修改操作</span></span><br><span class="line">    map1[<span class="number">1004</span>] = <span class="string">"Jim"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中键值对的数量</span></span><br><span class="line">    cout &lt;&lt; map1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定的键</span></span><br><span class="line">    map1.<span class="built_in">erase</span>(<span class="number">1003</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = map1.<span class="built_in">find</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterator != map1.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"finded, key: "</span> &lt;&lt; iterator-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; iterator-&gt;second &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not finded"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"key: "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Peter</span><br><span class="line">4</span><br><span class="line">finded, key: 1001, value: Tom</span><br><span class="line">key: 1004, value: Jim</span><br><span class="line">key: 1002, value: Peter</span><br><span class="line">key: 1001, value: Tom</span><br></pre></td></tr></tbody></table></figure><h3 id="有序关联容器"><a href="#有序关联容器" class="headerlink" title="有序关联容器"></a>有序关联容器</h3><p>在 C++ 中，有序关联容器的底层数据结构都是红黑树（一种平衡二叉搜索树），常用的有序关联容器有：</p><ul><li><code>set</code>: 一个有序容器，存储唯一键值（不允许重复），基于红黑树实现，提供高效的元素插入、删除和有序遍历。  </li><li><code>multiset</code>: 一个有序容器，存储键值（允许重复），基于红黑树实现，支持多键插入和有序遍历。  </li><li><code>map</code>: 一个有序的键值对容器（键不允许重复），基于红黑树实现，键唯一且与对应的值关联，支持高效查找和有序遍历。  </li><li><code>multimap</code>: 一个有序的键值对容器（键允许重复），基于红黑树实现，允许键重复，支持多键查找和有序存储。  </li></ul><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>本节将演示 <code>set</code> 容器的简单使用。值得一提的是，<code>multiset</code> 容器的使用跟 <code>set</code> 容器类似，这里不再累述。</p><h5 id="案例代码一-1"><a href="#案例代码一-1" class="headerlink" title="案例代码一"></a>案例代码一</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储唯一键值（不允许重复）的有序容器</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; set1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        set1.<span class="built_in">insert</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = set1.<span class="built_in">begin</span>(); it != set1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中的元素数量</span></span><br><span class="line">    cout &lt;&lt; set1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计容器中元素是 5 的个数</span></span><br><span class="line">    cout &lt;&lt; set1.<span class="built_in">count</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    set1.<span class="built_in">erase</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = set1.<span class="built_in">find</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterator != set1.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"find item : "</span> &lt;&lt; *iterator &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not find item"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: set1) {</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 21 22 26 27 36 39 41 51 55 60 67 81 89 90 91 94 96 </span><br><span class="line">18</span><br><span class="line">1</span><br><span class="line">not find item</span><br><span class="line">5 21 22 26 27 36 39 41 51 55 60 67 81 89 90 91 94 96 </span><br></pre></td></tr></tbody></table></figure><h5 id="案例代码二-1"><a href="#案例代码二-1" class="headerlink" title="案例代码二"></a>案例代码二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">long</span> id, string name) : _id(id), _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 set 容器是有序的，因此自定义类型都需要重载小于运算符，否则 set 容器将不知道如何对自定义类型进行排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Student &amp;other) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_id &lt; other._id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;student);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">long</span> _id;</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;student) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"id: "</span> &lt;&lt; student._id &lt;&lt; <span class="string">", name: "</span> &lt;&lt; student._name;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 存储唯一键值（不允许重复）的有序容器</span></span><br><span class="line">    set&lt;Student&gt; set1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1001</span>, <span class="string">"Tom"</span>));</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1002</span>, <span class="string">"Jim"</span>));</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1003</span>, <span class="string">"Peter"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = set1.<span class="built_in">begin</span>(); it != set1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id: 1001, name: Tom</span><br><span class="line">id: 1002, name: Jim</span><br><span class="line">id: 1003, name: Peter</span><br></pre></td></tr></tbody></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>本节将演示 <code>map</code> 容器的简单使用。值得一提的是，<code>multimap</code> 容器的使用跟 <code>map</code> 容器类似，这里不再累述。</p><h5 id="案例代码一-2"><a href="#案例代码一-2" class="headerlink" title="案例代码一"></a>案例代码一</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有序的键值对容器（键不允许重复）</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; map1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1001</span>, <span class="string">"Tom"</span>));</span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1002</span>, <span class="string">"Peter"</span>));</span><br><span class="line">    map1.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1003</span>, <span class="string">"David"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定键的值，如果 key 不存在，会自动插入一个键值对 [key, string()]</span></span><br><span class="line">    cout &lt;&lt; map1[<span class="number">1002</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或者修改操作</span></span><br><span class="line">    map1[<span class="number">1004</span>] = <span class="string">"Jim"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中键值对的数量</span></span><br><span class="line">    cout &lt;&lt; map1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定的键</span></span><br><span class="line">    map1.<span class="built_in">erase</span>(<span class="number">1003</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = map1.<span class="built_in">find</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterator != map1.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"finded, key: "</span> &lt;&lt; iterator-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; iterator-&gt;second &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"not finded"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"key: "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Peter</span><br><span class="line">4</span><br><span class="line">finded, key: 1001, value: Tom</span><br><span class="line">key: 1001, value: Tom</span><br><span class="line">key: 1002, value: Peter</span><br><span class="line">key: 1004, value: Jim</span><br></pre></td></tr></tbody></table></figure><h5 id="案例代码二-2"><a href="#案例代码二-2" class="headerlink" title="案例代码二"></a>案例代码二</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>() {</span><br><span class="line">        <span class="keyword">this</span>-&gt;_id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_name = <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">long</span> id, string name) : _id(id), _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;student);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">long</span> _id;</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;student) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"id: "</span> &lt;&lt; student._id &lt;&lt; <span class="string">", name: "</span> &lt;&lt; student._name;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 有序的键值对容器（键不允许重复）</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, Student&gt; map1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    map1.<span class="built_in">insert</span>({<span class="number">1001</span>, <span class="built_in">Student</span>(<span class="number">1001</span>, <span class="string">"Jim"</span>)});</span><br><span class="line">    map1.<span class="built_in">insert</span>({<span class="number">1002</span>, <span class="built_in">Student</span>(<span class="number">1002</span>, <span class="string">"Peter"</span>)});</span><br><span class="line">    map1.<span class="built_in">insert</span>({<span class="number">1003</span>, <span class="built_in">Student</span>(<span class="number">1003</span>, <span class="string">"David"</span>)});</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定键的值，如果 key 不存在，会自动插入一个键值对 [key, Student()]，这需要自定义的数据类型提供默认构造函数</span></span><br><span class="line">    cout &lt;&lt; map1[<span class="number">1002</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="comment">// 获取 key 和 value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"key: "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", value: "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: 1002, name: Peter</span><br><span class="line">key: 1001, value: id: 1001, name: Jim</span><br><span class="line">key: 1002, value: id: 1002, name: Peter</span><br><span class="line">key: 1003, value: id: 1003, name: David</span><br></pre></td></tr></tbody></table></figure><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>在 C++ 中，常用的容器适配器有：</p><ul><li><code>stack</code>: 一个遵循后进先出（LIFO）原则的容器适配器，底层默认是基于 <code>deque</code> 实现，也可以使用 <code>vector</code> 或 <code>list</code> 替代底层容器，支持在栈顶插入、删除和访问元素的操作。</li><li><code>queue</code>: 一个遵循先进先出（FIFO）原则的容器适配器，底层默认是基于 <code>deque</code> 实现，支持在队尾插入元素和在队头移除、访问元素的操作。</li><li><code>priority_queue</code>: 一个基于堆实现的容器适配器（即优先级队列），底层默认使用 <code>vector</code> 作为容器存储，借助堆算法按优先级（默认大顶堆）访问最高优先级的元素。</li></ul><div class="admonition note"><p class="admonition-title">容器迭代器的特点</p><ul><li>容器适配器没有自己的迭代器。</li><li>容器适配器的底层没有自己的数据机构，它本质是另外一个容器的封装，它的函数全部由底层依赖的容器来实现。</li></ul></div><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h4 id="案例代码-4"><a href="#案例代码-4" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈（后进先出 - LIFO）</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        s1.<span class="built_in">push</span>(item);</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回栈的元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 获取栈顶元素</span></span><br><span class="line">        cout &lt;&lt; s1.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="comment">// 弹栈</span></span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 80 23 89 30 85 6 58 5 67 32 98 13 65 42 60 75 85 77 57 </span><br><span class="line">size: 20</span><br><span class="line">57 77 85 75 60 42 65 13 98 32 67 5 58 6 85 30 89 23 80 10 </span><br></pre></td></tr></tbody></table></figure><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h4 id="案例代码-5"><a href="#案例代码-5" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列（先进先出 - FIFO）</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        q1.<span class="built_in">push</span>(item);</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队列的元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; q1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        cout &lt;&lt; q1.<span class="built_in">front</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">14 45 87 90 95 32 66 27 9 92 96 88 93 68 72 55 42 37 35 64 </span><br><span class="line">size: 20</span><br><span class="line">14 45 87 90 95 32 66 27 9 92 96 88 93 68 72 55 42 37 35 64 </span><br></pre></td></tr></tbody></table></figure><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><h4 id="案例代码-6"><a href="#案例代码-6" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        pque.<span class="built_in">push</span>(item);</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队列的元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; pque.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (!pque.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        cout &lt;&lt; pque.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        pque.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">85 32 2 2 38 96 10 2 83 34 1 64 19 90 64 20 6 81 100 47 </span><br><span class="line">size: 20</span><br><span class="line">100 96 90 85 83 81 64 64 47 38 34 32 20 19 10 6 2 2 2 1 </span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之四</title>
    <link href="https://www.techgrow.cn/posts/4f052863.html"/>
    <id>https://www.techgrow.cn/posts/4f052863.html</id>
    <published>2024-12-13T13:55:33.000Z</published>
    <updated>2024-12-13T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><span id="more"></span><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基类（父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parent</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义派生类（子类），继承方式是 public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Child</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 直接访问基类（父类）的 public 成员变量</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; <span class="string">", c="</span> &lt;&lt; <span class="keyword">this</span>-&gt;c &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Child <span class="title">child</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    child.<span class="built_in">print</span>();    <span class="comment">// 直接调用基类（父类）的 public 成员函数</span></span><br><span class="line">    child.<span class="built_in">echo</span>();     <span class="comment">// 直接调用派生类（子类）的 public 成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1, b=2</span><br><span class="line">a=1, b=2, c=3</span><br></pre></td></tr></tbody></table></figure><h2 id="派生类的构造过程"><a href="#派生类的构造过程" class="headerlink" title="派生类的构造过程"></a>派生类的构造过程</h2><ul><li><p>派生类对象构造的过程：</p><ul><li>派生类先调用基类的构造函数，初始化从基类继承来的成员。</li><li>派生类后调用自己的构造函数，初始化派生类自己特有的成员。</li></ul></li><li><p>派生类对象析构的过程：</p><ul><li>派生类先调用自己的析构函数，释放派生类成员可能占用的外部资源（堆内存，文件等）。</li><li>派生类后调用基类的析构函数，释放派生类内存中从基类继承来的成员可能占用的外部资源（堆内存、文件等）。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>在 C++ 的类继承中，先构造的后析构，即后构造的先析构。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data) : <span class="built_in">ma</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Base()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 显式调用 Base 的构造函数初始化 ma</span></span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Device</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Device <span class="title">d</span><span class="params">(<span class="number">2</span>)</span></span>;    <span class="comment">// 先构造的后析构，即后构造的先析构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base()</span><br><span class="line">Device()</span><br><span class="line">~Device()</span><br><span class="line">~Base()</span><br></pre></td></tr></tbody></table></figure><h2 id="重载、重写、隐藏"><a href="#重载、重写、隐藏" class="headerlink" title="重载、重写、隐藏"></a>重载、重写、隐藏</h2><ul><li><p>重载关系</p><ul><li>一组函数要重载，必须处在同一个作用域当中，且函数名字相同，但参数列表不同。</li></ul></li><li><p>隐藏关系</p><ul><li>在继承结构当中，派生类的同名成员会将基类的同名成员给隐藏掉，这里的隐藏是指作用域的隐藏。</li></ul></li><li><p>重写关系</p><ul><li>基类和派生类的函数，其函数名、返回值以及参数列表都相同，而且基类的方法是虚函数，那么派生类的方法就会被编译器自动处理成虚函数，它们之间成为重写（覆盖）关系。</li></ul></li></ul><h3 id="案例代码一"><a href="#案例代码一" class="headerlink" title="案例代码一"></a>案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show(int)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">20</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Device device;</span><br><span class="line">    device.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// device.show(20);         // 错误写法，派生类的 show() 函数将基类的 show(int a) 函数隐藏了，无法正常调用基类的同名函数</span></span><br><span class="line">    device.Base::<span class="built_in">show</span>(<span class="number">20</span>);      <span class="comment">// 正确写法，派生类加上作用域可以正常调用基类的同名函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Device::show()</span><br><span class="line">Base::show()</span><br></pre></td></tr></tbody></table></figure><h3 id="案例代码二"><a href="#案例代码二" class="headerlink" title="案例代码二"></a>案例代码二</h3><ul><li><p>在 C++ 的继承结构中，通常会说成是从上（基类）到下（派生类）的结构</p><ul><li>从上到下，即基类对象 -&gt; 派生类对象</li><li>从下到上，即派生类对象 -&gt; 基类对象</li></ul></li><li><p> C++ 中的多态表现           </p><ul><li>基类指针（引用）-&gt; 派生类对象</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 C++ 的继承结构中进行上下的类型转换时，默认只支持从下（派生类）到上（基类）的类型的转换，不支持从上（基类）到下（派生类）的类型的转换。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show(int)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">20</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"=========== test01() ==========="</span> &lt;&lt; endl;</span><br><span class="line">    Base base;</span><br><span class="line">    Device device;</span><br><span class="line">    base = device;      <span class="comment">// 正确写法，类型从下到上的转换</span></span><br><span class="line">    <span class="comment">// device = base;   // 错误写法，类型从上到下的转换</span></span><br><span class="line">    base.<span class="built_in">show</span>();</span><br><span class="line">    base.<span class="built_in">show</span>(<span class="number">30</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"=========== test02() ==========="</span> &lt;&lt; endl;</span><br><span class="line">    Base base;</span><br><span class="line">    Device device;</span><br><span class="line"></span><br><span class="line">    Base *_base = &amp;device;          <span class="comment">// 正确写法，类型从下到上的转换</span></span><br><span class="line">    <span class="comment">// Device *_device = &amp;base;     // 错误写法，类型从上到下的转换</span></span><br><span class="line">    _base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    _base-&gt;<span class="built_in">show</span>(<span class="number">40</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=========== test01() ===========</span><br><span class="line">Base::show()</span><br><span class="line">Base::show(int)</span><br><span class="line">=========== test02() ===========</span><br><span class="line">Base::show()</span><br><span class="line">Base::show(int)</span><br></pre></td></tr></tbody></table></figure><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="虚函数的概念"><a href="#虚函数的概念" class="headerlink" title="虚函数的概念"></a>虚函数的概念</h3><ul><li><p>(1) 当一个类里面定义了虚函数，那么在编译阶段，编译器会给这个类的类型产生一个唯一的 <code>vftable</code> 虚函数表，虚函数表中主要存储的内容是 <code>RTTI</code> 指针和虚函数的地址（<a href="../../../asset/2025/01/cplusplus-virtual-function-1.png">如图所示</a>）。当程序运行时，每一张虚函数表都会加载到内存的 <code>.rodata</code> 区。</p></li><li><p>(2) 当一个类里面定义了虚函数，那么这个类定义的对象在其运行时，内存中开始的部分会多存储一个 <code>vfptr</code> 虚函数指针（占 4 字节大小），它指向相应类型的虚函数表 <code>vftable</code>。一个类定义 N 个对象，它们的 <code>vfptr</code> 虚函数指针指向的都是同一张虚函数表。</p></li><li><p>(3) 如果派生类中的函数和从基类继承来的某个函数，其函数名、返回值、参数列表都相同，而且基类的函数是 <code>virtual</code> 关键字修饰的，那么派生类的这个函数会被编译器自动处理成虚函数。</p></li><li><p>(4) 一个类里面虚函数的个数，不影响类对象的内存大小（<code>vfptr</code> 虚函数指针永远只占用 4 个字节大小），影响的是虚函数表的大小。</p></li><li><p>(5) 在构造函数中调用虚函数，不会发生动态绑定。简而言之，在构造函数调用的函数，都是静态绑定。</p></li></ul><div class="admonition warning"><p class="admonition-title">哪些函数不能实现成虚函数</p><ul><li>(1) 构造函数不能实现成虚函数。</li><li>(2) <code>static</code> 关键字修饰的函数不能实现成虚函数。</li></ul></div><h3 id="静态绑定（普通函数）"><a href="#静态绑定（普通函数）" class="headerlink" title="静态绑定（普通函数）"></a>静态绑定（普通函数）</h3><ul><li>静态（编译时期）绑定，使用的是普通函数 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通函数（非虚函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通函数（非虚函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show(int a)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">20</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Device <span class="title">device</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Base *pb = &amp;device;</span><br><span class="line">    pb-&gt;<span class="built_in">show</span>();           <span class="comment">// 静态（编译时期）绑定（函数的调用）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Base) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Device) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(pb).<span class="built_in">name</span>() &lt;&lt; endl;      <span class="comment">// class Base *</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(*pb).<span class="built_in">name</span>() &lt;&lt; endl;     <span class="comment">// class Base</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base::show()</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">class Base *</span><br><span class="line">class Base</span><br></pre></td></tr></tbody></table></figure><h3 id="动态绑定（虚函数）"><a href="#动态绑定（虚函数）" class="headerlink" title="动态绑定（虚函数）"></a>动态绑定（虚函数）</h3><ul><li>动态（运行时期）绑定，使用的是虚函数 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show(int a)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">20</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Device <span class="title">device</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Base *pb = &amp;device;</span><br><span class="line">    pb-&gt;<span class="built_in">show</span>();           <span class="comment">// 动态（运行时期）绑定（函数的调用）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Base) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Device) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(pb).<span class="built_in">name</span>() &lt;&lt; endl;      <span class="comment">// class Base *</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(*pb).<span class="built_in">name</span>() &lt;&lt; endl;     <span class="comment">// class Device</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Device::show()</span><br><span class="line">16</span><br><span class="line">16</span><br><span class="line">class Base *</span><br><span class="line">class Device</span><br></pre></td></tr></tbody></table></figure><h3 id="查看类的内存布局"><a href="#查看类的内存布局" class="headerlink" title="查看类的内存布局"></a>查看类的内存布局</h3><p>在 Visual Studio 开发人员命令提示窗口内，可以使用以下命令查看类的内存布局信息，其中 <code>YYY</code> 是类的名称，<code>xxx</code> 是 C++ 源文件的名称。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayoutYYY xxx.cpp</span><br></pre></td></tr></tbody></table></figure><ul><li>在上述动态绑定（带虚函数）的代码中，Base 类的内存布局如下：</li></ul><p><img data-src="../../../asset/2025/01/cplusplus-virtual-function-2.png"></p><ul><li>在上述动态绑定（带虚函数）的代码中，Device 类的内存布局如下：</li></ul><p><img data-src="../../../asset/2025/01/cplusplus-virtual-function-3.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p>更多关于 Visual Studio 命令的详细使用教程，请阅读 <a href="https://blog.csdn.net/weixin_44380570/article/details/120562497">《使用 VS 查看对象模型以及结构体内存对齐》</a>。</p></div><h3 id="虚函数调用深入理解"><a href="#虚函数调用深入理解" class="headerlink" title="虚函数调用深入理解"></a>虚函数调用深入理解</h3><div class="admonition warning"><p class="admonition-title">思考问题</p><p>在 C++ 中，是不是虚函数的调用一定就是动态绑定？</p></div><p>在 C++ 中，虚函数的调用不一定就是动态绑定，比如：</p><ul><li>在类的构造函数中调用虚函数，只会发生静态绑定，而不会发生动态绑定。</li><li>类对象调用自己的成员函数（虚函数），只会发生静态绑定，而不会发生动态绑定。</li><li>通过指针或者引用变量调用虚函数，都会发生动态绑定，无论调用方是基类还是派生类，且无论被调用方是基类还是派生类。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">0</span>) : <span class="built_in">ma</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data = <span class="number">0</span>) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base base;</span><br><span class="line">    Device device;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    base.<span class="built_in">show</span>();    <span class="comment">// 静态绑定</span></span><br><span class="line">    device.<span class="built_in">show</span>();  <span class="comment">// 静态绑定</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Base *bptr1 = &amp;base;</span><br><span class="line">    bptr1-&gt;<span class="built_in">show</span>();   <span class="comment">// 动态绑定（必须由指针或者引用调用虚函数）</span></span><br><span class="line"></span><br><span class="line">    Base *bptr2 = &amp;device;</span><br><span class="line">    bptr2-&gt;<span class="built_in">show</span>();   <span class="comment">// 动态绑定（必须由指针或者引用调用虚函数）</span></span><br><span class="line"></span><br><span class="line">    Base &amp;b1 = base;</span><br><span class="line">    base.<span class="built_in">show</span>();     <span class="comment">// 动态绑定（必须由指针或者引用调用虚函数）</span></span><br><span class="line"></span><br><span class="line">    Base &amp;b2 = device;</span><br><span class="line">    b2.<span class="built_in">show</span>();       <span class="comment">// 动态绑定（必须由指针或者引用调用虚函数）</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"====================="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Device *dptr = &amp;device;</span><br><span class="line">    dptr-&gt;<span class="built_in">show</span>();   <span class="comment">// 动态绑定（虚函数通过指针或者引用变量调用，才会发生动态绑定）</span></span><br><span class="line"></span><br><span class="line">    Device &amp;d = device;</span><br><span class="line">    d.<span class="built_in">show</span>();       <span class="comment">// 动态绑定（虚函数通过指针或者引用变量调用，才会发生动态绑定）</span></span><br><span class="line"></span><br><span class="line">    Device *dptr2 = (Device *) &amp;base;   <span class="comment">// 强制类型转换（不安全）</span></span><br><span class="line">    dptr2-&gt;<span class="built_in">show</span>();   <span class="comment">// 动态绑定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">=====================</span><br><span class="line">Base::show()</span><br><span class="line">Device::show()</span><br><span class="line">=====================</span><br><span class="line">Base::show()</span><br><span class="line">Device::show()</span><br><span class="line">Base::show()</span><br><span class="line">Device::show()</span><br><span class="line">=====================</span><br><span class="line">Device::show()</span><br><span class="line">Device::show()</span><br><span class="line">Base::show()</span><br></pre></td></tr></tbody></table></figure><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><h3 id="虚析构函数的概念"><a href="#虚析构函数的概念" class="headerlink" title="虚析构函数的概念"></a>虚析构函数的概念</h3><ul><li>(1) 析构函数可以是虚的，虚析构函数主要用于指引 <code>delete</code> 运算符正确析构动态对象。</li><li>(2) 构造函数不能是虚函数，因为建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数。</li><li>(3) 虚析构函数使得在删除指向派生类对象的基类指针时，可以调用派生类的析构函数来实现释放派生类中堆内存的目的，从而防止内存泄漏。</li><li>(4) 当基类的指针（引用）指向在堆上 <code>new</code> 出来的派生类对象的时候，基类的析构函数必须实现成虚析构函数。在调用虚析构函数的时候，必定会发生动态绑定，否则会导致派生类的析构函数无法被调用。</li></ul><h3 id="虚析构函数的使用"><a href="#虚析构函数的使用" class="headerlink" title="虚析构函数的使用"></a>虚析构函数的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> data) : <span class="built_in">ma</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Base()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>(<span class="keyword">int</span> data) : <span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当基类的析构函数是 virtual 虚函数，那么派生类的析构函数会自动成为虚函数</span></span><br><span class="line">    ~<span class="built_in">Device</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base *pb = <span class="keyword">new</span> <span class="built_in">Device</span>(<span class="number">10</span>);</span><br><span class="line">    pb-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base()</span><br><span class="line">Device()</span><br><span class="line">Base::show()</span><br><span class="line">~Device()</span><br><span class="line">~Base()</span><br></pre></td></tr></tbody></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h3><ul><li><p>静态（编译时期）的多态</p><ul><li>函数重载</li><li>模板（类模板与函数模板）</li></ul></li><li><p>动态（运行时期）的多态</p><ul><li>在类的继承结构中，基类指针（引用）指向派生类对象，通过该指针（引用）调用同名函数（虚函数），基类指针指向哪个派生类对象，就会调用哪个派生类对象的同名函数（虚函数）。</li><li>动态多态的底层是通过动态绑定来实现的，涉及虚函数指针（<code>vfptr</code>）和虚函数表（<code>vftable</code>）。</li></ul></li></ul><h3 id="多态的案例代码一"><a href="#多态的案例代码一" class="headerlink" title="多态的案例代码一"></a>多态的案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(string name) : _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: miao miao"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: wang wang"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pig</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: heng heng"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">(Animal &amp;animal)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态多态（底层是通过动态绑定来实现的）</span></span><br><span class="line">    animal.<span class="built_in">bark</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Cat cat = <span class="built_in">Cat</span>(<span class="string">"Cat"</span>);</span><br><span class="line">    Dog dog = <span class="built_in">Dog</span>(<span class="string">"Dog"</span>);</span><br><span class="line">    Pig pig = <span class="built_in">Pig</span>(<span class="string">"Pig"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bark</span>(cat);</span><br><span class="line">    <span class="built_in">bark</span>(dog);</span><br><span class="line">    <span class="built_in">bark</span>(pig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat bark: miao miao</span><br><span class="line">Dog bark: wang wang</span><br><span class="line">Pig bark: heng heng</span><br></pre></td></tr></tbody></table></figure><h3 id="多态的案例代码二"><a href="#多态的案例代码二" class="headerlink" title="多态的案例代码二"></a>多态的案例代码二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(string name) : _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: miao miao"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: wang wang"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pig</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: heng heng"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">(Animal *animal)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态多态（底层是通过动态绑定来实现的）</span></span><br><span class="line">    animal-&gt;<span class="built_in">bark</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Cat cat = <span class="built_in">Cat</span>(<span class="string">"Cat"</span>);</span><br><span class="line">    Dog dog = <span class="built_in">Dog</span>(<span class="string">"Dog"</span>);</span><br><span class="line">    Pig pig = <span class="built_in">Pig</span>(<span class="string">"Pig"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bark</span>(&amp;cat);</span><br><span class="line">    <span class="built_in">bark</span>(&amp;dog);</span><br><span class="line">    <span class="built_in">bark</span>(&amp;pig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat bark: miao miao</span><br><span class="line">Dog bark: wang wang</span><br><span class="line">Pig bark: heng heng</span><br></pre></td></tr></tbody></table></figure><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><h3 id="纯虚函数和抽象类的概念"><a href="#纯虚函数和抽象类的概念" class="headerlink" title="纯虚函数和抽象类的概念"></a>纯虚函数和抽象类的概念</h3><p>基本概念：</p><ul><li>(a) 纯虚函数是一个在基类中声明的虚函数，且在基类中没有被定义，要求任何派生类都必须定义自己的版本。</li><li>(b) 纯虚函数为各派生类提供一个公共界面，可以实现接口的封装和设计、软件的模块功能划分等。</li><li>(c) 纯虚函数的声明形式： <code>virtual  类型  函数名 ( 参数表 ) = 0;</code>。</li><li>(d) <strong>一个拥有纯虚函数的基类，通常称之为 “抽象类”。</strong></li></ul><p>使用限制：</p><ul><li>(a) 可以声明抽象类的指针和引用。</li><li>(b) 抽象类不能创建对象（实例化）。</li><li>(c) 抽象类不能作为函数的参数类型和返回值类型。</li><li>(d) 如果基类中存在纯虚函数，那么派生类必须实现所有的纯虚函数，否则这个派生类也是一个抽象类。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>抽象类可以有构造函数。尽管抽象类无法被直接实例化（因为它包含至少一个纯虚函数），但它仍然可以定义构造函数，用于初始化抽象类的成员变量或执行其他构造逻辑。这样，当抽象类被继承并通过派生类构造时，抽象类的构造函数会被调用。同理，抽象类也可以有析构函数。</p></div><h3 id="纯虚函数和抽象类的案例一"><a href="#纯虚函数和抽象类的案例一" class="headerlink" title="纯虚函数和抽象类的案例一"></a>纯虚函数和抽象类的案例一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明纯虚函数，计算面积</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Circle</span>(<span class="keyword">double</span> r) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现纯虚函数，计算圆的面积</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">double</span> area = <span class="number">3.14</span> * r * r;</span><br><span class="line">        cout &lt;&lt; <span class="string">"圆的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现纯虚函数，计算三角形的面积</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">double</span> area = a * b / <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"三角形的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现纯虚函数，计算四边形的面积</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">double</span> area = a * b;</span><br><span class="line">        cout &lt;&lt; <span class="string">"四边形的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArea</span><span class="params">(Figure* base)</span> </span>{</span><br><span class="line">    base-&gt;<span class="built_in">getArea</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Figure f;    // 错误写法，抽象类不能实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Triangle <span class="title">Triangle</span><span class="params">(<span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Square <span class="title">square</span><span class="params">(<span class="number">50</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以声明抽象类的指针</span></span><br><span class="line">    Figure* pBase = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">5.3</span>);</span><br><span class="line">    pBase-&gt;<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以声明抽象类的引用</span></span><br><span class="line">    Figure&amp; base = square;</span><br><span class="line">    base.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printArea</span>(&amp;Triangle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">圆的面积: 88.2026</span><br><span class="line">四边形的面积: 3000</span><br><span class="line">三角形的面积: 300</span><br></pre></td></tr></tbody></table></figure><h3 id="纯虚函数和抽象类的案例二"><a href="#纯虚函数和抽象类的案例二" class="headerlink" title="纯虚函数和抽象类的案例二"></a>纯虚函数和抽象类的案例二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 抽象类可以有构造函数，用于初始化其成员变量</span></span><br><span class="line">    <span class="comment">// 当抽象类被继承并通过派生类构造时，抽象类的构造函数会被调用</span></span><br><span class="line">    <span class="built_in">Animal</span>(string name) : _name(name) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Animal()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象类可以有析构函数，用于释放资源</span></span><br><span class="line">    <span class="comment">// 当抽象类被继承并通过派生类析构时，抽象类的析构函数会被调用</span></span><br><span class="line">    ~<span class="built_in">Animal</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Animal()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: miao miao"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: wang wang"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pig</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: heng heng"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">(Animal &amp;animal)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态多态（底层是通过动态绑定来实现的）</span></span><br><span class="line">    animal.<span class="built_in">bark</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 错误写法，抽象类不能实例化</span></span><br><span class="line">    <span class="comment">// Animal animal("Animal");</span></span><br><span class="line"></span><br><span class="line">    Cat cat = <span class="built_in">Cat</span>(<span class="string">"Cat"</span>);</span><br><span class="line">    Dog dog = <span class="built_in">Dog</span>(<span class="string">"Dog"</span>);</span><br><span class="line">    Pig pig = <span class="built_in">Pig</span>(<span class="string">"Pig"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bark</span>(cat);</span><br><span class="line">    <span class="built_in">bark</span>(dog);</span><br><span class="line">    <span class="built_in">bark</span>(pig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Animal()</span><br><span class="line">Animal()</span><br><span class="line">Animal()</span><br><span class="line">Cat bark: miao miao</span><br><span class="line">Dog bark: wang wang</span><br><span class="line">Pig bark: heng heng</span><br><span class="line">~Animal()</span><br><span class="line">~Animal()</span><br><span class="line">~Animal()</span><br></pre></td></tr></tbody></table></figure><h2 id="虚继承与虚基类"><a href="#虚继承与虚基类" class="headerlink" title="虚继承与虚基类"></a>虚继承与虚基类</h2><h3 id="虚继承与虚基类的概念"><a href="#虚继承与虚基类的概念" class="headerlink" title="虚继承与虚基类的概念"></a>虚继承与虚基类的概念</h3><ul><li><p>基本概念</p><ul><li>虚继承的声明需要使用关键字 <code>virtual</code>。</li><li><strong>在 C++ 中，被虚继承的类通常称作为虚基类。</strong></li><li>虚继承的底层是靠虚基类指针（<code>vbptr</code>）和虚基类表（<code>vbtable</code>）来实现。</li><li>如果一个派生类从多个基类继承，而这些基类又有一个共同的基类（公共基类），则在对该基类中声明的成员进行访问时，可能会产生二义性，需要使用虚继承来解决二义性问题。</li><li>如果在多条继承路径上有一个公共的基类，那么在继承路径的某处汇合点，这个公共基类就会在派生类的对象中产生多个基类子对象。要使这个公共基类在派生类中只产生一个子对象，必须对这个基类的继承声明为虚继承，使这个基类成为 <code>虚基类</code>。</li></ul></li><li><p>适用场景</p><ul><li>虚继承只适用于有共同基类（公共基类）的多继承场景（比如菱形继承），如下图所示：</li></ul></li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-17.png"></p><ul><li>不适用场景<ul><li>对于 <code>V</code> 字形的多继承场景，虚继承是没办法解决二义性问题的，如下图所示：</li></ul></li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-21.png"></p><h3 id="虚继承与虚基类使用案例"><a href="#虚继承与虚基类使用案例" class="headerlink" title="虚继承与虚基类使用案例"></a>虚继承与虚基类使用案例</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>(<span class="keyword">int</span> x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">cout &lt;&lt; <span class="string">"Base 类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"x = "</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>(<span class="keyword">int</span> b, <span class="keyword">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 由于父类和虚基类没有默认的无参构造函数，所以这里的派生类需要在初始化列表中，显式调用父类、虚基类的有参构造函数</span></span><br><span class="line"><span class="built_in">Base3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> x) : <span class="built_in">Base1</span>(a, x), <span class="built_in">Base2</span>(b, x), <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Base3 <span class="title">base</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;  <span class="comment">// 虚基类Base的构造函数只会被调用一次</span></span><br><span class="line">base.<span class="built_in">printA</span>();</span><br><span class="line">base.<span class="built_in">printB</span>();</span><br><span class="line">base.<span class="built_in">printC</span>();</span><br><span class="line">base.<span class="built_in">printX</span>();<span class="comment">// 当不声明虚继承的时候，此写法会产生二义性，C++编译器会出现编译错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base 类的构造函数被调用</span><br><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">c = 3</span><br><span class="line">x = 4</span><br></pre></td></tr></tbody></table></figure><h3 id="虚继承的类内存布局之一"><a href="#虚继承的类内存布局之一" class="headerlink" title="虚继承的类内存布局之一"></a>虚继承的类内存布局之一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚基类（被虚继承的基类称为虚基类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"size : "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(B) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size : 16</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 中查看上述 B 派生类的内存布局，可以得到以下结果，其中 <code>vbptr</code> 是虚基类指针（Virtual Base Ptr），而 <code>vbtable</code> 是虚基类表（Virtual Base Table）。</p><p><img data-src="../../../asset/2025/01/cplusplus-virtual-class.png"></p><h3 id="虚继承的类内存布局之二"><a href="#虚继承的类内存布局之二" class="headerlink" title="虚继承的类内存布局之二"></a>虚继承的类内存布局之二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚基类（被虚继承的类称为虚基类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call A::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call B::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"size : "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(B) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A *a = new B();</span></span><br><span class="line">    <span class="comment">// a-&gt;show();       // 正常调用，发生动态绑定</span></span><br><span class="line">    <span class="comment">// delete a;        // 调用失败，异常终止执行，这是因为基类指针指向的是派生类中基类那部分数据的起始地址，导致无法正常释放堆上分配的内存空间</span></span><br><span class="line">    </span><br><span class="line">    B b;</span><br><span class="line">    A &amp;a = b;</span><br><span class="line">    b.<span class="built_in">show</span>();           <span class="comment">// 正常调用，发生动态绑定，且栈上分配的内存空间出了作用域之后可以正常被自动释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size : 32</span><br><span class="line">call B::show()</span><br></pre></td></tr></tbody></table></figure><p>在 Visual Studio 中查看上述 B 派生类的内存布局，可以得到以下结果；其中 <code>vbptr</code> 是虚基类指针（Virtual Base Ptr），而 <code>vbtable</code> 是虚基类表（Virtual Base Table）；<code>vfptr</code> 是虚函数指针（Virtual Function Ptr），<code>vftable</code> 是虚函数表（Virtual Function Table）。</p><p><img data-src="../../../asset/2025/01/cplusplus-virtual-class-2.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><p>基类指针（引用）指向派生类对象时，永远指向的是派生类中基类那部分数据的起始地址。</p></div><h2 id="菱形继承的问题"><a href="#菱形继承的问题" class="headerlink" title="菱形继承的问题"></a>菱形继承的问题</h2><h3 id="菱形继承的概念"><a href="#菱形继承的概念" class="headerlink" title="菱形继承的概念"></a>菱形继承的概念</h3><p>在 C++ 的多继承中，有一种特殊的继承结构，那就是菱形继承，如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-extends-17.png"></p><p>在 C++ 中，菱形继承会产生以下问题：</p><ul><li><strong>内存冗余问题</strong>：基类的内容被重复存储，占用额外内存。 </li><li><strong>成员重复问题</strong>：基类的成员在子类中会出现多份，导致访问不明确（存在二义性）。  </li><li><strong>构造与析构问题</strong>：基类的构造函数或析构函数可能被调用多次，导致不一致或意外行为。  </li><li><strong>多态冲突问题</strong>：虚函数可能产生不明确的调用，导致多态行为失效。  </li></ul><h3 id="菱形继承问题的产生"><a href="#菱形继承问题的产生" class="headerlink" title="菱形继承问题的产生"></a>菱形继承问题的产生</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> data) : <span class="built_in">ma</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">mc</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"C()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">C</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~C()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="keyword">int</span> data) : <span class="built_in">B</span>(data), <span class="built_in">C</span>(data), <span class="built_in">md</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"D()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">D</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~D()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> md;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="comment">// d.ma;        // 错误写法，存在二义性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">A()</span><br><span class="line">C()</span><br><span class="line">D()</span><br><span class="line">~D()</span><br><span class="line">~C()</span><br><span class="line">~A()</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><p>从上述的执行结果可以发现基类 A 被构造了两次，这执行效率是比较低的；而且派生类 D 无法正常访问基类 A 中的成员变量 <code>ma</code>，因为存在二义性。</p><h3 id="菱形继承问题的解决"><a href="#菱形继承问题的解决" class="headerlink" title="菱形继承问题的解决"></a>菱形继承问题的解决</h3><p>在 C++ 的多继承中，可以使用虚继承来解决菱形继承产生的问题。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> data) : <span class="built_in">ma</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">mb</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">mc</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"C()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">C</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~C()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mc;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="keyword">int</span> data) : <span class="built_in">A</span>(data), <span class="built_in">B</span>(data), <span class="built_in">C</span>(data), <span class="built_in">md</span>(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"D()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">D</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~D()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> md;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; d.ma &lt;&lt; endl;        <span class="comment">// 正确写法，不存在二义性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">C()</span><br><span class="line">D()</span><br><span class="line">20</span><br><span class="line">~D()</span><br><span class="line">~C()</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></tbody></table></figure><p>从上述的执行结果可以发现基类 A 只构造了一次，而且派生类 D 可以正常访问基类 A 中的成员变量 <code>ma</code>，因为不存在二义性。</p><h2 id="C-的四种类型转换"><a href="#C-的四种类型转换" class="headerlink" title="C++ 的四种类型转换"></a>C++ 的四种类型转换</h2><p>在 C++ 中，有以下 4 种类型转换：</p><ul><li><code>static_cast</code>：静态类型转换，如 <code>int</code> 转换成 <code>char</code></li><li><code>dynamic_cast</code>：动态类型转换，主要用在类的继承结构中，可以支持 RTTI 类型识别的上下类型转换，如父类和子类之间的多态类型转换</li><li><code>const_cast</code>：常量类型转换，用于赋予或者去除类型的 <code>const</code> 只读属性</li><li><code>reinterpreter_cast</code>：重新解释类型（强制类型转换）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device1</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device1::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device2</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device2::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device2::print()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Base *base)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断 base 指针指向的是不是 Device2 对象</span></span><br><span class="line">    <span class="comment">// 如果是，则 dynamic_cast 转换成功，并返回 Device2 对象的地址，否则返回 nullptr</span></span><br><span class="line">    Device2 *pDevice2 = <span class="keyword">dynamic_cast</span>&lt;Device2 *&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (pDevice2 == <span class="literal">nullptr</span>) {</span><br><span class="line">        base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        pDevice2-&gt;<span class="built_in">print</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const_cast：去掉常量属性的类型转换</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> * &gt; (&amp;a);</span><br><span class="line">    cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static_cast：提供编译器认为安全的类型转换</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">65</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(b);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reinterpret_cast：类似于 C 语言风格的类型转换</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt; (d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dynamic_cast：主要用在类的继承结构中，可以支持 RTTI 类型识别的上下类型转换</span></span><br><span class="line">    Device1 device1;</span><br><span class="line">    Device2 device2;</span><br><span class="line">    <span class="built_in">show</span>(&amp;device1);</span><br><span class="line">    <span class="built_in">show</span>(&amp;device2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">A</span><br><span class="line">call Device1::show()</span><br><span class="line">call Device2::print()</span><br></pre></td></tr></tbody></table></figure><h2 id="虚函数高频面试题"><a href="#虚函数高频面试题" class="headerlink" title="虚函数高频面试题"></a>虚函数高频面试题</h2><h3 id="虚函数高频面试题之一"><a href="#虚函数高频面试题之一" class="headerlink" title="虚函数高频面试题之一"></a>虚函数高频面试题之一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(string name) : _name(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: miao miao"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string name) : <span class="built_in">Animal</span>(name) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">" bark: wang wang"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Animal *p1 = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">"Cat"</span>);</span><br><span class="line">    Animal *p2 = <span class="keyword">new</span> <span class="built_in">Dog</span>(<span class="string">"Dog"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p11 = (<span class="keyword">int</span> *) p1;  <span class="comment">// p11[0] 指向的是 Cat 的前 4 个字节（存放的是 vfptr）</span></span><br><span class="line">    <span class="keyword">int</span> *p22 = (<span class="keyword">int</span> *) p2;  <span class="comment">// p22[0] 指向的是 Dog 的前 4 个字节（存放的是 vfptr）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = p11[<span class="number">0</span>];   <span class="comment">// 交换两个对象的虚函数指针（vfptr）的地址</span></span><br><span class="line">    p11[<span class="number">0</span>] = p22[<span class="number">0</span>];</span><br><span class="line">    p22[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    p1-&gt;<span class="built_in">bark</span>();     <span class="comment">// p1 -&gt; Cat vfptr -&gt; Dog vftable，输出：Cat bark: wang wang</span></span><br><span class="line">    p2-&gt;<span class="built_in">bark</span>();     <span class="comment">// p2 -&gt; Dog vfptr -&gt; Cat vftable，输出：Dog bark: miao miao</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat bark: wang wang</span><br><span class="line">Dog bark: miao miao</span><br></pre></td></tr></tbody></table></figure><h3 id="虚函数高频面试题之二"><a href="#虚函数高频面试题之二" class="headerlink" title="虚函数高频面试题之二"></a>虚函数高频面试题之二</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i = <span class="number">10</span>)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Base::show i : "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i = <span class="number">20</span>)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device::show i : "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Device</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用，参数压栈是在编译时期决定的，因此这里参数压栈时使用的是基类中虚函数的默认参数值</span></span><br><span class="line">    <span class="comment">// 动态绑定，p -&gt; Device vfptr -&gt; Device vftable -&gt; Device::show()，输出： call Device::show i : 10</span></span><br><span class="line">    b-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call Device::show i : 10</span><br></pre></td></tr></tbody></table></figure><h3 id="虚函数高频面试题之三"><a href="#虚函数高频面试题之三" class="headerlink" title="虚函数高频面试题之三"></a>虚函数高频面试题之三</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Device</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以正常调用，发生动态（运行时期）绑定，输出：call Device::show()</span></span><br><span class="line">    <span class="comment">// 成员函数能不能被调用，就是说函数的访问权限是不是 public，这是在编译阶段就需要确定好的，而动态绑定是发生在运行时期</span></span><br><span class="line">    b-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call Device::show()</span><br></pre></td></tr></tbody></table></figure><h3 id="虚函数高频面试题之四"><a href="#虚函数高频面试题之四" class="headerlink" title="虚函数高频面试题之四"></a>虚函数高频面试题之四</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Base()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Base::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 将当前对象的内存区域全部置为 0</span></span><br><span class="line">        <span class="comment">// 相当于当前对象内存中的 vfptr 虚函数指针被修改了，不再指向 vftable 虚函数表</span></span><br><span class="line">        <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Device</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Device::show()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base *bptr1 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    bptr1-&gt;<span class="built_in">show</span>();  <span class="comment">// 动态绑定，异常终止执行</span></span><br><span class="line">    <span class="keyword">delete</span> bptr1;</span><br><span class="line"></span><br><span class="line">    Base *bptr2 = <span class="keyword">new</span> <span class="built_in">Device</span>();</span><br><span class="line">    bptr2-&gt;<span class="built_in">show</span>();  <span class="comment">// 动态绑定，正常执行结束</span></span><br><span class="line">    <span class="keyword">delete</span> bptr2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之三</title>
    <link href="https://www.techgrow.cn/posts/3d7447d.html"/>
    <id>https://www.techgrow.cn/posts/3d7447d.html</id>
    <published>2024-12-05T13:55:33.000Z</published>
    <updated>2024-12-05T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><span id="more"></span><h3 id="二元运算符的重载"><a href="#二元运算符的重载" class="headerlink" title="二元运算符的重载"></a>二元运算符的重载</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CComplex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CComplex</span>(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> i = <span class="number">0</span>) : <span class="built_in">mreal</span>(r), <span class="built_in">mimage</span>(i) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在局部作用域加法运算符的重载函数</span></span><br><span class="line">    <span class="comment">// 这里不能返回引用，因为在栈上分配内存空间的对象，随着函数的运行结束，内存空间会自动释放</span></span><br><span class="line">    CComplex <span class="keyword">operator</span>+(<span class="keyword">const</span> CComplex &amp;other) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CComplex</span>(<span class="keyword">this</span>-&gt;mreal + other.mreal, <span class="keyword">this</span>-&gt;mimage + other.mimage);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用友元函数实现加法运算符的重载</span></span><br><span class="line">    <span class="keyword">friend</span> CComplex <span class="keyword">operator</span>+(<span class="keyword">const</span> CComplex &amp;left, <span class="keyword">const</span> CComplex &amp;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用友元函数实现左移运算符的重载</span></span><br><span class="line">    <span class="comment">// 左移运算符的重载只能使用友元函数来实现</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> CComplex &amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"mreal: "</span> &lt;&lt; mreal &lt;&lt; <span class="string">", mimage: "</span> &lt;&lt; mimage &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mreal;</span><br><span class="line">    <span class="keyword">int</span> mimage;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在全局作用域实现加法运算符的重载</span></span><br><span class="line">CComplex <span class="keyword">operator</span>+(<span class="keyword">const</span> CComplex &amp;left, <span class="keyword">const</span> CComplex &amp;right) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CComplex</span>(left.mreal + right.mreal, left.mimage + right.mimage);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在全局作用域实现左移运算符的重载</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> CComplex &amp;c) {</span><br><span class="line">    out &lt;&lt; <span class="string">"mreal: "</span> &lt;&lt; c.mreal &lt;&lt; <span class="string">", mimage: "</span> &lt;&lt; c.mimage &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CComplex <span class="title">c1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">CComplex <span class="title">c2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    CComplex c3 = c1 + c2;       <span class="comment">// 相当于 CComplex c3 = c1.operator+(c2);</span></span><br><span class="line">    c3.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    CComplex c4 = c1 + <span class="number">20</span>;      <span class="comment">// 默认可以正常编译运行，会自动调用 CComplex(int r = 0, int i = 0) 构造函数，然后再执行加法运算</span></span><br><span class="line">    c4.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器做对象运算的时候，会调用对象的运算符重载函数（优先调用成员方法）；如果没有成员方法，就会在全局作用域找合适的运算符重载函数。</span></span><br><span class="line">    CComplex c5 = <span class="number">30</span> + c1;      <span class="comment">// 默认不可以正常编译运行，除非是在全局作用域实现加法运算符的重载</span></span><br><span class="line">    c5.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c1 &lt;&lt; endl;     <span class="comment">// 左移运算符的重载</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mreal: 30, mimage: 30</span><br><span class="line">mreal: 30, mimage: 10</span><br><span class="line">mreal: 40, mimage: 10</span><br><span class="line">mreal: 10, mimage: 10</span><br></pre></td></tr></tbody></table></figure><h3 id="一元运算符的重载"><a href="#一元运算符的重载" class="headerlink" title="一元运算符的重载"></a>一元运算符的重载</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CComplex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CComplex</span>(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> i = <span class="number">0</span>) : <span class="built_in">mreal</span>(r), <span class="built_in">mimage</span>(i) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "前置++" 运算符的重载</span></span><br><span class="line">    CComplex &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">        <span class="keyword">this</span>-&gt;mreal++;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mimage++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "后置++" 运算符的重载</span></span><br><span class="line">    <span class="comment">// 使用占位参数进行函数重载，是为了解决与 "前置++" 类成员函数冲突的问题</span></span><br><span class="line">    CComplex <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CComplex</span>(<span class="keyword">this</span>-&gt;mreal++, <span class="keyword">this</span>-&gt;mimage++);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"mreal: "</span> &lt;&lt; mreal &lt;&lt; <span class="string">", mimage: "</span> &lt;&lt; mimage &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mreal;</span><br><span class="line">    <span class="keyword">int</span> mimage;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CComplex <span class="title">c1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置++</span></span><br><span class="line">    <span class="function">CComplex <span class="title">c2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    c2 = ++c1;</span><br><span class="line">    c1.<span class="built_in">print</span>();     <span class="comment">// 11 11</span></span><br><span class="line">    c2.<span class="built_in">print</span>();     <span class="comment">// 11 11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置++</span></span><br><span class="line">    <span class="function">CComplex <span class="title">c3</span><span class="params">(<span class="number">30</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    c3 = c1++;</span><br><span class="line">    c1.<span class="built_in">print</span>();     <span class="comment">// 12 12</span></span><br><span class="line">    c3.<span class="built_in">print</span>();     <span class="comment">// 11 11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mreal: 11, mimage: 11</span><br><span class="line">mreal: 11, mimage: 11</span><br><span class="line">mreal: 12, mimage: 12</span><br><span class="line">mreal: 11, mimage: 11</span><br></pre></td></tr></tbody></table></figure><h3 id="模拟实现字符串类"><a href="#模拟实现字符串类" class="headerlink" title="模拟实现字符串类"></a>模拟实现字符串类</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里模拟实现的字符串类，存在多次拷贝内存数据的问题，可以使用 C++ 提供的右值引用参数来解决，详细介绍请看 <a href="/posts/e302ad63.html#C-11-%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) &gt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) &lt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双等号运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载（读写）</span></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">return</span> _pstr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载（只读）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> _pstr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> length = <span class="built_in">strlen</span>(_pstr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 '\0' 结尾的字符串</span></span><br><span class="line">        <span class="keyword">if</span> (_pstr[length] == <span class="string">'\0'</span>) {</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不以 '\0' 结尾的字符串</span></span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 调用构造函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"abcde"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用构造函数</span></span><br><span class="line">    MyString str2 = <span class="string">"fghij"</span>;</span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    MyString str3 = str2;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    str3 = str1;</span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    MyString str4 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> result1 = str1 &gt; str2;</span><br><span class="line">    cout &lt;&lt; (result1 ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> result2 = str1 &lt; str2;</span><br><span class="line">    cout &lt;&lt; (result2 ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双等号运算符重载</span></span><br><span class="line">    str1 = str2;</span><br><span class="line">    <span class="keyword">bool</span> result3 = str1 == str2;</span><br><span class="line">    cout &lt;&lt; (result3 ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载</span></span><br><span class="line">    <span class="function">MyString <span class="title">str5</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">    str5[<span class="number">4</span>] = <span class="string">'k'</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"str5[3] = "</span> &lt;&lt; str5[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function">MyString <span class="title">str6</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"str6.length = "</span> &lt;&lt; str6.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tmpstr = str6.<span class="built_in">c_str</span>();</span><br><span class="line">    cout &lt;&lt; tmpstr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br><span class="line">fghij</span><br><span class="line">fghij</span><br><span class="line">abcde</span><br><span class="line">abcdefghij</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">str5[3] = k</span><br><span class="line">str6.length = 5</span><br><span class="line">world</span><br></pre></td></tr></tbody></table></figure><h2 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h2><div class="admonition note"><p class="admonition-title">迭代器的介绍</p><ul><li>迭代器的功能是：提供一种统一的方式来透明地遍历容器。</li><li>泛型算法参数接收的都是选代器。</li><li>在泛型算法中，通常都有一个可以统一地遍历所有容器的元素的迭代器。</li></ul></div><h3 id="模拟实现字符串类的迭代器"><a href="#模拟实现字符串类的迭代器" class="headerlink" title="模拟实现字符串类的迭代器"></a>模拟实现字符串类的迭代器</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里模拟实现的字符串类，存在多次拷贝内存数据的问题，可以使用 C++ 提供的右值引用参数来解决，详细介绍请看 <a href="/posts/e302ad63.html#C-11-%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_pstr, p);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_pstr = <span class="string">'\0'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line">        _pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str._pstr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, str._pstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) &gt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) &lt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双等号运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString &amp;str) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(_pstr, str._pstr) == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载（读写）</span></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">return</span> _pstr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中括号运算符重载（只读）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> _pstr[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字符串自身</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> length = <span class="built_in">strlen</span>(_pstr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 '\0' 结尾的字符串</span></span><br><span class="line">        <span class="keyword">if</span> (_pstr[length] == <span class="string">'\0'</span>) {</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不以 '\0' 结尾的字符串</span></span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">iterator</span>(<span class="keyword">char</span> *p = <span class="literal">nullptr</span>) : _p(p) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="keyword">return</span> _p != other._p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            _p++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_p++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        <span class="keyword">char</span> &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="keyword">return</span> *_p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> *_p;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_pstr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_pstr + <span class="built_in">length</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_pstr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str1, <span class="keyword">const</span> MyString &amp;str2) {</span><br><span class="line">    MyString tmpStr;</span><br><span class="line">    tmpStr._pstr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1._pstr) + <span class="built_in">strlen</span>(str2._pstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr._pstr, str1._pstr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr._pstr, str2._pstr);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyString &amp;str) {</span><br><span class="line">    out &lt;&lt; str._pstr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    MyString str1 = <span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span> (MyString::iterator it = str1.<span class="built_in">begin</span>(); it != str1.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    MyString str2 = <span class="string">"Golang"</span>;</span><br><span class="line">    <span class="comment">// 使用 For 循环遍历字符串，会自动调用字符串类的 begin() 和 end() 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: str2) {</span><br><span class="line">        cout &lt;&lt; ch &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H e l l o   W o r l d </span><br><span class="line">G o l a n g </span><br></pre></td></tr></tbody></table></figure><h3 id="模拟实现-vector-容器的迭代器"><a href="#模拟实现-vector-容器的迭代器" class="headerlink" title="模拟实现 vector 容器的迭代器"></a>模拟实现 vector 容器的迭代器</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里模拟实现的 vector 容器，在插入数据时存在多次拷贝内存数据的问题，可以使用 C++ 提供的 <code>move</code> 移动语义或者 <code>forward</code> 类型完美转发来解决，详细介绍请看 <a href="/posts/e302ad63.html#C-11-%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">这里</a>。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">iterator</span>(T *p = <span class="literal">nullptr</span>) : _ptr(p) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(_last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person(const Person &amp;p)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用中括号取值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"full: "</span> &lt;&lt; (v.<span class="built_in">full</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (v.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!v.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器插入元素</span></span><br><span class="line">    Vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器变遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (Vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 For 循环遍历容器，会自动调用容器类的 begin() 和 end() 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item : v) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">99 75 54 4 58 27 46 64 65 99 85 32 85 0 27 36 56 10 59 8 </span><br><span class="line">size: 20</span><br><span class="line">full: true</span><br><span class="line">empty:  false</span><br><span class="line">8 59 10 56 36 27 0 85 32 85 99 65 64 46 27 58 4 54 75 99 </span><br><span class="line">============ test02() ============</span><br><span class="line">75 51 32 20 28 23 4 55 76 61 78 75 88 84 31 46 11 30 62 29 </span><br><span class="line">75 51 32 20 28 23 4 55 76 61 78 75 88 84 31 46 11 30 62 29 </span><br><span class="line">75 51 32 20 28 23 4 55 76 61 78 75 88 84 31 46 11 30 62 29 </span><br></pre></td></tr></tbody></table></figure><h3 id="模拟重现-vector-迭代器的失效"><a href="#模拟重现-vector-迭代器的失效" class="headerlink" title="模拟重现 vector 迭代器的失效"></a>模拟重现 vector 迭代器的失效</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>这里模拟实现的 vector 容器，在插入数据时存在多次拷贝内存数据的问题，可以使用 C++ 提供的 <code>move</code> 移动语义或者 <code>forward</code> 类型完美转发来解决，详细介绍请看 <a href="/posts/e302ad63.html#C-11-%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">这里</a>。</p></div><h4 id="迭代器失效问题的发生"><a href="#迭代器失效问题的发生" class="headerlink" title="迭代器失效问题的发生"></a>迭代器失效问题的发生</h4><ul><li>第一种迭代器失效的情况（容器删除元素），以下代码会异常终止运行 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的所有偶数删除掉</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 迭代器失效的问题：第一次调用 erase() 函数以后，迭代器 it 就已经失效了</span></span><br><span class="line">            <span class="comment">// 当容器调用 erase() 函数后，当前删除位置到容器尾元素的所有的选代器将全部失效，但是首元素到当前删除位置的所有的迭代器依旧是生效的</span></span><br><span class="line">            v.<span class="built_in">erase</span>(it);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第二种迭代器失效的情况（容器插入元素），以下代码会异常终止运行 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器中所有的偶数前面添加一个小于该偶数的数字</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 迭代器失效的问题：第一次调用 insert() 函数以后，迭代器 it 就已经失效了</span></span><br><span class="line">            <span class="comment">// 当容器调用 insert() 函数后，当前插入位置到容器尾元素的所有的选代器将全部失效，但是首元素到当前插入位置的所有的迭代器依旧是生效的</span></span><br><span class="line">            <span class="comment">// 一旦 insert() 函数的插入操作引起扩容，那么原来容器从首元素到尾元素的所有的选代器将全部失效</span></span><br><span class="line">            v.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第三种迭代器失效的情况（容器触发扩容），当容器扩容后，原容器从首元素到尾元素的所有的选代器将全部失效。</li></ul><h4 id="迭代器失效问题的解决"><a href="#迭代器失效问题的解决" class="headerlink" title="迭代器失效问题的解决"></a>迭代器失效问题的解决</h4><h5 id="解决方案介绍"><a href="#解决方案介绍" class="headerlink" title="解决方案介绍"></a>解决方案介绍</h5><div class="admonition note"><p class="admonition-title">温馨提示</p><p>解决迭代器失效的问题，最关键是对插入点 / 删除点的迭代器执行更新操作。</p></div><ul><li>第一种迭代器失效的情况（容器删除元素），以下代码可以正常运行 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的所有偶数删除掉</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            it = v.<span class="built_in">erase</span>(it);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第二种迭代器失效的情况（容器插入元素），以下代码可以正常运行 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器中所有的偶数前面添加一个小于该偶数的数字</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            it = v.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h5><p>为了解决迭代器失效的问题，可以在容器内部维护一个专门用于存放迭代器的单向链表数据结构，当往容器插入 / 删除元素时，对迭代器的单向链表进行维护。值得一提的是，以下代码是在 <a href="/posts/3d7447d.html#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-vector-%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">上面的案例代码</a> 的基础上改造而来，实现了 vector 容器的插入（暂时不考虑容器扩容）和删除操作。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class Vector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">Vector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    Vector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last - <span class="number">1</span>);</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Vector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载中括号运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"OutOfRangeException"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(Vector&lt;T, Alloc&gt; *pvec = <span class="literal">nullptr</span>, T *p = <span class="literal">nullptr</span>) : _pVec(pvec), _ptr(p) {</span><br><span class="line">            <span class="comment">// 维护迭代器的单向链表结构</span></span><br><span class="line">            Iterator_Base *itb = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = itb;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载不等于运算符</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;other) <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 判断迭代器指向的容器是不是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != other._pVec) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator incompatable!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> _ptr != other._ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载前置 ++ 运算符</span></span><br><span class="line">        iterator &amp;<span class="keyword">operator</span>++() {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置 ++ 运算符</span></span><br><span class="line">        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(_ptr++);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解引用运算符重载</span></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">            <span class="comment">// 检测迭代器的有效性</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">"Iterator invalid!"</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">        Vector&lt;T, Alloc&gt; *_pVec; <span class="comment">// 当前迭代器是哪个容器的对象</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器底层首元素的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是容器末尾元素后继位置的迭代器的表示</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器插入元素</span></span><br><span class="line">    <span class="comment">// 这里暂时不考虑容器扩容，也不考虑 it._prt 的指针合法性</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往右边移动数组元素</span></span><br><span class="line">        T *p = _last;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);</span><br><span class="line"></span><br><span class="line">        _last++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器往容器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span> </span>{</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配数组的内存空间，并往左边移动数组元素</span></span><br><span class="line">        T *p = it._ptr;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line"></span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, it._ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的单向链表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span> {</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator *cur = <span class="literal">nullptr</span>, Iterator_Base *next = <span class="literal">nullptr</span>) : _cur(cur), _next(next) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterator *_cur;</span><br><span class="line">        Iterator_Base *_next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Iterator_Base _head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护迭代器的单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T *start, T *end)</span> </span>{</span><br><span class="line">        Iterator_Base *cur = &amp;<span class="keyword">this</span>-&gt;_head;</span><br><span class="line">        Iterator_Base *next = <span class="keyword">this</span>-&gt;_head._next;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (next-&gt;_cur-&gt;_ptr &gt;= start &amp;&amp; next-&gt;_cur-&gt;_ptr &lt;= end) {</span><br><span class="line">                <span class="comment">// 迭代器失效，将迭代器持有的容器指针置为空</span></span><br><span class="line">                next-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// 在迭代器链表中，删除当前迭代器节点，并继续判断后面的迭代器节点是否失效</span></span><br><span class="line">                cur-&gt;_next = next-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">                next = cur-&gt;_next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                next = next-&gt;_next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person(const Person &amp;p)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器插入元素</span></span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的所有偶数删除掉</span></span><br><span class="line">    <span class="keyword">for</span> (Vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            it = v.<span class="built_in">erase</span>(it);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 For 循环遍历容器，会自动调用容器类的 begin() 和 end() 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item : v) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器插入元素</span></span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器中所有的偶数前面添加一个小于该偶数的数字</span></span><br><span class="line">    <span class="keyword">for</span> (Vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            it = v.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 For 循环遍历容器，会自动调用容器类的 begin() 和 end() 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item : v) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">93 95 0 33 65 6 15 50 94 2 21 16 36 0 7 3 43 59 25 60 </span><br><span class="line">93 95 33 65 15 21 7 3 43 59 25 </span><br><span class="line">============ test02() ============</span><br><span class="line">67 86 10 44 87 27 47 53 79 60 66 24 7 67 58 24 25 73 27 19 </span><br><span class="line">67 85 86 9 10 43 44 87 27 47 53 79 59 60 65 66 23 24 7 67 57 58 23 24 25 73 27 19 </span><br></pre></td></tr></tbody></table></figure><h2 id="new-与-delete"><a href="#new-与-delete" class="headerlink" title="new 与 delete"></a>new 与 delete</h2><h3 id="malloc-与-new-的区别"><a href="#malloc-与-new-的区别" class="headerlink" title="malloc 与 new 的区别"></a>malloc 与 new 的区别</h3><p><code>malloc</code> 和 <code>new</code> 都用于在 C++ 中动态分配内存空间，但它们之间有本质的区别。</p><ul><li><strong>语法和用途</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>语法</td><td><code>void* ptr = malloc(size);</code></td><td><code>Type* ptr = new Type;</code></td></tr><tr><td>功能</td><td>仅按字节分配内存空间，不会调用构造函数。</td><td>按类型分配内存并调用对象的构造函数。</td></tr><tr><td>返回值</td><td>返回 <code>void*</code>，需要显式转换为目标类型指针。</td><td>返回指定类型的指针，无需显式转换。</td></tr></tbody></table><ul><li><strong>初始化</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>默认值</td><td>分配的内存未初始化，包含垃圾值。</td><td>基本类型未初始化，但类对象会调用构造函数进行初始化。</td></tr><tr><td>支持类型</td><td>通常适用于基本数据类型和简单内存块分配。</td><td>适用于类和复杂类型，支持构造函数调用。</td></tr></tbody></table><ul><li><strong>释放内存</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>释放方法</td><td>使用 <code>free(ptr);</code> 释放内存。</td><td>使用 <code>delete ptr;</code> 释放内存，并调用析构函数（如果有）。</td></tr><tr><td>析构函数调用</td><td>不会调用对象的析构函数。</td><td>自动调用对象的析构函数，进行清理操作。</td></tr></tbody></table><ul><li><strong>性能和类型安全</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>类型安全</td><td>无类型安全，需手动进行类型转换。</td><td>类型安全，无需手动类型转换。</td></tr><tr><td>性能</td><td>较低级，效率略高（无构造函数调用的情况下）。</td><td>高级，功能更强，但可能稍慢（有构造函数调用时）。</td></tr></tbody></table><ul><li><strong>支持数组分配</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>数组分配</td><td>手动计算所需字节数并分配：<code>int* arr = (int*) malloc(n * sizeof(int));</code></td><td>使用 <code>new[]</code>：<code>int* arr = new int[n];</code></td></tr><tr><td>释放数组</td><td>释放数组时，需用 <code>free(arr);</code></td><td>必须使用 <code>delete[] arr;</code>，否则可能导致内存泄漏或未调用析构函数。</td></tr></tbody></table><ul><li><strong>异常处理</strong></li></ul><table><thead><tr><th>区别点</th><th><code>malloc</code></th><th><code>new</code></th></tr></thead><tbody><tr><td>失败行为</td><td>分配失败返回 <code>NULL</code>，需要手动检查返回值。</td><td>分配失败抛出 <code>std::bad_alloc</code> 异常（除非使用 <code>new (std::nothrow)</code>）。</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">适用场景</p><ul><li>使用 <code>malloc</code>：适合兼容 C 代码、分配简单内存块、不需要调用构造函数或析构函数的场景。</li><li>使用 <code>new</code>：适合 C++ 风格编程，需要调用构造和析构功能的场景，推荐在现代 C++ 中优先使用。</li></ul></div><div class="admonition note"><p class="admonition-title">温馨提示</p><ul><li>在现代 C++ 中，推荐使用智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>） 或 <code>std::vector</code> 等容器，减少手动管理内存的风险。</li></ul></div><h3 id="free-和-delete-的区别"><a href="#free-和-delete-的区别" class="headerlink" title="free 和 delete 的区别"></a>free 和 delete 的区别</h3><p><code>free</code> 和 <code>delete</code> 都用于释放动态分配的内存空间，但它们之间有本质的区别。</p><ul><li><strong>语法和用途</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>语法</td><td><code>free(ptr);</code></td><td><code>delete ptr;</code> 或 <code>delete[] ptr;</code></td></tr><tr><td>适用对象</td><td>与 <code>malloc</code> 和 <code>calloc</code> 搭配使用的内存。</td><td>与 <code>new</code> 或 <code>new[]</code> 分配的内存。</td></tr><tr><td>用途</td><td>释放动态分配的内存，不关心类型和构造函数。</td><td>释放动态分配的内存，同时调用析构函数（如果有）。</td></tr></tbody></table><ul><li><strong>析构函数调用</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>析构函数调用</td><td>不会调用析构函数，只释放内存。</td><td>自动调用对象的析构函数，完成清理操作后释放内存。</td></tr></tbody></table><ul><li><strong>数组支持</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>数组释放</td><td>没有专门的数组释放机制，需明确释放首地址。</td><td>对于数组，需要使用 <code>delete[]</code> 来正确释放并调用析构函数。</td></tr></tbody></table><ul><li><strong>异常处理</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>内存管理</td><td>手动管理，不与异常处理直接相关。</td><td>更安全，若内存释放过程中发生异常，析构函数可以处理。</td></tr></tbody></table><ul><li><strong>性能差异</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>性能开销</td><td>较低，不会进行类型检查或调用析构函数。</td><td>较高，涉及类型检查和析构函数调用。</td></tr></tbody></table><ul><li><strong>用法不当的后果</strong></li></ul><table><thead><tr><th>区别点</th><th><code>free</code></th><th><code>delete</code></th></tr></thead><tbody><tr><td>用法不当</td><td>释放 <code>new</code> 分配的内存可能会导致未定义行为。</td><td>释放 <code>malloc</code> 分配的内存可能会导致未定义行为。</td></tr><tr><td>未使用正确的形式</td><td>不会自动检测类型或数组。</td><td>使用 <code>delete</code> 而非 <code>delete[]</code> 释放数组，可能会导致部分内存泄漏或析构函数未调用。</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>对数组使用 <code>new[]</code> 分配内存时，必须用 <code>delete[]</code> 释放内存。</li><li><code>free</code> 和 <code>delete</code> 不能混用。<code>malloc</code> 分配的内存必须用 <code>free</code> 释放内存；<code>new</code> 分配的内存必须用 <code>delete</code> 释放内存。</li></ul></div><div class="admonition note"><p class="admonition-title">温馨提示</p><ul><li>在现代 C++ 中，推荐使用智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>） 或 <code>std::vector</code> 等容器，减少手动管理内存的风险。</li></ul></div><h3 id="重载-new-和-delete-运算符"><a href="#重载-new-和-delete-运算符" class="headerlink" title="重载 new 和 delete 运算符"></a>重载 new 和 delete 运算符</h3><p>当 C++ 内置的 <code>new</code> 和 <code>delete</code> 运算符不能满足业务需求时（比如需要实现自定义的内存池，或者需要检测内存泄漏），可以通过运算符重载来改变 <code>new</code> 和 <code>delete</code> 运算符的默认行为。示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 new 运算符，先调用 operator new 开辟内存空间，然后再调用对象的构造函数（初始化）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"operator new address: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 delete 运算符，先调用 ptr 指向对象的析构函数，然后再调用 operator delete 释放内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator delete address: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 new[] 运算符，先调用 operator new[] 开辟内存空间，然后再调用对象的构造函数（初始化）</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size) {</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"operator new[] address: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 delete[] 运算符，先调用 ptr 指向对象的析构函数，然后再调用 operator delete[] 释放内存空间</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr) {</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">"operator delete[] address: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : _data(data) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Test()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用重载后的 new 和 delete 运算符</span></span><br><span class="line">        <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    } <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc &amp;exception) {</span><br><span class="line">        cerr &lt;&lt; exception.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用重载后的 new[] 和 delete[] 运算符</span></span><br><span class="line">        <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    } <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc &amp;exception) {</span><br><span class="line">        cerr &lt;&lt; exception.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test03() ============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用重载后的 new 和 delete 运算符</span></span><br><span class="line">        Test *t = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">    } <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc &amp;exception) {</span><br><span class="line">        cerr &lt;&lt; exception.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test04() ============"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用重载后的 new[] 和 delete[] 运算符</span></span><br><span class="line">        Test *t = <span class="keyword">new</span> Test[<span class="number">2</span>]();</span><br><span class="line">        <span class="keyword">delete</span>[] t;</span><br><span class="line">    } <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc &amp;exception) {</span><br><span class="line">        cerr &lt;&lt; exception.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">operator new address: 0x232fc20</span><br><span class="line">operator delete address: 0x232fc20</span><br><span class="line">============ test02() ============</span><br><span class="line">operator new[] address: 0x232fc40</span><br><span class="line">operator delete[] address: 0x232fc40</span><br><span class="line">============ test03() ============</span><br><span class="line">operator new address: 0x232fc20</span><br><span class="line">Test()</span><br><span class="line">~Test()</span><br><span class="line">operator delete address: 0x232fc20</span><br><span class="line">============ test04() ============</span><br><span class="line">operator new[] address: 0x232fc20</span><br><span class="line">Test()</span><br><span class="line">Test()</span><br><span class="line">~Test()</span><br><span class="line">~Test()</span><br><span class="line">operator delete[] address: 0x232fc20</span><br></pre></td></tr></tbody></table></figure><h3 id="通过运算符重载实现对象池"><a href="#通过运算符重载实现对象池" class="headerlink" title="通过运算符重载实现对象池"></a>通过运算符重载实现对象池</h3><p>这里将通过重载 <code>new</code> 和 <code>delete</code> 运算符来实现对象池，这样就可以避免为特定对象（如下面的 QueueItem）频繁开辟和释放内存空间，从而提高程序的运行效率。</p><div class="admonition note"><p class="admonition-title">C++ 的各种池对象</p><p>C++ 中常见的的池对象包括：内存池、对象池、进程池、线程池、连接池。</p></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Queue()"</span> &lt;&lt; endl;</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">        _front = _rear = <span class="keyword">new</span> <span class="built_in">QueueItem</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Queue</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Queue()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span> (_front != <span class="literal">nullptr</span>) {</span><br><span class="line">            QueueItem *next = _front-&gt;_next;</span><br><span class="line">            <span class="keyword">delete</span> _front;</span><br><span class="line">            _front = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作（插入尾节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;value)</span> </span>{</span><br><span class="line">        QueueItem *item = <span class="keyword">new</span> <span class="built_in">QueueItem</span>(value);</span><br><span class="line">        _rear-&gt;_next = item;</span><br><span class="line">        _rear = item;</span><br><span class="line">        _size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作（移除头节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Queue is empty, cannot pop"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        QueueItem *first = _front-&gt;_next;</span><br><span class="line">        _front-&gt;_next = first-&gt;_next;</span><br><span class="line">        <span class="keyword">if</span> (_front-&gt;_next == <span class="literal">nullptr</span>) {</span><br><span class="line">            _rear = _front;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">delete</span> first;</span><br><span class="line">        _size--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头节点</span></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"Queue is empty"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _front-&gt;_next-&gt;_data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _front == _rear;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 队列元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueItem</span> {</span></span><br><span class="line">        <span class="built_in">QueueItem</span>(T data = <span class="built_in">T</span>()) : _data(data), _next(<span class="literal">nullptr</span>) {</span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义 QueueItem 对象的内存开辟</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (_itemPool == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="comment">// 初始化对象池</span></span><br><span class="line">                _itemPool = (QueueItem *) <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in"><span class="keyword">sizeof</span></span>(QueueItem) * ITEM_POOL_SIZE];</span><br><span class="line">                QueueItem *p = _itemPool;</span><br><span class="line">                <span class="keyword">for</span> (; p &lt; _itemPool + ITEM_POOL_SIZE - <span class="number">1</span>; ++p) {</span><br><span class="line">                    p-&gt;_next = p + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 处理最后一个节点</span></span><br><span class="line">                p-&gt;_next = <span class="literal">nullptr</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            QueueItem *ptr = _itemPool;</span><br><span class="line">            _itemPool = _itemPool-&gt;_next;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义 QueueItem 对象的内存释放</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>{</span><br><span class="line">            <span class="comment">// 归还给对象池</span></span><br><span class="line">            QueueItem *p = (QueueItem *) ptr;</span><br><span class="line">            p-&gt;_next = _itemPool;</span><br><span class="line">            _itemPool = p;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        T _data;                                    <span class="comment">// 当前节点的数据</span></span><br><span class="line">        QueueItem *_next;                           <span class="comment">// 下一个节点</span></span><br><span class="line">        <span class="keyword">static</span> QueueItem *_itemPool;                <span class="comment">// 指向对象池中未使用的第一节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> ITEM_POOL_SIZE = <span class="number">10000</span>;    <span class="comment">// 对象池的大小</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    QueueItem *_front;  <span class="comment">// 头结点，是一个虚拟节点，用于简化队列操作（如插入和删除）</span></span><br><span class="line">    QueueItem *_rear;   <span class="comment">// 尾节点，是一个真实节点，始终指向队列的最后一个有效节点，或者在队列为空时指向虚拟头节点</span></span><br><span class="line">    <span class="keyword">int</span> _size;          <span class="comment">// 队列的大小</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Queue&lt;T&gt;::QueueItem *Queue&lt;T&gt;::QueueItem::_itemPool = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test01() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> value = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        queue.<span class="built_in">push</span>(value);</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"size = "</span> &lt;&lt; queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; queue.<span class="built_in">front</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"size = "</span> &lt;&lt; queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============ test02() ============"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这里不使用对象池，那么就会频繁开辟和释放对象的内存空间，导致性能消耗比较严重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> value = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        queue.<span class="built_in">push</span>(value);</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (queue.<span class="built_in">empty</span>() ? <span class="string">"empty"</span> : <span class="string">"not empty"</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">============ test01() ============</span><br><span class="line">Queue()</span><br><span class="line">60 32 73 100 26 31 94 6 47 60 </span><br><span class="line">size = 10</span><br><span class="line">60 32 73 100 26 31 94 6 47 60 </span><br><span class="line">size = 0</span><br><span class="line">~Queue()</span><br><span class="line">============ test02() ============</span><br><span class="line">Queue()</span><br><span class="line">empty</span><br><span class="line">~Queue()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之二</title>
    <link href="https://www.techgrow.cn/posts/418bd270.html"/>
    <id>https://www.techgrow.cn/posts/418bd270.html</id>
    <published>2024-11-29T13:55:33.000Z</published>
    <updated>2024-11-29T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><h2 id="类、对象、指针"><a href="#类、对象、指针" class="headerlink" title="类、对象、指针"></a>类、对象、指针</h2><span id="more"></span><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NAME_LENGTH = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGoods</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CGoods</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">double</span> price, <span class="keyword">int</span> amount) {</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;_name, name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;_price = price;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_amount = amount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAmount</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_amount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>{</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;_name, name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;_price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAmount</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;_amount = amount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;_name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"price: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;_price &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"amount: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;_amount &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> _name[NAME_LENGTH]; <span class="comment">// 静态分配内存</span></span><br><span class="line">    <span class="keyword">double</span> _price;</span><br><span class="line">    <span class="keyword">int</span> _amount;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CGoods <span class="title">good</span><span class="params">(<span class="string">"Book"</span>, <span class="number">80</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    good.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name: Book</span><br><span class="line">price: 80</span><br><span class="line">amount: 3</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>类的成员函数一经编译，在所有函数的参数列表中，都会隐式自动添加一个 <code>this</code> 指针，用于接收调用该函数的对象的地址。这样在函数被调用时，C++ 才知道是谁调用了该函数。</p></div><h3 id="指向类成员的指针"><a href="#指向类成员的指针" class="headerlink" title="指向类成员的指针"></a>指向类成员的指针</h3><h4 id="指向类成员变量的指针"><a href="#指向类成员变量的指针" class="headerlink" title="指向类成员变量的指针"></a>指向类成员变量的指针</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类成员静态变量</span></span><br><span class="line"><span class="keyword">int</span> Test::mb = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    Test t1;    <span class="comment">// 栈上分配内存</span></span><br><span class="line">    Test *t2 = <span class="keyword">new</span> <span class="built_in">Test</span>();  <span class="comment">// 堆上分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误写法</span></span><br><span class="line">    <span class="comment">// int * p = &amp;Test::ma;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向类成员变量的指针</span></span><br><span class="line">    <span class="keyword">int</span> Test::*p = &amp;Test::ma;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问类成员变量</span></span><br><span class="line">    t1.*p = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; t1.ma &lt;&lt; <span class="string">", "</span> &lt;&lt; t1.*p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问类成员变量</span></span><br><span class="line">    t2-&gt;*p = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; t2-&gt;ma &lt;&lt; <span class="string">", "</span> &lt;&lt; t2-&gt;*p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> t2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 正确写法, 指向类成员静态变量的指针</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;Test::mb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问类成员静态变量</span></span><br><span class="line">    *p1 = <span class="number">60</span>;</span><br><span class="line">    cout &lt;&lt; Test::mb &lt;&lt; <span class="string">", "</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20, 20</span><br><span class="line">30, 30</span><br><span class="line">60, 60</span><br></pre></td></tr></tbody></table></figure><h4 id="指向类成员函数的指针"><a href="#指向类成员函数的指针" class="headerlink" title="指向类成员函数的指针"></a>指向类成员函数的指针</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Test::func"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_func</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Test::static_func"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    Test t1;    <span class="comment">// 栈上分配内存</span></span><br><span class="line">    Test *t2 = <span class="keyword">new</span> <span class="built_in">Test</span>();  <span class="comment">// 堆上分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误写法</span></span><br><span class="line">    <span class="comment">// void (*pFunc)() = &amp;Test::func;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向类成员函数的指针（函数指针）</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (Test::*pFunc)() = &amp;Test::func;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用类成员函数</span></span><br><span class="line">    (t1.*pFunc)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用类成员函数</span></span><br><span class="line">    (t2-&gt;*pFunc)();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 正确写法, 指向类成员静态函数的指针（函数指针）</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pStaticFunc)() = &amp;Test::static_func;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用类成员静态函数</span></span><br><span class="line">    (*pStaticFunc)();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call Test::func</span><br><span class="line">call Test::func</span><br><span class="line">call Test::static_func</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul><li>构造函数<ul><li>定义对象时，构造函数会自动调用。</li><li>构造函数是可以重载的，可以有多个构造函数。</li><li>对象构造完成后，对象就产生了。</li></ul></li><li>析构函数<ul><li>析构函数不带参数，不能重载，有且只有一个析构函数。</li><li>对象析构完成后，对象就不存在了。</li></ul></li><li>二者的共同点<ul><li>当开发者没有自定义构造函数和析构函数时，编译器会自动生成一个默认构造函数（无参构造函数）和默认析构函数。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>在栈上分配内存空间的 C++ 对象（比如 <code>SeqStack s;</code>），当该对象出了作用域之后（比如函数执行结束之后），C++ 会自动调用该对象的析构函数来释放内存空间。</li><li>在堆上分配内存空间的 C++ 对象（比如 <code>SeqStack *s = new SeqStack();</code>），那么必须在该对象出了作用域之前（比如函数执行结束之前），手动执行 <code>delete</code> 操作来释放内存空间，这样该对象的析构函数才会被调用。</li></ul></div><blockquote><p>下面将实现一个顺序栈的数据结构，并结合构造函数与析构函数一起使用。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call SeqStack()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        _top = <span class="number">-1</span>;</span><br><span class="line">        _size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~SeqStack()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _pstatck;</span><br><span class="line">            _pstatck = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        _pstatck[++_top] = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        --_top;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstatck[_top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == _size - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *_pstatck; <span class="comment">// 动态开辟数组，存储顺序栈的元素</span></span><br><span class="line">    <span class="keyword">int</span> _top;   <span class="comment">// 指向栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> _size;  <span class="comment">// 数组的总大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 分配新的内存空间</span></span><br><span class="line">        <span class="keyword">int</span> *pnew = <span class="keyword">new</span> <span class="keyword">int</span>[_size * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) {</span><br><span class="line">            pnew[i] = _pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放旧的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstatck;</span><br><span class="line">        <span class="comment">// 指向新的内存空间</span></span><br><span class="line">        _pstatck = pnew;</span><br><span class="line">        _size *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"===== call test01() ====="</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">SeqStack <span class="title">s</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">        s.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"===== call test02() ====="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    SeqStack *s = <span class="keyword">new</span> <span class="built_in">SeqStack</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">        s-&gt;<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s-&gt;<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; s-&gt;<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        s-&gt;<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">===== call test01() =====</span><br><span class="line">call SeqStack()</span><br><span class="line">20 40 33 74 97 39 83 65 85 16 48 55 89 22 48 </span><br><span class="line">call ~SeqStack()</span><br><span class="line">===== call test02() =====</span><br><span class="line">call SeqStack()</span><br><span class="line">15 92 64 83 46 74 70 93 54 69 9 46 88 94 39 </span><br><span class="line">call ~SeqStack()</span><br></pre></td></tr></tbody></table></figure><h3 id="对象的深拷贝和浅拷贝"><a href="#对象的深拷贝和浅拷贝" class="headerlink" title="对象的深拷贝和浅拷贝"></a>对象的深拷贝和浅拷贝</h3><h4 id="使用案例一"><a href="#使用案例一" class="headerlink" title="使用案例一"></a>使用案例一</h4><p>下面将实现一个顺序栈的数据结构，并结合拷贝构造函数、深拷贝与赋值运算符重载一起使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call SeqStack()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        _top = <span class="number">-1</span>;</span><br><span class="line">        _size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~SeqStack()"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _pstatck;</span><br><span class="line">            _pstatck = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">const</span> SeqStack &amp;stack) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call SeqStack(const SeqStack &amp;stack)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 深拷贝（重新分配内存）</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> <span class="keyword">int</span>[stack._size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack._size; i++) {</span><br><span class="line">            _pstatck[i] = stack._pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        _top = stack._top;</span><br><span class="line">        _size = stack._size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运算符重载</span></span><br><span class="line">    SeqStack &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SeqStack &amp;stack) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call operator=(const SeqStack &amp;stack)"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;stack) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来占用的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[]_pstatck;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝（重新分配内存）</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> <span class="keyword">int</span>[stack._size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack._size; i++) {</span><br><span class="line">            _pstatck[i] = stack._pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        _top = stack._top;</span><br><span class="line">        _size = stack._size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        _pstatck[++_top] = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        --_top;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pstatck[_top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == _size - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) {</span><br><span class="line">            cout &lt;&lt; _pstatck[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取元素数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *_pstatck; <span class="comment">// 动态开辟数组，存储顺序栈的元素</span></span><br><span class="line">    <span class="keyword">int</span> _top;   <span class="comment">// 指向栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> _size;  <span class="comment">// 数组的总大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 分配新的内存空间</span></span><br><span class="line">        <span class="keyword">int</span> *pnew = <span class="keyword">new</span> <span class="keyword">int</span>[_size * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) {</span><br><span class="line">            pnew[i] = _pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放旧的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _pstatck;</span><br><span class="line">        <span class="comment">// 指向新的内存空间</span></span><br><span class="line">        _pstatck = pnew;</span><br><span class="line">        _size *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">SeqStack <span class="title">s1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        s1.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    SeqStack s2 = s1;   <span class="comment">// 默认会调用拷贝构造函数</span></span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">SeqStack <span class="title">s3</span><span class="params">(s1)</span></span>;   <span class="comment">// 默认会调用拷贝构造函数</span></span><br><span class="line">    s3.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    s2 = s3;  <span class="comment">// 赋值运算，不会调用拷贝构造函数，默认是浅拷贝，会发生内存泄漏（内存没有被正确释放），解决办法是通过运算符重载来实现深拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call SeqStack()</span><br><span class="line">88 95 94 93 13 7 9 86 43 10 </span><br><span class="line">call SeqStack(const SeqStack &amp;stack)</span><br><span class="line">88 95 94 93 13 7 9 86 43 10 </span><br><span class="line">call SeqStack(const SeqStack &amp;stack)</span><br><span class="line">88 95 94 93 13 7 9 86 43 10 </span><br><span class="line">call operator=(const SeqStack &amp;stack)</span><br><span class="line">call ~SeqStack()</span><br><span class="line">call ~SeqStack()</span><br><span class="line">call ~SeqStack()</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例二"><a href="#使用案例二" class="headerlink" title="使用案例二"></a>使用案例二</h4><p>下面将实现一个循环队列的数据结构，并结合拷贝构造函数、深拷贝与赋值运算符重载一起使用。</p><ul><li><p>循环队列的关键特性：</p><ul><li><strong>队列特性：</strong> 循环队列仍然遵循 “先进先出”（FIFO）的原则。</li><li><strong>循环特性：</strong> 当队尾指针到达数组末尾时，如果队列未满，则可以循环到数组开头继续插入新元素。</li><li><strong>队空与队满条件：</strong> 为了区分队列是空还是满，循环队列通常会牺牲一个数组元素的存储空间：</li><li>队列为空的条件：<code>front == rear</code></li><li>队列为满的条件：<code>(rear + 1) % capacity == front</code></li></ul></li><li><p>循环队列的应用场景：</p><ul><li><strong>缓冲区</strong>：在生产者 / 消费者模型中用作环形缓冲区。</li><li><strong>流量控制</strong>：如网络数据包的接收缓冲区。</li><li><strong>任务调度</strong>：在任务管理系统中，存储循环调度任务。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>(<span class="keyword">int</span> size = <span class="number">20</span>) {</span><br><span class="line">        _pQueue = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        _front = <span class="number">0</span>;</span><br><span class="line">        _rear = <span class="number">0</span>;</span><br><span class="line">        _size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数，不让用户调用</span></span><br><span class="line">    <span class="comment">// MyQueue(const MyQueue &amp;other) = delete;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyQueue</span>(<span class="keyword">const</span> MyQueue &amp;other) {</span><br><span class="line">        _front = other._front;</span><br><span class="line">        _rear = other._rear;</span><br><span class="line">        _size = other._size;</span><br><span class="line">        _pQueue = <span class="keyword">new</span> <span class="keyword">int</span>[_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = _front; i != _rear; i = (i + <span class="number">1</span>) % _size) {</span><br><span class="line">            _pQueue[i] = other._pQueue[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除赋值运算符，不让用户调用</span></span><br><span class="line">    <span class="comment">// MyQueue &amp;operator=(const MyQueue &amp;other) = delete;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyQueue &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyQueue &amp;other) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_pQueue != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[]_pQueue;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        _front = other._front;</span><br><span class="line">        _rear = other._rear;</span><br><span class="line">        _size = other._size;</span><br><span class="line">        _pQueue = <span class="keyword">new</span> <span class="keyword">int</span>[_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = _front; i != _rear; i = (i + <span class="number">1</span>) % _size) {</span><br><span class="line">            _pQueue[i] = other._pQueue[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyQueue</span>() {</span><br><span class="line">        <span class="keyword">if</span> (_pQueue != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _pQueue;</span><br><span class="line">            _pQueue = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        _pQueue[_rear] = value;</span><br><span class="line">        <span class="comment">// 循环队列</span></span><br><span class="line">        _rear = (_rear + <span class="number">1</span>) % _size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 循环队列</span></span><br><span class="line">        _front = (_front + <span class="number">1</span>) % _size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _pQueue[_front];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (_rear + <span class="number">1</span>) % _size == _front;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _front == _rear;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *_pQueue;   <span class="comment">// 队列的内存空间</span></span><br><span class="line">    <span class="keyword">int</span> _front;     <span class="comment">// 队头的位置</span></span><br><span class="line">    <span class="keyword">int</span> _rear;      <span class="comment">// 队尾的位置</span></span><br><span class="line">    <span class="keyword">int</span> _size;      <span class="comment">// 队列的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> *pTemp = <span class="keyword">new</span> <span class="keyword">int</span>[_size * <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = _front; i != _rear; i = (i + <span class="number">1</span>) % _size) {</span><br><span class="line">            pTemp[index++] = _pQueue[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">delete</span>[] _pQueue;</span><br><span class="line">        _pQueue = pTemp;</span><br><span class="line">        _size *= <span class="number">2</span>;</span><br><span class="line">        _front = <span class="number">0</span>;</span><br><span class="line">        _rear = index;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    MyQueue q1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="function">MyQueue <span class="title">q2</span><span class="params">(q1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyQueue q3;</span><br><span class="line">    q3 = q1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q3.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; q3.<span class="built_in">front</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        q3.<span class="built_in">poll</span>();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44 71 16 21 11 75 28 29 40 81 86 28 35 43 99 37 45 66 81 53</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDate</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自定义一个构造函数，编译器不会再自动生成一个默认构造函数（无参构造函数）</span></span><br><span class="line">    <span class="built_in">CDate</span>(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) {</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"year: "</span> &lt;&lt; _year &lt;&lt; <span class="string">", month: "</span> &lt;&lt; _month &lt;&lt; <span class="string">", day: "</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGoods</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用构造函数的初始化列表，可以指定当前对象的成员变量的初始化方式</span></span><br><span class="line">    <span class="built_in">CGoods</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> amount, <span class="keyword">double</span> price, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) : _amount(amount), _price(price), _date(year, month, day) {</span><br><span class="line">        <span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; _name &lt;&lt; <span class="string">", amount: "</span> &lt;&lt; _amount &lt;&lt; <span class="string">", price: "</span> &lt;&lt; _price &lt;&lt; endl;</span><br><span class="line">        _date.<span class="built_in">show</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">char</span> _name[<span class="number">20</span>];  <span class="comment">// 静态分配内存</span></span><br><span class="line">    <span class="keyword">int</span> _amount;</span><br><span class="line">    <span class="keyword">double</span> _price;</span><br><span class="line">    CDate _date;    <span class="comment">// 成员对象</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CGoods <span class="title">goods</span><span class="params">(<span class="string">"Book"</span>, <span class="number">100</span>, <span class="number">59.9</span>, <span class="number">1949</span>, <span class="number">12</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line">    goods.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: Book, amount: 100, price: 59.9</span><br><span class="line">year: 1949, month: 12, day: 22</span><br></pre></td></tr></tbody></table></figure><blockquote><p>高频面试题</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> data = <span class="number">10</span>) : <span class="built_in">mb</span>(data), <span class="built_in">ma</span>(mb) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"ma: "</span> &lt;&lt; ma &lt;&lt; <span class="string">", mb: "</span> &lt;&lt; mb &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line">    <span class="keyword">int</span> mb;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Test test;</span><br><span class="line">    test.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ma: -858993460, mb: 10</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>类成员变量的初始化顺序和它们定义的顺序有关，和构造函数初始化列表中定义的先后顺序无关，更多关于构造函数初始化列表的使用教程请看 <a href="/posts/beb2ebb3.html#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">这里</a>。</p></div><h2 id="类模板与函数模板"><a href="#类模板与函数模板" class="headerlink" title="类模板与函数模板"></a>类模板与函数模板</h2><h3 id="函数模板使用"><a href="#函数模板使用" class="headerlink" title="函数模板使用"></a>函数模板使用</h3><p>在 C++ 中，与函数模板相关的专业术语（知识点）有以下几个：</p><ul><li>函数模板</li><li>模板的实例化</li><li>模板函数</li><li>模板的类型参数</li><li>模板的非类型参数</li><li>模板的实参推演</li><li>模板的特例化（专用化）</li><li>非模板函数的重载关系</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>模板代码是不能在一个 <code>.cpp</code> 源文件中定义，然后在另一个 <code>.cpp</code> 源文件中使用的。</li><li>模板代码在调用之前，一定要看到模板定义的地方，这样模板才能够进行正常的实例化，产生能够被编译器编译的代码。所以，模板代码一般都是写在 <code>.h</code> 头文件中的，然后在 <code>.cpp</code> 源文件中使用 <code>#include</code> 指令将头文件包含进来。</li><li>另一种解决办法是，在调用模板函数之前，通过 <code>template bool compare&lt;int&gt;(int, int)</code> 告诉编译器，提前进行指定类型的模板实例化。</li></ul></div><h4 id="使用案例一-1"><a href="#使用案例一-1" class="headerlink" title="使用案例一"></a>使用案例一</h4><blockquote><p>函数模板的使用</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个模板参数列表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 定义一个函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"call compare(T a, T b)"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对 compare 函数模板，提供 const char* 类型的特例化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> compare&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"call compare(const char *a, const char *b)"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数（非模板函数）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"call normal compare()"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在函数调用点，编译器会使用用户指定的类型，从原函数模板实例化一份函数代码出来（称为模板函数），如下所示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">bool compare&lt;int&gt; (int a, int b) {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">bool compare&lt;double&gt; (double a, double b) {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 函数的调用点</span></span><br><span class="line">    compare&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">    compare&lt;<span class="keyword">double</span>&gt;(<span class="number">1.3</span>, <span class="number">4.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数模板的实参推演</span></span><br><span class="line">    <span class="built_in">compare</span>(<span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器优先将 compare 处理成普通函数，如果函数不存在，才会去找 compare 模板函数</span></span><br><span class="line">    <span class="built_in">compare</span>(<span class="string">"abc"</span>, <span class="string">"efg"</span>);</span><br><span class="line">    compare&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(<span class="string">"abc"</span>, <span class="string">"efg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call compare(T a, T b)</span><br><span class="line">call compare(T a, T b)</span><br><span class="line">call compare(T a, T b)</span><br><span class="line">call normal compare()</span><br><span class="line">call compare(const char *a, const char *b)</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例二-1"><a href="#使用案例二-1" class="headerlink" title="使用案例二"></a>使用案例二</h4><blockquote><p>模板的非类型参数使用</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="comment">// 使用模板的非类型参数（必须是整数类型，整数或者地址/引用都可以），非类型参数都是常量，只能使用，不能修改</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> SIZE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T *array)</span> </span>{</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SIZE - <span class="number">1</span> - i; j++) {</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> array[] = {<span class="number">12</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">63</span>};</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(array) / <span class="built_in"><span class="keyword">sizeof</span></span>(array[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    sort&lt;<span class="keyword">int</span>, size&gt;(array);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item: array) {</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 9 12 15 23 63 </span><br></pre></td></tr></tbody></table></figure><h3 id="类模板的使用"><a href="#类模板的使用" class="headerlink" title="类模板的使用"></a>类模板的使用</h3><h4 id="使用案例一-2"><a href="#使用案例一-2" class="headerlink" title="使用案例一"></a>使用案例一</h4><blockquote><p>类模板的使用</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建议构造和析构函数的名称不加 &lt;T&gt;，而且其他使用模板的地方都加上类型参数类列表，比如 &lt;T&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">int</span> size = <span class="number">10</span>) : _pstatck(<span class="keyword">new</span> T[size]), _top(<span class="number">-1</span>), _size(size) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>() {</span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[]_pstatck;</span><br><span class="line">            _pstatck = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">const</span> SeqStack&lt;T&gt; &amp;stack) : _top(stack._top), _size(stack._size) {</span><br><span class="line">        <span class="comment">// 实现深拷贝</span></span><br><span class="line">        _pstatck = <span class="keyword">new</span> T[_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _top; i++) {</span><br><span class="line">            _pstatck[i] = stack._pstatck[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    SeqStack&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SeqStack&lt;T&gt; &amp;stack) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == stack) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (_pstatck != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[]_pstatck;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现深拷贝</span></span><br><span class="line">        _top = stack._top;</span><br><span class="line">        _size = stack._size;</span><br><span class="line">        _pstatck = <span class="keyword">new</span> T[_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _top; i++) {</span><br><span class="line">            _pstatck[i] = stack._pstatck[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        _pstatck[++_top] = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            --_top;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"stack is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> _pstatck[_top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == _size - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _top == <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    T *_pstatck; <span class="comment">// 动态开辟数组，存储顺序栈的元素</span></span><br><span class="line">    <span class="keyword">int</span> _top;    <span class="comment">// 指向栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> _size;   <span class="comment">// 数组的总大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        T *ptmp = <span class="keyword">new</span> T[_size * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _top; i++) {</span><br><span class="line">            ptmp[i] = _pstatck[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">delete</span>[]_pstatck;</span><br><span class="line">        _pstatck = ptmp;</span><br><span class="line">        _size *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类模板的选择性实例化</span></span><br><span class="line">    <span class="comment">// 实例化后的模板类 class SeqStack&lt;int&gt; { };</span></span><br><span class="line">    SeqStack&lt;<span class="keyword">int</span>&gt; stack;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        stack.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 68 25 5 53 1 20 71 3 7 0 99 2 74 78 99 92 30 24 40</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例二-2"><a href="#使用案例二-2" class="headerlink" title="使用案例二"></a>使用案例二</h4><blockquote><p>类模板的默认类型参数使用</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类模板（使用默认类型参数）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">int</span>&gt;</span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line">class SeqStack {</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>() {</span><br><span class="line">    <span class="comment">// 使用默认类型参数</span></span><br><span class="line">    SeqStack&lt;&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用案例三"><a href="#使用案例三" class="headerlink" title="使用案例三"></a>使用案例三</h4><blockquote><p>使用类模板实现向量容器（Vector）</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyVector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        _first = <span class="keyword">new</span> T[size];</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyVector</span>() {</span><br><span class="line">        <span class="keyword">if</span> (_first != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _first;</span><br><span class="line">            _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _first = <span class="keyword">new</span> T[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _first[i] = v._first[i];</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyVector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (_first != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] _first;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        _first = <span class="keyword">new</span> T[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _first[i] = v._first[i];</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        *_last++ = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            --_last;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"MyVector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        T *_ptemp = <span class="keyword">new</span> T[size * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _ptemp[i] = _first[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] _first;</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    MyVector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"full: "</span> &lt;&lt; (v.<span class="built_in">full</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (v.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!v.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">49 32 50 26 17 87 26 65 49 83 36 57 97 61 25 44 84 23 41 35 </span><br><span class="line">size: 20</span><br><span class="line">full: true</span><br><span class="line">empty:  false</span><br><span class="line">35 41 23 84 44 25 61 97 57 36 83 49 65 26 87 17 26 50 32 49 </span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>上述代码实现的 vector 容器，如果存放的是 Peson 类的对象，那么在容器初始化的时候，默认会调用 10 次 Peson 类的构造函数，因为在容器的构造函数中使用了 <code>new</code> 操作，比如 <code>_first = new T[size]</code>。</li><li>上述代码实现的 vector 容器，如果存放的是 Peson 类的对象，当调用 <code>pop_back()</code> 函数来删除容器尾部的元素时，Person 对象所占用的内存空间并没有被释放，这存在内存泄漏问题。</li><li>解决内存泄漏的方法可以参考 C++ STL 中的 vector 容器的实现，也就是使用空间配置器（allocator）来解决，空间配置器负责做四件事情，包括：内存开辟、内存释放、对象构造、对象析构。</li></ul></div><blockquote><p>使用空间分配器优化后的代码（重点知识）</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 空间配置器（负责内存开辟、内存释放、对象构造、对象析构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocator</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存开辟</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的内存释放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p, <span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="comment">// 在指定的内存上构造对象（定位 new）</span></span><br><span class="line">        <span class="keyword">new</span> (p)<span class="built_in">T</span>(val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象析构</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>{</span><br><span class="line">        <span class="comment">// ~T() 代表了 T 类型对象的析构函数</span></span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = MyAllocator&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// 向量容器</span></span><br><span class="line">class MyVector {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyVector</span>(<span class="keyword">int</span> size = <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（先析构容器内的有效元素，然后再释放 _first 指针指向的堆内存）</span></span><br><span class="line">    ~<span class="built_in">MyVector</span>() {</span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    MyVector&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&lt;T&gt; &amp;v) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == v) {</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放堆上的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容器的总大小</span></span><br><span class="line">        <span class="keyword">int</span> size = v._end - v._first;</span><br><span class="line">        <span class="comment">// 有效元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = v._last - v._first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, v._first[i]);</span><br><span class="line">        }</span><br><span class="line">        _last = _first + length;</span><br><span class="line">        _end = _first + size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往容器尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>()) {</span><br><span class="line">            <span class="built_in">resize</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">        _last++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器尾部删除元素（需要将对象的析构和内存释放分开处理）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) {</span><br><span class="line">            _last--;</span><br><span class="line">            <span class="comment">// 在指定的内存空间中析构对象</span></span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器尾部的元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"MyVector is empty!"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有效元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_first;  <span class="comment">// 指向数组起始的位置</span></span><br><span class="line">    T *_last;   <span class="comment">// 指向数组中有效元素的后继位置</span></span><br><span class="line">    T *_end;    <span class="comment">// 指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 定义容器空间配置器的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">// 开辟数组的内存空间</span></span><br><span class="line">        T *_ptemp = _allocator.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 在指定的内存空间中构造对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_ptemp + i, _first[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构原来容器内的有效元素</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; p++) {</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的数组内存</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = _ptemp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + size * <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person &amp;p) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call Person(const Person &amp;p)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"call ~Person()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"============= test01() ============="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    MyVector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"full: "</span> &lt;&lt; (v.<span class="built_in">full</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"empty: "</span> &lt;&lt; (v.<span class="built_in">empty</span>() ? <span class="string">"true"</span> : <span class="string">" false"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!v.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n\n============= test02() ============="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person p1, p2, p3;</span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    MyVector&lt;Person&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">============= test01() =============</span><br><span class="line">44 60 71 5 8 44 58 52 73 97 20 21 0 10 28 44 94 81 54 82 </span><br><span class="line">size: 20</span><br><span class="line">full: true</span><br><span class="line">empty:  false</span><br><span class="line">82 54 81 94 44 28 10 0 21 20 97 73 52 58 44 8 5 71 60 44 </span><br><span class="line"></span><br><span class="line">============= test02() =============</span><br><span class="line">call Person()</span><br><span class="line">call Person()</span><br><span class="line">call Person()</span><br><span class="line">------------------------------------------</span><br><span class="line">call Person(const Person &amp;p)</span><br><span class="line">call Person(const Person &amp;p)</span><br><span class="line">call Person(const Person &amp;p)</span><br><span class="line">------------------------------------------</span><br><span class="line">call ~Person()</span><br><span class="line">------------------------------------------</span><br><span class="line">call ~Person()</span><br><span class="line">call ~Person()</span><br><span class="line">call ~Person()</span><br><span class="line">call ~Person()</span><br><span class="line">call ~Person()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 生产环境部署 Kafka-Eagle（EFAK）集群</title>
    <link href="https://www.techgrow.cn/posts/70bdcb69.html"/>
    <id>https://www.techgrow.cn/posts/70bdcb69.html</id>
    <published>2024-11-18T13:30:00.000Z</published>
    <updated>2024-12-07T13:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/d2fe844e.html">Linux 部署 Kafka Eagle（EFAK）单机</a></li><li><a href="/posts/73b15688.html">Docker 部署 Kafka Eagle（EFAK）单机</a></li><li><a href="/posts/70bdcb69.html">Linux 生产环境部署 Kafka Eagle（EFAK）集群</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍在三台服务器上，手动部署 Kafka-Eagle（EFAK）的集群服务，实现对 Kafka 集群的管理和监控，适用于 CentOS/Debian/Ubuntu 等发行版。</p><h2 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h2><ul><li><a href="https://github.com/smartloli/EFAK">Kafka Eagle（EFAK）官方项目</a></li><li><a href="https://docs.kafka-eagle.org/">Kafka Eagle（EFAK）官方文档</a></li><li><a href="https://github.com/smartloli/kafka-eagle-bin/tags">Kafka Eagle（EFAK）官方下载</a></li></ul><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="部署依赖服务"><a href="#部署依赖服务" class="headerlink" title="部署依赖服务"></a>部署依赖服务</h3><ul><li>在部署 Kafka Eagle（EFAK）集群之前，请确保已经部署好 ZooKeeper 集群、Kafka 集群、MySQL。</li></ul><table><thead><tr><th>服务</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> ZooKeeper</td><td><code>3.8.4</code></td><td>集群（三节点）</td></tr><tr><td>Kafka</td><td><code>3.9.0</code></td><td>集群（三节点）</td></tr><tr><td>MySQL</td><td><code>8.4.2</code></td><td>单机</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><ul><li>从 Kafka <code>2.8.0</code> 版本开始，Kafka 自身实现了 <code>Raft</code> 分布式一致性机制，这意味着 Kafka 集群是可以脱离 ZooKeeper 独立运行的。但是，本文使用的 Kafka 集群是依赖于 ZooKeeper 的，因此需要提前将 ZooKeeper 集群部署好。</li><li>Kafka Eagle（EFAK）集群需要一个数据库来统一存储其配置数据，如用户数据、Kafka 集群的监控指标数据等。当不使用 MySQL 来存储 Kafka 的监控指标数据时，Kafka Eagle（EFAK）默认使用的是 SQLite，而 SQLite 是存储在 EFAK 安装位置的嵌入式数据库。</li></ul></div><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><ul><li>创建数据库，用于 Kafka Eagle（EFAK）存储 Kafka 的监控指标数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE efak DEFAULT CHARACTER SET utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建数据库用户并授权访问，用于 Kafka Eagle（EFAK）连接 MySQL</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户</span><br><span class="line">CREATE USER <span class="string">'efak'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line">-- 用户授权</span><br><span class="line">GRANT ALL PRIVILEGES ON efak.* TO <span class="string">'efak'</span>@<span class="string">'%'</span>;</span><br><span class="line"></span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>在初始化 MySQL 数据库时，只需要创建数据库，而不需要手动创建数据库表。这是因为 Kafka Eagle（EFAK）会在启动的时候自动创建所需的 <a href="../../../asset/2024/12/linux-efak-cluster-db-tables.png">数据库表</a>，前提是 Kafka Eagle（EFAK）用于连接 MySQL 的用户有对应的数据库操作权限。</p></div><h2 id="Kafka-Eagle-集群部署"><a href="#Kafka-Eagle-集群部署" class="headerlink" title="Kafka Eagle 集群部署"></a>Kafka Eagle 集群部署</h2><p>本节将部署 Kafka Eagle（EFAK）集群服务，以实现对 Kafka 集群的管理和监控。值得一提的是，Kafka Eagle（EFAK）的运行依赖于 JDK 1.8+，请提前在各个服务器上安装并配置好 Java 运行环境，包括添加 <code>JAVA_HOME</code> 系统环境变量。</p><h3 id="规划集群"><a href="#规划集群" class="headerlink" title="规划集群"></a>规划集群</h3><table><thead><tr><th>节点</th><th> IP</th><th>Web UI 端口</th><th>集群通信端口</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> Kafka Eagle（EFAK）节点一</td><td><code>192.168.2.127</code></td><td><code>8048</code></td><td><code>8085</code></td><td><code>3.0.1</code></td><td>Master 节点</td></tr><tr><td> Kafka Eagle（EFAK）节点二</td><td><code>192.168.2.150</code></td><td><code>8048</code></td><td><code>8085</code></td><td><code>3.0.1</code></td><td>Slave 节点</td></tr><tr><td> Kafka Eagle（EFAK）节点三</td><td><code>192.168.2.203</code></td><td><code>8048</code></td><td><code>8085</code></td><td><code>3.0.1</code></td><td>Slave 节点</td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>(1) 由于服务器资源有限，本文部署的 Kafka Eagle（EFAK）集群只包含 1 个 Master 节点和 2 个 Slave 节点。</li><li>(2) 在生产环境部署 Kafka Eagle（EFAK）集群时，强烈建议至少申请四台服务器，然后至少部署 1 个 Master 节点和 3 个 Slave 节点（即一主三从），以此保证高可用性。</li></ul></div><h3 id="安装集群"><a href="#安装集群" class="headerlink" title="安装集群"></a>安装集群</h3><p>首先在三台服务器上，根据以下步骤分别安装好 Kafka Eagle（EFAK），安装完成后就形成了三个 Kafka Eagle 集群节点。</p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>为了操作方便，当安装和配置好一个集群节点后，可以使用 <code>scp</code> 命令将安装目录和系统配置文件直接拷贝到其他集群节点上，比如：</li><li>(1) 拷贝安装文件：<code>scp -r /opt/efak root@192.168.2.150:/opt</code></li><li>(2) 拷贝系统文件：<code>scp -r /etc/profile root@192.168.2.150:/etc</code></li></ul></div><h4 id="下载安装文件"><a href="#下载安装文件" class="headerlink" title="下载安装文件"></a>下载安装文件</h4><ul><li>浏览器访问 Kafka Eagle（EFAK）的 <a href="https://github.com/smartloli/kafka-eagle-bin/tags">GitHub 项目</a>，然后选择最新版本的二进制包进行下载并解压 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">$ wget https://github.com/smartloli/kafka-eagle-bin/archive/refs/tags/v3.0.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line">$ tar -xvf v3.0.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line">$ <span class="built_in">cd</span> kafka-eagle-bin-3.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次解压文件</span></span><br><span class="line">$ tar -xvf efak-web-3.0.1-bin.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动解压目录</span></span><br><span class="line">$ sudo mv efak-web-3.0.1 /opt/efak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件统一授权</span></span><br><span class="line">$ sudo chmod -R 777 /opt/efak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本授权执行</span></span><br><span class="line">$ sudo chmod +x /opt/efak/bin/ke.sh</span><br></pre></td></tr></tbody></table></figure><h4 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h4><div class="admonition note"><p class="admonition-title">提示</p><p>Kafka Eagle（EFAK）是支持管理多个 Kafka 集群的，由于笔者只部署了一个 Kafka 集群，因此在下述配置内容中只配置了一个 Kafka 集群。</p></div><ul><li>编辑 Kafka Eagle（EFAK）的配置文件 <code>system-config.properties</code></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份配置文件</span></span><br><span class="line">$ cp /opt/efak/conf/system-config.properties /opt/efak/conf/system-config.properties.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">$ vi /opt/efak/conf/system-config.properties</span><br></pre></td></tr></tbody></table></figure><ul><li>然后更改配置文件的内容，更改后的完整配置内容如下所示 </li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># multi zookeeper &amp; kafka cluster list</span></span><br><span class="line"><span class="comment"># Settings prefixed with 'kafka.eagle.' will be deprecated, use 'efak.' instead</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.zk.cluster.alias</span>=<span class="string">cluster1</span></span><br><span class="line"><span class="meta">cluster1.zk.list</span>=<span class="string">192.168.2.102:2181,192.168.2.103:2181,192.168.2.104:2181/kafka</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># zookeeper enable acl</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.zk.acl.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.zk.acl.schema</span>=<span class="string">digest</span></span><br><span class="line"><span class="meta">cluster1.zk.acl.username</span>=<span class="string">test</span></span><br><span class="line"><span class="meta">cluster1.zk.acl.password</span>=<span class="string">test123</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># broker size online list</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.broker.size</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># zk client thread limit</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">kafka.zk.limit.size</span>=<span class="string">32</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK webui port</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.webui.port</span>=<span class="string">8048</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># efak.cluster.mode.status=master</span></span><br><span class="line"><span class="comment"># efak.worknode.master.host=localhost</span></span><br><span class="line"><span class="comment"># efak.worknode.port=8085</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka jmx acl and ssl authenticate</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.acl</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.user</span>=<span class="string">keadmin</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.password</span>=<span class="string">keadmin123</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.ssl</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.truststore.location</span>=<span class="string">/data/ssl/certificates/kafka.truststore</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.truststore.password</span>=<span class="string">ke123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka offset storage</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.offset.storage</span>=<span class="string">kafka</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka jmx uri</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.uri</span>=<span class="string">service:jmx:rmi:///jndi/rmi://%s/jmxrmi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka metrics, 15 days by default</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.metrics.charts</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.metrics.retain</span>=<span class="string">30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka sql topic records max</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.sql.topic.records.max</span>=<span class="string">5000</span></span><br><span class="line"><span class="meta">efak.sql.topic.preview.records.max</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># delete kafka topic token</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.topic.token</span>=<span class="string">keadmin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka sasl authenticate</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.protocol</span>=<span class="string">SASL_PLAINTEXT</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.mechanism</span>=<span class="string">SCRAM-SHA-256</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.jaas.config</span>=<span class="string">org.apache.kafka.common.security.scram.ScramLoginModule required username="kafka" password="kafka-eagle";</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.client.id</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.blacklist.topics</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.cgroup.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.cgroup.topics</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka ssl authenticate</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.protocol</span>=<span class="string">SSL</span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.truststore.location</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.truststore.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.keystore.location</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.keystore.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.key.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.endpoint.identification.algorithm</span>=<span class="string">https</span></span><br><span class="line"><span class="meta">cluster1.efak.blacklist.topics</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.cgroup.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.cgroup.topics</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka sqlite jdbc driver address</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># efak.driver=org.sqlite.JDBC</span></span><br><span class="line"><span class="comment"># It is important to note that the '/opt/efak/db' path must exist.</span></span><br><span class="line"><span class="comment"># efak.url=jdbc:sqlite:/opt/efak/db/ke.db</span></span><br><span class="line"><span class="comment"># efak.username=root</span></span><br><span class="line"><span class="comment"># efak.password=smartloli</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka mysql jdbc driver address</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">efak.url</span>=<span class="string">jdbc:mysql://192.168.2.107:3306/efak?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span></span><br><span class="line"><span class="meta">efak.username</span>=<span class="string">efak</span></span><br><span class="line"><span class="meta">efak.password</span>=<span class="string">123456</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在上述配置内容中，最重要的是以下几个配置项，其他配置项一般使用默认值即可 </li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># multi zookeeper &amp; kafka cluster list</span></span><br><span class="line"><span class="comment"># Settings prefixed with 'kafka.eagle.' will be deprecated, use 'efak.' instead</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.zk.cluster.alias</span>=<span class="string">cluster1</span></span><br><span class="line"><span class="meta">cluster1.zk.list</span>=<span class="string">192.168.2.102:2181,192.168.2.103:2181,192.168.2.104:2181/kafka</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka offset storage</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.offset.storage</span>=<span class="string">kafka</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka metrics, 15 days by default</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.metrics.charts</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.metrics.retain</span>=<span class="string">30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka jdbc driver address</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">efak.url</span>=<span class="string">jdbc:mysql://192.168.2.107:3306/efak?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span></span><br><span class="line"><span class="meta">efak.username</span>=<span class="string">efak</span></span><br><span class="line"><span class="meta">efak.password</span>=<span class="string">123456</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">重要参数说明</p><ul><li><code>cluster1.zk.list</code>：指定 Kafka 集群一连接的 ZooKeeper 节点列表。</li><li><code>cluster1.efak.offset.storage</code>：指定 Kafka 集群一存储 Offset 的位置。</li><li><code>efak.username</code>：指定 Kafka Eagle（EFAK）连接数据库的用户名。</li><li><code>efak.password</code>：指定 Kafka Eagle（EFAK）连接数据库的密码。</li><li><code>efak.driver</code>：指定 Kafka Eagle（EFAK）连接数据库的驱动。</li><li><code>efak.url</code>：指定 Kafka Eagle（EFAK）连接数据库的 URL。</li><li><code>efak.metrics.charts</code>：在 Kafka Eagle（EFAK）的 UI 中，是否允许实时显示 Kafka 的监控指标图表。</li><li><code>efak.metrics.retain</code>：Kafka Eagle（EFAK）保留 Kafka 监控指标数据的最长时间（比如 30 天），超过设定的时间监控指标数据就会被删除。</li></ul></div><h4 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改系统配置文件，添加环境变量</span></span><br><span class="line">$ sudo vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> KE_HOME=/opt/efak</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$KE_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使系统配置文件的更改生效</span></span><br><span class="line">$ sudo <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></tbody></table></figure><h4 id="SSH-免秘钥登录"><a href="#SSH-免秘钥登录" class="headerlink" title="SSH 免秘钥登录"></a>SSH 免秘钥登录</h4><p>Kafka Eagle（EFAK）集群管理的 Shell 脚本是依赖于 SSH 免秘钥登录执行的，因此需要提前配置好各个集群节点之间的 SSH 免秘钥登录，否则执行官方的 <code>ke.sh</code> 脚本会出错。请分别在所有 Kafka Eagle（EFAK）集群节点上，依次执行以下操作。</p><ul><li>配置 SSH 服务允许使用公钥登录 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑 SSH 服务的配置文件</span></span><br><span class="line">$ sudo vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保以下配置项存在，并且未被注释</span></span><br><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 SSH 服务</span></span><br><span class="line">$ sudo systemctl restart sshd</span><br></pre></td></tr></tbody></table></figure><ul><li>生成 SSH 密钥对 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果需要使用密码保护私钥，则可以输入密码，否则直接按回车键跳过即可</span></span><br><span class="line">$ ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></tbody></table></figure><ul><li>将公钥传输到其他集群节点（比如，在节点一上进行操作，请自行更改节点的登录用户和 IP 地址）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id node1-user@node1-ip</span><br><span class="line">$ ssh-copy-id node2-user@node2-ip</span><br><span class="line">$ ssh-copy-id node3-user@node3-ip</span><br></pre></td></tr></tbody></table></figure><ul><li>验证 SSH 免密登录（比如，在节点一上进行操作，请自行更改节点的登录用户和 IP 地址）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh node1-user@node1-ip</span><br><span class="line">$ ssh node2-user@node2-ip</span><br><span class="line">$ ssh node3-user@node3-ip</span><br></pre></td></tr></tbody></table></figure><h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><h4 id="配置集群节点一"><a href="#配置集群节点一" class="headerlink" title="配置集群节点一"></a>配置集群节点一</h4><ul><li>更改 Kafka Eagle（EFAK）集群节点一的配置文件 <code>/opt/efak/conf/system-config.properties</code>，指定其作为 Master 节点，同时指定其 IP 地址与集群通信端口（不能使用 Web UI 端口 <code>8048</code>，否则端口会冲突）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /opt/efak/conf/system-config.properties</span><br></pre></td></tr></tbody></table></figure><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.cluster.mode.status</span>=<span class="string">master</span></span><br><span class="line"><span class="meta">efak.worknode.master.host</span>=<span class="string">192.168.2.127</span></span><br><span class="line"><span class="meta">efak.worknode.port</span>=<span class="string">8085</span></span><br></pre></td></tr></tbody></table></figure><ul><li>更改 Kafka Eagle（EFAK）集群节点一的配置文件 <code>/opt/efak/conf/works</code>，添加 Kafka Eagle（EFAK）集群的 Slave 节点列表 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /opt/efak/conf/works</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.150</span><br><span class="line">192.168.2.203</span><br></pre></td></tr></tbody></table></figure><h4 id="配置集群节点二"><a href="#配置集群节点二" class="headerlink" title="配置集群节点二"></a>配置集群节点二</h4><ul><li>更改 Kafka Eagle（EFAK）集群节点二的配置文件 <code>system-config.properties</code>，指定其作为 Slave 节点，同时指定其 IP 地址与集群通信端口（不能使用 Web UI 端口 <code>8048</code>，否则端口会冲突）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /opt/efak/conf/system-config.properties</span><br></pre></td></tr></tbody></table></figure><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.cluster.mode.status</span>=<span class="string">slave</span></span><br><span class="line"><span class="meta">efak.worknode.master.host</span>=<span class="string">192.168.2.150</span></span><br><span class="line"><span class="meta">efak.worknode.port</span>=<span class="string">8085</span></span><br></pre></td></tr></tbody></table></figure><ul><li>更改 Kafka Eagle（EFAK）集群节点二的配置文件 <code>/opt/efak/conf/works</code>，添加 Kafka Eagle（EFAK）集群的 Slave 节点列表 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /opt/efak/conf/works</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.150</span><br><span class="line">192.168.2.203</span><br></pre></td></tr></tbody></table></figure><h4 id="配置集群节点三"><a href="#配置集群节点三" class="headerlink" title="配置集群节点三"></a>配置集群节点三</h4><ul><li>更改 Kafka Eagle（EFAK）集群节点三的配置文件 <code>system-config.properties</code>，指定其作为 Slave 节点，同时指定其 IP 地址与集群通信端口（不能使用 Web UI 端口 <code>8048</code>，否则端口会冲突）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /opt/efak/conf/system-config.properties</span><br></pre></td></tr></tbody></table></figure><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.cluster.mode.status</span>=<span class="string">slave</span></span><br><span class="line"><span class="meta">efak.worknode.master.host</span>=<span class="string">192.168.2.203</span></span><br><span class="line"><span class="meta">efak.worknode.port</span>=<span class="string">8085</span></span><br></pre></td></tr></tbody></table></figure><ul><li>更改 Kafka Eagle（EFAK）集群节点三的配置文件 <code>/opt/efak/conf/works</code>，添加 Kafka Eagle（EFAK）集群的 Slave 节点列表 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /opt/efak/conf/works</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.150</span><br><span class="line">192.168.2.203</span><br></pre></td></tr></tbody></table></figure><h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>(1) 在启动 Kafka Eagle（EFAK）集群之前，必须保证 ZooKeeper 集群、Kafka 集群 和 MySQL 已经启动并正常运行。</li><li>(2) <strong>在启动 Kafka Eagle（EFAK）集群之前，必须保证 ZooKeeper 集群、Kafka 集群 和 MySQL 的各个服务端口可以被外部正常访问；如果外部访问不了，请检查操作系统的防火墙配置。</strong></li></ul></div><ul><li>在任意一个 Kafka Eagle（EFAK）集群节点上，执行脚本来启动集群（只需在任意一个节点上执行一次即可）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh cluster start</span><br></pre></td></tr></tbody></table></figure><ul><li>Kafka Eagle（EFAK）集群正常启动后，终端输出的日志信息如下所示 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Welcome to</span><br><span class="line">    ______    ______    ___     __ __</span><br><span class="line">   / ____/   / ____/   /   |   / //_/</span><br><span class="line">  / __/     / /_      / /| |  / ,&lt;   </span><br><span class="line"> / /___    / __/     / ___ | / /| |  </span><br><span class="line">/_____/   /_/       /_/  |_|/_/ |_|  </span><br><span class="line">( Eagle For Apache Kafka® )</span><br><span class="line"></span><br><span class="line">Version v3.0.1 -- Copyright 2016-2022</span><br><span class="line">*******************************************************************</span><br><span class="line">* EFAK Service has started success.</span><br><span class="line">* Welcome, Now you can visit 'http://192.168.2.127:8048'</span><br><span class="line">* Account:admin ,Password:123456</span><br><span class="line">*******************************************************************</span><br><span class="line">* &lt;Usage&gt; ke.sh [start|status|stop|restart|stats] &lt;/Usage&gt;</span><br><span class="line">* &lt;Usage&gt; https://www.kafka-eagle.org/ &lt;/Usage&gt;</span><br><span class="line">*******************************************************************</span><br><span class="line">[2024-12-07 21:38:36] INFO: EFAK Master-192.168.2.127 WebConsole Start Success.</span><br><span class="line">[2024-12-07 21:38:36] INFO: EFAK Slave-192.168.2.150 WebConsole Start Success.</span><br><span class="line">[2024-12-07 21:38:36] INFO: EFAK Slave-192.168.2.203 WebConsole Start Success.</span><br><span class="line">[2024-12-07 21:38:55] INFO: EFAK Master WorkNodeServer Start Success.</span><br><span class="line">[2024-12-07 21:39:01] INFO: EFAK Slave WorkNodeServer-192.168.2.150 Start Success.</span><br><span class="line">[2024-12-07 21:39:02] INFO: EFAK Slave WorkNodeServer-192.168.2.203 Start Success.</span><br></pre></td></tr></tbody></table></figure><ul><li>若 Kafka Eagle（EFAK）集群启动失败，可以在各个集群节点上通过查看日志信息来排查问题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看错误日志</span></span><br><span class="line">$ vi /opt/efak/logs/error.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作节点日志</span></span><br><span class="line">$ vi /opt/efak/logs/worknode.log</span><br></pre></td></tr></tbody></table></figure><h3 id="管理集群"><a href="#管理集群" class="headerlink" title="管理集群"></a>管理集群</h3><h4 id="管理整个集群"><a href="#管理整个集群" class="headerlink" title="管理整个集群"></a>管理整个集群</h4><ul><li>关闭 Kafka Eagle（EFAK）集群 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh cluster stop</span><br></pre></td></tr></tbody></table></figure><ul><li>重启 Kafka Eagle（EFAK）集群 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh cluster restart</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Kafka Eagle（EFAK）集群的状态 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh cluster status</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[2024-12-07 22:39:35] INFO: EFAK WebConsole Status.</span><br><span class="line">[2024-12-07 22:39:35] INFO : EFAK-192.168.2.127 is running, [2434] .</span><br><span class="line">[2024-12-07 22:39:37] INFO : EFAK-192.168.2.150 is running, [2542] .</span><br><span class="line">[2024-12-07 22:39:39] INFO : EFAK-192.168.2.203 is running, [2538] .</span><br><span class="line">[2024-12-07 22:39:35] INFO: EFAK WorkNodeServer Status.</span><br><span class="line">[2024-12-07 22:39:41] INFO : WorkNodeServer-192.168.2.127 is running, [2568] .</span><br><span class="line">[2024-12-07 22:39:42] INFO : WorkNodeServer-192.168.2.150 is running, [2457] .</span><br><span class="line">[2024-12-07 22:39:43] INFO : WorkNodeServer-192.168.2.203 is running, [2452] .</span><br><span class="line">Time taken: 2 seconds.</span><br></pre></td></tr></tbody></table></figure><h4 id="管理集群节点"><a href="#管理集群节点" class="headerlink" title="管理集群节点"></a>管理集群节点</h4><ul><li>关闭 Kafka Eagle（EFAK）集群中的某个节点 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh stop</span><br></pre></td></tr></tbody></table></figure><ul><li>重启 Kafka Eagle（EFAK）集群中的某个节点 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh restart</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Kafka Eagle（EFAK）集群中某个节点的进程信息 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh status</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2024-12-07 22:11:50] INFO : EFAK-fd34:dd83:8cb9::b3e 192.168.2.127 is running, [3346] .</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Kafka Eagle（EFAK）集群中某个节点在 Linux 操作系统中的句柄数 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh stats</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">===================== TCP Connections Count  ==========================</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">     39 2434/java</span><br><span class="line">===================== ESTABLISHED/TIME_OUT Status  ====================</span><br><span class="line">      1 192.168.2.203</span><br><span class="line">      1 192.168.2.150</span><br><span class="line">===================== Connection Number Of Different States ===========</span><br><span class="line">LISTEN 13</span><br><span class="line">ESTABLISHED 71</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Kafka Eagle（EFAK）集群中某个节点的垃圾回收（GC）情况 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh gc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2024-12-07 23:40:29] INFO : EFAK Process[52129] GC.</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line">  0.00 100.00  63.29   3.99  97.86  92.33     98    0.702     0    0.000     0    0.000    0.702</span><br><span class="line">  0.00 100.00  63.29   3.99  97.86  92.33     98    0.702     0    0.000     0    0.000    0.702</span><br><span class="line">  0.00 100.00  63.29   3.99  97.86  92.33     98    0.702     0    0.000     0    0.000    0.702</span><br></pre></td></tr></tbody></table></figure><h4 id="管理命令汇总"><a href="#管理命令汇总" class="headerlink" title="管理命令汇总"></a>管理命令汇总</h4><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td> ke.sh start</td><td> 启动 EFAK 服务器。</td></tr><tr><td>ke.sh status</td><td> 查看 EFAK 运行状态。</td></tr><tr><td>ke.sh stop</td><td> 停止 EFAK 服务器。</td></tr><tr><td>ke.sh restart</td><td> 重新启动 EFAK 服务器。</td></tr><tr><td>ke.sh stats</td><td> 查看 Linux 操作系统中的 EFAK 句柄数。</td></tr><tr><td>ke.sh find [ClassName]</td><td> 在 Jar 中找到类名的位置。</td></tr><tr><td>ke.sh gc</td><td> 查看 EFAK 进程的 GC 情况。</td></tr><tr><td>ke.sh version</td><td> 查看 EFAK 版本。</td></tr><tr><td>ke.sh jdk</td><td> 查看 EFAK 安装的 JDK 详细信息。</td></tr><tr><td>ke.sh sdate</td><td> 查看 EFAK 启动日期。</td></tr><tr><td>ke.sh cluster start</td><td> 启动 EFAK 集群。</td></tr><tr><td>ke.sh cluster stop</td><td> 停止 EFAK 集群。</td></tr><tr><td>ke.sh cluster restart</td><td> 重启 EFAK 集群。</td></tr><tr><td>ke.sh cluster status</td><td> 查看 EFAK 集群的状态。</td></tr></tbody></table><h3 id="验证集群"><a href="#验证集群" class="headerlink" title="验证集群"></a>验证集群</h3><ul><li>(1) 浏览器通过 <code>http://192.168.2.127:8048</code> 访问 Kafka Eagle（EFAK）的控制台管理页面（如下所示），默认的登录账号和密码是 <code>admin/123456</code>，请记得将 <code>192.168.2.127</code> 更改为你自己服务器的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-cluster-1.png"></p><ul><li>(2) 浏览器通过 <code>http://192.168.2.127:8048/tv</code> 就可以访问监控数据大屏的页面（如下所示），请记得将 <code>192.168.2.127</code> 更改为你自己服务器的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-cluster-2.png"></p><ul><li>(3) 浏览器通过 <code>http://192.168.2.127:8048/cluster/kafka</code> 就可以访问 Kafka 的监控页面（如下所示），请记得将 <code>192.168.2.127</code> 更改为你自己服务器的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-cluster-3.png"></p><ul><li>(4) 浏览器通过 <code>http://192.168.2.127:8048/cluster/zookeeper</code> 就可以访问 ZooKeeper 的监控页面（如下所示），请记得将 <code>192.168.2.127</code> 更改为你自己服务器的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-cluster-4.png"></p><ul><li>(5) 浏览器通过 <code>http://192.168.2.127:8048/cluster/efakserver</code> 就可以访问 EfakServer 的监控页面（如下所示），请记得将 <code>192.168.2.127</code> 更改为你自己服务器的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-cluster-8.png"></p><h2 id="Kafka-Eagle-部署问题"><a href="#Kafka-Eagle-部署问题" class="headerlink" title="Kafka Eagle 部署问题"></a>Kafka Eagle 部署问题</h2><h3 id="无法监控-Kafka-集群"><a href="#无法监控-Kafka-集群" class="headerlink" title="无法监控 Kafka 集群"></a>无法监控 Kafka 集群</h3><p>在 Kafka Eagle（EFAK）的控制台中访问 Kafka 的监控页面时，发现无法正常显示 Kafka 的运行状态，如下图所示：</p><p><img data-src="../../../asset/2024/12/linux-efak-cluster-6.png"></p><p>这通常是由于 Kafka 服务没有配置 JMX 服务或者 JMX 服务配置不正确导致的，因为 Kafka Eagle（EFAK）是基于 JMX 服务来实现 Kafka 运行状态的监控。解决办法是，为 Kafka 服务添加对应的 JMX 配置。</p><ul><li>(1) 如果 Kafka 服务是通过手动部署的（基于二进制安装包），那么可以在执行 <code>kafka-server-start.sh</code> 启动脚本时，添加 <code>JMX_PORT</code> 环境变量来启用 JMX 服务（如下所示），详细教程请参考 <a href="https://stackoverflow.com/questions/36708384/how-to-enable-remote-jmx-on-kafka-brokers-for-jmxtool">这里</a></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMX_PORT=19999 ./kafka-server-start.sh -daemon ../config/server.properties</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 如果 Kafka 服务是通过 Docker-Compose 部署的，那么可以参考以下配置内容，详细教程请参考 <a href="/posts/73b15688.html">这里</a></li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/kafka:3.9.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9092</span><span class="string">:9092</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">19999</span><span class="string">:19999</span>   <span class="comment"># 映射 JMX 端口</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_PORT:</span> <span class="number">19999</span>   <span class="comment"># 指定 JMX 端口</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_OPTS:</span> <span class="string">'-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=kafka -Dcom.sun.management.jmxremote.port=19999'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Kafka-Eagle-无法监控自己"><a href="#Kafka-Eagle-无法监控自己" class="headerlink" title="Kafka Eagle 无法监控自己"></a>Kafka Eagle 无法监控自己</h3><p>在 Kafka Eagle（EFAK）的控制台中访问 EfakServer 的监控页面时，发现无法正常显示 EfakServer 的运行状态，监控页面一直显示提示信息 <code>Processing</code> 或者节点状态显示为 <code>Offline</code>，如下图所示：</p><p><img data-src="../../../asset/2024/12/linux-efak-cluster-7.png"></p><p>这通常是因为 Kafka Eagle（EFAK）没有启用集群模式或者集群模式配置不正确导致的，请检查各个集群节点的配置，其中的 <code>8085</code> 端口是 EFAK 集群的通信端口（不能使用 Web UI 端口 <code>8048</code>，否则端口会冲突），如下所示：</p><ul><li>Master 节点的 <code>/opt/efak/conf/system-config.properties</code> 配置文件 </li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.cluster.mode.status</span>=<span class="string">master</span></span><br><span class="line"><span class="meta">efak.worknode.master.host</span>=<span class="string">192.168.2.127</span></span><br><span class="line"><span class="meta">efak.worknode.port</span>=<span class="string">8085</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Slave 节点一的 <code>/opt/efak/conf/system-config.properties</code> 配置文件 </li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.cluster.mode.status</span>=<span class="string">slave</span></span><br><span class="line"><span class="meta">efak.worknode.master.host</span>=<span class="string">192.168.2.150</span></span><br><span class="line"><span class="meta">efak.worknode.port</span>=<span class="string">8085</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Slave 节点二的 <code>/opt/efak/conf/system-config.properties</code> 配置文件 </li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.cluster.mode.status</span>=<span class="string">slave</span></span><br><span class="line"><span class="meta">efak.worknode.master.host</span>=<span class="string">192.168.2.203</span></span><br><span class="line"><span class="meta">efak.worknode.port</span>=<span class="string">8085</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Master 节点与 Slave 节点的 <code>/opt/efak/conf/works</code> 配置文件 </li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">192.168.2.150</span></span><br><span class="line"><span class="attr">192.168.2.203</span></span><br></pre></td></tr></tbody></table></figure><h3 id="内存不足导致服务启动失败"><a href="#内存不足导致服务启动失败" class="headerlink" title="内存不足导致服务启动失败"></a>内存不足导致服务启动失败</h3><p>在 Kafka Eagle（EFAK）的项目源码中，有一个 <code>ke.sh</code> <a href="https://github.com/smartloli/EFAK/blob/main/efak-web/src/main/resources/bin/ke.sh">启动脚本</a>，该脚本里面有以下一行代码：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KE_JAVA_OPTS=<span class="string">"-server -Xmx2g -Xms2g -XX:MaxGCPauseMillis=20 -XX:+UseG1GC -XX:MetaspaceSize=128m -XX:InitiatingHeapOccupancyPercent=35 -XX:G1HeapRegionSize=16M -XX:MinMetaspaceFreeRatio=50 -XX:MaxMetaspaceFreeRatio=80"</span></span><br></pre></td></tr></tbody></table></figure><p>其中 JVM 参数 <code>-Xms2g</code> 指定了初始堆内存为 <code>2G</code>，因此当操作系统的空闲内存不足 <code>2G</code> 时，会导致 Kafka Eagle（EFAK）服务启动失败。解决办法是，更改 Shell 脚本代码，或者增加机器的物理内存（强烈推荐）。</p><h3 id="监控大屏无法实时更新显示"><a href="#监控大屏无法实时更新显示" class="headerlink" title="监控大屏无法实时更新显示"></a>监控大屏无法实时更新显示</h3><p>在 Kafka Eagle（EFAK）的控制台中访问监控大屏页面时，发现即使有生产者正在发送消息和消费者正在消费消息，Kafka 集群的监控指标图表也无法实时更新显示或者没有任何监控数据显示（如下图所示）。这是因为 Kafka Eagle（EFAK）禁用了 Kafka 集群的监控指标图表实时更新。</p><p><img data-src="../../../asset/2024/12/linux-efak-cluster-5.png"></p><p>解决办法是，在 Kafka Eagle（EFAK）的 <code>system-config.properties</code> 配置文件中，更改或添加以下配置：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">efak.metrics.charts</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Kafka Eagle（EFAK）的控制台中，Kafka 集群监控指标图表的渲染和数据获取会消耗一定的资源。如果 Kafka 的集群规模较大或者系统资源有限，建议通过禁用 <code>efak.metrics.charts</code> 选项来减少系统负载。</p></div><h2 id="Kafka-Eagle-工作原理"><a href="#Kafka-Eagle-工作原理" class="headerlink" title="Kafka Eagle 工作原理"></a>Kafka Eagle 工作原理</h2><h3 id="Kafka-Eagle-集群整体架构"><a href="#Kafka-Eagle-集群整体架构" class="headerlink" title="Kafka Eagle 集群整体架构"></a>Kafka Eagle 集群整体架构</h3><p>当 Kafka Eagle（EFAK）以集群（分布式）模式部署，并且一共有 5 个节点（包括 1 个 Master 和 4 个 Slave）时，各个节点的角色如下图所示：</p><p><img data-src="../../../asset/2024/12/linux-efak-cluster-9.png"></p><h3 id="Kafka-Eagle-数据采集原理"><a href="#Kafka-Eagle-数据采集原理" class="headerlink" title="Kafka Eagle 数据采集原理"></a>Kafka Eagle 数据采集原理</h3><p>Kafka Eagle（EFAK）针对 Kafka 可以采集以下数据：</p><ul><li>Kafka Broker 常用机器加载信息：内存、CPU、IP、版本信息等</li><li>应用程序监控：消费者组、消费者、生产者、主题等</li><li>服务监控数据：TPS、QPS、RT 等</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-cluster-10.png"></p><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ul><li><a href="https://docs.kafka-eagle.org/2.installation/2.installonlinuxmac">Kafka Eagle（EFAK）官方安装文档</a></li><li><a href="/posts/d2fe844e.html">Linux 部署 Kafka-Eagle（EFAK）单机</a></li><li><a href="/posts/73b15688.html">Docker 部署 Kafka Eagle（EFAK）单机</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何在 Linux 生产环境部署 Kafka-Eagle（EFAK）集群，实现对 Kafka 集群的监控。</summary>
    
    
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 生产环境搭建 Kafka-KRaft 集群</title>
    <link href="https://www.techgrow.cn/posts/e3aa2fd8.html"/>
    <id>https://www.techgrow.cn/posts/e3aa2fd8.html</id>
    <published>2024-11-15T13:30:00.000Z</published>
    <updated>2024-12-07T13:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/d2c9b56d.html">Docker 搭建 Kafka 集群</a></li><li><a href="/posts/124a5015.html">Linux 单机搭建 Kafka 集群</a></li><li><a href="/posts/6dceb9c9.html">Linux 生产环境搭建 Kafka 集群</a></li><li><a href="/posts/e3aa2fd8.html">Linux 生产环境搭建 Kafka-KRaft 集群</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将使用多台物理机器（至少三台），基于 KRaft 模式搭建 Kafka 集群，适用于在 CentOS/Debian/Ubuntu 等发行版。</p><span id="more"></span><h2 id="Kafka-KRaft-模式介绍"><a href="#Kafka-KRaft-模式介绍" class="headerlink" title="Kafka-KRaft 模式介绍"></a>Kafka-KRaft 模式介绍</h2><h3 id="KRaft-模式的概述"><a href="#KRaft-模式的概述" class="headerlink" title="KRaft 模式的概述"></a>KRaft 模式的概述</h3><p><img data-src="../../../asset/2024/12/kafka-kraft-1.png"></p><ul><li>左图为 Kafka 的 ZooKeeer 模式架构，元数据存储在 Zookeeper 中，运行时会动态选举一个 Broker 节点作为 Controller（唯一），由 Controller 进行 Kafka 集群管理。</li><li>左图为 Kafka 的 KRaft 模式架构，不再依赖 Zookeeper 集群，而是使用多个 Controller 节点来代替 Zookeeper，元数据保存在 Controller 中，由 Controller 直接管理 Kafka 集群。</li></ul><table><thead><tr><th>特性</th><th> ZooKeeper 模式</th><th> KRaft 模式</th></tr></thead><tbody><tr><td> Leader 选举依赖性</td><td>需要 ZooKeeper 提供元数据存储和通知机制</td><td>不依赖 ZooKeeper，完全有 Kafka 自己自行实现</td></tr><tr><td>元数据管理</td><td>由 ZooKeeper 管理</td><td>由 Kafka 自己的 Raft 集群管理</td></tr><tr><td>一致性保障</td><td> ZooKeeper 提供一致性</td><td> Raft 协议保障一致性</td></tr><tr><td>引入版本</td><td> Kafka 早期版本（默认是 ZooKeeper 模式）</td><td>Kafka <code>2.8.0+</code>（KRaft 模式）</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">版本说明</p><p>从 Kafka <code>2.8.0</code> 版本开始，Kafka 自身实现了 Raft 分布式一致性机制，这意味着 Kafka 集群可以脱离 ZooKeeper 独立运行。</p></div><h3 id="KRaft-模式的优势"><a href="#KRaft-模式的优势" class="headerlink" title="KRaft 模式的优势"></a>KRaft 模式的优势</h3><ul><li>Kafka 不再依赖外部服务，而是能够独立运行。</li><li>Controller 管理集群时，不再需要从 Zookeeper 中先读取数据，提高了集群性能。</li><li>由于不依赖 Zookeeper，因此 Kafka 集群扩展时不再受到 Zookeeper 读写能力的限制。</li><li>Controller 节点不再是通过动态选举来决定，而是由配置文件指定，这样开发者可以有针对性地加强。</li><li>Controller 节点支持通过配置来指定，而不是像以前一样对随机 Controller 节点的高负载束手无策。</li></ul><h2 id="Kafka-KRaft-集群部署"><a href="#Kafka-KRaft-集群部署" class="headerlink" title="Kafka-KRaft 集群部署"></a>Kafka-KRaft 集群部署</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="集群部署规划"><a href="#集群部署规划" class="headerlink" title="集群部署规划"></a>集群部署规划</h4><table><thead><tr><th>节点</th><th>节点 ID</th><th> 主机名</th><th>角色</th><th> IP 地址</th><th> Broker 端口</th><th> Controller 端口</th><th>版本</th></tr></thead><tbody><tr><td> Kafka 集群节点一</td><td> 1</td><td><code>kafka01</code></td><td><code>broker</code>、<code>controller</code></td><td><code>192.168.2.127</code></td><td><code>9092</code></td><td><code>9093</code></td><td><code>3.8.1</code></td></tr><tr><td>Kafka 集群节点二</td><td> 2</td><td><code>kafka02</code></td><td><code>broker</code>、<code>controller</code></td><td><code>192.168.2.150</code></td><td><code>9092</code></td><td><code>9093</code></td><td><code>3.8.1</code></td></tr><tr><td>Kafka 集群节点三</td><td> 3</td><td><code>kafka03</code></td><td><code>broker</code>、<code>controller</code></td><td><code>192.168.2.203</code></td><td><code>9092</code></td><td><code>9093</code></td><td><code>3.8.1</code></td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><ul><li>对于 Kafka-KRaft 集群，可以在配置文件中通过 <code>process.roles</code> 配置项来指定某个节点单独作为 Broker 或者单独作为 Controller，还可以指定某个节点同时作为 Broker 和 Controller。</li><li><strong>特别注意，为了保证 Kafka-KRaft 集群的高可用性，要求至少要有 3 个 Controller。</strong></li></ul></div><h4 id="添加主机名映射"><a href="#添加主机名映射" class="headerlink" title="添加主机名映射"></a>添加主机名映射</h4><p>在所有 Kafka-KRaft 集群节点中，分别通过修改 <code>/etc/hosts</code> 配置文件来添加主机名和 IP 地址的映射关系，用于将主机名解析到指定的 IP 地址。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑系统配置文件，添加以下配置内容</span></span><br><span class="line"><span class="comment"># vi /etc/hosts</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.127   kafka01</span><br><span class="line">192.168.2.150   kafka02</span><br><span class="line">192.168.2.203   kafka03</span><br></pre></td></tr></tbody></table></figure><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><div class="admonition note"><p class="admonition-title">Kafka 下载地址</p><ul><li>(1) Kafka 的安装包可以从 <a href="https://kafka.apache.org/downloads.html">官网</a> 下载。</li><li>(2) 以下载得到的压缩文件 <code>kafka_2.13-3.8.1.tgz</code> 为例，<code>2.11</code> 是 Scala 的版本号，<code>3.2.1</code> 是 Kafka 的版本号。</li><li>(3) 值得一提的是，Kafka 的 Broker 组件是使用 Scala 开发的，而 Producer 组件和 Consumer 组件是使用 Java 开发的。</li></ul></div><ul><li>Kafka 安装 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建安装目录</span></span><br><span class="line"><span class="comment"># mkdir -p /usr/local/kafka-cluster</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入安装目录</span></span><br><span class="line"><span class="comment"># cd /usr/local/kafka-cluster</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line"><span class="comment"># wget https://downloads.apache.org/kafka/3.8.1/kafka_2.13-3.8.1.tgz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line"><span class="comment"># tar -xvf kafka_2.13-3.8.1.tgz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名目录（作为节点一的安装目录）</span></span><br><span class="line"><span class="comment"># mv kafka_2.13-3.8.1 kafka-node01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line"><span class="comment"># rm -rf kafka_2.13-3.8.1.tgz</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Kafka 基础配置 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">``` sh</span><br><span class="line"><span class="comment"># 进入节点一的安装目录</span></span><br><span class="line"><span class="comment"># cd /usr/local/kafka-cluster/kafka-node01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据存储目录</span></span><br><span class="line"><span class="comment"># mkdir data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 KRaft 的配置文件（更改或添加以下内容即可）</span></span><br><span class="line"><span class="comment"># vi config/kraft/server.properties</span></span><br></pre></td></tr></tbody></table></figure><p>最关键的配置项是 <code>process.roles</code>、<code>node.id</code>、<code>controller.quorum.voters</code>、<code>advertised.listeners</code>、<code>log.dirs</code>。在生产阶段，其他配置项可以根据业务需求适当调整具体的参数值。</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定节点的角色,可以单独指定为 broker 或者 controller,还可以两者同时指定</span></span><br><span class="line"><span class="meta">process.roles</span>=<span class="string">broker,controller</span></span><br><span class="line"><span class="comment"># Kafka 节点的 ID,必须在集群中唯一</span></span><br><span class="line"><span class="meta">node.id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 定义控制器选举的投票者,格式为 node.id@host:port</span></span><br><span class="line"><span class="meta">controller.quorum.voters</span>=<span class="string">1@kafka01:9093,2@kafka02:9093,3@kafka03:9093</span></span><br><span class="line"><span class="comment"># 配置 Kafka 使用的监听地址和端口</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://:9092,CONTROLLER://:9093</span></span><br><span class="line"><span class="comment"># 定义 Broker 之间通信使用的监听器名称</span></span><br><span class="line"><span class="meta">inter.broker.listener.name</span>=<span class="string">PLAINTEXT</span></span><br><span class="line"><span class="comment"># 定义 Broker 对外暴露的监听地址,供客户端连接</span></span><br><span class="line"><span class="meta">advertised.listeners</span>=<span class="string">PLAINTEXT://kafka01:9092</span></span><br><span class="line"><span class="comment"># 定义 Controller 之间通信使用的监听器名称</span></span><br><span class="line"><span class="meta">controller.listener.names</span>=<span class="string">CONTROLLER</span></span><br><span class="line"><span class="comment"># 定义监听器与安全协议的映射关系</span></span><br><span class="line"><span class="meta">listener.security.protocol.map</span>=<span class="string">CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL</span></span><br><span class="line"><span class="comment"># 指定 Kafka 使用的日志（数据）存储目录</span></span><br><span class="line"><span class="meta">log.dirs</span>=<span class="string">/usr/local/kafka-cluster/kafka-node01/data</span></span><br><span class="line"><span class="comment"># 处理网络请求的线程数量</span></span><br><span class="line"><span class="meta">num.network.threads</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"># 用来处理磁盘 IO 的线程数量</span></span><br><span class="line"><span class="meta">num.io.threads</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 发送套接字的缓冲区大小</span></span><br><span class="line"><span class="meta">socket.send.buffer.bytes</span>=<span class="string">102400</span></span><br><span class="line"><span class="comment"># 接收套接字的缓冲区大小</span></span><br><span class="line"><span class="meta">socket.receive.buffer.bytes</span>=<span class="string">102400</span></span><br><span class="line"><span class="comment"># 请求套接字的缓冲区大小</span></span><br><span class="line"><span class="meta">socket.request.max.bytes</span>=<span class="string">104857600</span></span><br><span class="line"><span class="comment"># 每个 Topic 在创建时的分区数量,默认是 1 个分区</span></span><br><span class="line"><span class="meta">num.partitions</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"># 用来恢复和清理 Data 下数据的线程数量</span></span><br><span class="line"><span class="meta">num.recovery.threads.per.data.dir</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 是否启用自动创建主题的功能,默认是启用,禁用后可以避免因拼写错误或误用主题名而自动创建不必要的主题</span></span><br><span class="line"><span class="meta">auto.create.topics.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 每个 Topic 在创建时的分区副本数量,默认是 1 个副本</span></span><br><span class="line"><span class="meta">default.replication.factor</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"># 设置内置主题 __consumer_offsets 的副本数量,默认是 1 个副本,用于存储消费者组的偏移量</span></span><br><span class="line"><span class="meta">offsets.topic.replication.factor</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"># 设置事务状态日志主题 __transaction_state 的副本数量,默认是 1 个副本</span></span><br><span class="line"><span class="meta">transaction.state.log.replication.factor</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"># 设置事务状态日志主题的最小同步副本数（ISR）,确保至少有多个副本成功同步数据才能提交事务</span></span><br><span class="line"><span class="meta">transaction.state.log.min.isr</span>=<span class="string">2</span></span><br><span class="line"><span class="comment"># 每个 Segment 文件保留的最长时间,超时将被删除,默认保留 7 天</span></span><br><span class="line"><span class="meta">log.retention.hours</span>=<span class="string">168</span></span><br><span class="line"><span class="comment"># 每个 Segment 文件的大小,默认最大 1G</span></span><br><span class="line"><span class="meta">log.segment.bytes</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment"># 检查过期数据的时间,默认 5 分钟检查一次数据是否过期</span></span><br><span class="line"><span class="meta">log.retention.check.interval.ms</span>=<span class="string">300000</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>(1) 这里需要更改是 Kafka-KRaft 的配置文件 <code>config/kraft/server.properties</code>，而不是 Kafka 的默认配置文件 <code>config/server.properties</code>。</li><li>(2) 上述部分配置默认是不存在于 Kafka-KRaft 的配置文件 <code>config/kraft/server.properties</code> 中的，因此需要手动添加缺少的配置项，比如 <code>default.replication.factor</code>。</li></ul></div><ul><li>Kafka 创建多个节点</li></ul><p>通过 <code>scp</code> 命令拷贝两份上面已经配置好的 Kafka 节点一安装目录到其他 Kafka 集群节点上，以此作为集群另外两个节点的安装文件。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝安装目录到节点二</span></span><br><span class="line"><span class="comment"># scp -r /usr/local/kafka-cluster/kafka-node01 root@kafka02:/usr/local/kafka-cluster/kafka-node02</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝安装目录到节点三</span></span><br><span class="line"><span class="comment"># scp -r /usr/local/kafka-cluster/kafka-node01 root@kafka03:/usr/local/kafka-cluster/kafka-node03</span></span><br></pre></td></tr></tbody></table></figure><p>安装目录拷贝完成后，还需要更改另外两个集群节点里的 Kafka-KRaft 配置文件 <code>config/kraft/server.properties</code> 中的 <code>node.id</code>、<code>advertised.listeners</code>、<code>log.dirs</code> 参数。节点二和节点三的核心配置如下：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节点二的核心配置</span></span><br><span class="line"><span class="meta">node.id</span>=<span class="string">2</span></span><br><span class="line"><span class="meta">process.roles</span>=<span class="string">broker,controller</span></span><br><span class="line"><span class="meta">controller.quorum.voters</span>=<span class="string">1@kafka01:9093,2@kafka02:9093,3@kafka03:9093</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://:9092,CONTROLLER://:9093</span></span><br><span class="line"><span class="meta">inter.broker.listener.name</span>=<span class="string">PLAINTEXT</span></span><br><span class="line"><span class="meta">advertised.listeners</span>=<span class="string">PLAINTEXT://kafka02:9092</span></span><br><span class="line"><span class="meta">controller.listener.names</span>=<span class="string">CONTROLLER</span></span><br><span class="line"><span class="meta">listener.security.protocol.map</span>=<span class="string">CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL</span></span><br><span class="line"><span class="meta">log.dirs</span>=<span class="string">/usr/local/kafka-cluster/kafka-node02/data</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节点三的核心配置</span></span><br><span class="line"><span class="meta">node.id</span>=<span class="string">3</span></span><br><span class="line"><span class="meta">process.roles</span>=<span class="string">broker,controller</span></span><br><span class="line"><span class="meta">controller.quorum.voters</span>=<span class="string">1@kafka01:9093,2@kafka02:9093,3@kafka03:9093</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://:9092,CONTROLLER://:9093</span></span><br><span class="line"><span class="meta">inter.broker.listener.name</span>=<span class="string">PLAINTEXT</span></span><br><span class="line"><span class="meta">advertised.listeners</span>=<span class="string">PLAINTEXT://kafka03:9092</span></span><br><span class="line"><span class="meta">controller.listener.names</span>=<span class="string">CONTROLLER</span></span><br><span class="line"><span class="meta">listener.security.protocol.map</span>=<span class="string">CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL</span></span><br><span class="line"><span class="meta">log.dirs</span>=<span class="string">/usr/local/kafka-cluster/kafka-node03/data</span></span><br></pre></td></tr></tbody></table></figure><h3 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h3><h4 id="初始化存储目录"><a href="#初始化存储目录" class="headerlink" title="初始化存储目录"></a>初始化存储目录</h4><ul><li>首先，在任意一个集群节点（比如节点一）中生成一个唯一的集群 ID</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节点一生成一个唯一的集群 ID</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node01/bin/kafka-storage.sh random-uuid</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rNh-6V2lSvy4kC0LmYOl6w</span><br></pre></td></tr></tbody></table></figure><ul><li>然后，在所有 Kafka-KRaft 集群节点中，分别用上面生成的集群 ID 来初始化 Kafka 的存储目录 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化节点一的存储目录</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node01/bin/kafka-storage.sh format -t rNh-6V2lSvy4kC0LmYOl6w -c /usr/local/kafka-cluster/kafka-node01/config/kraft/server.properties</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化节点二的存储目录</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node02/bin/kafka-storage.sh format -t rNh-6V2lSvy4kC0LmYOl6w -c /usr/local/kafka-cluster/kafka-node02/config/kraft/server.properties</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化节点三的存储目录</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node03/bin/kafka-storage.sh format -t rNh-6V2lSvy4kC0LmYOl6w -c /usr/local/kafka-cluster/kafka-node03/config/kraft/server.properties</span></span><br></pre></td></tr></tbody></table></figure><h4 id="启动各个集群节点"><a href="#启动各个集群节点" class="headerlink" title="启动各个集群节点"></a>启动各个集群节点</h4><p>在所有 Kafka-KRaft 集群节点中，分别在后台启动 Kafka 节点</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动节点一</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node01/bin/kafka-server-start.sh -daemon /usr/local/kafka-cluster/kafka-node01/config/kraft/server.properties</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动节点二</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node02/bin/kafka-server-start.sh -daemon /usr/local/kafka-cluster/kafka-node02/config/kraft/server.properties</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动节点三</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node03/bin/kafka-server-start.sh -daemon /usr/local/kafka-cluster/kafka-node03/config/kraft/server.properties</span></span><br></pre></td></tr></tbody></table></figure><h4 id="查看启动日志信息"><a href="#查看启动日志信息" class="headerlink" title="查看启动日志信息"></a>查看启动日志信息</h4><p>在所有 Kafka-KRaft 集群节点中，分别查看 Broker 和 Controller 的启动日志信息，观察 Kafka 节点是否正常启动</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点一的 Brokder 日志</span></span><br><span class="line"><span class="comment"># vim /usr/local/kafka-cluster/kafka-node01/logs/server.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点一的 Controller 日志</span></span><br><span class="line"><span class="comment"># vim /usr/local/kafka-cluster/kafka-node01/logs/controller.log</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点二的 Brokder 日志</span></span><br><span class="line"><span class="comment"># vim /usr/local/kafka-cluster/kafka-node02/logs/server.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点二的 Controller 日志</span></span><br><span class="line"><span class="comment"># vim /usr/local/kafka-cluster/kafka-node02/logs/controller.log</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点三的 Brokder 日志</span></span><br><span class="line"><span class="comment"># vim /usr/local/kafka-cluster/kafka-node03/logs/server.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点三的 Controller 日志</span></span><br><span class="line"><span class="comment"># vim /usr/local/kafka-cluster/kafka-node03/logs/controller.log</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">前台启动 Kafka 集群节点</p><p>若希望更直观地观察 Kafka-KRaft 集群节点的启动日志信息，可以去掉上述节点启动命令中的 <code>-daemon</code> 参数，这样就可以使用前台方式启动 Kafka-KRaft 集群节点。</p></div><h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><h4 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h4><p>在所有 Kafka-KRaft 集群节点中，分别使用以下命令查看集群节点的运行状态。如果发现集群节点启动失败，则可以根据 Kafka 的日志文件来定位问题。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看端口占用情况</span></span><br><span class="line"><span class="comment"># netstat -nplt | grep -E ':9092|:9093'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Kafka 进程</span></span><br><span class="line"><span class="comment"># ps -aux | grep kafka</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有 Java 进程</span></span><br><span class="line"><span class="comment"># jps -l</span></span><br></pre></td></tr></tbody></table></figure><h4 id="集群关闭"><a href="#集群关闭" class="headerlink" title="集群关闭"></a>集群关闭</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭节点一</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node01/bin/kafka-server-stop.sh stop</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭节点二</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node02/bin/kafka-server-stop.sh stop</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭节点三</span></span><br><span class="line"><span class="comment"># /usr/local/kafka-cluster/kafka-node03/bin/kafka-server-stop.sh stop</span></span><br></pre></td></tr></tbody></table></figure><h4 id="集群重建"><a href="#集群重建" class="headerlink" title="集群重建"></a>集群重建</h4><p>若希望重建 Kafka-KRaft 集群，可以按照以下步骤进行操作（<strong>清空数据目录的操作不可恢复，生产环境下慎用</strong>）。</p><ul><li>(1) 关闭所有 Kafka-KRaft 集群节点</li><li> (2) 在所有 Kafka-KRaft 集群节点中，分别清空 <code>data</code> 数据目录和 <code>logs</code> 日志目录里的文件</li><li> (3) 在所有 Kafka-KRaft 集群节点中，分别重新执行 <code>kafka-storage.sh format</code> 命令来初始化 Kafka 的存储目录</li><li> (4) 重新启动所有 Kafka-KRaft 集群节点</li></ul><h3 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h3><ul><li>进入任意节点（比如节点一）的安装目录下的 <code>bin</code> 目录 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入安装目录</span></span><br><span class="line"><span class="comment"># cd /usr/local/kafka-cluster/kafka-node01/bin</span></span><br></pre></td></tr></tbody></table></figure><ul><li>创建主题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建主题</span></span><br><span class="line"><span class="comment"># ./kafka-topics.sh --bootstrap-server kafka02:9092 --create --partitions 1 --replication-factor 3 --topic test</span></span><br></pre></td></tr></tbody></table></figure><ul><li>查看主题列表 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看主题列表</span></span><br><span class="line"><span class="comment"># ./kafka-topics.sh --bootstrap-server kafka02:9092 --list</span></span><br></pre></td></tr></tbody></table></figure><ul><li>查看主题详细信息 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看主题详细信息</span></span><br><span class="line"><span class="comment"># ./kafka-topics.sh --bootstrap-server kafka02:9092 --topic test --describe</span></span><br></pre></td></tr></tbody></table></figure><ul><li>启动控制台消费者 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动消费者</span></span><br><span class="line"><span class="comment"># ./kafka-console-consumer.sh --bootstrap-server kafka02:9092 --topic test --from-beginning</span></span><br></pre></td></tr></tbody></table></figure><ul><li>启动控制台生产者 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动生产者</span></span><br><span class="line"><span class="comment"># ./kafka-console-producer.sh --broker-list kafka02:9092 --topic test</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在生产者的控制台手动输入 <code>hello kafka</code>，消费者就可以消费到生产者的消息，并在控制台输出 <code>hello kafka</code>，这表示消费者成功消费了生产者发送的消息！</li></ul><h2 id="Kafka-KRaft-集群调优"><a href="#Kafka-KRaft-集群调优" class="headerlink" title="Kafka-KRaft 集群调优"></a>Kafka-KRaft 集群调优</h2><h3 id="调整-Kafka-的堆内存大小"><a href="#调整-Kafka-的堆内存大小" class="headerlink" title="调整 Kafka 的堆内存大小"></a>调整 Kafka 的堆内存大小</h3><p>若希望调整 Kafka 的堆内存大小，可以找到各个 Kafka-KRaft 集群节点的服务启动脚本文件 <code>bin/kafka-server-start.sh</code>，然后在脚本文件中修改如下参数值：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_HEAP_OPTS</span>"</span> = <span class="string">"x"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">"-Xmx2G -Xms2G"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍如何在 Linux 生产环境中，基于 KRaft 模式部署 Kafka 集群，适用于使用多台物理机器搭建集群。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署 Kafka Eagle（EFAK）单机</title>
    <link href="https://www.techgrow.cn/posts/73b15688.html"/>
    <id>https://www.techgrow.cn/posts/73b15688.html</id>
    <published>2024-11-12T13:30:00.000Z</published>
    <updated>2024-12-05T13:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/d2fe844e.html">Linux 部署 Kafka Eagle（EFAK）单机</a></li><li><a href="/posts/73b15688.html">Docker 部署 Kafka Eagle（EFAK）单机</a></li><li><a href="/posts/70bdcb69.html">Linux 生产环境部署 Kafka Eagle（EFAK）集群</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍使用 Docker-Compose 部署 Kafka-Eagle（EFAK）的单机服务，实现对 Kafka 集群的管理和监控。</p><div class="admonition note"><p class="admonition-title">Kafka Eagle（EFAK）的介绍</p><p><a href="https://github.com/smartloli/EFAK">Kafka Eagle</a>（现已改名为 EFAK，Eagle For Apache Kafka）是一款国产开源 Kafka 集群监控系统，可以用来监视 Kafka 集群的 Broker 状态、Topic 信息、IO、内存、Consumer 线程、偏移量等信息，并进行可视化图表展示。独特的 KQL 还可以通过 SQL 在线查询 Kafka 中的数据。Kafka Eagle 自身支持单机和集群两种方式进行部署，在企业的生产环境中使用得比较多，尤其是大规模 Kafka 集群环境。</p></div><span id="more"></span><h3 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h3><ul><li><p>官方项目资源</p><ul><li><a href="https://github.com/smartloli/EFAK">Kafka Eagle（EFAK）官方项目</a></li><li><a href="https://docs.kafka-eagle.org/">Kafka Eagle（EFAK）官方文档</a></li></ul></li><li><p> Docker 资源</p><ul><li><a href="https://hub.docker.com/r/nickzurich/efak">Kafka Eagle（EFAK）镜像地址</a></li><li><a href="https://github.com/nick-zh/docker-kafka-eagle">Kafka Eagle（EFAK）Docker 项目</a></li></ul></li></ul><h3 id="部署规划"><a href="#部署规划" class="headerlink" title="部署规划"></a>部署规划</h3><table><thead><tr><th>组件</th><th>版本</th><th>部署方式</th><th>说明</th></tr></thead><tbody><tr><td> ZooKeeper</td><td><code>3.8.4</code></td><td>Docker-Compose</td><td> 集群（三节点）</td></tr><tr><td>Kafka</td><td><code>3.9.0</code></td><td>Docker-Compose</td><td> 集群（三节点）</td></tr><tr><td>MySQL</td><td><code>8.4.2</code></td><td>Docker-Compose</td><td> 单机</td></tr><tr><td> Kafka Eagle（EFAK）</td><td><code>3.0.1</code></td><td>Docker-Compose</td><td> 单机</td></tr></tbody></table><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在部署 Kafka Eagle 之前，需要将 Kafka 集群和 MySQL 提前部署好。值得一提的是，如果项目中已有 Kafka 集群和 MySQL 服务正在运行，则可以忽略跳过二者的部署操作。</p><h3 id="MySQL-部署"><a href="#MySQL-部署" class="headerlink" title="MySQL 部署"></a>MySQL 部署</h3><ul><li><a href="/posts/2669f243.html">Docker 部署 MySQL 8</a></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Kafka Eagle（EFAK）需要一个数据库来存储其配置数据，如用户数据、Kafka 集群的监控指标数据等。</li><li>在默认情况下，Kafka Eagle（EFAK）使用的是 SQLite，而 SQLite 是存储在 EFAK 安装位置的嵌入式数据库。</li></ul></div><h3 id="Kafka-集群部署"><a href="#Kafka-集群部署" class="headerlink" title="Kafka 集群部署"></a>Kafka 集群部署</h3><ul><li><a href="/posts/d2c9b56d.html">Docker 搭建 Kafka 集群</a></li></ul><div class="admonition note"><p class="admonition-title">提示</p><ul><li>本文使用的 Kafka 集群是依赖于 Zookeeper 集群的，因此需要将 Zookeeper 集群提前搭建起来。</li><li>值得一提的是，从 Kafka <code>2.8.0</code> 版本开始，Kafka 自身实现了 <code>Raft</code> 分布式一致性机制，这意味着 Kafka 集群是可以脱离 ZooKeeper 独立运行的。</li></ul></div><h3 id="完整的-YML-配置"><a href="#完整的-YML-配置" class="headerlink" title="完整的 YML 配置"></a>完整的 YML 配置</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>下述 <code>docker-compose.yml</code> 配置文件的内容可以直接复用，只需要简单更改数据卷（<code>volumes</code>）的配置，并将 <code>192.168.56.112</code> 更改为你自己宿主机的 IP 地址即可。</p></div><p>严格按照上述教程，通过 Docker-Compose 成功部署 Kafka 集群和 MySQL 后，<code>docker-compose.yml</code> 配置文件的完整内容如下所示：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.4.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"mysqld"</span>, <span class="string">"--mysql-native-password=ON"</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/mysql:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD-SHELL"</span>, <span class="string">"mysqladmin ping -h localhost"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">30s</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper01</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">ruok</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper01/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper01/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper02</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper02</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">ruok</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper02/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper02/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper03</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper03</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">ruok</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper03/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper03/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">kafka01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/kafka:3.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka01</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9093</span><span class="string">:9093</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_NODE_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_LISTENERS:</span> <span class="string">PLAINTEXT://:9093</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://192.168.56.112:9093</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper01:2181,zookeeper02:2181,zookeeper03:2181/kafka</span></span><br><span class="line">      <span class="attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"kafka-topics.sh"</span>, <span class="string">"--bootstrap-server"</span>, <span class="string">"kafka01:9093,kafka02:9094,kafka03:9095"</span>, <span class="string">"--list"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">15s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">30s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/kafka/kafka01:/bitnami/kafka</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">zookeeper01:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper02:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper03:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/kafka:3.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka02</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka02</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9094</span><span class="string">:9094</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_NODE_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_LISTENERS:</span> <span class="string">PLAINTEXT://:9094</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://192.168.56.112:9094</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper01:2181,zookeeper02:2181,zookeeper03:2181/kafka</span></span><br><span class="line">      <span class="attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"kafka-topics.sh"</span>, <span class="string">"--bootstrap-server"</span>, <span class="string">"kafka01:9093,kafka02:9094,kafka03:9095"</span>, <span class="string">"--list"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">15s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">30s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/kafka/kafka02:/bitnami/kafka</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">zookeeper01:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper02:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper03:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/kafka:3.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka03</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka03</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9095</span><span class="string">:9095</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_NODE_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_LISTENERS:</span> <span class="string">PLAINTEXT://:9095</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://192.168.56.112:9095</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper01:2181,zookeeper02:2181,zookeeper03:2181/kafka</span></span><br><span class="line">      <span class="attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"kafka-topics.sh"</span>, <span class="string">"--bootstrap-server"</span>, <span class="string">"kafka01:9093,kafka02:9094,kafka03:9095"</span>, <span class="string">"--list"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">15s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">30s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/kafka/kafka03:/bitnami/kafka</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">zookeeper01:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper02:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper03:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">distributed-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Kafka-Eagle-单机部署"><a href="#Kafka-Eagle-单机部署" class="headerlink" title="Kafka Eagle 单机部署"></a>Kafka Eagle 单机部署</h2><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><ul><li>创建数据库，用于 Kafka Eagle（EFAK）存储 Kafka 的监控指标数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE efak DEFAULT CHARACTER SET utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建数据库用户并授权访问，用于 Kafka Eagle（EFAK）连接 MySQL</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户</span><br><span class="line">CREATE USER <span class="string">'efak'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line">-- 用户授权</span><br><span class="line">GRANT ALL PRIVILEGES ON efak.* TO <span class="string">'efak'</span>@<span class="string">'%'</span>;</span><br><span class="line"></span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><ul><li>(1) 在初始化 MySQL 数据库时，只需要创建数据库，而不需要手动创建数据库表。这是因为 Kafka Eagle（EFAK）会在启动的时候自动创建所需的<a href="../../../asset/2024/12/kafka-eagle-db-tables.png">数据库表</a>，前提是 Kafka Eagle（EFAK）用于连接 MySQL 的用户有对应的数据库操作权限。</li><li>(2) 值得一提的是，当不使用 MySQL 来存储 Kafka 的监控指标数据时，Kafka Eagle（EFAK）默认会使用 SQlite 作为数据库。</li></ul></div><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>下述配置内容是在上面用于部署 Kafka 集群和 MySQL 的 <code>docker-compose.yml</code> 配置文件的基础上更改而来的，其主要变化有以下几点：</li><li>(1) 新增 Kafka Eagle（EFAK）的配置</li><li> (2) Kafka 容器新增 JMX 服务的配置</li><li> (3) 去掉 Kafka 容器启动时的健康检测配置（<code>healthcheck</code>）</li><li>(4) 更改 ZooKeeper 容器的 "四字命令" 配置为 <code>mntr,conf,ruok,stat</code></li></ul></div><hr><div class="admonition note"><p class="admonition-title">为什么要去掉 Kafka 容器启动时的健康检测</p><ul><li>这是因为 Kafka Eagle（EFAK）需要依赖 Kafka 的 JMX 服务来对 Kafaka 实现监控，可是一旦启用 JMX，在 Kafka 容器内部不能再执行类似 <code>kafka-topics.sh --bootstrap-server xxx --list</code> 这样的命令，否则会抛出 JMX 端口占用冲突的异常。</li></ul></div><hr><div class="admonition note"><p class="admonition-title">为什么要更改 ZooKeeper 容器的四字命令配置</p><ul><li>这是因为 Kafka Eagle（EFAK）需要依赖 ZooKeeper 的 "四字命令" 来对 ZooKeeper 实现监控。在默认情况下，ZooKeeper 会禁用 "四字命令"，这样会导致 Kafka Eagle（EFAK）无法正常监控 ZooKeeper 的运行状态，所以需要启用下面这几个 "四字命令"。</li><li><code>ruok</code>：用于检查 Zookeeper 服务是否正常运行。</li><li><code>conf</code>：返回当前 Zookeeper 集群的配置，例如节点配置、数据目录等。</li><li><code>stat</code>：返回 Zookeeper 节点的状态，包括当前连接数、Zookeeper 节点的版本、日志文件信息等。</li><li><code>mntr</code>：返回 Zookeeper 的监控信息，包括各个节点的状态、同步信息等，通常用于健康检测和性能监控。</li></ul></div><ul><li>更改上面用于部署 Kafka 集群和 MySQL 的 <code>docker-compose.yml</code> 配置文件，并添加 Kafka Eagle（EFAK）的配置，完整的配置内容如下所示：</li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.4.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"mysqld"</span>, <span class="string">"--mysql-native-password=ON"</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/mysql:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD-SHELL"</span>, <span class="string">"mysqladmin ping -h localhost"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">30s</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">zookeeper01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper01</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">mntr,conf,ruok,stat</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper01/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper01/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper02</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper02</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">mntr,conf,ruok,stat</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper02/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper02/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper03</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zookeeper03</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">mntr,conf,ruok,stat</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper01:2888:3888;2181</span> <span class="string">server.2=zookeeper02:2888:3888;2181</span> <span class="string">server.3=zookeeper03:2888:3888;2181</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo ruok | nc localhost 2181 | grep imok"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">20s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper03/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/zookeeper/zookeeper03/datalog:/datalog</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">kafka01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/kafka:3.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka01</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9093</span><span class="string">:9093</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">19999</span><span class="string">:19999</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_NODE_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_LISTENERS:</span> <span class="string">PLAINTEXT://:9093</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://192.168.56.112:9093</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper01:2181,zookeeper02:2181,zookeeper03:2181/kafka</span></span><br><span class="line">      <span class="attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_PORT:</span> <span class="number">19999</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_OPTS:</span> <span class="string">'-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=kafka01 -Dcom.sun.management.jmxremote.port=19999'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/kafka/kafka01:/bitnami/kafka</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">zookeeper01:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper02:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper03:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/kafka:3.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka02</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka02</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9094</span><span class="string">:9094</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">29999</span><span class="string">:29999</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_NODE_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_LISTENERS:</span> <span class="string">PLAINTEXT://:9094</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://192.168.56.112:9094</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper01:2181,zookeeper02:2181,zookeeper03:2181/kafka</span></span><br><span class="line">      <span class="attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_PORT:</span> <span class="number">29999</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_OPTS:</span> <span class="string">'-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=kafka02 -Dcom.sun.management.jmxremote.port=29999'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/kafka/kafka02:/bitnami/kafka</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">zookeeper01:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper02:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper03:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/kafka:3.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka03</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka03</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9095</span><span class="string">:9095</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">39999</span><span class="string">:39999</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_NODE_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_LISTENERS:</span> <span class="string">PLAINTEXT://:9095</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://192.168.56.112:9095</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper01:2181,zookeeper02:2181,zookeeper03:2181/kafka</span></span><br><span class="line">      <span class="attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_PORT:</span> <span class="number">39999</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_OPTS:</span> <span class="string">'-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=kafka03 -Dcom.sun.management.jmxremote.port=39999'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/kafka/kafka03:/bitnami/kafka</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">zookeeper01:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper02:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">zookeeper03:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">efak:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nickzurich/efak:3.0.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">efak</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8048</span><span class="string">:8048</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">EFAK_CLUSTER_ZK_LIST:</span> <span class="string">zookeeper01:2181,zookeeper02:2181,zookeeper03:2181/kafka</span></span><br><span class="line">      <span class="attr">EFAK_CLUSTER_KAFKA_EAGLE_OFFSET_STORAGE:</span> <span class="string">kafka</span></span><br><span class="line">      <span class="attr">EFAK_DB_USERNAME:</span> <span class="string">efak</span></span><br><span class="line">      <span class="attr">EFAK_DB_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">EFAK_DB_DRIVER:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">EFAK_DB_URL:</span> <span class="string">jdbc:mysql://mysql:3306/efak?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka03</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">distributed-network</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">distributed-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">重要参数说明</p><ul><li><code>EFAK_CLUSTER_ZK_LIST</code>：指定 ZooKeeper 集群的节点列表。</li><li><code>EFAK_CLUSTER_KAFKA_EAGLE_OFFSET_STORAGE</code>：指定 Kafka 集群存储 Offset 的位置。</li><li><code>EFAK_DB_USERNAME</code>：指定 Kafka Eagle（EFAK）连接数据库的用户名。</li><li><code>EFAK_DB_PASSWORD</code>：指定 Kafka Eagle（EFAK）连接数据库的密码。</li><li><code>EFAK_DB_DRIVER</code>：指定 Kafka Eagle（EFAK）连接数据库的驱动。</li><li><code>EFAK_DB_URL</code>：指定 Kafka Eagle（EFAK）连接数据库的 URL。</li><li><code>KAFKA_JMX_PORT</code>：指定 Kafka 使用的 JMX 监听端口。</li><li><code>KAFKA_JMX_OPTS</code>：通过 Java 的系统属性配置 JMX 的详细选项，比如是否启用 JMX、RMI 主机名、RMI 端口、JMX 的身份认证、JMX 的 SSL 证书 等。</li><li><code>KAFKA_CFG_ADVERTISED_LISTENERS: PLAINTEXT://192.168.56.112:9095</code>：<strong>这里的 <code>192.168.56.112</code> 是宿主机的 IP 地址或者公网 IP 地址。如果配置错误，会导致外部 Kafka 客户端无法正常连接 Docker 容器内的 Kafka 服务器</strong>。</li></ul></div><ul><li>创建并启动 Kafka Eagle（EFAK） 容器（<strong>请必须保证操作系统有 2G 空闲内存，否则容器会启动失败</strong>）</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sudo docker-compose up -d</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>当不使用 MySQL 来存储 Kafka 的监控指标数据时，Kafka Eagle（EFAK）默认会使用 SQlite 作为数据库；此时如果希望持久化容器内的 SQlite 数据文件，可以通过数据卷挂载 Kafka Eagle（EFAK）容器内的 <code>/hadoop/efak/db/ke.db</code> 文件到宿主机内。</li><li>在停止 Kafka 集群时，一定要等 Kafka 所有节点进程全部停止后，再停止 Zookeeper 集群。因为 Zookeeper 集群当中记录着 Kafka 集群的相关信息，Zookeeper 集群一旦先停止，Kafka 集群就没有办法再获取停止进程的信息，最后只能手动杀死 Kafka 进程了。</li></ul></div><h3 id="验证容器"><a href="#验证容器" class="headerlink" title="验证容器"></a>验证容器</h3><h4 id="查看容器状态"><a href="#查看容器状态" class="headerlink" title="查看容器状态"></a>查看容器状态</h4><ul><li>查看所有 Kafka Eagle（EFAK） 容器的运行状态 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ebc5136d2afb   nickzurich/efak:3.0.1   "entrypoint.sh"          44 seconds ago   Up 42 seconds             0.0.0.0:8048-&gt;8048/tcp, :::8048-&gt;8048/tcp, 8080/tcp                       efak</span><br><span class="line">ed37bf8c8eac   bitnami/kafka:3.9.0     "/opt/bitnami/script…"   17 minutes ago   Up 16 minutes             9092/tcp, 0.0.0.0:9093-&gt;9093/tcp, :::9093-&gt;9093/tcp                       kafka01</span><br><span class="line">c09ca638d783   bitnami/kafka:3.9.0     "/opt/bitnami/script…"   17 minutes ago   Up 16 minutes             9092/tcp, 0.0.0.0:9095-&gt;9095/tcp, :::9095-&gt;9095/tcp                       kafka03</span><br><span class="line">9f2636e03ad3   bitnami/kafka:3.9.0     "/opt/bitnami/script…"   17 minutes ago   Up 16 minutes             9092/tcp, 0.0.0.0:9094-&gt;9094/tcp, :::9094-&gt;9094/tcp                       kafka02</span><br><span class="line">d82f6b11979c   zookeeper:3.8.4         "/docker-entrypoint.…"   17 minutes ago   Up 17 minutes (healthy)   2888/tcp, 3888/tcp, 8080/tcp, 0.0.0.0:2182-&gt;2181/tcp, :::2182-&gt;2181/tcp   zookeeper02</span><br><span class="line">639310a6bdd2   zookeeper:3.8.4         "/docker-entrypoint.…"   17 minutes ago   Up 17 minutes (healthy)   2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, :::2181-&gt;2181/tcp, 8080/tcp   zookeeper01</span><br><span class="line">9d255997e30e   zookeeper:3.8.4         "/docker-entrypoint.…"   17 minutes ago   Up 17 minutes (healthy)   2888/tcp, 3888/tcp, 8080/tcp, 0.0.0.0:2183-&gt;2181/tcp, :::2183-&gt;2181/tcp   zookeeper03</span><br><span class="line">3361ac6e2d10   mysql:8.4.2             "docker-entrypoint.s…"   17 minutes ago   Up 17 minutes (healthy)   33060/tcp, 0.0.0.0:3309-&gt;3306/tcp, :::3309-&gt;3306/tcp                      mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>若 Kafka Eagle（EFAK）容器启动失败，可以通过以下命令查看容器的启动日志来排查问题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动日志</span></span><br><span class="line">sudo docker logs -f --tail 100 efak</span><br></pre></td></tr></tbody></table></figure><h4 id="访问管理页面"><a href="#访问管理页面" class="headerlink" title="访问管理页面"></a>访问管理页面</h4><ul><li>(1) 浏览器通过 <code>http://192.168.56.112:8048</code> 访问 Kafka Eagle（EFAK）的控制台管理页面（如下所示），默认的登录账号和密码是 <code>admin/123456</code>，请记得将 <code>192.168.56.112</code> 更改为你自己宿主机的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/kafka-eagle-1.png"></p><ul><li>(2) 登录 Kafka Eagle（EFAK）的控制台后，浏览器通过 <code>http://192.168.56.112:8048/tv</code> 就可以访问监控数据大屏的页面（如下所示），请记得将 <code>192.168.56.112</code> 更改为你自己宿主机的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/kafka-eagle-2.png"></p><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li>在默认情况下，Kafka Eagle（EFAK）的监控数据大屏页面不会实时更新显示 Kafka 集群的监控指标图表，比如 CPU 与内存的使用率、生产速率、消费速率等。</li><li>如果需要在 Kafka Eagle（EFAK）的 UI 中实时显示 Kafka 集群的监控指标图表，可以通过给 Kafka Eagle（EFAK）容器添加环境变量 <code>EFAK_METRICS_CHARTS: true</code> 来开启该功能。</li><li>值得一提的是，Kafka 集群监控指标图表的渲染和数据获取会消耗一定的资源，如果 Kafka 的集群规模较大或者系统资源有限，建议通过禁用 <code>EFAK_METRICS_CHARTS</code> 选项（默认禁用）来减少系统负载。</li></ul></div><ul><li>(3) 当 Kafka 的 JMX 服务配置正确后，浏览器通过 <code>http://192.168.56.112:8048/cluster/kafka</code> 就可以访问 Kafka 的监控页面（如下所示），请记得将 <code>192.168.56.112</code> 更改为你自己宿主机的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/kafka-eagle-3.png"></p><ul><li>(4) 当 ZooKeeper 的 “四字命令” 配置正确后，浏览器通过 <code>http://192.168.56.112:8048/cluster/zookeeper</code> 就可以访问 ZooKeeper 的监控页面（如下所示），请记得将 <code>192.168.56.112</code> 更改为你自己宿主机的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/kafka-eagle-4.png"></p><h2 id="Kafka-Eagle-部署问题"><a href="#Kafka-Eagle-部署问题" class="headerlink" title="Kafka Eagle 部署问题"></a>Kafka Eagle 部署问题</h2><h3 id="JMX-端口占用冲突"><a href="#JMX-端口占用冲突" class="headerlink" title="JMX 端口占用冲突"></a>JMX 端口占用冲突</h3><p>当 Kafka 容器新增 JMX 服务的配置后，在 Kafka 容器内部执行类似 <code>kafka-console-producer.sh --broker-list xxx --topic test</code> 这样的命令，会抛出 JMX 端口占用冲突的异常（如下所示）。解决方法是只在 Kafka 容器外执行管理命令。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.rmi.server.ExportException: Port already in use: 19999; nested exception is: </span><br><span class="line">java.net.BindException: Address already in use</span><br><span class="line">at java.rmi/sun.rmi.transport.tcp.TCPTransport.listen(TCPTransport.java:346)</span><br><span class="line">at java.rmi/sun.rmi.transport.tcp.TCPTransport.exportObject(TCPTransport.java:243)</span><br><span class="line">at java.rmi/sun.rmi.transport.tcp.TCPEndpoint.exportObject(TCPEndpoint.java:415)</span><br><span class="line">at java.rmi/sun.rmi.transport.LiveRef.exportObject(LiveRef.java:147)</span><br><span class="line">at java.rmi/sun.rmi.server.UnicastServerRef.exportObject(UnicastServerRef.java:235)</span><br><span class="line">at java.rmi/sun.rmi.registry.RegistryImpl.setup(RegistryImpl.java:223)</span><br><span class="line">at java.rmi/sun.rmi.registry.RegistryImpl.&lt;init&gt;(RegistryImpl.java:182)</span><br><span class="line">at jdk.management.agent/sun.management.jmxremote.SingleEntryRegistry.&lt;init&gt;(SingleEntryRegistry.java:49)</span><br><span class="line">at jdk.management.agent/sun.management.jmxremote.ConnectorBootstrap.exportMBeanServer(ConnectorBootstrap.java:859)</span><br><span class="line">at jdk.management.agent/sun.management.jmxremote.ConnectorBootstrap.startRemoteConnectorServer(ConnectorBootstrap.java:480)</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">相关 Issues 案例</p><ul><li><a href="https://github.com/bitnami/charts/issues/12917"> Kafka JMX Exporter, Port already in use: 5555</a></li><li><a href="https://github.com/wurstmeister/kafka-docker/issues/171">when KAFKA_JMX_PORT specified, cannot use kafka-console-producer</a></li></ul></div><h3 id="Kafka-Eagle-集群部署"><a href="#Kafka-Eagle-集群部署" class="headerlink" title="Kafka Eagle 集群部署"></a>Kafka Eagle 集群部署</h3><p>在生产环境中，往往都需要部署多个 Kafka Eagle（EFAK） 实例，以此实现高可用。Kafka Eagle（EFAK）是天生支持集群（分布式）部署的，但由于 Kafka Eagle（EFAK）官方目前构建的 Docker 镜像并不支持集群部署功能。因此，如果需要部署 Kafka Eagle（EFAK）集群，只能是手动进行部署或者自行构建 Docker 镜像来实现，其中手动部署的教程请参考 <a href="https://docs.kafka-eagle.org/2.installation/2.installonlinuxmac#id-2.2.7-start-the-efak-server-distributed">官方文档</a> 或者 <a href="/posts/70bdcb69.html">本站教程</a>。</p><h3 id="挂载-Kafka-Eagle-配置文件无效"><a href="#挂载-Kafka-Eagle-配置文件无效" class="headerlink" title="挂载 Kafka Eagle 配置文件无效"></a>挂载 Kafka Eagle 配置文件无效</h3><p>当使用的 Kafka Eagle（EFAK）镜像是 <code>3.0.1</code> 版本时，不能再通过数据卷挂载配置文件到容器内的方式（如下所示）来指定 <code>system-config.properties</code> 配置文件。因为 Kafka Eagle（EFAK）容器在每次启动时，都会拷贝默认的 <code>system-config.properties</code> 配置文件进行覆盖，导致外部挂载的配置文件也被 “重置”，详见<a href="https://github.com/nick-zh/docker-kafka-eagle/blob/main/entrypoint.sh">这里</a>的脚本代码。解决办法是，在 Docker-Compose 中通过环境变量来指定 Kafka Eagle（EFAK）的配置参数。值得一提的是，Kafka Eagle（EFAK）镜像支持的所有环境变量可以从 <a href="https://github.com/nick-zh/docker-kafka-eagle/blob/main/Dockerfile">这里</a> 获取得到。</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">efak:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nickzurich/efak:3.0.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">efak</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8048</span><span class="string">:8048</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/efak/system-config.properties:/opt/efak/conf/system-config.properties</span>    <span class="comment"># 挂载的配置文件不会生效，且会被覆盖修改</span></span><br></pre></td></tr></tbody></table></figure><h3 id="内存不足导致容器启动失败"><a href="#内存不足导致容器启动失败" class="headerlink" title="内存不足导致容器启动失败"></a>内存不足导致容器启动失败</h3><p>在 Kafka Eagle（EFAK）的项目源码中，有一个 <code>ke.sh</code> <a href="https://github.com/smartloli/EFAK/blob/main/efak-web/src/main/resources/bin/ke.sh">启动脚本</a>，该脚本里面有以下一行代码：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KE_JAVA_OPTS=<span class="string">"-server -Xmx2g -Xms2g -XX:MaxGCPauseMillis=20 -XX:+UseG1GC -XX:MetaspaceSize=128m -XX:InitiatingHeapOccupancyPercent=35 -XX:G1HeapRegionSize=16M -XX:MinMetaspaceFreeRatio=50 -XX:MaxMetaspaceFreeRatio=80"</span></span><br></pre></td></tr></tbody></table></figure><p>其中 JVM 参数 <code>-Xms2g</code> 指定了初始堆内存为 <code>2G</code>，因此当操作系统的空闲内存不足 <code>2G</code> 时，会导致 Kafka Eagle（EFAK）容器启动失败。解决办法是，更改 Shell 脚本代码并重新构建 Kafka Eagle（EFAK）镜像，或者增加机器的物理内存（强烈推荐）。</p><h3 id="监控大屏无法实时更新显示"><a href="#监控大屏无法实时更新显示" class="headerlink" title="监控大屏无法实时更新显示"></a>监控大屏无法实时更新显示</h3><p>在 Kafka Eagle（EFAK）的控制台中访问监控大屏页面时，发现即使有生产者正在发送消息和消费者正在消费消息，Kafka 集群的监控指标图表也无法实时更新显示或者没有任何监控数据显示（如下图所示）。这是因为 Kafka Eagle（EFAK）默认禁用了 Kafka 集群的监控指标图表实时更新。</p><p><img data-src="../../../asset/2024/12/kafka-eagle-7.png"></p><p>解决办法是，通过给 Kafka Eagle（EFAK）容器添加环境变量 <code>EFAK_METRICS_CHARTS: true</code> 来开启 Kafka 集群的监控指标图表实时更新。</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">efak:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nickzurich/efak:3.0.1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">EFAK_METRICS_CHARTS:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Kafka Eagle（EFAK）的控制台中，Kafka 集群监控指标图表的渲染和数据获取会消耗一定的资源。如果 Kafka 的集群规模较大或者系统资源有限，建议通过禁用 <code>EFAK_METRICS_CHARTS</code> 选项（默认禁用）来减少系统负载。</p></div><h3 id="Kafka-Eagle-无法监控自己"><a href="#Kafka-Eagle-无法监控自己" class="headerlink" title="Kafka Eagle 无法监控自己"></a>Kafka Eagle 无法监控自己</h3><p>在 Kafka Eagle（EFAK）的控制台中访问 EfakServer 的监控页面时，发现无法正常显示 EfakServer 的运行状态，监控页面一直显示提示信息 <code>Processing</code> 或者节点状态显示为 <code>Offline</code>，如下图所示：</p><p><img data-src="../../../asset/2024/12/kafka-eagle-8.png"></p><p>这个问题可以忽略不解决，猜测（待验证）只有当 Kafka Eagle（EFAK）以集群（分布式）模式部署时，EfakServer 的监控页面才会正常显示相关监控信息，详细说明请看 <a href="/posts/70bdcb69.html#Kafka-Eagle-%E6%97%A0%E6%B3%95%E7%9B%91%E6%8E%A7%E8%87%AA%E5%B7%B1">这里</a>。</p><h3 id="无法监控-ZooKeeper-集群"><a href="#无法监控-ZooKeeper-集群" class="headerlink" title="无法监控 ZooKeeper 集群"></a>无法监控 ZooKeeper 集群</h3><p>在 Kafka Eagle（EFAK）的控制台中访问 ZooKeeper 的监控页面时，发现无法正常显示 ZooKeeper 的运行状态，如下图所示：</p><p><img data-src="../../../asset/2024/12/kafka-eagle-6.png"></p><p>这通常是由于 ZooKeeper 容器没有配置 “四字命令” 或者 “四字命令” 配置不正确导致的，因为 Kafka Eagle（EFAK）是基于 ZooKeeper 的 “四字命令” 来实现 ZooKeeper 运行状态的监控。解决办法是，为 ZooKeeper 容器添加对应的 “四字命令” 配置，如下所示：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zookeeper:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">zookeeper:3.8.4</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">ZOO_4LW_COMMANDS_WHITELIST:</span> <span class="string">mntr,conf,ruok,stat</span></span><br></pre></td></tr></tbody></table></figure><h3 id="无法监控-Kafka-集群"><a href="#无法监控-Kafka-集群" class="headerlink" title="无法监控 Kafka 集群"></a>无法监控 Kafka 集群</h3><p>在 Kafka Eagle（EFAK）的控制台中访问 Kafka 的监控页面时，发现无法正常显示 Kafka 的运行状态，如下图所示：</p><p><img data-src="../../../asset/2024/12/kafka-eagle-5.png"></p><p>这通常是由于 Kafka 容器没有配置 JMX 服务或者 JMX 服务配置不正确导致的，因为 Kafka Eagle（EFAK）是基于 JMX 服务来实现 Kafka 运行状态的监控。解决办法是，为 Kafka 容器添加对应的 JMX 配置，如下所示：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/kafka:3.9.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9092</span><span class="string">:9092</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">19999</span><span class="string">:19999</span>   <span class="comment"># 映射 JMX 端口</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_PORT:</span> <span class="number">19999</span>   <span class="comment"># 指定 JMX 端口</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_OPTS:</span> <span class="string">'-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=kafka -Dcom.sun.management.jmxremote.port=19999'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1965683">构建 Kafka Eagle 的 Docker 镜像</a></li><li><a href="https://juejin.cn/post/7310569308915220492">通过 Docker-Compose 快速部署 EFAK</a></li><li><a href="https://www.cnblogs.com/scfssq/p/17390955.html">Docker-Compose 部署 Kafka 和 Kafka Eagle</a></li><li><a href="/posts/70bdcb69.html">Linux 生产环境部署 Kafka-Eagle（EFAK）集群</a></li><li><a href="/posts/d2fe844e.html">Linux 部署 Kafka-Eagle（EFAK）单机</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何使用 Docker 部署 Kafka Eagle 的单机服务，实现对 Kafka 集群的监控。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux 部署 Kafka-Eagle（EFAK）单机</title>
    <link href="https://www.techgrow.cn/posts/d2fe844e.html"/>
    <id>https://www.techgrow.cn/posts/d2fe844e.html</id>
    <published>2024-11-08T13:30:00.000Z</published>
    <updated>2024-12-07T13:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/d2fe844e.html">Linux 部署 Kafka Eagle（EFAK）单机</a></li><li><a href="/posts/73b15688.html">Docker 部署 Kafka Eagle（EFAK）单机</a></li><li><a href="/posts/70bdcb69.html">Linux 生产环境部署 Kafka Eagle（EFAK）集群</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍在 Linux 系统上，手动部署 Kafka-Eagle（EFAK）的单机服务，实现对 Kafka 集群的管理和监控，适用于 CentOS/Debian/Ubuntu 等发行版。</p><h2 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h2><ul><li><a href="https://github.com/smartloli/EFAK">Kafka Eagle（EFAK）官方项目</a></li><li><a href="https://docs.kafka-eagle.org/">Kafka Eagle（EFAK）官方文档</a></li><li><a href="https://github.com/smartloli/kafka-eagle-bin/tags">Kafka Eagle（EFAK）官方下载</a></li></ul><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="部署依赖服务"><a href="#部署依赖服务" class="headerlink" title="部署依赖服务"></a>部署依赖服务</h3><ul><li>在部署 Kafka Eagle（EFAK）之前，请确保已经部署好 ZooKeeper 集群、Kafka 集群、MySQL。</li></ul><table><thead><tr><th>服务</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> ZooKeeper</td><td><code>3.8.4</code></td><td>集群（三节点）</td></tr><tr><td>Kafka</td><td><code>3.9.0</code></td><td>集群（三节点）</td></tr><tr><td>MySQL</td><td><code>8.4.2</code></td><td>单机</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">提示</p><ul><li>从 Kafka <code>2.8.0</code> 版本开始，Kafka 自身实现了 <code>Raft</code> 分布式一致性机制，这意味着 Kafka 集群是可以脱离 ZooKeeper 独立运行的。但是，本文使用的 Kafka 集群是依赖于 ZooKeeper 的，因此需要提前将 ZooKeeper 集群部署好。</li><li>Kafka Eagle（EFAK）集群需要一个数据库来统一存储其配置数据，如用户数据、Kafka 集群的监控指标数据等。当不使用 MySQL 来存储 Kafka 的监控指标数据时，Kafka Eagle（EFAK）默认使用的是 SQLite，而 SQLite 是存储在 EFAK 安装位置的嵌入式数据库。</li></ul></div><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><ul><li>创建数据库，用于 Kafka Eagle（EFAK）存储 Kafka 的监控指标数据 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE efak DEFAULT CHARACTER SET utf8mb4;</span><br></pre></td></tr></tbody></table></figure><ul><li>创建数据库用户并授权访问，用于 Kafka Eagle（EFAK）连接 MySQL</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户</span><br><span class="line">CREATE USER <span class="string">'efak'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line">-- 用户授权</span><br><span class="line">GRANT ALL PRIVILEGES ON efak.* TO <span class="string">'efak'</span>@<span class="string">'%'</span>;</span><br><span class="line"></span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>在初始化 MySQL 数据库时，只需要创建数据库，而不需要手动创建数据库表。这是因为 Kafka Eagle（EFAK）会在启动的时候自动创建所需的 <a href="../../../asset/2024/12/linux-efak-db-tables.png">数据库表</a>，前提是 Kafka Eagle（EFAK）用于连接 MySQL 的用户有对应的数据库操作权限。</p></div><h2 id="Kafka-Eagle-单机部署"><a href="#Kafka-Eagle-单机部署" class="headerlink" title="Kafka Eagle 单机部署"></a>Kafka Eagle 单机部署</h2><p>本节将部署 Kafka Eagle（EFAK）单实例，以实现对 Kafka 集群的管理和监控。值得一提的是，Kafka Eagle（EFAK）的运行依赖于 JDK 1.8+，请提前安装并配置好 Java 运行环境，包括添加 <code>JAVA_HOME</code> 系统环境变量。</p><h3 id="单机部署规划"><a href="#单机部署规划" class="headerlink" title="单机部署规划"></a>单机部署规划</h3><table><thead><tr><th>服务</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td> Kafka Eagle（EFAK）</td><td><code>3.0.1</code></td><td>单机</td></tr></tbody></table><h3 id="下载安装文件"><a href="#下载安装文件" class="headerlink" title="下载安装文件"></a>下载安装文件</h3><ul><li>浏览器访问 Kafka Eagle（EFAK）的 <a href="https://github.com/smartloli/kafka-eagle-bin/tags">GitHub 项目</a>，然后选择最新版本的二进制包进行下载并解压 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">$ wget https://github.com/smartloli/kafka-eagle-bin/archive/refs/tags/v3.0.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line">$ tar -xvf v3.0.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line">$ <span class="built_in">cd</span> kafka-eagle-bin-3.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次解压文件</span></span><br><span class="line">$ tar -xvf efak-web-3.0.1-bin.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动解压目录</span></span><br><span class="line">$ sudo mv efak-web-3.0.1 /opt/efak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件统一授权</span></span><br><span class="line">$ sudo chmod -R 777 /opt/efak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本授权执行</span></span><br><span class="line">$ sudo chmod +x /opt/efak/bin/ke.sh</span><br></pre></td></tr></tbody></table></figure><h3 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h3><div class="admonition note"><p class="admonition-title">提示</p><p>Kafka Eagle（EFAK）是支持管理多个 Kafka 集群的，由于笔者只部署了一个 Kafka 集群，因此在下述配置内容中只配置了一个 Kafka 集群。</p></div><ul><li>编辑 Kafka Eagle（EFAK）的配置文件 <code>system-config.properties</code></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份配置文件</span></span><br><span class="line">$ cp /opt/efak/conf/system-config.properties /opt/efak/conf/system-config.properties.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">$ vi /opt/efak/conf/system-config.properties</span><br></pre></td></tr></tbody></table></figure><ul><li>然后更改配置文件的内容，更改后的完整配置内容如下所示 </li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># multi zookeeper &amp; kafka cluster list</span></span><br><span class="line"><span class="comment"># Settings prefixed with 'kafka.eagle.' will be deprecated, use 'efak.' instead</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.zk.cluster.alias</span>=<span class="string">cluster1</span></span><br><span class="line"><span class="meta">cluster1.zk.list</span>=<span class="string">192.168.1.102:2181,192.168.1.103:2181,192.168.1.104:2181/kafka</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># zookeeper enable acl</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.zk.acl.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.zk.acl.schema</span>=<span class="string">digest</span></span><br><span class="line"><span class="meta">cluster1.zk.acl.username</span>=<span class="string">test</span></span><br><span class="line"><span class="meta">cluster1.zk.acl.password</span>=<span class="string">test123</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># broker size online list</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.broker.size</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># zk client thread limit</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">kafka.zk.limit.size</span>=<span class="string">32</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK webui port</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.webui.port</span>=<span class="string">8048</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># efak.cluster.mode.status=master</span></span><br><span class="line"><span class="comment"># efak.worknode.master.host=localhost</span></span><br><span class="line"><span class="comment"># efak.worknode.port=8085</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka jmx acl and ssl authenticate</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.acl</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.user</span>=<span class="string">keadmin</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.password</span>=<span class="string">keadmin123</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.ssl</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.truststore.location</span>=<span class="string">/data/ssl/certificates/kafka.truststore</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.truststore.password</span>=<span class="string">ke123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka offset storage</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.offset.storage</span>=<span class="string">kafka</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka jmx uri</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.jmx.uri</span>=<span class="string">service:jmx:rmi:///jndi/rmi://%s/jmxrmi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka metrics, 15 days by default</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.metrics.charts</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.metrics.retain</span>=<span class="string">30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka sql topic records max</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.sql.topic.records.max</span>=<span class="string">5000</span></span><br><span class="line"><span class="meta">efak.sql.topic.preview.records.max</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># delete kafka topic token</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.topic.token</span>=<span class="string">keadmin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka sasl authenticate</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.protocol</span>=<span class="string">SASL_PLAINTEXT</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.mechanism</span>=<span class="string">SCRAM-SHA-256</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.jaas.config</span>=<span class="string">org.apache.kafka.common.security.scram.ScramLoginModule required username="kafka" password="kafka-eagle";</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.client.id</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.blacklist.topics</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.cgroup.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.sasl.cgroup.topics</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka ssl authenticate</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.protocol</span>=<span class="string">SSL</span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.truststore.location</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.truststore.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.keystore.location</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.keystore.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.key.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.endpoint.identification.algorithm</span>=<span class="string">https</span></span><br><span class="line"><span class="meta">cluster1.efak.blacklist.topics</span>=<span class="string"></span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.cgroup.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">cluster1.efak.ssl.cgroup.topics</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka sqlite jdbc driver address</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># efak.driver=org.sqlite.JDBC</span></span><br><span class="line"><span class="comment"># It is important to note that the '/opt/efak/db' path must exist.</span></span><br><span class="line"><span class="comment"># efak.url=jdbc:sqlite:/opt/efak/db/ke.db</span></span><br><span class="line"><span class="comment"># efak.username=root</span></span><br><span class="line"><span class="comment"># efak.password=smartloli</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka mysql jdbc driver address</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">efak.url</span>=<span class="string">jdbc:mysql://192.168.1.107:3306/efak?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span></span><br><span class="line"><span class="meta">efak.username</span>=<span class="string">efak</span></span><br><span class="line"><span class="meta">efak.password</span>=<span class="string">123456</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在上述配置内容中，最重要的是以下几个配置项，其他配置项一般使用默认值即可 </li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># multi zookeeper &amp; kafka cluster list</span></span><br><span class="line"><span class="comment"># Settings prefixed with 'kafka.eagle.' will be deprecated, use 'efak.' instead</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.zk.cluster.alias</span>=<span class="string">cluster1</span></span><br><span class="line"><span class="meta">cluster1.zk.list</span>=<span class="string">192.168.1.102:2181,192.168.1.103:2181,192.168.1.104:2181/kafka</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># efak.cluster.mode.status=master</span></span><br><span class="line"><span class="comment"># efak.worknode.master.host=localhost</span></span><br><span class="line"><span class="comment"># efak.worknode.port=8085</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka offset storage</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">cluster1.efak.offset.storage</span>=<span class="string">kafka</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka metrics, 15 days by default</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.metrics.charts</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">efak.metrics.retain</span>=<span class="string">30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># kafka jdbc driver address</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">efak.url</span>=<span class="string">jdbc:mysql://192.168.1.107:3306/efak?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span></span><br><span class="line"><span class="meta">efak.username</span>=<span class="string">efak</span></span><br><span class="line"><span class="meta">efak.password</span>=<span class="string">123456</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">重要参数说明</p><ul><li><code>cluster1.zk.list</code>：指定 Kafka 集群一连接的 ZooKeeper 节点列表。</li><li><code>cluster1.efak.offset.storage</code>：指定 Kafka 集群一存储 Offset 的位置。</li><li><code>efak.username</code>：指定 Kafka Eagle（EFAK）连接数据库的用户名。</li><li><code>efak.password</code>：指定 Kafka Eagle（EFAK）连接数据库的密码。</li><li><code>efak.driver</code>：指定 Kafka Eagle（EFAK）连接数据库的驱动。</li><li><code>efak.url</code>：指定 Kafka Eagle（EFAK）连接数据库的 URL。</li><li><code>efak.distributed.enable</code>：指定 Kafka Eagle（EFAK）是否以集群（分布式）模式运行。</li><li><code>efak.metrics.charts</code>：在 Kafka Eagle（EFAK）的 UI 中，是否允许实时显示 Kafka 的监控指标图表。</li><li><code>efak.metrics.retain</code>：Kafka Eagle（EFAK）保留 Kafka 监控指标数据的最长时间（比如 30 天），超过设定的时间监控指标数据就会被删除。</li></ul></div><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改系统配置文件，添加环境变量</span></span><br><span class="line">$ sudo vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> KE_HOME=/opt/efak</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$KE_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使改系统配置文件的更改生效</span></span><br><span class="line">$ sudo <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></tbody></table></figure><h3 id="启动监控服务"><a href="#启动监控服务" class="headerlink" title="启动监控服务"></a>启动监控服务</h3><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在启动 Kafka Eagle（EFAK）服务之前，必须保证 ZooKeeper 集群、Kafka 集群、MySQL 已经启动并正常运行。</p></div><ul><li>启动 Kafka Eagle（EFAK）服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh start</span><br></pre></td></tr></tbody></table></figure><ul><li>Kafka Eagle（EFAK）服务正常启动后，终端输出的日志信息如下所示 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Welcome to</span><br><span class="line">    ______    ______    ___     __ __</span><br><span class="line">   / ____/   / ____/   /   |   / //_/</span><br><span class="line">  / __/     / /_      / /| |  / ,&lt;   </span><br><span class="line"> / /___    / __/     / ___ | / /| |  </span><br><span class="line">/_____/   /_/       /_/  |_|/_/ |_|  </span><br><span class="line">( Eagle For Apache Kafka® )</span><br><span class="line"></span><br><span class="line">Version v3.0.1 -- Copyright 2016-2022</span><br><span class="line">*******************************************************************</span><br><span class="line">* EFAK Service has started success.</span><br><span class="line">* Welcome, Now you can visit 'http://192.168.1.140:8048'</span><br><span class="line">* Account:admin ,Password:123456</span><br><span class="line">*******************************************************************</span><br><span class="line">* &lt;Usage&gt; ke.sh [start|status|stop|restart|stats] &lt;/Usage&gt;</span><br><span class="line">* &lt;Usage&gt; https://www.kafka-eagle.org/ &lt;/Usage&gt;</span><br><span class="line">*******************************************************************</span><br></pre></td></tr></tbody></table></figure><ul><li>若 Kafka Eagle（EFAK）服务启动失败，可以通过查看错误日志来排查问题 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /opt/efak/logs/error.log</span><br></pre></td></tr></tbody></table></figure><h3 id="管理监控服务"><a href="#管理监控服务" class="headerlink" title="管理监控服务"></a>管理监控服务</h3><ul><li>关闭 Kafka Eagle（EFAK）服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh stop</span><br></pre></td></tr></tbody></table></figure><ul><li>重启 Kafka Eagle（EFAK）服务 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh restart</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Kafka Eagle（EFAK）服务的进程信息 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh status</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2024-12-06 23:29:22] INFO : EFAK-fd34:dd83:8cb9::350 192.168.1.140 is running, [71079] .</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Kafka Eagle（EFAK）服务在 Linux 系统中的句柄数 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh stats</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">===================== TCP Connections Count  ==========================</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">     58 71079/java</span><br><span class="line">===================== ESTABLISHED/TIME_OUT Status  ====================</span><br><span class="line">    112 127.0.0.1</span><br><span class="line">     72 192.168.1.140</span><br><span class="line">      2 101.43.223.179</span><br><span class="line">      1 58.63.233.5</span><br><span class="line">      1 220.181.174.34</span><br><span class="line">      1 220.181.174.33</span><br><span class="line">      1 20.42.73.30</span><br><span class="line">      1 173.194.202.188</span><br><span class="line">      1 13.250.7.155</span><br><span class="line">===================== Connection Number Of Different States ===========</span><br><span class="line">LISTEN 72</span><br><span class="line">CLOSE_WAIT 5</span><br><span class="line">ESTABLISHED 192</span><br><span class="line">FIN_WAIT2 1</span><br><span class="line">TIME_WAIT 151</span><br><span class="line">===================== End =============================================</span><br></pre></td></tr></tbody></table></figure><ul><li>查看 Kafka Eagle（EFAK）服务的垃圾回收（GC）情况 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ke.sh gc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2024-12-06 23:40:29] INFO : EFAK Process[52129] GC.</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line">  0.00 100.00  63.29   3.99  97.86  92.33     98    0.702     0    0.000     0    0.000    0.702</span><br><span class="line">  0.00 100.00  63.29   3.99  97.86  92.33     98    0.702     0    0.000     0    0.000    0.702</span><br><span class="line">  0.00 100.00  63.29   3.99  97.86  92.33     98    0.702     0    0.000     0    0.000    0.702</span><br></pre></td></tr></tbody></table></figure><h3 id="验证监控服务"><a href="#验证监控服务" class="headerlink" title="验证监控服务"></a>验证监控服务</h3><ul><li>(1) 浏览器通过 <code>http://192.168.1.140:8048</code> 访问 Kafka Eagle（EFAK）的控制台管理页面（如下所示），默认的登录账号和密码是 <code>admin/123456</code>，请记得将 <code>192.168.1.140</code> 更改为你自己机器的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-1.png"></p><ul><li>(2) 浏览器通过 <code>http://192.168.1.140:8048/tv</code> 就可以访问监控数据大屏的页面（如下所示），请记得将 <code>192.168.1.140</code> 更改为你自己机器的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-2.png"></p><ul><li>(3) 浏览器通过 <code>http://192.168.1.140:8048/cluster/kafka</code> 就可以访问 Kafka 的监控页面（如下所示），请记得将 <code>192.168.1.140</code> 更改为你自己机器的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-3.png"></p><ul><li>(4) 浏览器通过 <code>http://192.168.1.140:8048/cluster/zookeeper</code> 就可以访问 ZooKeeper 的监控页面（如下所示），请记得将 <code>192.168.1.140</code> 更改为你自己机器的 IP 地址。</li></ul><p><img data-src="../../../asset/2024/12/linux-efak-4.png"></p><h2 id="Kafka-Eagle-部署问题"><a href="#Kafka-Eagle-部署问题" class="headerlink" title="Kafka Eagle 部署问题"></a>Kafka Eagle 部署问题</h2><h3 id="无法监控-Kafka-集群"><a href="#无法监控-Kafka-集群" class="headerlink" title="无法监控 Kafka 集群"></a>无法监控 Kafka 集群</h3><p>在 Kafka Eagle（EFAK）的控制台中访问 Kafka 的监控页面时，发现无法正常显示 Kafka 的运行状态，如下图所示：</p><p><img data-src="../../../asset/2024/12/linux-efak-6.png"></p><p>这通常是由于 Kafka 服务没有配置 JMX 服务或者 JMX 服务配置不正确导致的，因为 Kafka Eagle（EFAK）是基于 JMX 服务来实现 Kafka 运行状态的监控。解决办法是，为 Kafka 服务添加对应的 JMX 配置。</p><ul><li>(1) 如果 Kafka 服务是通过手动部署的（基于二进制安装包），那么可以在执行 <code>kafka-server-start.sh</code> 启动脚本时，添加 <code>JMX_PORT</code> 环境变量来启用 JMX 服务（如下所示），详细教程请参考 <a href="https://stackoverflow.com/questions/36708384/how-to-enable-remote-jmx-on-kafka-brokers-for-jmxtool">这里</a></li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMX_PORT=19999 ./kafka-server-start.sh -daemon ../config/server.properties</span><br></pre></td></tr></tbody></table></figure><ul><li>(2) 如果 Kafka 服务是通过 Docker-Compose 部署的，那么可以参考以下配置内容，详细教程请参考 <a href="/posts/73b15688.html">这里</a></li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/kafka:3.9.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9092</span><span class="string">:9092</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">19999</span><span class="string">:19999</span>   <span class="comment"># 映射 JMX 端口</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_PORT:</span> <span class="number">19999</span>   <span class="comment"># 指定 JMX 端口</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_OPTS:</span> <span class="string">'-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=kafka -Dcom.sun.management.jmxremote.port=19999'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Kafka-Eagle-无法监控自己"><a href="#Kafka-Eagle-无法监控自己" class="headerlink" title="Kafka Eagle 无法监控自己"></a>Kafka Eagle 无法监控自己</h3><p>在 Kafka Eagle（EFAK）的控制台中访问 EfakServer 的监控页面时，发现无法正常显示 EfakServer 的运行状态，监控页面一直显示提示信息 <code>Processing</code> 或者节点状态显示为 <code>Offline</code>，如下图所示：</p><p><img data-src="../../../asset/2024/12/linux-efak-7.png"></p><p>这个问题可以忽略不解决，猜测（待验证）只有当 Kafka Eagle（EFAK）以集群（分布式）模式部署时，EfakServer 的监控页面才会正常显示相关监控信息，详细说明请看 <a href="/posts/70bdcb69.html#Kafka-Eagle-%E6%97%A0%E6%B3%95%E7%9B%91%E6%8E%A7%E8%87%AA%E5%B7%B1">这里</a>。如果不希望 UI 将节点状态显示为 <code>Offline</code>，可参考以下配置信息：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># EFAK enable distributed</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="meta">efak.distributed.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># efak.cluster.mode.status=master</span></span><br><span class="line"><span class="comment"># efak.worknode.master.host=localhost</span></span><br><span class="line"><span class="comment"># efak.worknode.port=8085</span></span><br></pre></td></tr></tbody></table></figure><h3 id="内存不足导致服务启动失败"><a href="#内存不足导致服务启动失败" class="headerlink" title="内存不足导致服务启动失败"></a>内存不足导致服务启动失败</h3><p>在 Kafka Eagle（EFAK）的项目源码中，有一个 <code>ke.sh</code> <a href="https://github.com/smartloli/EFAK/blob/main/efak-web/src/main/resources/bin/ke.sh">启动脚本</a>，该脚本里面有以下一行代码：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KE_JAVA_OPTS=<span class="string">"-server -Xmx2g -Xms2g -XX:MaxGCPauseMillis=20 -XX:+UseG1GC -XX:MetaspaceSize=128m -XX:InitiatingHeapOccupancyPercent=35 -XX:G1HeapRegionSize=16M -XX:MinMetaspaceFreeRatio=50 -XX:MaxMetaspaceFreeRatio=80"</span></span><br></pre></td></tr></tbody></table></figure><p>其中 JVM 参数 <code>-Xms2g</code> 指定了初始堆内存为 <code>2G</code>，因此当操作系统的空闲内存不足 <code>2G</code> 时，会导致 Kafka Eagle（EFAK）服务启动失败。解决办法是，更改 Shell 脚本代码，或者增加机器的物理内存（强烈推荐）。</p><h3 id="监控大屏无法实时更新显示"><a href="#监控大屏无法实时更新显示" class="headerlink" title="监控大屏无法实时更新显示"></a>监控大屏无法实时更新显示</h3><p>在 Kafka Eagle（EFAK）的控制台中访问监控大屏页面时，发现即使有生产者正在发送消息和消费者正在消费消息，Kafka 集群的监控指标图表也无法实时更新显示或者没有任何监控数据显示（如下图所示）。这是因为 Kafka Eagle（EFAK）禁用了 Kafka 集群的监控指标图表实时更新。</p><p><img data-src="../../../asset/2024/12/linux-efak-5.png"></p><p>解决办法是，在 Kafka Eagle（EFAK）的 <code>system-config.properties</code> 配置文件中，更改或添加以下配置：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">efak.metrics.charts</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>在 Kafka Eagle（EFAK）的控制台中，Kafka 集群监控指标图表的渲染和数据获取会消耗一定的资源。如果 Kafka 的集群规模较大或者系统资源有限，建议通过禁用 <code>efak.metrics.charts</code> 选项来减少系统负载。</p></div><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ul><li><a href="https://docs.kafka-eagle.org/2.installation/2.installonlinuxmac">Kafka Eagle（EFAK）官方安装文档</a></li><li><a href="/posts/73b15688.html">Docker 部署 Kafka Eagle（EFAK）单机</a></li><li><a href="/posts/70bdcb69.html">Linux 生产环境部署 Kafka-Eagle（EFAK）集群</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何在 Linux 系统上部署 Kafka-Eagle（EFAK）单机服务，实现对 Kafka 集群的监控。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++ 巩固基础之一</title>
    <link href="https://www.techgrow.cn/posts/8c3cfc46.html"/>
    <id>https://www.techgrow.cn/posts/8c3cfc46.html</id>
    <published>2024-10-26T13:55:33.000Z</published>
    <updated>2024-10-26T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><a href="/posts/8c3cfc46.html">C++ 巩固基础之一</a>、<a href="/posts/418bd270.html">C++ 巩固基础之二</a>、<a href="/posts/3d7447d.html">C++ 巩固基础之三</a></li><li><a href="/posts/4f052863.html">C++ 巩固基础之四</a>、<a href="/posts/52e74a26.html">C++ 巩固基础之五</a>、<a href="/posts/a4fe8225.html">C++ 巩固基础之六</a></li></ul><h2 id="编译与链接原理"><a href="#编译与链接原理" class="headerlink" title="编译与链接原理"></a>编译与链接原理</h2><div class="admonition note"><p class="admonition-title">提示</p><p>强烈建议在阅读完本节的内容后，多花点时间深入读一遍《深入理解计算机系统 - 第三版》的第 7 章 "链接"。</p></div><h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><table><thead><tr><th>步骤</th><th>命令</th></tr></thead><tbody><tr><td> 1. 预处理</td><td> gcc -E hello.c -o hello.i</td></tr><tr><td>2. 编译到汇编代码</td><td> gcc -S hello.i -o hello.s</td></tr><tr><td>3. 汇编到目标代码（机器语言）</td><td>gcc -c hello.s -o hello.o</td></tr><tr><td>4. 链接，生成可执行文件</td><td> gcc hello.o -o hello</td></tr><tr><td> 以上四个步骤，可以合成一个步骤，直接编译链接成可执行的目标文件</td><td> gcc hello.c -o hello</td></tr></tbody></table><span id="more"></span><h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><table><thead><tr><th>参数</th><th>作用</th><th>编译示例</th><th>示例说明</th></tr></thead><tbody><tr><td> -o</td><td> 指定输出可执行程序的名称，默认文件名为”a.out”</td><td>gcc hello.c -o hello</td><td> 编译单个源文件 hello.c，指定输出可执行程序的名称为 hello，支持同时编译多个源文件</td></tr><tr><td> -E</td><td> 仅作预处理，不进行编译、汇编和链接</td><td> gcc -E hello.c -o hello.i</td><td> 仅预处理源文件，指定生成中间文件 <code>*.i</code>，此阶段主要处理源文件中的 #ifdef、#include、#define 等预处理命令</td></tr><tr><td> -S</td><td> 只编译到汇编语言，不进行汇编和链接，生成汇编代码</td><td> gcc -S hello.c -o hello.s</td><td> 仅编译到汇编语言，指定生成汇编源文件 <code>*.s</code></td></tr><tr><td>-c</td><td> 只编译、汇编到目标代码，不进行链接，生成目标文件（机器语言）</td><td>gcc -c hello.s -o hello.o</td><td> 根据汇编源文件 <code>*.s</code>，指定生成目标文件 <code>*.o</code>，最后根据生成的目标文件，可执行 <code>gcc hello.o -o hello</code> 命令生成可执行程序</td></tr><tr><td> -l</td><td> 指定程序链接哪个静态库或者动态库</td><td></td><td></td></tr><tr><td> -m</td><td> 表示是数学库，也就是使用 math.h 头文件</td><td> gcc hello.c -o hello -lm</td><td> 编译单个源文件 hello.c，指定输出可执行程序名称为 hello，并指定程序链接到数学库</td></tr><tr><td> -I dir</td><td> 在头文件的搜索路径列表中添加 dir 目录</td><td></td><td></td></tr><tr><td> -L dir</td><td> 在库文件的搜索路径列表中添加 dir 目录</td><td></td><td></td></tr><tr><td> -O、-O2、-O3</td><td> 将优化状态打开，该选项不能与”-g” 选项联合使用</td><td></td><td></td></tr><tr><td> -g</td><td> 在生成的可执行程序中包含标准调试信息</td><td></td><td></td></tr><tr><td> -Wall</td><td> 在发生警告时取消编译操作，即将警告看作是错误</td><td></td><td></td></tr><tr><td> -pedantic</td><td> 严格要求代码符合 ANSI/ISO C 标准，若不符合则给出编译警告信息</td><td></td><td></td></tr><tr><td> -w</td><td> 禁止输出所有警告</td><td></td><td></td></tr><tr><td> -v</td><td> 打印编译器内部编译各过程的命令行信息和编译器的版本号</td><td></td><td> </td></tr></tbody></table><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>C++ 的编译和链接过程通常分为四个主要阶段：预处理、编译、汇编和链接。每个阶段都有特定的任务，最终生成可执行文件。这些阶段的流程如下：</p><ul><li><strong>预处理</strong>：处理 <code>#include</code>、<code>#define</code> 等指令，生成纯文本代码。</li><li><strong>编译</strong>：将代码转换成汇编代码。</li><li><strong>汇编</strong>：将汇编代码转换成机器代码，生成目标文件。</li><li><strong>链接</strong>：将目标文件和库文件组合，生成可执行文件。</li></ul><p><img data-src="../../../asset/2021/12/gcc-step-view.png"></p><blockquote><p>第一步：预处理</p></blockquote><p>预处理阶段由预处理器处理，主要任务是处理源代码中的以 <code>#</code> 开头的指令，包括 <code>#include</code>、<code>#define</code> 等。预处理的主要任务包括：</p><ul><li><strong>头文件包含</strong>：将 <code>#include</code> 引用的头文件内容插入代码中。</li><li><strong>宏替换</strong>：将 <code>#define</code> 宏展开成具体内容。</li><li><strong>条件编译</strong>：根据 <code>#if</code>、<code>#ifdef</code> 等条件编译指令有选择地编译代码片段。</li></ul><p>经过预处理后的代码形成一个纯文本文件，通常称为 “预处理文件”。</p><blockquote><p>第二步：编译</p></blockquote><p>在编译阶段，编译器将预处理后的代码转换成<strong>汇编代码</strong>。编译的主要任务包括：</p><ul><li><strong>语法分析和语义分析</strong>：检查代码的语法和语义是否正确，如变量是否定义、数据类型是否匹配等。</li><li><strong>生成中间代码</strong>：将源码转换成一种与机器无关的中间表示，以便后续优化和生成目标代码。</li><li><strong>优化</strong>：编译器可能会优化代码以提高执行效率，比如消除冗余代码、优化循环等。</li></ul><p>编译阶段输出的通常是一个 <code>.s</code> 文件，其中包含汇编代码。</p><blockquote><p>第三步：汇编</p></blockquote><p>汇编阶段由汇编器将汇编代码转换为<strong>机器代码</strong>。机器代码是与目标 CPU 架构相关的低级二进制指令。汇编器会生成一个<strong>目标文件</strong>，通常带有 <code>.o</code> 或 <code>.obj</code> 后缀。值得一提的是，每个源文件都会经过汇编阶段，生成一个独立的目标文件。</p><blockquote><p>第四步：链接</p></blockquote><p>链接阶段由链接器负责，主要任务是将多个目标文件和库文件组合成一个<strong>可执行文件</strong>。链接的主要任务包括：</p><ul><li><strong>符号解析</strong>：将所有函数和变量的引用与其定义关联起来。例如，如果一个文件引用了另一个文件的函数，链接器会将引用解析为实际地址。</li><li><strong>地址分配</strong>：链接器分配每个符号（函数、变量）在最终可执行文件中的内存地址。</li><li><strong>合并代码段和数据段</strong>：链接器会将所有目标文件的代码段、数据段等部分合并，形成最终的可执行文件。</li></ul><p>链接完成后，生成最终的可执行文件，程序可以在操作系统上直接执行。</p><h3 id="编译分析"><a href="#编译分析" class="headerlink" title="编译分析"></a>编译分析</h3><p>0</p><blockquote><p>C++ 编译示例代码</p></blockquote><ul><li><code>sum.cpp</code> 的源码 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> gdata = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>main.cpp</code> 的源码 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> gdata;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = gdata;</span><br><span class="line">    <span class="keyword">int</span> b = data;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>编译代码生成可执行文件（默认是 <code>a.out</code>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp sum.cpp</span><br></pre></td></tr></tbody></table></figure><blockquote><p>C++ 编译分析命令</p></blockquote><ul><li>只编译、汇编到目标代码，不进行链接 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="params"> -c</span> sum.cpp</span><br><span class="line">g++<span class="params"> -c</span> main.cpp</span><br></pre></td></tr></tbody></table></figure><ul><li>查看目标文件的符号表，包括函数和全局变量的地址、大小等信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump<span class="params"> -t</span> sum.o</span><br><span class="line">objdump<span class="params"> -t</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>显示目标文件中各个段的内容（即十六进制和 ASCII 表示的原始数据）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump<span class="params"> -s</span> sum.o</span><br><span class="line">objdump<span class="params"> -s</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>查看目标文件的文件头信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readelf<span class="params"> -h</span> sum.o</span><br><span class="line">readelf<span class="params"> -h</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>查看目标文件中各段的详细信息，包括段的名称、大小、地址、类型和属性等 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readelf<span class="params"> -S</span> sum.o</span><br><span class="line">readelf<span class="params"> -S</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>将目标文件中的汇编代码（通过反汇编得到）与源代码进行对比显示，以便进行调试和分析 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="params"> -c</span> main.cpp<span class="params"> -g</span>    // 生成目标文件，-g 参数表示带上调试信息</span><br><span class="line">objdump<span class="params"> -S</span> main.o</span><br></pre></td></tr></tbody></table></figure><ul><li>链接所有目标文件，并查看指定文件的符号表信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="params"> -e</span> main *.o     // 将所有的目标文件链接成一个完整的程序，默认会生成一个名为 a.out 的可执行文件</span><br><span class="line">objdump<span class="params"> -t</span> a.out</span><br></pre></td></tr></tbody></table></figure><ul><li>查看可执行文件（通常是 ELF 格式）的程序头信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf<span class="params"> -l</span> a.out</span><br></pre></td></tr></tbody></table></figure><h2 id="C-的内存分配与释放"><a href="#C-的内存分配与释放" class="headerlink" title="C++ 的内存分配与释放"></a>C++ 的内存分配与释放</h2><h3 id="C-的内存分配"><a href="#C-的内存分配" class="headerlink" title="C++ 的内存分配"></a>C++ 的内存分配</h3><h4 id="new-和-malloc-的概述"><a href="#new-和-malloc-的概述" class="headerlink" title="new 和 malloc 的概述"></a>new 和 malloc 的概述</h4><ul><li><p><code>new</code> 的概述</p><ul><li><code>new</code> 是 C++ 的关键字，专门用于动态内存分配。</li><li>在分配内存的同时，<code>new</code> 会调用类对象的构造函数（如果是类对象）。</li><li>如果分配失败，<code>new</code> 会抛出异常 <code>std::bad_alloc</code>。</li></ul></li><li><p><code>malloc</code> 的概述</p><ul><li><code>malloc</code> 是 C 语言中的函数，用于分配一块连续的内存。</li><li>它不会初始化分配的内存，也不会调用类对象的构造函数（如果分配的内存是用于类对象）。</li><li>如果分配失败，<code>malloc</code> 返回 <code>NULL</code>，需要手动检查。</li></ul></li></ul><h4 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc 的区别"></a>new 和 malloc 的区别</h4><table><thead><tr><th>特性</th><th><code>new</code></th><th><code>malloc</code></th></tr></thead><tbody><tr><td>适用语言</td><td> C++</td><td>C 和 C++</td></tr><tr><td> 是否调用构造函数</td><td>分配内存，会调用构造函数</td><td>仅分配内存，不会调用构造函数</td></tr><tr><td>初始化</td><td>自动初始化（如 <code>new int[5]()</code> -&gt; 0）</td><td>不初始化，分配的内存为未定义的垃圾值</td></tr><tr><td>返回值</td><td>返回具体类型的指针，无需类型转换</td><td>返回 <code>void *</code>，需要显式类型转换</td></tr><tr><td>释放方式</td><td>使用 <code>delete</code> 或 <code>delete[]</code> 释放内存</td><td>使用 <code>free</code> 释放内存</td></tr><tr><td>错误处理</td><td>内存分配失败时抛出 <code>std::bad_alloc</code> 异常</td><td>内存分配失败时返回 <code>NULL</code>，需手动检查</td></tr><tr><td>内存分配用途</td><td>高级面向对象编程，推荐用于 C++ 动态内存分配</td><td>兼容 C 语言，适用于简单的内存分配需求</td></tr></tbody></table><h3 id="C-的内存释放"><a href="#C-的内存释放" class="headerlink" title="C++ 的内存释放"></a>C++ 的内存释放</h3><h4 id="delete-和-free-的概述"><a href="#delete-和-free-的概述" class="headerlink" title="delete 和 free 的概述"></a>delete 和 free 的概述</h4><ul><li><p><code>delete</code> 的概述</p><ul><li><code>delete</code> 关键字用于释放通过 <code>new</code> 分配的内存。</li><li>在释放内存之前，<code>delete</code> 会先调用类对象的析构函数，以确保资源（如文件句柄、网络连接等）正确释放。</li><li>如果分配的是数组，必须使用 <code>delete[]</code>，否则行为未定义。</li></ul></li><li><p><code>free</code> 的概述</p><ul><li><code>free</code> 是 C 标准库函数，用于释放通过 <code>malloc/calloc/realloc</code> 分配的内存。</li><li>它只会释放内存，不会执行任何其他操作，例如对象的析构。</li></ul></li><li><p><code>delete</code> 与 <code>free</code> 不能混用</p><ul><li>通过 <code>new</code> 分配的内存必须用 <code>delete</code> 释放，不能用 <code>free</code>，否则会导致未定义行为。</li><li>通过 <code>malloc</code> 分配的内存必须用 <code>free</code> 释放，不能用 <code>delete</code>，否则会导致未定义行为。</li></ul></li><li><p><code>delete</code> 与 <code>free</code> 的内存布局和管理差异</p><ul><li><code>new</code> 和 <code>delete</code> 是 C++ 的关键字，它们了解对象的类型，并能为复杂类型的构造和析构做出正确的处理。</li><li><code>malloc</code> 和 <code>free</code> 是 C 的函数，它们只分配和释放内存，不了解对象的类型。</li></ul></li></ul><h4 id="delete-和-free-的区别"><a href="#delete-和-free-的区别" class="headerlink" title="delete 和 free 的区别"></a>delete 和 free 的区别</h4><table><thead><tr><th>特性</th><th><code>delete</code></th><th><code>free</code></th></tr></thead><tbody><tr><td>适用语言</td><td> C++</td><td>C 和 C++</td></tr><tr><td> 适用对象</td><td>动态分配的对象（通过 <code>new</code> 分配）</td><td>动态分配的内存块（通过 <code>malloc/calloc</code> 分配）</td></tr><tr><td>是否调用析构函数</td><td>是，会调用类对象的析构函数</td><td>否，只释放内存，不调用析构函数</td></tr><tr><td>分配与释放的匹配要求</td><td>必须和 <code>new</code> 成对使用</td><td>必须和 <code>malloc/calloc</code> 成对使用</td></tr><tr><td>底层机制</td><td> C++ 的运行时库负责，处理更高级的资源管理</td><td> C 的运行时库负责，直接释放内存</td></tr><tr><td>数组释放</td><td>使用 <code>delete[]</code> 释放动态数组</td><td>没有专门的数组释放功能</td></tr></tbody></table><h3 id="内存分配与释放的使用"><a href="#内存分配与释放的使用" class="headerlink" title="内存分配与释放的使用"></a>内存分配与释放的使用</h3><h4 id="new-和-delete-的使用"><a href="#new-和-delete-的使用" class="headerlink" title="new 和 delete 的使用"></a>new 和 delete 的使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>); <span class="comment">// 分配内存，并且会初始化内存为 20</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]();    <span class="comment">// 数组初始化为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">delete</span>[] arr;   <span class="comment">// 释放数组内存</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = 20</span><br><span class="line">0 0 0 0 0 </span><br></pre></td></tr></tbody></table></figure><h4 id="malloc-和-free-的使用"><a href="#malloc-和-free-的使用" class="headerlink" title="malloc 和 free 的使用"></a>malloc 和 free 的使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"p = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = 20</span><br></pre></td></tr></tbody></table></figure><h4 id="new-的几种常见用法"><a href="#new-的几种常见用法" class="headerlink" title="new 的几种常见用法"></a>new 的几种常见用法</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 第一种用法</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种用法</span></span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="built_in"><span class="keyword">new</span></span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 即使内存分配失败，也不抛出异常</span></span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种用法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">delete</span> p3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四种用法</span></span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p4 = <span class="built_in"><span class="keyword">new</span></span> (&amp;data) <span class="built_in"><span class="keyword">int</span></span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"data = "</span> &lt;&lt; data &lt;&lt; endl; <span class="comment">// 输出 50</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = 50</span><br></pre></td></tr></tbody></table></figure><h2 id="C-的-const、指针、引用"><a href="#C-的-const、指针、引用" class="headerlink" title="C++ 的 const、指针、引用"></a>C++ 的 const、指针、引用</h2><ul><li>引用的本质<ul><li>引用本质上是一种更安全的指针。</li></ul></li><li>指针与引用的区别<ul><li>引用必须初始化，指针可以不初始化。</li><li>引用只有一级引用，没有多级引用；指针可以有一级指针，也可以有多级指针。</li><li>定义一个引用变量和定义一个指针变量，其底层的汇编指令是一模一样的。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><ul><li><a href="/posts/b03c11a0.html">C++ 的 const 与引用介绍</a></li></ul></div><h3 id="C-语言案例代码"><a href="#C-语言案例代码" class="headerlink" title="C 语言案例代码"></a>C 语言案例代码</h3><ul><li>C 语言中常量的使用 </li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _main() {</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这行代码 C 编译器编译不通过，因为 a 虽然是常量，但在 C 语言中，它并不是编译期常量（即不是编译器在编译时可以确定的常量），而是运行时的常量</span></span><br><span class="line">    <span class="comment">// 标准 C 语言（C89/C90 和 C99）要求数组大小在编译时确定，所以不能使用 const int 变量来定义数组大小</span></span><br><span class="line">    <span class="comment">// int array[a] = {};</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C 语言中的 const 变量属于伪常量，有自己的内存空间，可以通过操作指针的方式来修改 const 变量的值</span></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, *p, *(&amp;a));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 30 30</span><br></pre></td></tr></tbody></table></figure><h3 id="C-案例代码一"><a href="#C-案例代码一" class="headerlink" title="C++ 案例代码一"></a>C++ 案例代码一</h3><ul><li>C++ 中常量的使用 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 用字面量常量初始化常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 C++ 中，常量可以作为数组大小，因为 C++ 中 const 常量是在编译时确定的</span></span><br><span class="line">    <span class="keyword">int</span> array[a] = {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 C++ 中，不可以通过操作指针的方式来修改 const 变量的值</span></span><br><span class="line">    <span class="comment">// 当使用 &amp; 操作符取 const 常量的地址时，编译器会临时开辟一块内存空间</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, *p, *(&amp;a));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 用变量来初始化常量（通常叫常变量）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时不能再用来作为数组大小</span></span><br><span class="line">    <span class="comment">// int array[b] = {};</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时可以通过操作指针的方式来修改 const 变量的值</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, *p, *(&amp;a));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 20 3</span><br><span class="line">20 20 20</span><br></pre></td></tr></tbody></table></figure><h3 id="C-案例代码二"><a href="#C-案例代码二" class="headerlink" title="C++ 案例代码二"></a>C++ 案例代码二</h3><ul><li>C++ 中指针与引用的使用 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> {</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级指针作函数参数，参数 p 是一个指向 Person 指针的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocatMemory1</span><span class="params">(Person **p)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态分配内存给 *p，使其指向一个新的 Person 对象</span></span><br><span class="line">    *p = (Person *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    (*p)-&gt;age = <span class="number">18</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义一个 Person 类型的指针 p，初始化为 NULL（空指针）</span></span><br><span class="line">    Person *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 传入 &amp;p（Person* 的地址）</span></span><br><span class="line">    <span class="built_in">allocatMemory1</span>(&amp;p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; p-&gt;age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针引用作函数参数，参数 p 是 Person* 类型的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocatMemory2</span><span class="params">(Person *&amp;p)</span> </span>{</span><br><span class="line">    <span class="comment">// 动态分配内存给 p，使其指向一个新的 Person 对象</span></span><br><span class="line">    p = (Person *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    p-&gt;age = <span class="number">20</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义一个 Person 类型的指针 p，初始化为 NULL（空指针）</span></span><br><span class="line">    Person *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 直接传入 p</span></span><br><span class="line">    <span class="built_in">allocatMemory2</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; p-&gt;age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 常量引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;num = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内存的0x0018ff44位置写一个4字节的10</span></span><br><span class="line">    <span class="comment">// int *p = (int *) 0x0018ff44;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级指针</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> **q = &amp;p;</span><br><span class="line">    cout &lt;&lt; **q &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级指针</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针引用</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">age = 18</span><br><span class="line">age = 20</span><br></pre></td></tr></tbody></table></figure><h3 id="C-案例代码三"><a href="#C-案例代码三" class="headerlink" title="C++ 案例代码三"></a>C++ 案例代码三</h3><ul><li>C++ 中指针与引用、左值引用与右值引用的使用 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针与引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a; <span class="comment">// 引用，其底层是基于指针实现的</span></span><br><span class="line">    <span class="comment">// int &amp;c = 20; // 错误写法</span></span><br><span class="line"></span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// 20 20 20</span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// 30 30 30</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针与引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// swap1(&amp;a, &amp;b);</span></span><br><span class="line">    <span class="built_in">swap2</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;   <span class="comment">// a = 20, b = 10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用数组变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> array[<span class="number">5</span>] = {};</span><br><span class="line">    <span class="keyword">int</span> *p = array;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(array) &lt;&lt; endl;  <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个引用变量来引用数组变量</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (&amp;q)[<span class="number">5</span>] = array;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(q) &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左值引用与右值引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 左值，它有内存，有名称，值可以修改</span></span><br><span class="line">    <span class="keyword">int</span> &amp;b = a; <span class="comment">// 左值引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">// b = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int &amp;c = 20; // 错误写法，左值引用只能引用左值，20 是右值（没有内存和名称），不能引用 20</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;c = <span class="number">20</span>; <span class="comment">// 正确写法，C++ 提供了右值引用</span></span><br><span class="line">    <span class="comment">// int &amp;&amp;c = a; // 错误写法，右值引用只能引用右值，a 是左值，不能引用 a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// c = 20</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">20 20 20</span><br><span class="line">30 30 30</span><br><span class="line">a = 20, b = 10</span><br><span class="line">20</span><br><span class="line">4</span><br><span class="line">20</span><br><span class="line">b = 10</span><br><span class="line">c = 20</span><br></pre></td></tr></tbody></table></figure><h3 id="C-案例代码四"><a href="#C-案例代码四" class="headerlink" title="C++ 案例代码四"></a>C++ 案例代码四</h3><ul><li>const 与一二级指针的使用 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const与一级指针的结合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// int *p = &amp;a; // 错误写法，不能将常量的地址泄漏给一个普通的指针或者普通的引用变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const与一级指针的结合</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; C++的语言规范：const 修饰的是离它最近的类型</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; const 在 * 的左边则定值，const 在 * 的右边则定向，即左定值右定向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种写法（左定值）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    p = &amp;b; <span class="comment">// 正确写法，可以任意指向不同的int类型的内存</span></span><br><span class="line">    <span class="comment">// *p = 30; // 错误写法，不能通过指针间接修改指向的内存的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"p = "</span> &lt;&lt; *p &lt;&lt; endl; <span class="comment">// p = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种写法的变体（左定值）</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> *p2 = &amp;a;</span><br><span class="line">    p2 = &amp;b; <span class="comment">// 正确写法，可以任意指向不同的int类型的内存</span></span><br><span class="line">    <span class="comment">// *p2 = 30; // 错误写法，不能通过指针间接修改指向的内存的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"p2 = "</span> &lt;&lt; *p2 &lt;&lt; endl; <span class="comment">// p2 = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种写法（右定向）</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">    <span class="comment">// p3 = &amp;b; // 错误写法，不可以任意指向不同的int类型的内存</span></span><br><span class="line">    *p3 = <span class="number">30</span>; <span class="comment">// 正确写法，可以通过指针间接修改指向的内存的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"p3 = "</span> &lt;&lt; *p3 &lt;&lt; <span class="string">", a = "</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// p3 = 30, a = 30</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const与二级指针的结合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种写法</span></span><br><span class="line">    <span class="comment">// const int **q = &amp;p;  // 错误写法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种写法</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> *q = &amp;p;  <span class="comment">// 正确写法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种写法</span></span><br><span class="line">    <span class="comment">// int **const q = &amp;p;  // 错误写法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = 20</span><br><span class="line">p2 = 20</span><br><span class="line">p3 = 30, a = 30</span><br></pre></td></tr></tbody></table></figure><h2 id="C-形参带默认值的函数"><a href="#C-形参带默认值的函数" class="headerlink" title="C++ 形参带默认值的函数"></a>C++ 形参带默认值的函数</h2><ul><li>形参设置默认值的时候，必须从右向左设置。</li><li>形参是否设置默认值，对函数的调用效率会产生影响（底层生成的汇编指令会有差别）。</li><li>函数定义时可以给形参设置默认值，函数声明时也可以给形参设置默认值。</li><li>形参设置默认值的时候，不管是在函数定义处，还是在函数声明处，形参的默认值设置只能出现一次。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的形参带默认值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a = <span class="number">30</span>, <span class="keyword">int</span> b = <span class="number">40</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> result = a + b;</span><br><span class="line">    cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="built_in">sum</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result2 = "</span> &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="built_in">sum</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"result3 = "</span> &lt;&lt; result3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行后的输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = 30</span><br><span class="line">result2 = 50</span><br><span class="line">result3 = 70</span><br></pre></td></tr></tbody></table></figure><h2 id="C-内联函数的使用"><a href="#C-内联函数的使用" class="headerlink" title="C++ 内联函数的使用"></a>C++ 内联函数的使用</h2><ul><li>普通函数<ul><li>普通函数的调用会有开销，比如：参数压栈、函数栈帧的开辟、回退等操作。</li></ul></li><li>内联函数<ul><li>内联函数在编译过程中，就没有函数的调用开销，而是在函数的调用点直接用函数的代码展开（替换）处理。</li><li><code>inline</code> 关键字只是建议编译器将指定的函数处理成内联函数，但并不是所有的 <code>inline</code> 关键字都会被编译器处理成内联函数，比如：递归函数。</li><li>在 Debug 版本中，<code>inline</code> 关键字是不起作用的，<code>inline</code> 关键字只有在 Release 版本中才起作用。</li><li>当编译器将 <code>inline</code> 关键字修饰的函数处理成内联函数后，就不会再生成该函数对应的符号表内容。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="C-函数重载的使用"><a href="#C-函数重载的使用" class="headerlink" title="C++ 函数重载的使用"></a>C++ 函数重载的使用</h2><p>一组函数，其中函数名相同，参数列表的个数、类型、顺序不同，那么这一组函数就称为 - 函数重载。</p><ul><li>(1) 一组函数要称得上是函数重载，那么这组函数必须是处于同一个作用域当中的。</li><li>(2) 一组函数，函数名称相同，参数列表相同，仅仅返回值不同，这不叫函数重载。</li><li>(3) C++ 的多态有两种表现形式，包括静态多态（编译时期）和动态多态（运行时期），而函数重载属于静态多态的一种。</li><li>(4) <code>const</code> 关键字不能作为判断函数是否重载的条件，比如 <code>void sub(int a);</code> 与 <code>void sub(const int a)</code> 之间不是重载关系。</li></ul><div class="admonition note"><p class="admonition-title">为什么 C++ 支持函数重载，而 C 语言不支持函数重载？</p><ul><li>C++ 代码产生函数符号的时候，由函数名 + 参数列表决定。</li><li>C 语言代码产生函数符号的时候，仅由函数名决定。</li></ul></div><h3 id="函数重载案例代码一"><a href="#函数重载案例代码一" class="headerlink" title="函数重载案例代码一"></a>函数重载案例代码一</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"compare_int_int"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"compare_double_double"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"compare_char*_char*"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">compare</span>(<span class="number">3.4</span>, <span class="number">2.4</span>);</span><br><span class="line">    <span class="built_in">compare</span>(<span class="string">"abc"</span>, <span class="string">"efd"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="函数代码重载案例二"><a href="#函数代码重载案例二" class="headerlink" title="函数代码重载案例二"></a>函数代码重载案例二</h3><p>C++ 调用在 C 语言中定义的函数时，默认会编译失败，这是因为 C++ 与 C 语言生成函数符号的规则是不同的，从而导致 C++ 在编译时找不到在 C 语言中定义的函数。解决方法是，在 C++ 代码中，使用 <code>extern "C" { }</code> 来包裹函数的声明。</p><ul><li>C 语言的源代码 </li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>C++ 的源代码 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记大括号里的函数符号是按照 C 语言的规则来生成</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line">    <span class="comment">// 函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>如果是 C 语言需要调用在 C++ 中定义的函数，那么在 C++ 的代码中，也需要使用  <code>extern "C" { }</code> 包裹函数的定义。</p></div><p>值得一提的是，在多语言的项目开发中，往往会看到下面这样的 C++ 代码，其中的 <code>__cplusplus</code> 是 C++ 编译器内置的宏名。这样写的好处是，无论是在 C++ 还是 C 语言的代码中调用 <code>sum()</code> 函数，编译器都可以正常编译。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="进程之间的通信方式"><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a>进程之间的通信方式</h2><p>在 C++ 中，进程间通信（IPC）有多种方式可供选择。以下是一些常见的 IPC 方法：</p><ul><li><p><strong>管道（Pipe）</strong>  </p><ul><li>匿名管道：只能在父子进程之间通信。它在 Unix 和 Windows 上都支持。</li><li>命名管道：允许不同的进程进行通信。它可以跨不同的无亲缘关系的进程进行通信。</li></ul></li><li><p><strong>信号（Signal）</strong>  </p><ul><li>信号是一种异步通知机制，可以用于进程之间的简单通信。通常用于通知进程某个事件发生，例如终止、暂停等。信号适用于 Unix 系统。</li></ul></li><li><p><strong>消息队列（Message Queue）</strong>  </p><ul><li>消息队列允许进程之间通过发送和接收消息进行通信。这种方式支持消息的优先级排序，能够在多种操作系统上实现。POSIX 和 System V 都提供了消息队列的实现。</li></ul></li><li><p><strong>共享内存（Shared Memory）</strong>  </p><ul><li>共享内存是一种高效的 IPC 方式，允许多个进程共享同一块内存区域。由于数据直接存储在共享的内存空间中，读写速度较快，但需要使用同步机制来避免竞争条件。</li></ul></li><li><p><strong>信号量（Semaphore）</strong>  </p><ul><li>信号量是一种用于多进程间同步的机制，通常和共享内存配合使用，以保证进程对共享资源的有序访问。System V 和 POSIX 都提供了信号量的实现。</li></ul></li><li><p><strong>套接字（Socket）</strong>  </p><ul><li>套接字是一种强大的通信方式，支持同一台机器上的进程通信（本地套接字）以及不同机器之间的网络通信（网络套接字）。它具有跨平台的特性，广泛用于分布式系统。</li></ul></li><li><p><strong>内存映射文件（Memory-Mapped Files）</strong>  </p><ul><li>内存映射文件可以将文件内容映射到进程的地址空间中，多个进程可以通过映射相同的文件来实现数据共享。这种方式在 Unix 和 Windows 系统上都支持。</li></ul></li><li><p><strong>远程过程调用（Remote Procedure Call）</strong>  </p><ul><li>RPC 允许进程在远程主机上执行函数调用。虽然并非严格意义上的 IPC 机制，但它能够在分布式系统中用于进程通信。gRPC 是一种流行的 RPC 框架。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>在选择 IPC 方式时，可以根据应用的需求（如速度、复杂性、跨平台性）来选择合适的方式。例如，管道和消息队列适合简单的通信需求，而共享内存适合大数据量的高效通信。</p></div><h2 id="进程的虚拟地址空间内存划分和布局"><a href="#进程的虚拟地址空间内存划分和布局" class="headerlink" title="进程的虚拟地址空间内存划分和布局"></a>进程的虚拟地址空间内存划分和布局</h2><p>在 X86 32 位的 Linux 系统上，Linux 系统会给进程分配 2^32 大小（4GB）的一块空间，其中用户空间（User Space）占 3GB，内核空间（Kernel Space）占 1GB。值得一提的是，每一个进程的用户空间是私有的，但是内核空间是共享的。</p><p><img data-src="../../../asset/2024/11/process-address.png"></p><ul><li><code>.text</code>：已编译程序的机器代码。</li><li><code>.rodata</code>：只读数据，比如 <code>printf</code> 语句中的格式串和开关语句的跳转表。</li><li><code>.data</code>：已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不出现在 <code>.data</code> 节中，也不出现在 <code>.bss</code> 节中。</li><li><code>.bss</code>：未初始化的全局和静态 C 变量，以及所有被初始化为 <code>0</code> 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。程序运行时，在内存中分配这些变量，初始值为 <code>0</code>。</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的巩固教程。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Flatpak 解决 OBS 多路推流插件不生效的问题</title>
    <link href="https://www.techgrow.cn/posts/e5c0e9c6.html"/>
    <id>https://www.techgrow.cn/posts/e5c0e9c6.html</id>
    <published>2024-10-15T13:35:21.000Z</published>
    <updated>2024-10-15T13:35:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在 Linux 系统上，通过 Flatpak 安装 OBS 的最新版本（<code>30.2.3</code>）后，为了实现多平台直播推流，又安装了 <a href="https://github.com/sorayuki/obs-multi-rtmp">obs-multi-rtmp</a> 多路推流插件的 <code>0.6.0.1</code> 版本，最终发现 obs-multi-rtmp 多路推流插件并没有生效。查阅 <a href="https://github.com/sorayuki/obs-multi-rtmp/issues/436">GitHub Issues</a> 才知道，这是因为 Flatpak 安装 <code>30.2.3</code> 版本的 OBS 后，OBS 无法加载 <code>~/.var/app/com.obsproject.Studio/config/obs-studio/plugins</code> 目录下的 obs-multi-rtmp 多路推流插件。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><a href="https://github.com/obsproject/obs-studio">obs-studio</a></li><li><a href="https://github.com/rqh656418510/obs-multi-rtmp">obs-multi-rtmp</a></li></ul><span id="more"></span><h2 id="多路推流插件的安装"><a href="#多路推流插件的安装" class="headerlink" title="多路推流插件的安装"></a>多路推流插件的安装</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>通过 Flatpak Builder 手动构建 obs-multi-rtmp 多路推流插件的 Flatpak 软件包，并在本地安装，详细教程请看 <a href="https://github.com/pepesan/com.obsproject.Studio.Plugin.MultiRtmp">这里</a>。</p><ul><li>安装 OBS 的最新版本（比如 <code>30.2.3</code>）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$ sudo</span> apt install flatpak flatpak-builder</span><br><span class="line"><span class="keyword">$ sudo</span> flatpak remote-add<span class="params"> --if</span>-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo</span><br><span class="line"><span class="keyword">$ sudo</span> flatpak install flathub org.kde.Sdk//6.4</span><br><span class="line"><span class="keyword">$ sudo</span> flatpak install flathub com.obsproject.Studio//stable</span><br><span class="line"><span class="keyword">$ mkdir</span><span class="params"> -p</span> build</span><br></pre></td></tr></tbody></table></figure><ul><li>构建并安装多路推流插件的软件包 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取Git项目</span></span><br><span class="line"><span class="keyword">$ git</span> <span class="built_in">clone</span> https://github.com/pepesan/com.obsproject.Studio.Plugin.MultiRtmp.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建多路推流插件的软件包</span></span><br><span class="line"><span class="keyword">$ sudo</span> flatpak-builder<span class="params"> --force</span>-clean build-dir com.obsproject.Studio.Plugin.MultiRtmp.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装多路推流插件的软件包</span></span><br><span class="line"><span class="keyword">$ sudo</span> flatpak-builder<span class="params"> --user</span><span class="params"> --install</span><span class="params"> --force</span>-clean build-dir com.obsproject.Studio.Plugin.MultiRtmp.yaml</span><br></pre></td></tr></tbody></table></figure><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>降低 OBS 的版本，也就是通过 Flatpak 更新安装 <code>30.1.2</code> 版本的 OBS，然后通过拷贝文件的方式来安装 <code>0.6.0.1</code> 版本的 obs-multi-rtmp 多路推流插件。值得一提的是，这里必须先通过 Flatpak 安装好 OBS 的高版本，详细教程请看 <a href="https://cursosdedesarrollo.com/2024/07/solucion-a-los-problemas-con-la-version-30-2-x-de-obs-studio-via-flatpak-y-el-plugin-obs-multi-rtmp/">这里</a>。</p><ul><li>查看 OBS 的历史版本信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$ flatpak</span> remote-info<span class="params"> --log</span> flathub com.obsproject.Studio</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Ref: app/com.obsproject.Studio/x86_64/stable</span><br><span class="line">ID: com.obsproject.Studio</span><br><span class="line">Arch: x86_64</span><br><span class="line">Branch: stable</span><br><span class="line">Collection ID: org.flathub.Stable</span><br><span class="line">Date: 2024-08-15 22:57:46 +0000</span><br><span class="line">Subject: Export com.obsproject.Studio</span><br><span class="line">Commit: dc38e67bbca5d6c9c3d005f84bbf006109310de3852a9cd32b1dc19e030b1b0c</span><br><span class="line">Parent: 68d5e09141770575d2c962c06dea2bde8c8f97f035a75f6a47b0c1dfd39a7749</span><br><span class="line">Download size: 186.5 MB</span><br><span class="line">Installed size: 490.0 MB</span><br><span class="line">Runtime: org.kde.Platform/x86_64/6.6</span><br><span class="line">Sdk: org.kde.Sdk/x86_64/6.6</span><br><span class="line">History:</span><br><span class="line"> Subject: Export com.obsproject.Studio</span><br><span class="line"> Date: 2024-07-23 18:02:18 +0000</span><br><span class="line"> Commit: 68d5e09141770575d2c962c06dea2bde8c8f97f035a75f6a47b0c1dfd39a7749</span><br><span class="line"></span><br><span class="line"> Subject: Export com.obsproject.Studio</span><br><span class="line"> Date: 2024-07-22 23:41:23 +0000</span><br><span class="line"> Commit: bf9183bb1b4f291037a55df64402ed2dda0a8236907545c1a699ca1b205396fe</span><br><span class="line"></span><br><span class="line"> Subject: Export com.obsproject.Studio</span><br><span class="line"> Date: 2024-07-12 23:26:00 +0000</span><br><span class="line"> Commit: 4c452dfbd40bad7156b04449b61eb0bb651456f0848cd7e04c3064aac1ab2e90</span><br><span class="line"></span><br><span class="line"> Subject: Export com.obsproject.Studio</span><br><span class="line"> Date: 2024-04-05 23:58:57 +0000</span><br><span class="line"> Commit: 71d974e21fd96594d6ce66314962435a46674e1c441abcc9a6d64cbe5a5f7eda</span><br><span class="line"></span><br><span class="line"> Subject: Export com.obsproject.Studio</span><br><span class="line"> Date: 2024-03-23 21:36:59 +0000</span><br><span class="line"> Commit: 9acb8be364db52dcb4ea8ff0b20d63579ecd18d22bd7419deb20a2245356ffd7</span><br><span class="line"></span><br><span class="line"> Subject: Export com.obsproject.Studio</span><br><span class="line"> Date: 2024-03-12 23:58:40 +0000</span><br><span class="line"> Commit: c5bc6eb99d2d638e0892320dd43d0cd5f948d6d90bf786abe2995087a068d131</span><br><span class="line"></span><br><span class="line"> Subject: Export com.obsproject.Studio</span><br><span class="line"> Date: 2023-12-11 19:47:03 +0000</span><br><span class="line"> Commit: e641d66f8f509ff18c1e82bfd6e32e0e0021e56cb01d1471b00f56d82ea8bfa1</span><br></pre></td></tr></tbody></table></figure><ul><li>降低（回滚）OBS 的版本 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 降低到 30.1.2 版本</span></span><br><span class="line"><span class="keyword">$ sudo</span> flatpak update<span class="params"> --commit</span> 71d974e21fd96594d6ce66314962435a46674e1c441abcc9a6d64cbe5a5f7eda  com.obsproject.Studio</span><br></pre></td></tr></tbody></table></figure><ul><li>下载并拷贝 obs-multi-rtmp 多路推流插件到 OBS 的插件目录，插件的各个版本可以从 <a href="https://github.com/sorayuki/obs-multi-rtmp/releases">GitHub Relaese</a> 获取 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 0.6.0.1 版本的多路推流插件</span></span><br><span class="line"><span class="keyword">$ wget</span> https://github.com/sorayuki/obs-multi-rtmp/releases/download/0.6.0.1/obs-multi-rtmp-0.6.0.0-x86_64-linux-gnu.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压插件</span></span><br><span class="line"><span class="keyword">$ tar</span><span class="params"> -xf</span> obs-multi-rtmp-0.6.0.1-x86_64-linux-gnu.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="keyword">$ mkdir</span><span class="params"> -p</span> ~/.var/app/com.obsproject.Studio/config/obs-studio/plugins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝插件</span></span><br><span class="line"><span class="keyword">$ cp</span><span class="params"> -R</span><span class="params"> -rf</span> obs-multi-rtmp ~/.var/app/com.obsproject.Studio/config/obs-studio/plugins/obs-multi-rtmp</span><br></pre></td></tr></tbody></table></figure><h2 id="多路推流插件的使用"><a href="#多路推流插件的使用" class="headerlink" title="多路推流插件的使用"></a>多路推流插件的使用</h2><ul><li>(1) 插件安装完成后，重新启动 OBS 应用</li></ul><p><img data-src="../../../asset/2024/10/obs-multi-rtmp-0.png"></p><ul><li> (2) 打开 OBS 主界面的 <code>停靠窗口</code> 菜单，然后点击 <code>多路推流</code>，如果找不到，可以试试找 <code>视图 -&gt; 停靠部件 -&gt; 多路推流</code></li></ul><p><img data-src="../../../asset/2024/10/obs-multi-rtmp-1.png"></p><ul><li>(3) 此时会弹出多路推流的窗口，如果没有弹出窗口，可以试试重启 OBS 应用</li></ul><p><img data-src="../../../asset/2024/10/obs-multi-rtmp-2.png"></p><ul><li> (4) 点击多路推流窗口里的 <code>新建推流目标</code> 按钮，这样就可以新建多个推流配置</li></ul><p><img data-src="../../../asset/2024/10/obs-multi-rtmp-3.png"></p>]]></content>
    
    
    <summary type="html">本文主要介绍 Flatpak 如何解决 OBS 多路推流插件不生效的问题。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装单机版的 Nacos 与 MySQL 8</title>
    <link href="https://www.techgrow.cn/posts/1326ecd9.html"/>
    <id>https://www.techgrow.cn/posts/1326ecd9.html</id>
    <published>2024-10-12T12:05:42.000Z</published>
    <updated>2024-10-12T12:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将通过 Docker 安装单机版的 Nacos 和 MySQL 8，并让 Nacos 将数据存储在 MySQL 8 中。</p><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><table><thead><tr><th>中间件</th><th>版本</th></tr></thead><tbody><tr><td> Docker</td><td>24.0.5</td></tr><tr><td>Docker Compose</td><td>2.20.2</td></tr><tr><td>MySQL</td><td>8.4.2</td></tr><tr><td>Nacos</td><td>2.4.3</td></tr></tbody></table><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="下载-Nacos-项目"><a href="#下载-Nacos-项目" class="headerlink" title="下载 Nacos 项目"></a>下载 Nacos 项目</h3><div class="admonition note"><p class="admonition-title">Nacos 的项目源码</p><p>Nacos 项目最新的代码可以从 <a href="https://github.com/alibaba/nacos">GitHub 仓库</a> 获取，或者从 <a href="https://github.com/alibaba/nacos/releases">GitHub Releases</a> 获取指定版本的项目源码（强烈推荐）。</p></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载指定版本的 Nacos 的项目源码</span></span><br><span class="line"><span class="keyword">$ wget</span> https://github.com/alibaba/nacos/archive/refs/tags/2.4.3.tar.gz<span class="params"> -O</span> nacos-2.4.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码压缩文件</span></span><br><span class="line"><span class="keyword">$ tar</span><span class="params"> -xvf</span> nacos-2.4.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名源码目录（方便后面直接引用）</span></span><br><span class="line"><span class="keyword">$ mv</span> nacos-2.4.3 nacos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="keyword">$ cd</span> nacos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录结构，后面会使用 mysql-schema.sql 来初始化 MySQL 数据库</span></span><br><span class="line"><span class="keyword">$ tree</span> distribution/conf/</span><br><span class="line">├── 1.4.0-ipv6_support-update.sql</span><br><span class="line">├── announcement_en-US.conf</span><br><span class="line">├── announcement_zh-CN.conf</span><br><span class="line">├── application.properties</span><br><span class="line">├── application.properties.example</span><br><span class="line">├── cluster.conf.example</span><br><span class="line">├── console-guide.conf</span><br><span class="line">├── derby-schema.sql</span><br><span class="line">├── mysql-schema.sql</span><br><span class="line">└── nacos-logback.xml</span><br></pre></td></tr></tbody></table></figure><h3 id="下载-Nacos-Docker-项目"><a href="#下载-Nacos-Docker-项目" class="headerlink" title="下载 Nacos Docker 项目"></a>下载 Nacos Docker 项目</h3><div class="admonition note"><p class="admonition-title">Nacos Docker 项目源码</p><p>Nacos Docker 项目最新的代码可以从 <a href="https://github.com/nacos-group/nacos-docker">GitHub 仓库</a> 获取，或者从 <a href="https://github.com/nacos-group/nacos-docker/releases">GitHub Releases</a> 获取指定版本的项目源码（强烈推荐）。</p></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载指定版本的 Nacos Docker 的项目源码</span></span><br><span class="line"><span class="keyword">$ wget</span> https://github.com/nacos-group/nacos-docker/archive/refs/tags/v2.4.3.tar.gz<span class="params"> -O</span> nacos-docker-2.4.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压源码压缩文件</span></span><br><span class="line"><span class="keyword">$ tar</span><span class="params"> -xvf</span> nacos-docker-2.4.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名源码目录（方便后面直接引用）</span></span><br><span class="line"><span class="keyword">$ mv</span> nacos-docker-2.4.3 nacos-docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="keyword">$ cd</span> nacos-docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录结构，其中包含了 Docker 各种使用示例的配置文件，比如 standalone-mysql-8.yaml</span></span><br><span class="line"><span class="keyword">$ tree</span> .</span><br><span class="line">├── build</span><br><span class="line">│&nbsp;&nbsp; ├── bin</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── docker-startup.sh</span><br><span class="line">│&nbsp;&nbsp; ├── conf</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── application.properties</span><br><span class="line">│&nbsp;&nbsp; ├── Dockerfile</span><br><span class="line">│&nbsp;&nbsp; └── Dockerfile.Slim</span><br><span class="line">├── changlog</span><br><span class="line">├── env</span><br><span class="line">│&nbsp;&nbsp; ├── custom-application-config.env</span><br><span class="line">│&nbsp;&nbsp; ├── mysql.env</span><br><span class="line">│&nbsp;&nbsp; ├── nacos-embedded.env</span><br><span class="line">│&nbsp;&nbsp; ├── nacos-hostname.env</span><br><span class="line">│&nbsp;&nbsp; ├── nacos-ip.env</span><br><span class="line">│&nbsp;&nbsp; └── nacos-standlone-mysql.env</span><br><span class="line">├── example</span><br><span class="line">│&nbsp;&nbsp; ├── cluster-embedded.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── cluster-hostname.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── cluster-ip.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── custom-application-config.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── image</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── mysql</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;     ├── 5.7</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;     │&nbsp;&nbsp; └── Dockerfile</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;     └── 8</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp;         └── Dockerfile</span><br><span class="line">│&nbsp;&nbsp; ├── init.d</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── application.properties</span><br><span class="line">│&nbsp;&nbsp; ├── prometheus</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── prometheus-cluster.yaml</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── prometheus-standalone.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── standalone-derby.yaml</span><br><span class="line">│&nbsp;&nbsp; ├── standalone-mysql-5.7.yaml</span><br><span class="line">│&nbsp;&nbsp; └── standalone-mysql-8.yaml</span><br><span class="line">├── README.md</span><br><span class="line">└── README_ZH.md</span><br></pre></td></tr></tbody></table></figure><h2 id="Docker-安装-MySQL-8"><a href="#Docker-安装-MySQL-8" class="headerlink" title="Docker 安装 MySQL 8"></a>Docker 安装 MySQL 8</h2><h3 id="创建数据目录"><a href="#创建数据目录" class="headerlink" title="创建数据目录"></a>创建数据目录</h3><ul><li>在宿主机内创建数据目录，用于挂载 MySQL 容器内的数据文件 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir<span class="params"> -p</span> /usr/<span class="built_in">local</span>/mysql/data</span><br></pre></td></tr></tbody></table></figure><h3 id="创建-YML-配置文件"><a href="#创建-YML-配置文件" class="headerlink" title="创建 YML 配置文件"></a>创建 YML 配置文件</h3><ul><li>创建 <code>docker-compose.yml</code> 配置文件 </li></ul><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.4.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql-server</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"mysqld"</span>, <span class="string">"--mysql-native-password=ON"</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'/usr/local/mysql/data:/var/lib/mysql'</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD-SHELL"</span>, <span class="string">"mysqladmin ping -h localhost"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">nacos-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><h3 id="创建-MySQL-8-容器"><a href="#创建-MySQL-8-容器" class="headerlink" title="创建 MySQL 8 容器"></a>创建 MySQL 8 容器</h3><ul><li>使用 Docker Compose 创建并启动 MySQL 容器 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up<span class="params"> -d</span></span><br></pre></td></tr></tbody></table></figure><h3 id="初始化-MySQL-8-数据库"><a href="#初始化-MySQL-8-数据库" class="headerlink" title="初始化 MySQL 8 数据库"></a>初始化 MySQL 8 数据库</h3><ul><li>拷贝数据库初始化脚本到 MySQL 容器内部，这里的初始化脚本可以从 <a href="/posts/1326ecd9.html#%E4%B8%8B%E8%BD%BD-Nacos-%E9%A1%B9%E7%9B%AE">Nacos 项目</a> 中获取得到。<strong>特别注意，数据库初始化脚本与 Nacos 的版本必须互相匹配 </strong></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp nacos/distribution/conf/mysql-schema.sql mysql-server:/</span><br></pre></td></tr></tbody></table></figure><ul><li>登录 MySQL 数据库 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接进 MySQL 容器的内部</span></span><br><span class="line">docker <span class="built_in">exec</span><span class="params"> -it</span> mysql-server /bin/bash </span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录 MySQL 数据库</span></span><br><span class="line">mysql<span class="params"> -h</span> localhost<span class="params"> -u</span> root<span class="params"> -p</span></span><br></pre></td></tr></tbody></table></figure><ul><li>初始化 MySQL 数据库 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">mysql&gt; CREATE USER <span class="string">'nacos'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'nacos'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">mysql&gt; create database nacos_devtest default character <span class="built_in">set</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户授权访问</span></span><br><span class="line">mysql&gt; GRANT ALL ON nacos_devtest.* TO <span class="string">'nacos'</span>@<span class="string">'%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line">mysql&gt; use nacos_devtest;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行数据库初始化脚本</span></span><br><span class="line">mysql&gt; <span class="built_in">source</span> /mysql-schema.sql;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据库表</span></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------------+</span><br><span class="line">| Tables_in_nacos_devtest |</span><br><span class="line">+------------------------+</span><br><span class="line">| config_info            |</span><br><span class="line">| config_info_aggr       |</span><br><span class="line">| config_info_beta       |</span><br><span class="line">| config_info_tag        |</span><br><span class="line">| config_tags_relation   |</span><br><span class="line">| group_capacity         |</span><br><span class="line">| his_config_info        |</span><br><span class="line">| permissions            |</span><br><span class="line">| roles                  |</span><br><span class="line">| tenant_capacity        |</span><br><span class="line">| tenant_info            |</span><br><span class="line">| users                  |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></tbody></table></figure><h2 id="Docker-安装-Nacos"><a href="#Docker-安装-Nacos" class="headerlink" title="Docker 安装 Nacos"></a>Docker 安装 Nacos</h2><h3 id="创建日志目录"><a href="#创建日志目录" class="headerlink" title="创建日志目录"></a>创建日志目录</h3><ul><li>在宿主机内创建日志目录，用于挂载 Nacos 容器内的日志文件 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir<span class="params"> -p</span> /var/<span class="built_in">log</span>/nacos/logs</span><br></pre></td></tr></tbody></table></figure><h3 id="编辑-YML-配置文件"><a href="#编辑-YML-配置文件" class="headerlink" title="编辑 YML 配置文件"></a>编辑 YML 配置文件</h3><p>在上面创建的 <code>docker-compose.yml</code> 配置文件的基础上，添加 Nacos 的配置信息：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.4.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql-server</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"mysqld"</span>, <span class="string">"--mysql-native-password=ON"</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'/usr/local/mysql/data:/var/lib/mysql'</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">"CMD-SHELL"</span>, <span class="string">"mysqladmin ping -h localhost"</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:v2.4.3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos-standalone</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PREFER_HOST_MODE=hostname</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PLATFORM=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_NAME=nacos_devtest</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PORT=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_USER=nacos</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PASSWORD=nacos</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_KEY=2222</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_VALUE=2xxx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_TOKEN=SecretKey012345678901234567890123456789012345678901234567890123456789</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/log/nacos/logs:/home/nacos/logs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8848:8848"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9848:9848"</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">mysql:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">nacos-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></tbody></table></figure><ul><li>重要参数说明：<ul><li><code>SPRING_DATASOURCE_PLATFORM=mysql</code>：使用 MySQL 作为存储。</li><li><code>MYSQL_SERVICE_PORT=3306</code>：指定 MySQL 的端口。</li><li><code>MYSQL_SERVICE_USER=nacos</code>：指定连接 MySQL 时使用的用户名。</li><li><code>MYSQL_SERVICE_PASSWORD=nacos</code>：指定连接 MySQL 时使用的密码。</li><li><code>MYSQL_SERVICE_HOST=mysql</code>：这里的 <code>mysql</code> 是在 Docker Compose 中定义的 MySQL 服务的名称，用作其他服务（如 Nacos）访问 MySQL 的主机名，Docker Compose 会自动将这个名称解析为 MySQL 容器的 IP 地址。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>在上面的 YML 配置文件中，Nacos 容器的环境变量参考自 <a href="/posts/1326ecd9.html#%E4%B8%8B%E8%BD%BD-Nacos-Docker-%E9%A1%B9%E7%9B%AE">Nacos Docker 项目</a>里的 YML 配置文件，即 <code>nacos-docker/example/standalone-mysql-8.yaml</code>。</p></div><h3 id="创建-Nacos-容器"><a href="#创建-Nacos-容器" class="headerlink" title="创建 Nacos 容器"></a>创建 Nacos 容器</h3><ul><li>使用 Docker Compose 创建并启动 Nacos 容器 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up<span class="params"> -d</span></span><br></pre></td></tr></tbody></table></figure><h3 id="测试-Nacos-容器"><a href="#测试-Nacos-容器" class="headerlink" title="测试 Nacos 容器"></a>测试 Nacos 容器</h3><ul><li>查看 Nacos 容器的日志信息 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs<span class="params"> -f</span><span class="params"> --tail</span> 50 nacos-standalone</span><br></pre></td></tr></tbody></table></figure><ul><li>或者直接查看宿主机内的 Nacos 日志文件 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail<span class="params"> -f</span><span class="params"> -n</span> 50 /var/<span class="built_in">log</span>/nacos/logs/nacos.<span class="built_in">log</span></span><br></pre></td></tr></tbody></table></figure><ul><li>浏览器通过 <code>http://127.0.0.1:8848/nacos</code> 访问 Nacos 的控制台页面，若是可以正常访问，则说明 Nacos 正常运行</li></ul><p><img data-src="../../../asset/2024/10/docker-nacos-mysql8.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hub.docker.com/r/nacos/nacos-server">Nacos 的 Docker Hub 官网</a></li><li><a href="/posts/961beae9.html">Docker 安装 Nacos 单机和集群</a></li><li><a href="/posts/2669f243.html">Docker 安装 MySQL 8 教程</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍如何使用 Docker 安装单机版的 Nacos 与 MySQL 8。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>分布式链路追踪的技术选型介绍</title>
    <link href="https://www.techgrow.cn/posts/b5d62eb5.html"/>
    <id>https://www.techgrow.cn/posts/b5d62eb5.html</id>
    <published>2024-09-29T13:32:38.000Z</published>
    <updated>2024-09-29T13:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a>Jaeger</h2><ul><li>简介：<ul><li>Jaeger 是 Uber 开源的分布式追踪系统，具备强大的追踪、监控和故障诊断功能。它是 CNCF 的项目之一，得到了广泛的社区支持。</li></ul></li><li>特点：<ul><li>高性能：Jaeger 专为大规模分布式系统设计，适合高并发、大规模系统。</li><li>丰富的功能：支持多种存储后端（如 Elasticsearch、Cassandra），具备查询、可视化、错误诊断等多种强大功能。</li><li>支持 OpenTracing：与 OpenTracing 标准完全兼容，可与多种语言和平台进行集成。</li><li>扩展性：支持多种采样策略和链路追踪数据的丰富查询。</li></ul></li><li>适用场景：<ul><li>适合大型分布式系统，尤其是要求在高性能、高并发的场景下表现优异。</li><li>适合系统需要和其他平台或语言进行互操作，且希望遵循 OpenTracing 标准的场景。</li></ul></li></ul><span id="more"></span><h2 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h2><ul><li>简介：<ul><li>Zipkin 是 Twitter 开源的一个分布式链路追踪系统，最早集成在 Spring Cloud Sleuth 中，可以用于收集时序数据并可视化微服务调用链路。</li></ul></li><li>特点：<ul><li>轻量级：它的架构相对简单，容易部署，尤其适合中小规模系统。</li><li>集成度高：Spring Cloud Sleuth 对 Zipkin 的支持非常完善，集成简单，提供了现成的解决方案。</li><li>查询功能：支持可视化链路展示，方便查看微服务调用的延时、失败等信息。</li><li>插件化支持：可以支持不同的存储后端，比如 MySQL、Elasticsearch 等。</li></ul></li><li>适用场景： <ul><li>适合中小型项目（规模不大），且已使用 Spring Cloud 生态技术。</li></ul></li></ul><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><ul><li>简介：<ul><li>Sleuth 是 Spring Cloud 自带的分布式链路追踪工具，支持自动为 Spring Cloud 的微服务添加 TraceId 和 SpanId。</li></ul></li><li>特点：<ul><li>深度集成：和 Spring Cloud 生态高度集成，几乎开箱即用，默认使用 Zipkin 来进行数据存储和展示。</li><li>自动化：自动为 HTTP 请求、消息队列、数据库操作等关键操作添加追踪信息，无需开发者手动干预。</li><li>可扩展性：支持与其他追踪系统（如 Jaeger）的集成，具备较高的扩展性。</li></ul></li><li>适用场景： <ul><li>适合基于 Spring Cloud 架构的中小型项目团队，尤其是希望利用 Spring 生态快速集成链路追踪的情况。</li></ul></li></ul><h2 id="Pinpoint"><a href="#Pinpoint" class="headerlink" title="Pinpoint"></a>Pinpoint</h2><ul><li>简介：<ul><li>Pinpoint 是一款开源的 APM（应用性能管理）工具，主要用于大规模分布式系统的性能监控和故障诊断。它最初由韩国的 Naver 公司开发，现已成为监控 Java 和 PHP 应用的常用工具之一。</li></ul></li><li>特点：<ul><li>分布式跟踪：支持跟踪分布式系统中不同服务之间的调用关系，提供详细的调用链分析。</li><li>实时监控：通过仪表盘实时查看应用的状态，如响应时间、吞吐量、硬件资源使用情况（如 CPU、内存）等。</li><li>非侵入式安装：不需要修改现有代码即可集成 Pinpoint，可以通过字节码注入的方式收集数据。</li><li>支持多种框架：Pinpoint 支持监控 Java 和 PHP 应用，涵盖常见的 Web 框架、RPC 框架（如 Spring、Dubbo、gRPC）等。</li><li>可视化展示：提供拓扑图、调用链视图、热图等丰富的可视化（UI）功能，帮助快速定位性能问题。</li><li>告警机制：支持自定义性能阈值，监控超过阈值时发送告警通知。</li></ul></li><li>适用场景：<ul><li>适用于微服务架构或者大型分布式系统的性能监控，可以追踪多个服务间的调用关系，帮助开发者快速定位系统的性能瓶颈，优化应用性能，并快速定位问题。</li></ul></li></ul><h2 id="OpenTracing"><a href="#OpenTracing" class="headerlink" title="OpenTracing"></a>OpenTracing</h2><ul><li>简介：<ul><li>OpenTracing 是一个开源的 API 标准，诞生于 2016 年，旨在为分布式追踪系统提供统一的接口规范。它允许开发者在应用程序代码中无缝插入追踪代码，而无需绑定到特定的追踪工具（如 Jaeger 或 Zipkin）</li></ul></li><li>目标：<ul><li>提供跨语言的标准 API 来记录分布式系统中的 Trace 和 Span，使得开发者能够通过标准接口与各种追踪实现集成。</li></ul></li><li>局限性：<ul><li>OpenTracing 仅提供了 API 规范，没有包含具体的实现和上下文传播等内容。因此，开发者还需要额外的库或工具来实际记录和处理追踪数据。</li></ul></li></ul><h2 id="OpenCensus"><a href="#OpenCensus" class="headerlink" title="OpenCensus"></a>OpenCensus</h2><ul><li>简介：<ul><li>OpenCensus 由 Google 开发，最初作为其内部监控系统的开源版本，旨在解决分布式系统的追踪和度量问题。与 OpenTracing 不同，OpenCensus 不仅提供 API 规范，还包含了用于收集和导出追踪和度量数据的库和实现。</li></ul></li><li>特点：<ul><li>OpenCensus 不仅支持分布式追踪，还提供应用程序级别的度量（Metrics），如请求速率、延迟等。它还包含了一些内置的采集和上下文传播机制。</li></ul></li><li>局限性： <ul><li>OpenCensus 不仅提供了 API，还提供了具体的实现，这与 OpenTracing 产生了竞争关系。</li><li>OpenCensus 与 OpenTracing 的功能重叠，并且各自采用了不同的 API 规范，导致生态系统中出现了分裂。</li></ul></li></ul><h2 id="OpenTelemetry"><a href="#OpenTelemetry" class="headerlink" title="OpenTelemetry"></a>OpenTelemetry</h2><ul><li>简介：<ul><li>OpenTelemetry 是 OpenTracing 和 OpenCensus 的合并项目，由 CNCF 领导。它于 2019 年启动，旨在统一追踪和度量的标准，成为云原生应用的统一遥测（Telemetry）解决方案。</li></ul></li><li>目标：<ul><li>结合 OpenTracing 的标准化 API 和 OpenCensus 的实现，OpenTelemetry 提供了一个统一的库，支持分布式追踪、度量和日志的收集和导出。</li></ul></li><li>特点：<ul><li>分布式追踪： 提供类似于 OpenTracing 的 API，用于记录分布式系统中的追踪信息。</li><li>度量： 像 OpenCensus 一样，OpenTelemetry 也提供了应用性能度量数据的收集。</li><li>日志： 除了追踪和度量，OpenTelemetry 计划支持日志数据的统一收集和处理。</li><li>支持多种后端： OpenTelemetry 支持将数据导出到多种后端系统，如 Jaeger、Zipkin、Prometheus 等。</li></ul></li><li>发展现状：<ul><li>OpenTelemetry 是目前 CNCF 重点支持的项目，逐渐成为行业标准，并被广泛应用于云原生应用程序中。</li></ul></li></ul><h2 id="SkyWalking"><a href="#SkyWalking" class="headerlink" title="SkyWalking"></a>SkyWalking</h2><ul><li>简介：<ul><li>SkyWalking 是一个非常强大的全栈 APM（应用性能监控）和分布式链路追踪解决方案，而 OpenTracing、OpenCensus、OpenTelemetry 则是更倾向于标准化和 API 的解决方案。</li></ul></li><li>核心功能：<ul><li>开箱即用：SkyWalking 从数据收集到可视化仪表盘都有现成的功能，尤其适合希望快速搭建一整套 APM 解决方案的团队。</li><li>分布式链路追踪：自动追踪微服务之间的调用，记录服务调用链，提供请求延迟、错误率等信息。</li><li>性能监控（APM）：提供如响应时间、吞吐量、系统健康状况等性能指标的监控。</li><li>服务拓扑图：SkyWalking 生成微服务之间的交互拓扑图，帮助用户快速理解系统的依赖关系。</li><li>日志和度量集成：支持集成日志系统（如 ELK）以及度量系统，形成一个全方位的监控平台。</li><li>自动探针：通过代理（Agent）自动采集应用程序的 Trace 和 Metrics，无需对代码进行显式修改。</li><li>性能和扩展性：支持大规模分布式系统的监控，具备强大的可扩展性，支持高并发的链路追踪数据采集和处理。</li></ul></li><li>适用场景：<ul><li>多语言支持：SkyWalking 支持多种编程语言和框架，这使得它非常适合多技术栈的团队。</li><li>完整的 APM 需求：如果系统不仅需要链路追踪，还需要监控应用性能、日志分析，那么非常适合选择 SkyWalking。</li><li>自动化集成：对于已经运行的大规模分布式系统，如果不想在代码中手动添加追踪信息，SkyWalking 的自动探针功能非常适合。</li></ul></li></ul><blockquote><p>SkyWalking 与 OpenTelemetry 的对比</p></blockquote><ul><li>生态与标准：<ul><li>OpenTelemetry 是 CNCF 的标准项目，提供追踪、度量和日志的统一 API，并且可以与 Jaeger、Prometheus、Zipkin 等工具进行深度集成。</li><li>SkyWalking 则是一个完整的监控和链路追踪解决方案，不仅仅是一个 API 标准。它提供了完整的前端 UI、数据存储后端，以及自动化的数据收集器。</li><li>SkyWalking 也兼容 OpenTracing 和 OpenTelemetry API，这意味着可以将 SkyWalking 与其他系统结合使用，甚至可以使用 OpenTelemetry 的 API 通过 SkyWalking 收集和处理数据。</li></ul></li><li>功能差异：<ul><li>自动化程度：SkyWalking 提供了强大的 自动探针功能，开发者不需要在代码中显式添加追踪代码。这对于已经运行中的大型分布式系统特别有用。而 OpenTelemetry 需要通过 SDK 或 API 来实现追踪（尽管有一些自动化探针，也需要配置）。</li><li>全栈 APM：SkyWalking 不仅仅是一个分布式追踪工具，它是一个完整的 APM 解决方案，提供应用性能监控、链路追踪、日志集成等功能。OpenTelemetry 本身只是一个标准和工具库，需要和其他工具（如 Jaeger 或 Prometheus）配合使用才能实现同样的功能。</li><li>可视化和存储：SkyWalking 内置了完善的可视化仪表盘和后端存储解决方案（如 Elasticsearch、MySQL 等）。而 OpenTelemetry 没有内置的存储和可视化功能，需要与 Jaeger、Prometheus、Grafana 等工具组合使用。</li><li>生态支持：SkyWalking 提供了对多种环境的深度支持，包括 Java、Go、Node.js、PHP 等语言，且支持多种微服务框架（如 Kubernetes、Spring Cloud、Envoy、Istio 等）。</li></ul></li></ul><blockquote><p>SkyWalking 与 Jaeger、Zipkin 的对比</p></blockquote><ul><li>功能集成度：<ul><li>SkyWalking 是一个集成度更高的系统，除了链路追踪，还包括性能监控、日志管理等功能。</li><li>Jaeger 和 Zipkin 专注于分布式追踪，它们侧重于提供链路追踪的可视化和数据采集。</li></ul></li><li>可视化体验：<ul><li>SkyWalking 的 UI 更加用户友好，内置了服务拓扑图、依赖分析、告警功能，可以提供更丰富的可视化体验。</li><li>Jaeger 和 Zipkin 更偏重于单一的追踪功能，可能需要与其他工具组合使用才能达到同样的监控效果。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">如何选择 SkyWalking 和 OpenTracing</p><ul><li>如果目标是快速构建一个可视化、自动化的监控平台，SkyWalking 是一个非常合适的选择。</li><li>如果需要使用行业标准（比如 OpenTracing），且需要与结合其他工具来构建定制化的监控系统，OpenTelemetry 是一个更灵活、标准化的选择。</li></ul></div><h2 id="其他实现方案"><a href="#其他实现方案" class="headerlink" title="其他实现方案"></a>其他实现方案</h2><p>分布式链路追踪系统还有其他比较成熟的实现，例如：</p><ul><li>京东的 Hydra</li><li> 美团点评的 CAT</li><li> 新浪的 Watchman</li><li>Apache 的 HTrace</li><li> 阿里巴巴的鹰眼 Tracing</li></ul><h2 id="技术方案对比"><a href="#技术方案对比" class="headerlink" title="技术方案对比"></a>技术方案对比</h2><p><img data-src="../../../asset/2024/09/micrometer-4.png"></p><hr><p><img data-src="../../../asset/2024/09/micrometer-5.png"></p><hr><p><img data-src="../../../asset/2024/10/distribute-tracing-3.png"></p><hr><p><img data-src="../../../asset/2024/10/distribute-tracing-2.png"></p><hr><p><img data-src="../../../asset/2024/10/distribute-tracing-1.png"></p><hr><p><img data-src="../../../asset/2024/10/distribute-tracing-4.png"></p><h2 id="技术选型总结"><a href="#技术选型总结" class="headerlink" title="技术选型总结"></a>技术选型总结</h2><ul><li>如果是中小型项目，且已使用 Spring Cloud 周边生态的技术，建议采用 Sleuth + Zipkin 方案。</li><li>如果目标是快速构建一个高性能、可视化、自动化的大型分布式链路追踪平台，Pinpoint 和 SkyWalking 都是一个非常合适的选择。</li><li>如果需要使用行业标准（比如 OpenTracing），且需要与结合其他工具来构建定制化的大型分布式链路追踪系统，OpenTelemetry 是一个更灵活、标准化的选择。</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍分布式链路追踪技术选型的内容，包括 Jaeger、Zipkin、Sleuth、OpenTracing、OpenCensus、OpenTelemetry 等。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Debian 11 安装 Docker 与 Docker-Compose</title>
    <link href="https://www.techgrow.cn/posts/a4847c57.html"/>
    <id>https://www.techgrow.cn/posts/a4847c57.html</id>
    <published>2024-09-16T13:18:02.000Z</published>
    <updated>2024-09-16T13:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://www.docker.com/">Docker 官网</a></li><li><a href="https://hub.docker.com/">Docker Hub 官网</a></li><li><a href="https://docs.docker.com/">Docker 官方文档</a></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="卸载已有软件"><a href="#卸载已有软件" class="headerlink" title="卸载已有软件"></a>卸载已有软件</h3><p>卸载已安装的 Docker，避免对后续的安装步骤产生影响。</p><span id="more"></span><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载旧版本，包括有关的配置文件</span></span><br><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保证卸载干净</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">sudo rm -rf /etc/docker</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /usr/libexec/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br><span class="line">sudo rm -rf /etc/apt/keyrings</span><br></pre></td></tr></tbody></table></figure><h3 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><h3 id="添加存储库"><a href="#添加存储库" class="headerlink" title="添加存储库"></a>添加存储库</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥</span></span><br><span class="line">sudo curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Docker 的 APT 存储库</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian <span class="subst">$(lsb_release -cs)</span> stable"</span> | tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 APT 索引</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></tbody></table></figure><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装最新版本的 Docker</span></span><br><span class="line">sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>Docker Buildx 是 Docker 官方推出的一款增强型构建工具，旨在简化和优化多架构容器映像的构建流程。它整合了 QEMU 模拟器和多平台构建能力，使得开发者可以在单一的构建过程中同时为多个平台（如 x86、ARM 等）构建容器映像，极大地提高了构建效率和开发体验。</p></div><h3 id="Docker-启动"><a href="#Docker-启动" class="headerlink" title="Docker 启动"></a>Docker 启动</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启动 Docker</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Docker 的运行状态</span></span><br><span class="line">sudo systemctl status docker</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">普通用户使用 Docker 命令</p><p>如果希望让非 <code>root</code> 用户也能使用 Docker 命令，可以将该用户添加到 <code>docker</code> 用户组，比如 <code>sudo usermod -aG docker your-user-name</code>。</p></div><h3 id="Docker-配置源"><a href="#Docker-配置源" class="headerlink" title="Docker 配置源"></a>Docker 配置源</h3><p>由于 Docker Hub 存在不可抗拒因素，导致在国内无法访问，因此需要配置 Docker 使用国内镜像源。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建配置目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">{</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [       </span><br><span class="line">     <span class="string">"https://ustc-edu-cn.mirror.aliyuncs.com"</span>,</span><br><span class="line">     <span class="string">"https://docker.m.daocloud.io"</span>,</span><br><span class="line">     <span class="string">"https://docker.mirrors.ustc.edu.cn"</span>,     </span><br><span class="line">     <span class="string">"https://hub-mirror.c.163.com"</span>,        </span><br><span class="line">     <span class="string">"https://mirror.baidubce.com"</span>,         </span><br><span class="line">     <span class="string">"https://ccr.ccs.tencentyun.com"</span>,</span><br><span class="line">     <span class="string">"https://huecker.io"</span>,</span><br><span class="line">     <span class="string">"https://dockerhub.timeweb.cloud"</span>,</span><br><span class="line">     <span class="string">"https://noohub.ru"</span></span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置文件生效</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Docker</span></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Docker 的运行状态</span></span><br><span class="line">sudo systemctl status docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Docker 的运行信息</span></span><br><span class="line">sudo docker info</span><br></pre></td></tr></tbody></table></figure><h3 id="Docker-验证安裝"><a href="#Docker-验证安裝" class="headerlink" title="Docker 验证安裝"></a>Docker 验证安裝</h3><p>验证是否正确安装了 Docker，以下命令将下载一个测试镜像并在容器中运行它，容器在运行时将输出一条参考消息并退出</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></tbody></table></figure><h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker-Compose"></a>安装 Docker-Compose</h2><div class="admonition note"><p class="admonition-title">提示</p><p>推荐使用第二种方式（基于 <code>curl</code> 命令）进行安装，因为可以指定具体安装哪个版本的 Docker-Compose，而且后期升级维护也更方便。</p></div><h3 id="第一种安装方式"><a href="#第一种安装方式" class="headerlink" title="第一种安装方式"></a>第一种安装方式</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Docker-Compose 插件</span></span><br><span class="line">sudo apt install -y docker-compose-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 Docker-Compose 插件</span></span><br><span class="line">sudo docker compose -v</span><br></pre></td></tr></tbody></table></figure><h3 id="第二种安装方式"><a href="#第二种安装方式" class="headerlink" title="第二种安装方式"></a>第二种安装方式</h3><p>这里除了可以使用 <code>curl</code> 命令来下载 Docker-Compose 的二进制包，还可以在 <a href="https://github.com/docker/compose/releases">GitHub Releases</a> 上面手动下载对应的文件，然后上传到目标服务器。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.29.1/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件授权</span></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证下载</span></span><br><span class="line">sudo docker-compose -v</span><br></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="/posts/57bca56f.html">Docker 介绍与安装</a></li><li><a href="/posts/b31f4d18.html">Docker-Compose 安装与使用</a></li><li><a href="https://blog.csdn.net/weixin_49187218/article/details/136935982">Debian 11 上安装 Docker</a></li><li><a href="https://blog.csdn.net/qq_30818545/article/details/124514016">Debian11 之 Docker 稳定版本安装</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Debian 11 如何安装 Docker 与 Docker-Compose。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    <category term="Debian" scheme="https://www.techgrow.cn/tags/Debian/"/>
    
  </entry>
  
</feed>
