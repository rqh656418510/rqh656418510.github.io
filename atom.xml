<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术空间</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2024-06-27T12:10:21.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Centos7 的 Yum 包管理</title>
    <link href="https://www.techgrow.cn/posts/295a93a1.html"/>
    <id>https://www.techgrow.cn/posts/295a93a1.html</id>
    <published>2024-06-27T12:10:21.000Z</published>
    <updated>2024-06-27T12:10:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="查看软件包的可用版本"><a href="#查看软件包的可用版本" class="headerlink" title="查看软件包的可用版本"></a>查看软件包的可用版本</h3><ul><li>方法一：使用 <code>yum info</code> 命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum info &lt;包名&gt;<span class="params"> --showduplicates</span></span><br></pre></td></tr></tbody></table></figure><ul><li>方法二：使用 <code>yum list</code> 命令 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum list &lt;包名&gt;<span class="params"> --showduplicates</span></span><br></pre></td></tr></tbody></table></figure><ul><li>方法三：使用 <code>yum-utils</code> 工具 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 yum-utils 工具</span></span><br><span class="line">sudo yum install yum-utils</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看软件包的历史版本</span></span><br><span class="line">sudo repoquery --show-duplicates --qf <span class="string">"%{name}-%{version}-%{release}"</span> &lt;包名&gt;</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h3 id="安装指定版本的软件包"><a href="#安装指定版本的软件包" class="headerlink" title="安装指定版本的软件包"></a>安装指定版本的软件包</h3><p>在使用 <code>yum</code> 安装软件时，可以指定要安装的版本。以下是安装指定版本软件的方法：</p><blockquote><p>查找可用版本</p></blockquote><p>首先，查看某个软件包的所有可用版本：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list &lt;包名&gt;<span class="params"> --showduplicates</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>安装指定版本</p></blockquote><p>使用 <code>yum install</code> 命令并指定要安装的版本号：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install &lt;包名&gt;-&lt;版本号&gt;</span><br></pre></td></tr></tbody></table></figure><p>例如，要安装 <code>httpd</code> 的特定版本 <code>2.4.6-90.el7.centos</code>，可以使用以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd-2.4.6-90.el7.centos</span><br></pre></td></tr></tbody></table></figure><blockquote><p>排除其他版本（可选）</p></blockquote><p>如果想确保不会意外升级到其他版本，可以配置 <code>yum</code> 排除其他版本。编辑 <code>/etc/yum.conf</code> 文件，并添加以下行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">exclude=&lt;包名&gt;</span><br></pre></td></tr></tbody></table></figure><p>可以排除多个软件包，使用空格分隔：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">exclude=&lt;包名1&gt; &lt;包名2&gt;</span><br></pre></td></tr></tbody></table></figure><p>然后，在需要安装特定版本时，可以使用以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install<span class="params"> --disableexcludes</span>=all &lt;包名&gt;-&lt;版本号&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>降级到指定版本（可选）</p></blockquote><p>如果已经安装了某个包，但想降级到某个特定版本，可以使用 <code>yum downgrade</code> 命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum downgrade &lt;包名&gt;-&lt;版本号&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>回滚到特定版本（可选）</p></blockquote><p>可以使用 <code>yum history</code> 命令来查看和回滚特定版本：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有的历史记录</span></span><br><span class="line">yum <span class="built_in">history</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定的历史记录</span></span><br><span class="line">yum <span class="built_in">history</span> info &lt;历史ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚到指定的历史记录</span></span><br><span class="line">yum <span class="built_in">history</span> undo &lt;历史ID&gt;</span><br></pre></td></tr></tbody></table></figure><div class="admonition warning"><p class="admonition-title">特别注意</p><p>如果在某个 YUM 历史操作记录中，安装或更新了多个软件包，那么执行回滚后，该历史记录里的所有操作都会回滚（即可能会批量回滚多个软件的版本）。</p></div><h3 id="排除更新指定的软件包"><a href="#排除更新指定的软件包" class="headerlink" title="排除更新指定的软件包"></a>排除更新指定的软件包</h3><p>在 CentOS 7 系统中，如果想使用 <code>yum update</code> 更新系统时排除某个软件包，可以通过以下几种方法来实现：</p><blockquote><p>方法一</p></blockquote><p>在运行 <code>yum update</code> 命令时，使用 <code>--exclude</code> 选项来排除特定的软件包。例如，如果想要排除 <code>httpd</code> 软件包，可以运行以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update<span class="params"> --exclude</span>=httpd</span><br></pre></td></tr></tbody></table></figure><p>也可以排除多个软件包，例如：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update<span class="params"> --exclude</span>=httpd<span class="params"> --exclude</span>=nginx</span><br></pre></td></tr></tbody></table></figure><blockquote><p>方法二</p></blockquote><p>如果希望永久性地排除某个软件包的更新，可以编辑 <code>yum</code> 的配置文件 <code>/etc/yum.conf</code>，在 <code>[main]</code> 部分添加 <code>exclude</code> 选项。例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">exclude=httpd</span><br></pre></td></tr></tbody></table></figure><p>可以排除多个软件包，使用空格分隔：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">exclude=httpd nginx</span><br></pre></td></tr></tbody></table></figure><p>这样配置之后，每次运行 <code>yum update</code> 时，都会自动排除指定的软件包。</p><blockquote><p>方法三</p></blockquote><p>可以使用 <code>yum-plugin-versionlock</code> 插件来锁定特定软件包的版本。首先安装该插件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install yum-plugin-versionlock</span><br></pre></td></tr></tbody></table></figure><p>然后锁定想要的版本的软件包，例如：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum versionlock add httpd</span><br></pre></td></tr></tbody></table></figure><p>这将会锁定当前安装的 <code>httpd</code> 软件包版本，防止它被更新，可以查看当前锁定的软件包列表：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum versionlock list</span><br></pre></td></tr></tbody></table></figure><p>如果需要取消版本锁定，可以使用以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum versionlock delete httpd</span><br></pre></td></tr></tbody></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="YUM-更新系统出错"><a href="#YUM-更新系统出错" class="headerlink" title="YUM 更新系统出错"></a>YUM 更新系统出错</h3><p>在 Centos7 上执行 <code>yum update</code> 命令更新系统时，出现 “Invalid version flag: or” 错误，通常是由于 Yum 配置文件或某些第三方软件包配置不正确导致的。以下是解决该问题的一些方法：</p><ul><li>方法一：清理缓存。尝试清理 Yum 的缓存，并重新更新。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum clean all</span><br><span class="line">sudo yum makecache</span><br><span class="line">sudo yum update</span><br></pre></td></tr></tbody></table></figure><ul><li>方法二：检查并修复软件仓库配置。某些第三方仓库配置文件可能会引起该错误，尝试禁用所有第三方仓库，只使用默认的 CentOS 仓库进行更新。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有启用的仓库</span></span><br><span class="line">sudo yum repolist enabled</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁用所有第三方仓库</span></span><br><span class="line">1. 打开 `/etc/yum.repos.d/` 目录下的各个 `.repo` 文件。</span><br><span class="line">2. 将 `.repo` 文件里的 `enabled=1` 改为 `enabled=0`，只保留官方仓库启用。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再次尝试更新</span></span><br><span class="line">sudo yum update</span><br></pre></td></tr></tbody></table></figure><ul><li>方法三：查看并修复依赖关系。有时依赖关系可能会引起问题，尝试修复：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum check</span><br><span class="line">sudo package-cleanup<span class="params"> --problems</span></span><br><span class="line">sudo package-cleanup<span class="params"> --dupes</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 Centos7 的 Yum 包管理。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Centos" scheme="https://www.techgrow.cn/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引的最左前缀原则详解</title>
    <link href="https://www.techgrow.cn/posts/284a5386.html"/>
    <id>https://www.techgrow.cn/posts/284a5386.html</id>
    <published>2024-06-23T14:39:42.000Z</published>
    <updated>2024-06-23T14:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="最左前缀原则的介绍"><a href="#最左前缀原则的介绍" class="headerlink" title="最左前缀原则的介绍"></a>最左前缀原则的介绍</h2><p>最左前缀原则指的是：使用组合索引（联合索引）时，查询条件需要从索引的最左列开始匹配，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效 (这一列后面的字段的索引会失效)。比如，针对 A、B、C 三个字段建立了一个组合索引，那么在写一个 SQL 时就一定要提供 A 字段的查询条件，这样才能让组合索引生效。这是由于在建立 A、B、C 三个字段的组合索引时，MySQL 底层的 B+ 树是按照 A、B、C 三个字段从左往右去比较大小进行排序的，也就是说 B+ 树的索引结构依赖于从左到右逐层递进地有序搜索路径。如果查询条件中缺少了最左边的列，B+ 树将无法确定初始的搜索路径，从而无法利用索引进行高效查询。</p><span id="more"></span><h2 id="最左前缀原则的使用"><a href="#最左前缀原则的使用" class="headerlink" title="最左前缀原则的使用"></a>最左前缀原则的使用</h2><h3 id="使用案例一"><a href="#使用案例一" class="headerlink" title="使用案例一"></a>使用案例一</h3><blockquote><p>组合索引 + <code>where</code> 子句的使用</p></blockquote><p><img data-src="../../../asset/2024/07/mysql-index-left-rule.png"></p><h3 id="使用案例二"><a href="#使用案例二" class="headerlink" title="使用案例二"></a>使用案例二</h3><blockquote><p>组合索引 + <code>where</code> 子句的使用</p></blockquote><p>假设 MySQL 8.0 数据库中有一张表 <code>t_user</code>，表里面有 <code>id</code>、<code>phone</code>、<code>name</code>、<code>age</code>、<code>status</code> 这些字段，而且 <code>phone</code>、<code>name</code>、<code>age</code> 这三个字段创建了组合索引 <code>idx_phone_name_age</code>。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建组合索引</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> index idx_phone_name_age <span class="keyword">on</span> t_user(phone, name, age);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 索引不会失效，因为遵循最左前缀原则</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">'123456'</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">'Amy'</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">221</span>     <span class="operator">|</span> const,const,const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line"># 索引不会失效，最左前缀原则和过滤条件的顺序无关</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">'Amy'</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">20</span> <span class="keyword">and</span> phone <span class="operator">=</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">221</span>     <span class="operator">|</span> const,const,const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line"># 索引部分失效，因为跳跃了 name 这里一列</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">'123456'</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line"># 索引全部失效，因为跳跃了 phone 这里一列，将不遵循最左前缀原则</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">'Amy'</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用案例三"><a href="#使用案例三" class="headerlink" title="使用案例三"></a>使用案例三</h3><blockquote><p>组合索引 + <code>where</code> 子句 + <code>order by</code> 子句的使用</p></blockquote><p>假设 MySQL 8.0 数据库中有一张表 <code>t_user</code>，表里面有 <code>id</code>、<code>phone</code>、<code>name</code>、<code>age</code>、<code>status</code> 这些字段，而且 <code>phone</code>、<code>name</code>、<code>age</code> 这三个字段创建了组合索引 <code>idx_phone_name_age</code>。</p><ul><li>创建组合索引 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> index idx_phone_name_age <span class="keyword">on</span> t_user(phone, name, age);</span><br></pre></td></tr></tbody></table></figure><ul><li>无过滤条件（如 <code>where</code> 条件，不包括 <code>limit</code> 条件），索引不会生效 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 索引全部失效，因为没有过滤条件</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> phone, name, age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"></span><br><span class="line"># 索引全部失效，因为没有过滤条件，不包括 `limit` 条件</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> phone, name, age limit <span class="number">5</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"></span><br><span class="line"># 索引不会失效，因为有过滤条件</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">'123456'</span> <span class="keyword">order</span> <span class="keyword">by</span> phone, name, age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></tbody></table></figure><ul><li>查询字段与过滤字段对索引的影响 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 索引部分生效</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">'123456'</span> <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">order</span> <span class="keyword">by</span> phone, name, age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>    <span class="number">33.33</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line"># 索引完全生效，因为触发了覆盖索引</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> phone, age <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">'123456'</span> <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">order</span> <span class="keyword">by</span> phone, name, age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>    <span class="number">33.33</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+--------------------------+</span></span><br></pre></td></tr></tbody></table></figure><ul><li>排序字段的顺序和索引的顺序不一致对索引的影响 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 排序字段的顺序和索引的顺序一致时，不会触发 `filesort`</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> phone, age <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">'123456'</span> <span class="keyword">order</span> <span class="keyword">by</span> phone, name, age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"># 排序字段的顺序和索引的顺序不一致时，会触发 `filesort`</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> phone, age <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">'123456'</span> <span class="keyword">order</span> <span class="keyword">by</span> phone, age, name;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------------+</span></span><br></pre></td></tr></tbody></table></figure><ul><li>多个索引字段排序时，排序方向（升序、降序）不一致对索引的影响 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 多个索引字段排序时，排序方向（升序、降序）一致，不会触发 `filesort`</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> phone, age <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">'123456'</span> <span class="keyword">order</span> <span class="keyword">by</span> phone <span class="keyword">desc</span>, name <span class="keyword">desc</span>, age <span class="keyword">desc</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> Backward index scan; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+----------------------------------+</span></span><br><span class="line"></span><br><span class="line"># 多个索引字段排序时，排序方向（升序、降序）不一致，会触发 `filesort`</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> phone, age <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">'123456'</span> <span class="keyword">order</span> <span class="keyword">by</span> phone <span class="keyword">desc</span>, name <span class="keyword">asc</span>, age <span class="keyword">desc</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> idx_phone_name_age <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------------+</span></span><br></pre></td></tr></tbody></table></figure><h2 id="最左前缀原则的原理"><a href="#最左前缀原则的原理" class="headerlink" title="最左前缀原则的原理"></a>最左前缀原则的原理</h2><p>最左前缀原则指的是在使用组合索引时，查询必须从索引的最左边开始匹配。换句话说，如果针对 A、B、C 三个字段建立了一个组合索引，那么在查询中需要至少包含字段 A，才能有效地利用索引。具体原因可以从 B+ 树的结构来分析。</p><h3 id="B-树的结构"><a href="#B-树的结构" class="headerlink" title="B+ 树的结构"></a>B+ 树的结构</h3><p>B+ 树是一种平衡树，每个节点包含多个键，并且所有的叶子节点处在同一层。B+ 树有以下几个特性：</p><ul><li>叶子节点之间形成一个有序的链表。</li><li>所有的值（Value）都只在叶子节点上出现。</li><li>非叶子节点只存储键（Key），用于指导搜索方向。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>更多关于 MySQL 索引底层的 B+ 树数据结构的介绍，请看 <a href="/posts/bf8bc8c0.html">这里</a>。</p></div><h3 id="底层原理分析"><a href="#底层原理分析" class="headerlink" title="底层原理分析"></a>底层原理分析</h3><ul><li>(1) <strong>B+ 树的键排序</strong>：B+ 树的非叶子节点包含键，这些键按照字典顺序排序。在组合索引 (A、B、C) 中，键的排序是先按照列 A 排序，在列 A 相同的情况下，再按照列 B 排序，最后按照列 C 排序。因此，B+ 树的节点实际上形成了一种层次排序结构。</li><li>(2) <strong>搜索路径的确定</strong>：在 B+ 树中进行搜索时，从根节点开始，根据节点中的键判断搜索路径。例如，根节点包含列 A 的不同值范围，如果查询条件中不包含列 A，B+ 树无法判断该走哪条路径，从而无法使用索引。</li><li>(3) <strong>最左前缀匹配</strong>：如果查询条件中包含了列 A，那么 B+ 树可以使用列 A 的值来定位到相应的子节点。如果查询条件进一步包含列 B 和列 C，B+ 树可以继续使用这些列的值来精确定位。但是，如果查询条件中缺少列 A，B+ 树将无法进行初步的路径选择，导致无法使用索引。</li></ul><h3 id="案例分析说明"><a href="#案例分析说明" class="headerlink" title="案例分析说明"></a>案例分析说明</h3><p>假设有一个表 <code>my_table</code>，在 A、B、C 三个字段上建立了一个组合索引，数据如下：</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>1</td><td>3</td><td>2</td></tr><tr><td>2</td><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td><td>2</td></tr></tbody></table><p>B+ 树索引的结构如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       A</span><br><span class="line">     /   \</span><br><span class="line">    1     2</span><br><span class="line">   / \   / \</span><br><span class="line">  B   B B   B</span><br><span class="line"> / \ / \/ \ / \</span><br><span class="line">2  3 1  2 1  2</span><br></pre></td></tr></tbody></table></figure><ul><li>查询 <code>SELECT * FROM my_table WHERE A = 1 AND B = 2</code> 可以有效利用索引，因为从根节点 A 出发，找到值为 1 的分支，再在 B 节点找到值为 2 的分支。</li><li>查询 <code>SELECT * FROM my_table WHERE B = 2</code> 则无法利用索引，因为无法确定从根节点 A 的哪个分支开始搜索。</li></ul><div class="admonition note"><p class="admonition-title">总结</p><p>最左前缀原则之所以存在，正是因为 B+ 树的索引结构依赖于从左到右逐层递进地有序搜索路径。如果查询条件中缺少了最左边的列，B+ 树将无法确定初始的搜索路径，从而无法利用索引进行高效查询。</p></div><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="最佳实践一"><a href="#最佳实践一" class="headerlink" title="最佳实践一"></a>最佳实践一</h3><p>组合索引的创建应该遵从以下规则：</p><ul><li>(1) 在创建组合索引的时候，过滤性（唯一性）最好的字段在索引字段顺序中，位置越靠左边越好</li><li> (2) 组合索引出现范围查询时，应该尽量把这个字段放在索引顺序的最右边</li><li> (3) 在创建组合索引的时候，应该尽量包含 <code>where</code> 子句中的字段</li><li> (4) 应该尽量避免造成索引失效的情况</li></ul><h3 id="最佳实践二"><a href="#最佳实践二" class="headerlink" title="最佳实践二"></a>最佳实践二</h3><p>索引的使用应该注意以下几点内容：</p><ul><li>(1) 如果排序字段不在索引列上，MySQL 就会触发 <code>filesort</code>，导致查询性能降低；有两种排序算法：单路排序和双路排序</li><li> (2) 无过滤不索引，即如果没有过滤条件（如 <code>where</code> 条件，不包括 <code>limit</code> 条件），索引不会生效</li><li> (3) 在 SQL 语句中，如果索引字段的顺序写错了，会触发 <code>filesort</code></li><li>(4) 使用 <code>order by</code> 查询时，如果索引字段的位置非最左，会触发 <code>filesort</code></li><li>(5) 使用 <code>order by</code> 查询时，如果索引字段的排序方向（升序、降序）不一致，会触发 <code>filesort</code></li><li>(6) 熟练使用 <code>explain</code>，必要时使用 <code>optimizer_trace</code></li></ul><h3 id="最佳实践三"><a href="#最佳实践三" class="headerlink" title="最佳实践三"></a>最佳实践三</h3><p>利用最左前缀原则优化 Order By 语句，最关键的几点如下：</p><ul><li>(1) 在 SQL 语句中，一定要有过滤条件（如 <code>where</code> 条件），否则执行 <code>order by</code> 时索引会失效</li><li> (2) 首先要对 SQL 进行分析，检查必要的查询字段、过滤字段、排序字段是否按顺序创建好了素引</li><li> (3) 如果查询字段没有创建索引，可能会产生回表操作，导致触发 <code>filesort</code>，降低查询性能</li><li> (4) 排序字段的顺序和索引的顺序不一致时，会触发 <code>filesort</code>，降低查询性能</li><li> (5) 多个索引字段排序时，如果排序方向（升序、降序）不一致，会触发 <code>filesort</code>，降低查询性能</li><li> (6) 使用 <code>explain</code> 观察查询类型和索引利用情况</li><li> (7) 尽可能减少不必要的 <code>filesort</code></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 MySQL 索引的最左前缀原则详解。</summary>
    
    
    
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引底层数据结构详解</title>
    <link href="https://www.techgrow.cn/posts/bf8bc8c0.html"/>
    <id>https://www.techgrow.cn/posts/bf8bc8c0.html</id>
    <published>2024-06-18T14:39:42.000Z</published>
    <updated>2024-06-18T14:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="索引的介绍"><a href="#索引的介绍" class="headerlink" title="索引的介绍"></a>索引的介绍</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p><strong>MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。<strong>简而言之，索引的本质是数据结构</strong>。</p><span id="more"></span><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL 的索引是在存储引擎层实现的，不同的存储引擎支持不同的索引结构，主要包含以下几种：</p><p><img data-src="../../../asset/2024/06/mysql-index-1.png"></p><p>MySQL 不同的存储引擎对于索引结构的支持情况如下：</p><p><img data-src="../../../asset/2024/06/mysql-index-2.png"></p><div class="admonition note"><p class="admonition-title">提示</p><p>在 MySQL 中，通常所说的索引，如果没有特别指明，都是指 B+ 树数据结构的索引。</p></div><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>假如说 MySQL 的索引结构采用二叉树的数据结构，比较理想的结构如下：</p><p><img data-src="../../../asset/2024/06/mysql-index-3.png"></p><p>如果主键（数据）是顺序插入的，则会形成一个单向链表，结构如下：</p><p><img data-src="../../../asset/2024/06/mysql-index-4.png"></p><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li>按顺序插入时，会形成一个链表，查询性能大大降低。</li><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p><img data-src="../../../asset/2024/06/mysql-index-5.png"></p><p>由于红黑树（如上所示）也是一颗二叉树，因此也存在 “大数据量情况下，层级较深，检索速度慢” 的问题。所以，在 MySQL 的索引结构中，并没有选择二叉树或者红黑树，而选择的是 B+ 树。那什么是 B+ 树呢？在详解 B+ 树 之前，先来介绍一下 B- 树。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B- 树"></a>B- 树</h3><p><img data-src="../../../asset/2024/06/mysql-index-6.png"></p><ul><li><p>定义：</p><ul><li>B- 树是一种多叉路平衡查找树，相对于二叉树，B- 树每个节点可以有多个分支，即多叉。</li><li>以一颗最大度数（max-degree）为 5 (5 阶) 的 B- 树为例，那这个 B- 树每个节点最多存储 4 个 Key，5 个指针。</li><li>树的度数指的是一个节点的子节点个数。</li></ul></li><li><p>特点：</p><ul><li>5 阶的 B- 树，每一个节点最多存储 4 个 Key，对应 5 个指针。</li><li>一旦节点存储的 Key 数量到达 5，就会裂变，中间元素向上分裂。</li><li>在 B- 树中，非叶子节点和叶子节点都会存放数据。</li></ul></li></ul><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>B+ 树是 B- 树的变种，以一颗最大度数（max-degree）为 4（4 阶）的 B+ 树为例，来看一下其结构示意图：</p><p><img data-src="../../../asset/2024/06/mysql-index-7.png"></p><p>从上图可以看到，两部分：</p><ul><li>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</li><li>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</li></ul><p><strong>B+ 树与 B- 树的区别</strong>：</p><ul><li>B+ 树的叶子节点会形成一个单向链表。</li><li>B+ 树的所有数据都只会存放在叶子节点。</li><li>B+ 树的非叶子节点仅仅起到索引数据作用，具体的数据都是存放在叶子节点。</li></ul><p><strong>B+ 树相比 B- 树的优势</strong>：</p><ul><li>单一节点存储更多的元素，使得查询的 I/O 次数更少。</li><li>所有查询都要查找到叶子节点，查询性能稳定。</li><li>所有叶子节点形成有序链表，便于范围查询。</li></ul><p>上述所看到的结构是标准的 B+ 树的数据结构，接下来再看看 MySQL 中优化之后的 B+ 树。MySQL 索引数据结构对经典的 B+ 树进行了优化，在原 B+ 树的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+ 树，提高区间访问的性能，利于排序。</p><p><img data-src="../../../asset/2024/06/mysql-index-8.png"></p><p><strong>为什么 InnoDB 选择 B+ 树作为索引结构？</strong></p><ul><li>相对于二叉树，B+ 树的层级更少，搜索效率更高。</li><li>相对 Hash 索引，B+ 树支持范围查找以及排序操作。</li><li>对于 B- 树，无论是叶子节点还是非叶子节点都会保存数据，这样会导致一页中存储的键值减少，指针跟着减少；要同样保存大量数据，只能增加树的高度，导致性能降低。</li><li>B+ 树中间节点没有卫星数据（索引元素所指向的数据记录），只有索引。这就意味着同样的大小的磁盘页可以容纳更多节点元素，在相同的数据量下，B+ 树更加 “矮胖”，I/O 操作更少。</li><li>因为卫星数据的不同，导致查询过程也不同；B- 树的查找只需找到匹配元素即可，最好情况下查找到根节点，最坏情况下查找到叶子结点，所说性能很不稳定，而 B+ 树每次必须查找到叶子结点，性能稳定。</li></ul><div class="admonition note"><p class="admonition-title">提示</p><p>MySQL 索引使用的是 B+ 树，因为索引是用来加快查询速度的，而 B+ 树会对数据进行排序，所以它可以提高查询速度。另外，在一个 B+ 树的节点中可以存储多个元素，从而可以使得 B+ 树的高度不会太高。在 MySQL 中一个 InnoDB ⻚就是一个 B+ 树节点，一个 InnoDB ⻚默认 16KB， 所以一般情况下一颗两层的 B+ 树可以存 2000 万行左右的数据。通过利用 B+ 树的叶子节点存储所有数据，并进行排序，而且叶子节点之间通过链表连接，这样可以很好地支持范围查询等 SQL 语句。</p></div><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>MySQL 中除了支持 B+ 树索引，还支持一种 Hash 索引类型。</p><ul><li>结构：<ul><li>哈希索引就是采用一定的 Hash 算法，将键值换算成新的 Hash 值，映射到对应的槽位上，然后存储在 Hash 表中。</li></ul></li></ul><p><img data-src="../../../asset/2024/06/mysql-index-9.png"></p><p>如果两个（或多个）键值，映射到一个相同的槽位上，那就会产生哈希冲突（也称为哈希碰撞），可以通过链表来解决。</p><p><img data-src="../../../asset/2024/06/mysql-index-10.png"></p><ul><li>特点：<ul><li>Hash 索引只支持对等比较（如 =，in），不支持范围查询（如 between、&gt;、&lt;、…）。</li><li>无法利用索引完成排序操作。</li><li>查询效率高，通常（不存在哈希冲突的情况）只需要一次检索就可以了，效率通常要高于 B+ 树索引。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">存储引擎的支持</p><p>在 MySQL 中，支持 Hash 索引的是 Memory 存储引擎。而 InnoDB 中具有自适应 Hash 功能，Hash 索引是 InnoDB 存储引擎根据 B+ 树索引在指定条件下自动构建的。</p></div><h2 id="联合索引的数据结构"><a href="#联合索引的数据结构" class="headerlink" title="联合索引的数据结构"></a>联合索引的数据结构</h2><h3 id="联合索引的定义"><a href="#联合索引的定义" class="headerlink" title="联合索引的定义"></a>联合索引的定义</h3><p>联合索引又叫组合索引（复合索引），例如下表：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">24</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `position` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `birthday` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_name_age_position` (`name`,`age`,`position`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></tbody></table></figure><p>如下索引就是一个联合索引：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`idx_name_age_position` (`name`,`age`,`position`) <span class="keyword">USING</span> BTREE</span><br></pre></td></tr></tbody></table></figure><h3 id="联合索引的结构"><a href="#联合索引的结构" class="headerlink" title="联合索引的结构"></a>联合索引的结构</h3><p>联合索引的底层数据结构如下：</p><p><img data-src="../../../asset/2024/06/mysql-index-14.png"></p><p>比较相等时，先比较第一列的值，如果相等，再继续比较第二列，以此类推。了解联合索引的存储结构后，就知道索引最左前缀匹配原则是怎么回事了。在使用联合索引时，对于索引列的定义顺序将会影响到最终查询时索引的使用情况。例如联合索引 <code>(name, age, position)</code>，MySQL 会从最左边的列优先匹配，如果最左边的带头大哥 <code>name</code> 字段没有使用到，在未使用覆盖索引的情况下，就只能全表扫描（因为索引失效了）。简而言之，使用联合索引时，MySQL 会优先使用联合索引的第一列进行匹配，此后才会匹配下一列；如果不指定第一列匹配的值，也就无法得知下一步查询哪个节点。</p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为两种：聚簇索引（主键索引、聚集索引）、非聚簇索引（非主键索引、辅助索引、二级索引）。</p><p><img data-src="../../../asset/2024/06/mysql-index-11.png"></p><ul><li><p><strong>聚簇索引（Clustered Index）</strong>：</p><ul><li>定义：索引和数据存储在一起。数据表中的记录按索引的键值顺序存储在磁盘上。每个表只能有一个聚簇索引。</li><li>特点：<ul><li>数据存储顺序：数据物理上按索引键的顺序存储。</li><li>主键：通常主键会自动成为聚簇索引，但也可以指定其他列为聚簇索引。</li><li>索引结构：InnoDB 的聚簇索引是按照主键顺序构建 B+ 树结构的。</li><li>检索速度：对索引键的查询速度较快，因为数据和索引在一起。</li><li>插入和更新：插入和更新可能会比较慢，因为需要保持数据的物理顺序。</li><li>适用场景：适用于经常需要范围查询的场景，比如查找某一范围内的数据。</li></ul></li></ul></li><li><p><strong>非聚簇索引（Non-Clustered Index）</strong>：</p><ul><li>定义：索引和数据分开存储。非聚簇索引存储的是索引键值和指向数据记录的指针。每个表可以有多个非聚簇索引。</li><li>特点：<ul><li>数据存储顺序：数据的物理存储顺序与索引无关。</li><li>索引存储：索引存储的是键值和指向数据的指针。</li><li>检索速度：对索引键的检索速度较快，但访问实际数据时需要通过指针进行二次查找。</li><li>插入和更新：插入和更新相对较快，因为不需要保持数据的物理顺序。</li><li>适用场景：适用于查找特定值或者少量记录的场景。</li></ul></li></ul></li><li><p><strong>聚簇索引的选取规则</strong>：</p><ul><li>如果存在主键（Primary Key），主键索引就是聚簇索引。</li><li>如果不存在主键，将使用第一个唯一（Unique）索引作为聚簇索引。</li><li>如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动创建一个隐藏的 row-id 作为聚簇索引。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">存储引擎的支持</p><ul><li>InnoDB 使用的是聚簇索引，树的叶子节点上的 data 就是数据本身。</li><li>MyISAM 使用的是非聚簇索引，树的叶子节点上的 data 不是数据本身，而是数据存放的地址。</li></ul></div><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>当执行如下的 SQL 语句时（name 字段建立了索引），具体的查找过程是什么样子的？</p><p><img data-src="../../../asset/2024/06/mysql-index-12.png"></p><p>具体查找过程如下:</p><ul><li>(1) 由于是根据 name 字段进行查询，所以先根据 name=’Arm’ 条件到 name 字段的二级索引中进行匹配查找，但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>(2) 由于查询返回的数据是主键值，所以此时，还需要根据主键值 10，到聚集索引中查找对应的数据记录。</li><li>(3) 最终拿到这一行的数据，直接返回即可。</li></ul><h3 id="思考题目一"><a href="#思考题目一" class="headerlink" title="思考题目一"></a>思考题目一</h3><p>以下两条 SQL 语句（id 字段为主键，name 字段建立了索引），哪个执行效率更高？为什么？</p><ul><li>A. select * from user where id = 10;</li><li>B. select * from user where name = ‘Arm’;</li></ul><p>A 语句的执行效率要高于 B 语句。因为 A 语句直接走聚簇索引，可以直接返回数据。而 B 语句需要先查询 name 字段的非聚簇索引（二级索引），然后再查询聚簇索引，也就是需要进行回表查询，所以效率不高。</p><div class="admonition note"><p class="admonition-title">什么是回表查询</p><p>先根据普通索引（非聚簇索引）查询到主键值，再根据主键值在聚簇索引中获取行记录，这就是回表查询。值得一提的是，回表查询，相对于只扫描一遍聚簇索引的性能，要低一些。</p></div><p>使用覆盖索引来避免回表：</p><ul><li><p>什么是覆盖索引：指索引包含了查询中涉及的所有列（包括需要筛选、排序和返回的列），这样就可以直接从索引中获取所有需要的数据，而不需要访问数据表本身。覆盖索引是一种避免回表查询的优化策略，只需要在一棵索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快。</p></li><li><p>具体的实现方式：将被查询的字段都建立普通索引或者联合索引，这样的话就可以直接返回索引中的数据，不需要再通过聚簇索引去定位行记录，避免了回表操作的执行。</p></li></ul><h3 id="思考题目二"><a href="#思考题目二" class="headerlink" title="思考题目二"></a>思考题目二</h3><p>InnoDB 主键索引的 B+ 树最多能存储多少条记录？</p><p><img data-src="../../../asset/2024/06/mysql-index-13.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">假设：一行数据大小为 1k，一页中就可以存储 16 行这样的数据（页的大小 16K）。</span><br><span class="line">InnoDB 的指针占用 6 个字节的空间，主键即使为 bigint，占用字节数为 8。</span><br><span class="line"></span><br><span class="line">高度为 2 时：设 key 为 n ，则指针数量为 n + 1。</span><br><span class="line">n * 8 + (n + 1) * 6 = 16 * 1024，算出 n 约为 1170</span><br><span class="line"></span><br><span class="line">每一个指针指向一个页，一个页是 16K，一行数据大小为 1k。</span><br><span class="line">1171 * 16 = 18736，指针 × 行数 = 记录。</span><br><span class="line"></span><br><span class="line">也就是说，如果 B+ 树的高度为 2，则可以存储 18000 条左右记录。</span><br><span class="line"></span><br><span class="line">高度为 3 时：第一层根节点只有一个节点，一个节点由上面算出来是 1171 个指针，在第 2 层每一个节点那就也有 1171 个指针。</span><br><span class="line">所以此时指针共有 1711 * 1171 个，再 x16 就是记录数。</span><br><span class="line">1171 * 1171 * 16 = 21939856</span><br><span class="line"></span><br><span class="line">也就是说，如果 B+ 树的高度为 3，则可以存储 2200w 条左右的记录。</span><br><span class="line"></span><br><span class="line">所以 InnoDB 中的 B+ 树高度一般为 1 ~ 3 层，就可以满足千万级别的数据存储。在查找数据时，一次页的查找代表一次 I/O，所以通过主键索引查询通常只需要 1 ~ 3 次 I/O 操作即可查找到数据。</span><br></pre></td></tr></tbody></table></figure><h2 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h2><h3 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h3><ul><li>创建索引 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX index_name <span class="keyword">ON</span> table_name (index_col_name, ... ) ;</span><br></pre></td></tr></tbody></table></figure><ul><li>查看索引 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name ;</span><br></pre></td></tr></tbody></table></figure><ul><li>删除索引 </li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name ;</span><br></pre></td></tr></tbody></table></figure><h3 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A. name 字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_name <span class="keyword">ON</span> tb_user(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- B. phone 手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_user_phone <span class="keyword">ON</span> tb_user(phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- C. 为 profession、age、status 创建联合索引。</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_pro_age_sta <span class="keyword">ON</span> tb_user(profession, age, status);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- D. 为 email 建立合适的索引来提升查询效率。</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_email <span class="keyword">ON</span> tb_user(email);</span><br></pre></td></tr></tbody></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="高频面试题一"><a href="#高频面试题一" class="headerlink" title="高频面试题一"></a>高频面试题一</h3><blockquote><p>面试题：为什么建议 InnoDB 表必须创建主键，并且推荐使用整型的自增主键？</p></blockquote><ul><li><p>(1) 如果在创建表时不设置主键，InnoDB 会自动从第一列开始筛选一列数据不重复的列（唯一列）做为主键，如果找不到这样的列，就会自动创建一个隐藏的列（row-id）做为主键，这会大大增加 MySQL 的工作量，所以建议在创建 InnoDB 表时一定要设置主键。</p></li><li><p>(2) 使用整型的字段做为主键，一方面在数据比较时不需要进行转换，另一方面存储也比较节省空间。那为什么要强调主键自增呢？如果主键 ID 是无序的，那么很有可能新插入的值会导致当前节点分裂，此时 MySQL 不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。反之，如果每次插入有序，那就会在当前页后面连续写入，写不下就会重新分配一个节点，内存都是连续的，这样效率自然也就最高了。</p></li></ul><h3 id="高频面试题二"><a href="#高频面试题二" class="headerlink" title="高频面试题二"></a>高频面试题二</h3><blockquote><p>面试题：为什么非聚簇索引结构的叶子节点存储的是主键值？</p></blockquote><p>非聚簇索引的叶子节点存储主键值而非全部数据，主要也是为了一致性和节省空间。如果非聚簇索引储存的也是数据，那么每次插入 MySQL 都不得不更新每棵索引树，这样就加剧了新增、更改数据时的性能损耗，并且这样一来空间利用率也不高，必然产生了大量冗余数据。</p><h3 id="高频面试题三"><a href="#高频面试题三" class="headerlink" title="高频面试题三"></a>高频面试题三</h3><blockquote><p>面试题：为什么 InnoDB 选择 B+ 树作为索引结构？</p></blockquote><ul><li>相对于二叉树，B+ 树的层级更少，搜索效率更高。</li><li>相对 Hash 索引，B+ 树支持范围查找以及排序操作。</li><li>对于 B- 树，无论是叶子节点还是非叶子节点都会保存数据，这样会导致一页中存储的键值减少，指针跟着减少；要同样保存大量数据，只能增加树的高度，导致性能降低。</li><li>B+ 树中间节点没有卫星数据（索引元素所指向的数据记录），只有索引。这就意味着同样的大小的磁盘页可以容纳更多节点元素，在相同的数据量下，B+ 树更加 “矮胖”，I/O 操作更少。</li><li>因为卫星数据的不同，导致查询过程也不同；B- 树的查找只需找到匹配元素即可，最好情况下查找到根节点，最坏情况下查找到叶子结点，所说性能很不稳定，而 B+ 树每次必须查找到叶子结点，性能稳定。</li></ul><h3 id="高频面试题四"><a href="#高频面试题四" class="headerlink" title="高频面试题四"></a>高频面试题四</h3><blockquote><p>面试题：B 树与 B+ 树的区别是什么？</p></blockquote><p>B 树和 B+ 树是两种不同的树形数据结构，主要用于数据库索引和文件系统。</p><ul><li><p><strong>B 树</strong>：</p><ul><li>(1) 节点结构：每个节点包含键值和指向子节点的指针。一个节点可以存储多个键值和多个指针。</li><li>(2) 数据存储：所有节点（包括叶子节点和非叶子节点）都可以存储数据记录。</li><li>(3) 查找路径：在查找过程中，可以在任意节点上找到目标键值。</li><li>(4) 叶子节点：叶子节点没有链表结构，不需要相互连接。</li><li>(5) 保证有序：键值在节点内是按顺序排列的，而且节点之间的子节点指针也会根据键值的顺序进行排列。</li></ul></li><li><p><strong>B+ 树</strong>：</p><ul><li>(1) 节点结构：非叶子节点只存储键值和指向子节点的指针，不存储数据记录。</li><li>(2) 数据存储：所有数据记录都存储在叶子节点上，非叶子节点仅用于索引。</li><li>(3) 查找路径：在查找过程中，所有查找最终都会落在叶子节点上，因为数据记录只存储在叶子节点。</li><li>(4) 叶子节点：所有叶子节点形成一个有序的链表，便于范围查询和顺序访问。</li><li>(5) 保证有序：键值在非叶子节点内是按顺序排列的，而且数据记录在叶子节点内也是按顺序排列的。</li></ul></li></ul><p>B 树与 B+ 树的区别如下：</p><ul><li><p>(1) <strong>叶子节点的结构</strong>：</p><ul><li>B 树：叶子节点之间没有链表结构。</li><li>B+ 树：叶子节点通过链表连接，便于顺序访问。</li></ul></li><li><p>(2) <strong>数据存储位置</strong>：</p><ul><li>B 树：数据记录存储在所有节点上。</li><li>B+ 树：数据记录只存储在叶子节点上，非叶子节点仅用于索引。</li></ul></li><li><p>(3) <strong>查询效率</strong>：</p><ul><li>B 树：查询时可能在非叶子节点找到数据，搜索路径较短。</li><li>B+ 树：所有查询都必须到达叶子节点，但叶子节点之间的有序链表结构提高了范围查询和顺序访问的效率。</li></ul></li><li><p>(4) <strong>范围查询</strong>：</p><ul><li>B 树：范围查询不如 B+ 树高效，叶子节点之间没有链表结构。</li><li>B+ 树：范围查询更高效，因为叶子节点按顺序链表连接。</li></ul></li></ul><p>综上所述，B 树和 B+ 树各有优劣。B 树在查找单个键值时可能效率更高，而 B+ 树在范围查询和顺序访问方面表现更佳，因此在数据库系统中，B+ 树更为常用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cloud.tencent.com/developer/article/2197608">MySQL 6 种索引数据结构详解</a></li><li><a href="https://cloud.tencent.com/developer/article/1739709">深入理解 MySQL 索引底层数据结构</a></li><li><a href="https://blog.csdn.net/fvdfsdafdsafs/article/details/138211176">索引原理分析 (AVL 树、B-Tree、B+Tree)</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 MySQL 索引的底层数据结构，包括二叉树、B- 树、B+ 树、哈希表等。</summary>
    
    
    
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Butterfly 主题整合 TechGrow 公众号引流工具</title>
    <link href="https://www.techgrow.cn/posts/8e3e42f0.html"/>
    <id>https://www.techgrow.cn/posts/8e3e42f0.html</id>
    <published>2024-05-11T12:52:08.000Z</published>
    <updated>2024-05-11T12:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a> 是一款优秀的 Hexo 第三方主题，高版本的 Butterfly（如 4.13.0 版本），不能使用 <a href="https://github.com/rqh656418510/hexo-readmore">hexo-readmore</a> 插件来整合 <a href="https://docs.techgrow.cn/">TechGrow 公众号引流工具</a>；否则会导致 Pjax 不能完全生效，比如从首页点击文章链接进入文章页面后，APlayer 播放器会中断播放（即记不住播放进度）。解决方法是，采用手动整合的方式来使用公众号引流工具。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>第一步：卸载已安装的 <code>hexo-readmore</code> 插件 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-readmore --save</span><br></pre></td></tr></tbody></table></figure><ul><li>第二步：在 Hexo 的 <code>_config.yml</code> 配置文件里面，删除所有与 <code>hexo-readmore</code> 插件相关的配置信息</li></ul><span id="more"></span><h2 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h2><p>更改 Butterfly 主题的 <code>_config.yml</code> 文件，添加以下配置信息</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel="stylesheet"</span> <span class="string">type="text/css"</span> <span class="string">href="https://qiniu.techgrow.cn/readmore/dist/hexo.css"&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src="https://qiniu.techgrow.cn/readmore/dist/readmore.js"</span> <span class="string">type="text/javascript"&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax&gt;var</span> <span class="string">isMobile=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows</span> <span class="string">Phone)/i);var</span> <span class="string">allowMobile=false;if(!isMobile||(isMobile&amp;&amp;allowMobile)){try{var</span> <span class="string">plugin=new</span> <span class="string">ReadmorePlugin();plugin.init({"type":"hexo","id":"article-container","name":"全栈技术驿站","blogId":"18762-1609305354821-257","qrcode":"https://www.techgrow.cn/img/wx_mp_qr.png","keyword":"Tech","random":"1","height":"auto","expires":"365","interval":"30","tocSelector":"#card-toc"})}catch(e){console.warn("readmore</span> <span class="string">plugin</span> <span class="string">occurred</span> <span class="string">error")}}&lt;/script&gt;</span></span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">提示</p><p>上面最后一行的配置内容，是基于下面的 HTML 代码压缩得到，请根据实际情况更改对应的博客信息。如何希望在移动端设备中，也需要扫码关注才能解锁文章，那么可以将下述代码更改为 <code>var allowMobile = true;</code></p></div><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-pjax</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> isMobile = navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> allowMobile = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (!isMobile || (isMobile &amp;&amp; allowMobile)) {</span></span><br><span class="line"><span class="javascript"><span class="keyword">try</span> {</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> plugin = <span class="keyword">new</span> ReadmorePlugin();</span></span><br><span class="line"><span class="javascript">plugin.init({</span></span><br><span class="line"><span class="javascript"><span class="string">"type"</span>: <span class="string">"hexo"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"id"</span>: <span class="string">"article-container"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"name"</span>: <span class="string">"全栈技术驿站"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"blogId"</span>: <span class="string">"18762-1609305354821-257"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"qrcode"</span>: <span class="string">"https://www.techgrow.cn/img/wx_mp_qr.png"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"keyword"</span>: <span class="string">"Tech"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"random"</span>: <span class="string">"1"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"height"</span>: <span class="string">"auto"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"expires"</span>: <span class="string">"365"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"interval"</span>: <span class="string">"30"</span>,</span></span><br><span class="line"><span class="javascript"><span class="string">"tocSelector"</span>: <span class="string">"#card-toc"</span></span></span><br><span class="line"><span class="javascript">});</span></span><br><span class="line"><span class="javascript">} <span class="keyword">catch</span>(e) {</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.warn(<span class="string">"readmore plugin occurred error"</span>);</span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="构建博客"><a href="#构建博客" class="headerlink" title="构建博客"></a>构建博客</h2><p>执行以下的 Hexo 命令，重新构建博客，并在本地预览。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理静态文件</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动预览服务</span></span><br><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 Butterfly 主题如何整合 TechGrow 公众号引流工具。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="静态博客" scheme="https://www.techgrow.cn/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>软件开发画图软件推荐</title>
    <link href="https://www.techgrow.cn/posts/796276ab.html"/>
    <id>https://www.techgrow.cn/posts/796276ab.html</id>
    <published>2024-04-27T13:18:36.000Z</published>
    <updated>2024-04-27T13:18:36.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="画图软件"><a href="#画图软件" class="headerlink" title="画图软件"></a>画图软件</h2><table><thead><tr><th>软件</th><th>官网</th><th>适用场景</th><th>收费说明</th><th>版本说明</th></tr></thead><tbody><tr><td>亿图图示 </td><td><a href="https://www.edrawsoft.cn/edrawmax/">https://www.edrawsoft.cn/edrawmax/</a></td><td> 思维盗图、流程图、组织结构图、UML 图、软件架构图</td><td>基础功能免费，高级功能收费</td><td> PC 版、Web 版</td></tr><tr><td> ProcessOn</td><td><a href="https://www.processon.com/">https://www.processon.com/</a></td><td> 思维导图、流程图、组织结构图、原型图、UML 图、网络拓扑图</td><td>基础功能免费，高级功能收费</td><td> Web 版</td></tr></tbody></table><span id="more"></span>]]></content>
    
    
    <summary type="html">本文主要推荐好用的画图软件。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程死锁的定位与分析</title>
    <link href="https://www.techgrow.cn/posts/17b04dfd.html"/>
    <id>https://www.techgrow.cn/posts/17b04dfd.html</id>
    <published>2024-04-16T14:34:42.000Z</published>
    <updated>2024-04-16T14:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="线程死锁的介绍"><a href="#线程死锁的介绍" class="headerlink" title="线程死锁的介绍"></a>线程死锁的介绍</h2><p><strong>线程死锁是指在多线程编程中，两个或多个线程相互持有对方所需要的资源，而又同时等待对方释放资源，导致它们都无法继续执行的情况。</strong>在这种情况下，线程将被永久地阻塞，程序也无法正常执行下去。线程死锁是多线程编程中常见的问题，解决方法通常包括谨慎设计资源获取的顺序、使用超时机制、以及资源分配的策略等。</p><span id="more"></span><p><img data-src="../../../asset/2024/03/thread-dead-lock-1.png"></p><blockquote><p>产生线程死锁的原因</p></blockquote><ul><li>系统资源不足</li><li>资源分配不当</li><li>线程运行推进的顺序不对</li></ul><blockquote><p>产生线程死锁的四个必要条件</p></blockquote><ul><li>互斥<ul><li>解决方法：把互斥的共享资源封装成可同时访问（并发访问）</li></ul></li><li>占有且等待<ul><li>解决方法：在线程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会降低资源的利用效率</li></ul></li><li>非抢占式<ul><li>解决方法：如果线程不能立即分配到所需的全部资源，要求它不占有任何其他资源，也就是说只能够在同时获得所有需要的资源时，才执行资源分配操作</li></ul></li><li>循环等待<ul><li>解决方法：对资源进行排序，要求线程按顺序请求资源</li></ul></li></ul><h2 id="编写产生线程死锁的代码"><a href="#编写产生线程死锁的代码" class="headerlink" title="编写产生线程死锁的代码"></a>编写产生线程死锁的代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" get "</span> + lockA);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get "</span> + lockB);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String lockA = <span class="keyword">new</span> String(<span class="string">"lockA"</span>);</span><br><span class="line">        String lockB = <span class="keyword">new</span> String(<span class="string">"lockB"</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockA, lockB), <span class="string">"T1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockB, lockA), <span class="string">"T2"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T1 get lockA</span><br><span class="line">T2 get lockB</span><br><span class="line">程序卡住，线程死锁 ....</span><br></pre></td></tr></tbody></table></figure><h2 id="线程死锁代码定位与分析"><a href="#线程死锁代码定位与分析" class="headerlink" title="线程死锁代码定位与分析"></a>线程死锁代码定位与分析</h2><p>当 Java 程序出现死锁的时候，首先需要使用 <code>jps</code> 命令，查看当前正在运行的 Java 应用程序的进程 ID (PID)</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></tbody></table></figure><p>可以看到 DeadLockDemo 这个 Java 应用程序一直在运行，且进程 ID 是 73690</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">483 sun.tools.jps.Jps</span><br><span class="line">72677 com.intellij.idea.Main</span><br><span class="line">73669 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">73254 org.jetbrains.idea.maven.server.RemoteMavenServer36</span><br><span class="line">73690 com.java.interview.lock.DeadLockDemo</span><br></pre></td></tr></tbody></table></figure><p>然后使用 <code>jstack</code> 命令查看 Java 应用程序的堆栈信息</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack  73690    // 后面的数字是 jps 命令输出的 Java 应用程序的进程 ID (PID)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"T1":</span><br><span class="line">  waiting to lock monitor 0x00007f3794008200 (object 0x000000062ca6cfe8, a java.lang.String),</span><br><span class="line">  which is held by "T2"</span><br><span class="line">"T2":</span><br><span class="line">  waiting to lock monitor 0x00007f3794007f00 (object 0x000000062ca6cfa0, a java.lang.String),</span><br><span class="line">  which is held by "T1"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"T1":</span><br><span class="line">at com.java.interview.lock.HoldLockThread.run(DeadLockDemo.java:28)</span><br><span class="line">- waiting to lock &lt;0x000000062ca6cfe8&gt; (a java.lang.String)</span><br><span class="line">- locked &lt;0x000000062ca6cfa0&gt; (a java.lang.String)</span><br><span class="line">at java.lang.Thread.run(java.base@11.0.9/Thread.java:834)</span><br><span class="line">"T2":</span><br><span class="line">at com.java.interview.lock.HoldLockThread.run(DeadLockDemo.java:28)</span><br><span class="line">- waiting to lock &lt;0x000000062ca6cfa0&gt; (a java.lang.String)</span><br><span class="line">- locked &lt;0x000000062ca6cfe8&gt; (a java.lang.String)</span><br><span class="line">at java.lang.Thread.run(java.base@11.0.9/Thread.java:834)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></tbody></table></figure><p>通过查看最后一行的堆栈信息，可以看到 <code>Found 1 deadlock</code>，即表示 Java 应用程序存在一个死锁</p>]]></content>
    
    
    <summary type="html">本文主要介绍如何定位和分析 Java 线程死锁的代码。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Java" scheme="https://www.techgrow.cn/tags/Java/"/>
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器的性能诊断工具</title>
    <link href="https://www.techgrow.cn/posts/3898ef75.html"/>
    <id>https://www.techgrow.cn/posts/3898ef75.html</id>
    <published>2024-04-11T14:13:45.000Z</published>
    <updated>2024-04-11T14:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="查看整机系统性能"><a href="#查看整机系统性能" class="headerlink" title="查看整机系统性能"></a>查看整机系统性能</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>使用 <code>top</code> 命令，可以查看系统的负载情况，重点关注的是 <code>%CPU</code>、<code>%MEM</code> 、<code>load average</code> 三个性能指标。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p><img data-src="../../../asset/2024/04/linux-command-top.png"></p><p>这里的 <code>load average: 0.08, 0.10, 0.12</code> 代表系统的平均负载，三个值分别表示系统在过去 1 分钟、5 分钟、15 分钟内的平均负载情况。通常情况下，这个数值越低越好，因为它反映了系统的负载情况，即系统中正在运行或等待运行的进程数量。值得一提的是，在 <code>top</code> 命令运行期间，按下键盘的数字键 <code>1</code>，可以看到每个 CPU 的使用率。</p><h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h3><p>使用 <code>htop</code> 命令，通过友好和丰富的界面，可以更方便地查看和管理系统资源的使用情况。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop</span><br></pre></td></tr></tbody></table></figure><p><code>htop</code> 是一个交互式的系统监控工具，输出结果的格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1  [                                        0.0%]     Tasks: 94, 103 thr; 1 running</span><br><span class="line">2  [                                        0.1%]     Load average: 0.00 0.01 0.05</span><br><span class="line">3  [                                        0.0%]     Uptime: 10 days, 03:45:28</span><br><span class="line">4  [                                        0.0%]</span><br><span class="line">Mem[|||||||||||||||||||||||||||||||||||867/15861MB]</span><br><span class="line">Swp[                                        0/7999MB]</span><br><span class="line"></span><br><span class="line">PID USER      PRI  NI  VIRT   RES   SHR S CPU% MEM%   TIME+  Command</span><br><span class="line">943 root       20   0  1.7G 53968  6720 S  0.0  0.3  0:03.56 systemd</span><br><span class="line">937 root       20   0  1.7G 37500  6348 S  0.0  0.2  0:05.76 (sd-pam)</span><br><span class="line">923 root       20   0  381M 18424 11140 S  0.0  0.1  0:00.38 NetworkManager</span><br><span class="line">911 root       20   0  6.2G 12932  8568 S  0.0  0.1  0:01.14 Xorg</span><br><span class="line">707 root       20   0  1.8G 11920  7476 S  0.0  0.1  0:01.55 dockerd</span><br><span class="line">841 root       20   0  1.6G 11692  4380 S  0.0  0.1  0:00.60 polkitd</span><br><span class="line">918 root       20   0  1.3G  9264  5144 S  0.0  0.1  0:00.56 ModemManager</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>在这个界面中，可以使用键盘上的方向键和其他功能键来浏览进程列表和查看系统资源的使用情况。可以按下 <code>F1</code> 键查看帮助文档，以了解更多操作方法。</p><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>使用 <code>uptime</code> 命令，可以查看系统的运行时间以及系统的平均负载。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uptime</span><br></pre></td></tr></tbody></table></figure><p><code>uptime</code> 是系统性能命令的精简版，输出结果的格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15:32:11 up 10 days,  5:17,  2 users,  load average: 0.08, 0.10, 0.12</span><br></pre></td></tr></tbody></table></figure><h2 id="查看-CPU-信息"><a href="#查看-CPU-信息" class="headerlink" title="查看 CPU 信息"></a>查看 CPU 信息</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>使用 <code>vmstat</code> 命令，可以查看进程、内存、I/O 操作和 CPU 活动等统计信息。一般配合两个数字参数来使用，第一个参数是采样的时间间隔（以秒为单位），第二个参数是采样的次数。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat -n 2 3   // 每隔2秒采样一次，一共采样3次</span><br></pre></td></tr></tbody></table></figure><p><code>vmstat</code> 命令的输出结果格式如下：</p><p><img data-src="../../../asset/2024/03/linux-command-vmstat-0.png"></p><p><code>vmstat</code> 命令的输出结果说明如下：</p><ul><li><p><code>procs</code></p><ul><li><code>r</code>: 正在运行或等待运行的进程数量。如果这个数字长期高于 CPU 核心数量，则表示系统可能存在 CPU 瓶颈。</li><li><code>b</code>: 在等待 I/O 操作完成时被阻塞的进程数量。如果这个数字持续增长，则表示可能存在磁盘 I/O、网络 I/O 等瓶颈。</li></ul></li><li><p><code>memory</code>:</p><ul><li><code>swpd</code>: 虚拟内存已使用的大小（单位：KB）。即表示被换出到磁盘的内存大小。</li><li><code>free</code>: 空闲内存的大小（单位：KB）。</li><li><code>buff</code>: 用作缓冲区的内存大小（单位：KB）。缓冲区是用于存储文件系统元数据的内存。</li><li><code>cache</code>: 用作缓存的内存大小（单位：KB）。缓存是用于存储文件数据的内存。</li><li><code>si</code>: 每秒从磁盘交换到内存的数据量（单位：KB）。</li><li><code>so</code>: 每秒从内存交换到磁盘的数据量（单位：KB）。</li></ul></li><li><p><code>swap</code>:</p><ul><li><code>si</code>: 每秒从磁盘交换到内存的数据量（单位：KB）。</li><li><code>so</code>: 每秒从内存交换到磁盘的数据量（单位：KB）。</li></ul></li><li><p><code>io</code>:</p><ul><li><code>bi</code>: 每秒从块设备读取的块数量（单位：blocks/s）。</li><li><code>bo</code>: 每秒写入块设备的块数量（单位：blocks/s）。</li></ul></li><li><p><code>system</code>:</p><ul><li><code>in</code>: 每秒中断的数量，包括时钟中断。</li><li><code>cs</code>: 每秒上下文切换的数量（单位：次 /s）。</li></ul></li><li><p><code>cpu</code></p><ul><li><code>us</code>：用户进程的 CPU 时间占用百分比，us 值越高，用户进程消耗的 CPU 时间越多，如果长期大于 <code>50%</code>，则需要优化程序。</li><li><code>sy</code>：内核进程的 CPU 时间占用百分比。</li><li><code>id</code>：CPU 空闲时间占用百分比。</li><li><code>wa</code>：等待 I/O 操作完成的 CPU 时间占用百分比。</li><li><code>st</code>：被虚拟机监控程序（如 KVM）偷取的 CPU 时间百分比</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><p>us + sy 的参考值为 <code>80%</code>，如果 us + sy 大于 <code>80%</code>，说明系统可能存在 CPU 资源不足的问题。</p></div><h3 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h3><p>使用 <code>mpstat</code> 命令，可以查看每个 CPU 的统计信息，包括 CPU 的使用情况、上下文切换、中断等。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 5     // 每隔5秒显示一次每个CPU的统计信息</span><br></pre></td></tr></tbody></table></figure><h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><p>使用 <code>pidstat</code> 命令，可以查看进程的 CPU、内存、I/O 以及上下文切换等资源的使用情况。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pidstat -u 5    // 每隔5秒显示一次所有进程的CPU使用情况</span><br><span class="line">pidstat -u 5 -p 14421    //每隔5秒显示一次进程ID为14421的CPU使用情况</span><br><span class="line">pidstat -u 5 -p 14421 25541    //每隔5秒显示一次进程ID为14421、25541的CPU使用情况</span><br></pre></td></tr></tbody></table></figure><p><code>pidstat</code> 命令的输出结果格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15时06分35秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">15时06分40秒  1000      5997    0.40    0.40    0.00    0.80    17  java</span><br></pre></td></tr></tbody></table></figure><p><code>pidstat</code> 命令的输出结果说明如下：</p><ul><li><code>PID</code>：进程 ID。</li><li><code>%usr</code>：用户空间的 CPU 使用率，即进程在用户模式下消耗 CPU 的百分比。</li><li><code>%system</code>：内核空间的 CPU 使用率，即进程在内核模式下消耗 CPU 的百分比。</li><li><code>%guest</code>：虚拟 CPU 使用率，即进程运行虚拟 CPU 的时间百分比。</li><li><code>%CPU</code>：进程在所有 CPU 上的 CPU 使用率。</li><li><code>CPU</code>：进程运行的 CPU 编号。</li><li><code>Command</code>：进程的命令名称。</li></ul><h2 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h2><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>使用 <code>free</code> 命令，可以查看系统内存的使用情况，包括物理内存、交换空间和系统缓存的使用情况。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">free       // 输出的内存大小会以KB为单位显示</span><br><span class="line">free -m    // 输出的内存大小会以MB为单位显示</span><br><span class="line">free -g    // 输出的内存大小会以GB为单位显示</span><br><span class="line">free -h    // 输出的内存大小会自动以人类能看懂的方式（如KB、MB、GB）来显示</span><br></pre></td></tr></tbody></table></figure><p><code>free</code> 命令的输出结果格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       16238752     3190972     8253404      520508     4799376    12177876</span><br><span class="line">Swap:       2097148           0     2097148</span><br></pre></td></tr></tbody></table></figure><p><code>free</code> 命令的输出结果说明如下：</p><ul><li><code>total</code>: 总的物理内存大小。</li><li><code>used</code>: 已经被使用的物理内存大小。</li><li><code>free</code>: 可用的物理内存大小。</li><li><code>shared</code>: 被共享的内存大小，一般为 0。</li><li><code>buff/cache</code>: 用作缓存的内存大小。</li><li><code>available</code>: 可用的内存大小。</li><li><code>Swap total</code>: 交换空间的总大小。</li><li><code>Swap used</code>: 已经被使用的交换空间大小。</li><li><code>Swap free</code>: 可用的交换空间大小。</li></ul><h2 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>使用 <code>df</code> 命令，可以查看磁盘空间的使用情况，包括磁盘的总空间、已用空间、可用空间以及文件系统的挂载点。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h       // 输出的磁盘空间大小会以人类能看懂的方式（如KB、MB、GB）来显示</span><br></pre></td></tr></tbody></table></figure><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>使用 <code>iostat</code> 命令，可以查看磁盘 I/O 活动、磁盘分区的吞吐量和响应时间等。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -xdk 2 3     // 每隔2秒采样一次，一共采样3次</span><br></pre></td></tr></tbody></table></figure><p><code>iostat</code> 命令的输出结果格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00    34.63    1.56    2.57    28.16   148.78    85.77     0.91  220.93    5.91  351.07   3.30   1.36</span><br><span class="line">sdb               0.00     0.01    0.41    0.00     4.72     0.04    23.32     0.00    3.06    3.06    1.75   2.75   0.11</span><br></pre></td></tr></tbody></table></figure><p><code>iostat</code> 命令的输出结果说明如下：</p><ul><li><code>Device</code>：磁盘或分区的设备名。</li><li><code>rrqm/s</code>：每秒钟合并的读取请求。</li><li><code>wrqm/s</code>：每秒钟合并的写入请求。</li><li><code>r/s</code>：每秒钟完成的读取请求次数（独立请求）。</li><li><code>w/s</code>：每秒钟完成的写入请求次数（独立请求）。</li><li><code>rkB/s</code>：每秒从磁盘读取的数据量，单位为 KB/s。</li><li><code>wkB/s</code>：每秒写入到磁盘的数据量，单位为 KB/s。</li><li><code>avgrq-sz</code>：平均每个请求的扇区数。</li><li><code>avgqu-sz</code>：平均请求队列长度。</li><li><code>await</code>：平均 I/O 操作等待时间（单位为毫秒）。</li><li><code>r_await</code>：平均读取操作等待时间（单位为毫秒）。</li><li><code>w_await</code>：平均写入操作等待时间（单位为毫秒）。</li><li><code>svctm</code>：平均 I/O 操作服务时间（单位为毫秒）。</li><li><code>%util</code>：设备利用率，即设备在采样周期内的活动时间与周期总时间的比率。</li></ul><div class="admonition warning"><p class="admonition-title">特别注意</p><ul><li><code>awit</code> 的值越小，代表磁盘性能越好。</li><li><code>rkB/s</code> 与 <code>wkB/s</code> 根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据的读写，肯定不正常，必须需要优化程序。</li><li><code>svctm</code> 的值与 <code>await</code> 的值很接近，表示几乎没有 I/O 等待，磁盘性能好。如果 <code>await</code> 的值远高于 <code>svctm</code> 的值，则表示 I/O 队列等待太长，需要优化程序或更换更快的磁盘（如 SSD 硬盘）。</li></ul></div><h3 id="pidstat-1"><a href="#pidstat-1" class="headerlink" title="pidstat"></a>pidstat</h3><p>使用 <code>pidstat</code> 命令，可以查看进程的磁盘 I/O 等统计信息。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pidstat -d -u 5                   // 每隔5秒显示一次所有进程的磁盘I/O情况</span><br><span class="line">pidstat -d -u 5 -p 14421          // 每隔5秒显示一次进程ID为14421的磁盘I/O情况</span><br><span class="line">pidstat -d -u 5 -p 14421 25541    // 每隔5秒显示一次进程ID为14421、25541的磁盘I/O情况</span><br></pre></td></tr></tbody></table></figure><p><code>pidstat</code> 命令的输出结果格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16时24分13秒   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">16时24分15秒  1000      5997      0.00      0.00      0.00  java</span><br></pre></td></tr></tbody></table></figure><p><code>pidstat</code> 命令的输出结果说明如下：</p><ul><li><code>UID</code>：进程所属用户的用户 ID。</li><li><code>PID</code>：进程 ID。</li><li><code>kB_rd/s</code>：每秒从磁盘读取的数据量（单位为 KB）。</li><li><code>kB_wr/s</code>：每秒写入到磁盘的数据量（单位为 KB）。</li><li><code>kB_ccwr/s</code>：每秒取消预读取的数据量（单位为 KB）。</li><li><code>Command</code>：进程的命令名称。</li></ul><h2 id="查看网络信息"><a href="#查看网络信息" class="headerlink" title="查看网络信息"></a>查看网络信息</h2><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>使用 <code>netstat</code> 命令，可以查看网络连接、路由表、接口统计信息等。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">netstat -a  // 显示所有活动的网络连接</span><br><span class="line">netstat -l  // 显示所有监听端口</span><br><span class="line">netstat -t  // 显示所有 TCP 连接</span><br><span class="line">netstat -u  // 显示所有 UDP 连接</span><br><span class="line">netstat -p  // 显示进程和 PID</span><br><span class="line">netstat -r  // 显示路由表</span><br><span class="line">netstat -i  // 显示接口统计信息</span><br><span class="line">netstat -n  // 以数字形式显示网络连接和路由信息，忽略对 IP 地址和端口号的主机名解析</span><br><span class="line">netstat -tuln | grep 3306  // 显示所有监听的 TCP 连接，并筛选出其中监听在本地端口 3306 上的连接</span><br><span class="line">netstat -aon|grep 3306  // 显示所有的网络连接和监听端口，并筛选出本地端口为 3306 的连接，并显示与之相关联的进程 ID</span><br></pre></td></tr></tbody></table></figure><p><code>netstat</code> 命令的输出结果格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1234/sshd           </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      5678/sendmail       </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      9012/httpd          </span><br><span class="line">udp        0      0 0.0.0.0:68              0.0.0.0:*                           3456/dhclient       </span><br><span class="line">udp        0      0 0.0.0.0:123             0.0.0.0:*                           7890/ntpd           </span><br></pre></td></tr></tbody></table></figure><h3 id="ifstat"><a href="#ifstat" class="headerlink" title="ifstat"></a>ifstat</h3><p>使用 <code>ifstat</code> 命令，可以查看每个网络接口的输入和输出流量信息。Linux 系统默认是没有 <code>ifstat</code> 命令的，需要自行安装。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstat         // 查看所有网络接口的流量信息</span><br><span class="line">ifstat eth0    // 查看特定网络接口的流量信息</span><br></pre></td></tr></tbody></table></figure><p><code>ifstat</code> 命令的输出结果格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Interface        RX Pkts/Rate    TX Pkts/Rate    RX Data/Rate    TX Data/Rate  </span><br><span class="line">                 RX Errs/Drop    TX Errs/Drop    RX Over/Rate    TX Coll/Rate  </span><br><span class="line">lo                  1175 0          1175 0        103200 0        103200 0      </span><br><span class="line">                       0 0             0 0             0 0             0 0      </span><br><span class="line">eth0                8183 0         24556 0        677082 0        34262K 0      </span><br><span class="line">                       0 0             0 0             0 0             0 0      </span><br><span class="line">eth1                   0 0             0 0             0 0             0 0      </span><br><span class="line">                       0 0             0 0             0 0             0 0   </span><br></pre></td></tr></tbody></table></figure><h3 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h3><p>使用 <code>iftop</code> 命令，可以实时查看系统的网络连接和流量使用情况。Linux 系统默认是没有 <code>iftop</code> 命令的，需要自行安装。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iftop            // 查看所有网络接口的实时流量信息</span><br><span class="line">iftop -i eth0    // 查看特定网络接口的实时流量信息</span><br><span class="line">iftop -n         // 查看所有网络接口的实时流量信息，并禁用 DNS 反解析，以加快显示速度</span><br></pre></td></tr></tbody></table></figure><p><code>iftop</code> 命令的输出结果格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface: en0</span><br><span class="line">IP address is: 192.168.1.2</span><br><span class="line">MAC address is: 00:1f:f3:6a:3d:97</span><br><span class="line">  1.94Mb         3.89Mb         5.83Mb</span><br></pre></td></tr></tbody></table></figure><p><code>iftop</code> 命令的输出结果说明如下：</p><ul><li><code>iftop</code> 默认每隔 2 秒更新一次数据。</li><li><code>iftop</code> 默认输出 3 列数据，分别表示入站流量、出站流量和总流量。</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Linux 服务器的性能诊断工具。</summary>
    
    
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C 语言和 C++ 精品电子书资源推荐</title>
    <link href="https://www.techgrow.cn/posts/1461029e.html"/>
    <id>https://www.techgrow.cn/posts/1461029e.html</id>
    <published>2024-03-12T15:12:41.000Z</published>
    <updated>2024-03-12T15:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><ul><li><a href="https://sn9.us/file/632278-376032112">C 专家编程</a></li><li><a href="https://sn9.us/file/632278-375759118">C 和指针</a></li><li><a href="https://sn9.us/file/632278-376032122">C 和指针课后题答案 (英文版)</a></li><li><a href="https://sn9.us/file/632278-413723421">C 标准库中文版</a></li><li><a href="https://sn9.us/file/632278-413723439">C 程序设计 (第四版 - 谭浩强 - 扫描版)</a></li><li><a href="https://sn9.us/file/632278-413723433">C 编程惯用法：高级程序员常用方法和技巧 (王昕 - 扫描版)</a></li><li><a href="https://sn9.us/file/632278-413723430">C 语言参考手册 (第五版)</a></li><li><a href="https://sn9.us/file/632278-376035626">C 语言接口与实现</a></li><li><a href="https://sn9.us/file/632278-376034345">你必须知道的 495 个 C 语言问题</a></li><li><a href="https://sn9.us/file/632278-376033973">C 语言程序设计现代方法 (第二版)</a></li><li><a href="https://sn9.us/file/632278-376033493">C 语言核心技术</a></li><li><a href="https://sn9.us/file/632278-376033508">C 语言深度解剖 (书签版)</a></li><li><a href="https://sn9.us/file/632278-376032403">C 陷阱与缺陷</a></li><li><a href="https://sn9.us/file/632278-376032115">C 和 C++ 代码精粹</a></li><li><a href="https://sn9.us/file/632278-413723448">The C Programming Language (中文版)</a></li><li><a href="https://sn9.us/file/632278-413723457">The C Programming Language (英文版)</a></li><li><a href="https://sn9.us/file/632278-376035095">高质量程序设计指南.C/C++ 语言 (第三版 - 林锐 - 扫描版)</a></li><li><a href="https://sn9.us/file/632278-383494044">程序员的自我修养 — 链接、装载与库</a></li></ul><span id="more"></span><h2 id="C-开发"><a href="#C-开发" class="headerlink" title="C++ 开发"></a>C++ 开发</h2><ul><li><a href="https://sn9.us/file/632278-382829324">C++ Primer Plus (第 6 版) 中文版</a></li><li><a href="https://sn9.us/file/632278-376126118">C++ Primer 第 5 版 中文版</a></li><li><a href="https://sn9.us/file/632278-375722464">C++ Primer 第 5 版 英文版</a></li><li><a href="https://sn9.us/file/632278-376192138">Accelerated C++</a></li><li><a href="https://sn9.us/file/632278-376163164">ACE 程序员指南 - 网络与系统编程的实用设计模式</a></li><li><a href="https://sn9.us/file/632278-375790397">API Design for C++</a></li><li><a href="https://sn9.us/file/632278-375760951">C++ API 设计</a></li><li><a href="https://sn9.us/file/632278-376144337">Boost_C++_Application_Development_Cookbook</a></li><li><a href="https://sn9.us/file/632278-376145819">Boost 程序库探秘</a></li><li><a href="https://sn9.us/file/632278-376148152">Boost 程序库完全开发指南</a></li><li><a href="https://sn9.us/file/632278-376166515">C++ Concurrency in Action</a></li><li><a href="https://sn9.us/file/632278-375759973">C++ 并发编程实战 (中文版)</a></li><li><a href="https://sn9.us/file/632278-375712822">C++ Templates (简体中文版)</a></li><li><a href="https://sn9.us/file/632278-376163878">C++STL 程序员开发指南</a></li><li><a href="https://sn9.us/file/632278-375794339">C++ 必知必会</a></li><li><a href="https://sn9.us/file/632278-375712907">C++ 编程规范 101 条规则、准则最佳实践</a></li><li><a href="https://sn9.us/file/632278-375713020">C++ 编程思想_中文版_第 2 版_第 1 卷</a></li><li><a href="https://sn9.us/file/632278-375713065">C++ 编程思想_中文版_第 2 版_第 2 卷</a></li><li><a href="https://sn9.us/file/632278-376163158">C++ 编程新思维</a></li><li><a href="https://sn9.us/file/632278-375793834">C++ 标准程序库 (侯捷译)</a></li><li><a href="https://sn9.us/file/632278-375736387">C++ 标准程序库英文版 (第二版)</a></li><li><a href="https://sn9.us/file/632278-375760243">C++ 沉思录</a></li><li><a href="https://sn9.us/file/632278-375711926">C++ 代码设计与重用</a></li><li><a href="https://sn9.us/file/632278-375712103">C++ 多线程编程实战</a></li><li><a href="https://sn9.us/file/632278-375712244">C++ 黑客编程揭秘与防范</a></li><li><a href="https://sn9.us/file/632278-375713290">C++ 跨平台开发技术指南</a></li><li><a href="https://sn9.us/file/632278-376162906">C++ 设计新思维泛型编程与设计模式之应用</a></li><li><a href="https://sn9.us/file/632278-375726523">Effective C++ 中文第三版</a></li><li><a href="https://sn9.us/file/632278-375728854">More Effective C++ (中文版)</a></li><li><a href="https://sn9.us/file/632278-375751015">STL 源码剖析简体中文完整版 (清晰扫描带目录)</a></li><li><a href="https://sn9.us/file/632278-375793871">Effective STL 中文版</a></li><li><a href="https://sn9.us/file/632278-375713354">Essential C++ 中文版</a></li><li><a href="https://sn9.us/file/632278-375713470">Exceptional C++ Style 中文版</a></li><li><a href="https://sn9.us/file/632278-375713501">More Exceptional C++ 中文版</a></li><li><a href="https://sn9.us/file/632278-375713486">Google C++ Style Guide (中文版)</a></li><li><a href="https://sn9.us/file/632278-375713554">The C++ Programming Language 3rd Edition</a></li><li><a href="https://sn9.us/file/632278-375712756">C++ 反汇编与逆向分析技术揭秘</a></li><li><a href="https://sn9.us/file/632278-376163167">代码的力量：C／C++ 中国象棋程序入门与提高</a></li><li><a href="https://sn9.us/file/632278-375712784">提高 C++ 性能的编程技术</a></li><li><a href="https://sn9.us/file/632278-376148651">Linux 多线程服务端编程：使用 muduo C++ 网络库</a></li><li><a href="https://sn9.us/file/632278-375760487">深度探索 C++ 对象模型</a></li><li><a href="https://sn9.us/file/632278-375759499">深入理解 C++11：C++11 新特性解析与应用</a></li><li><a href="https://sn9.us/file/632278-375712564">深入实践 C++ 模板编程</a></li><li><a href="https://sn9.us/file/632278-375713740">实用 C++ 调试指南</a></li><li><a href="https://sn9.us/file/632278-376163161">网络编程 卷 1 运用 ACE 和模式消除复杂性</a></li><li><a href="https://sn9.us/file/632278-376253828">网络编程 卷 2 基于 ACE 和框架的系统化复用</a></li></ul><h2 id="QT-开发"><a href="#QT-开发" class="headerlink" title="QT 开发"></a>QT 开发</h2><ul><li><a href="https://sn9.us/file/632278-383242788">精通 QT4 编程 (第二版)</a></li><li><a href="https://sn9.us/file/632278-383242886">Qt 学习之路</a></li><li><a href="https://sn9.us/file/632278-383242506">Qt5 类继承关系图</a></li><li><a href="https://sn9.us/file/632278-376189688">C++ GUI Qt4 编程 (第二版)</a></li><li><a href="https://sn9.us/file/632278-383243774">Qt Quick 核心编程</a></li><li><a href="https://sn9.us/file/632278-376188875">Qt 及 QtQuick 开发实战精解</a></li><li><a href="https://sn9.us/file/632278-376188515">Qt 及 QtQuick 开发实战精解源代码</a></li><li><a href="https://sn9.us/file/632278-376188832">《Qt Creator 快速入门》第 2 版源码</a></li><li><a href="https://sn9.us/file/632278-376188643">qt 高级编程</a></li><li><a href="https://sn9.us/file/632278-376188400">Linux 窗口程序设计 —Qt4 精彩实例分析</a></li><li><a href="https://sn9.us/file/632278-376188194">Linux 窗口程序设计 —Qt4 精彩实例分析源代码</a></li><li><a href="https://sn9.us/file/632278-376188209">Qt 中的 C++ 技术</a></li><li><a href="https://sn9.us/file/632278-376188175">Qt Creator 快速入门.</a></li><li><a href="https://sn9.us/file/632278-376188172">qml 杂记 Qt_Quick 中文手册</a></li><li><a href="https://sn9.us/file/632278-376188145">C++ Qt 设计模式 第 2 版 (中文版)</a></li></ul><h2 id="Linux-系统编程"><a href="#Linux-系统编程" class="headerlink" title="Linux 系统编程"></a>Linux 系统编程</h2><ul><li><a href="https://sn9.us/file/632278-383494041">Linux 程序设计 中文第 4 版</a></li><li><a href="https://sn9.us/file/632278-383494038">POSIX 多线程程序设计</a></li><li><a href="https://sn9.us/file/632278-376015739">POSIX 多线程程序设计中文版源代码</a></li><li><a href="https://sn9.us/file/632278-383494035">Linux 高级程序设计</a></li><li><a href="https://sn9.us/file/632278-383494032">Linux 程序设计第 4 版</a></li><li><a href="https://sn9.us/file/632278-376015243">Linux 程序设计 中文第 4 版源代码</a></li><li><a href="https://sn9.us/file/632278-376010578">Linux 系统编程</a></li><li><a href="https://sn9.us/file/632278-376019933">UNIX 网络编程卷 1：套接字联网 API 第 3 版</a></li><li><a href="https://sn9.us/file/632278-376016831">UNIX 网络编程 卷 2：进程间通信 第 2 版 源代码</a></li><li><a href="https://sn9.us/file/632278-376010578">Linux 系统编程</a></li><li><a href="https://sn9.us/file/632278-376017254">Unix 环境高级编程</a></li><li><a href="https://sn9.us/file/632278-376015885">Unix 环境高级编程 课后习题详细解答</a></li><li><a href="https://sn9.us/file/632278-376016822">UNIX 程序员手册</a></li><li><a href="https://sn9.us/file/632278-376020241">Linux C 编程从初学到精通</a></li></ul><h2 id="Windows-系统编程"><a href="#Windows-系统编程" class="headerlink" title="Windows 系统编程"></a>Windows 系统编程</h2><ul><li><a href="https://sn9.us/file/632278-382930409">WINDOWS 核心编程第五版</a></li><li><a href="https://sn9.us/file/632278-376164229">精通 Windows API - 函数、接口、编程实例</a></li><li><a href="https://sn9.us/file/632278-376163153">Windows 高级调试</a></li><li><a href="https://sn9.us/file/632278-376162901">Visual c++ 2012 入门经典</a></li><li><a href="https://sn9.us/file/632278-376160660">深入解析 Windows 操作系统 中文第四版</a></li><li><a href="https://sn9.us/file/632278-376158223">Visual Studio 程序员箴言</a></li><li><a href="https://sn9.us/file/632278-376156024">Visual_C++2010 入门经典 第 5 版</a></li><li><a href="https://sn9.us/file/632278-376156021">精通 Windows.Sockets 网络开发 - 基于 Visual.C. 实现</a></li><li><a href="https://sn9.us/file/632278-376152109">Visual Studio 2010 高级编程</a></li><li><a href="https://sn9.us/file/632278-376152101">Microsoft Windows 网络编程 (第 2 版)</a></li><li><a href="https://sn9.us/file/632278-376150600">Essntial COM by Meji</a></li><li><a href="https://sn9.us/file/632278-376150597">Com 技术内幕</a></li><li><a href="https://sn9.us/file/632278-376150591">Windows 编程 (第 6 版)</a></li><li><a href="https://sn9.us/file/632278-376150588">Windows 程序设计 (第 5 版，珍藏版)</a></li></ul>]]></content>
    
    
    <summary type="html">C 语言和 C++ 精品电子书资源推荐，涵盖 C 语言、C++ 开发、QT 开发、Linux 系统编程、Windows 系统编程等书籍。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="生活随笔" scheme="https://www.techgrow.cn/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="在线电子书" scheme="https://www.techgrow.cn/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>微信公众平台之服务号、订阅号、企业号的区别</title>
    <link href="https://www.techgrow.cn/posts/aaa405b6.html"/>
    <id>https://www.techgrow.cn/posts/aaa405b6.html</id>
    <published>2024-03-07T15:29:32.000Z</published>
    <updated>2024-03-07T15:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微信公众平台目前一共推出了三种公众账号：服务号、订阅号与企业号，那么这三种账号之间有什么区别和联系呢？微信官方的解释比较概括，只讲了这三种公众账号的功能，并没有细讲它们之间的区别，那么接下来笔者根据自己的经验详细展开介绍一下。</p><h2 id="三种账号的区别"><a href="#三种账号的区别" class="headerlink" title="三种账号的区别"></a>三种账号的区别</h2><p>在整个微信账号体系中，订阅号是发布信息的平‌台，服务号是为用户提供服务的平‌台，而企业号则是企业进行 “内部管理” 的平‌台，通过加载第三方应用，可以实现员工的沟通、协作和管理。现在很多公司已基于微信企业号做了应用开发，例如企微云平台等。</p><span id="more"></span><h3 id="侧重功能不同"><a href="#侧重功能不同" class="headerlink" title="侧重功能不同"></a>侧重功能不同</h3><ul><li><code>订阅号</code>：侧重于信息传播</li><li><code>服务号</code>：侧重于对用户进行服务</li><li><code>企业号</code>：侧重于生产运营管理</li></ul><h3 id="适用范围不同"><a href="#适用范围不同" class="headerlink" title="适用范围不同"></a>适用范围不同</h3><ul><li><code>订阅号</code>：主要适用于个人、媒体、企业、政府或其他有需求的组织</li><li><code>服务号</code>：主要适用于媒体、企业、政府或其他有需求的组织</li><li><code>企业号</code>：主要适用于企业、政府、事业单位或其他有需求的组织</li></ul><h3 id="推送消息显示的位置不同"><a href="#推送消息显示的位置不同" class="headerlink" title="推送消息显示的位置不同"></a>推送消息显示的位置不同</h3><ul><li><code>订阅号</code>：推送的消息，显示在微信对话列表中的 “订阅号” 文件夹里</li><li><code>服务号</code>：推送的消息，直接显示在微信对话列表中</li><li><code>企业号</code>：推送的消息，直接显示在微信对话列表中</li></ul><h3 id="推送消息的限制次数不同"><a href="#推送消息的限制次数不同" class="headerlink" title="推送消息的限制次数不同"></a>推送消息的限制次数不同</h3><ul><li><code>订阅号</code>：每天可群发 1 条消息</li><li><code>服务号</code>：每月可群发 4 条消息</li><li><code>企业号</code>：每分钟可群发 200 次</li></ul><h3 id="消息的保密性不同"><a href="#消息的保密性不同" class="headerlink" title="消息的保密性不同"></a>消息的保密性不同</h3><ul><li><code>订阅号</code>：消息可以转发和分享</li><li><code>服务号</code>：消息可以转发和分享</li><li><code>企业号</code>：消息可以转发和分享，但加密的消息禁止转发和分享</li></ul><h3 id="关注者的验证方式不同"><a href="#关注者的验证方式不同" class="headerlink" title="关注者的验证方式不同"></a>关注者的验证方式不同</h3><ul><li><code>订阅号</code>：可以被任何微信用户扫码关注</li><li><code>服务号</code>：可以被任何微信用户扫码关注</li><li><code>企业号</code>：只有企业通讯录里的成员可关注</li></ul><h3 id="自定义菜单权限不同"><a href="#自定义菜单权限不同" class="headerlink" title="自定义菜单权限不同"></a>自定义菜单权限不同</h3><ul><li><code>订阅号</code>：通过认证之后可使用自定义菜单功能（目前无需认证也支持自定义菜单）</li><li><code>服务号</code>：无需认证即可使用自定义菜单功能</li><li><code>企业号</code>：无需认证即可使用自定义菜单功能</li></ul><h3 id="高级接口权限不同"><a href="#高级接口权限不同" class="headerlink" title="高级接口权限不同"></a>高级接口权限不同</h3><ul><li><code>订阅号</code>：不支持高级接口权限</li><li><code>服务号</code>：通过认证之后，支持高级接口权限</li><li><code>企业号</code>：通过认证之后，支持高级接口权限</li></ul><h3 id="微信支付功能权限不同"><a href="#微信支付功能权限不同" class="headerlink" title="微信支付功能权限不同"></a>微信支付功能权限不同</h3><ul><li><code>订阅号</code>：不支持微信支付功能</li><li><code>服务号</code>：通过认证之后，支持微信支付功能</li><li><code>企业号</code>：通过认证之后，支持微信支付功能</li></ul><h3 id="定制应用权限不同"><a href="#定制应用权限不同" class="headerlink" title="定制应用权限不同"></a>定制应用权限不同</h3><ul><li><code>订阅号</code>：不支持定制应用</li><li><code>服务号</code>：不支持定制应用</li><li><code>企业号</code>：支持定制应用</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍在微信公众号平台开发中，服务号、订阅号、企业号的区别。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发随笔" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 性能优化教程</title>
    <link href="https://www.techgrow.cn/posts/e86e9dbd.html"/>
    <id>https://www.techgrow.cn/posts/e86e9dbd.html</id>
    <published>2024-02-08T12:10:21.000Z</published>
    <updated>2024-02-08T12:10:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="ES-优化"><a href="#ES-优化" class="headerlink" title="ES 优化"></a>ES 优化</h2><ul><li><p><strong>索引优化</strong>：</p><ul><li>映射（Mapping）：合理设计索引映射，避免使用动态映射，并为每个字段明确指定数据类型。</li><li>字段类型：对于不需要全文搜索的字段，使用 <code>keyword</code> 类型而非 <code>text</code> 类型。</li><li>合并（Merging）：通过配置 <code>index.merge</code> 参数优化段合并，以减少 I/O 开销。</li><li>刷新间隔：调整 <code>index.refresh_interval</code> 参数，减少刷新频率以提高写入性能（默认是 1 秒，可以根据实际需要调整）。</li></ul></li><li><p><strong>查询优化</strong>：</p><ul><li>缓存：利用 ES 的节点查询缓存和过滤器缓存来加速常见查询。</li><li>分片首选项：设置 <code>preference</code> 参数来避免每次查询都访问不同的副本，从而提高缓存命中率。</li><li>分页：避免深分页，使用 <code>search_after</code> 或 <code>scroll</code> 来处理大量结果集。</li></ul></li></ul><span id="more"></span><ul><li><p><strong>集群优化</strong>：</p><ul><li>节点类型：配置专用的主节点、数据节点和客户端节点（协调节点）。</li><li>主节点：负责管理集群状态和索引元数据，建议配置数量为较小且为奇数（如 3 个）。</li><li>数据节点：负责存储数据和处理搜索、聚合操作，需要较高的内存和磁盘 I/O。</li><li>客户端节点：只负责处理请求和分发，不存储数据和索引，不参与集群管理。</li><li>分片数量：合理配置索引的分片数量和副本数量，太多的分片会导致管理开销增加，而太少的分片则可能无法充分利用集群资源。</li><li>副本数量：在生产环境中，至少配置一个副本以提高数据的可用性。</li></ul></li><li><p><strong>硬件优化</strong>：</p><ul><li>磁盘：使用高速 SSD 磁盘，提高读写速度。</li><li>CPU：多核 CPU 有助于处理并发查询和索引操作。</li><li>内存：确保有足够的可用内存，因为 ES 需要将索引数据和文件系统缓存保存在内存中。一般建议为 ES 分配 50% 的物理内存给 JVM 堆内存，但不超过 32GB。</li></ul></li><li><p><strong>监控和维护</strong>：</p><ul><li>监控：使用 X-Pack Monitoring、Elasticsearch-head、ES-client、Cerebro 等工具实时监控集群健康状况。</li><li>日志管理：定期检查和清理日志，防止磁盘空间不足。</li><li>快照备份：定期进行快照备份，确保数据可以恢复。</li></ul></li></ul><h2 id="JVM-优化"><a href="#JVM-优化" class="headerlink" title="JVM 优化"></a>JVM 优化</h2><ul><li><p><strong>堆内存设置</strong>：</p><ul><li>合理分配堆内存：一般建议将堆内存设置为系统内存的 50%，但不超过 32GB，以避免触发 Compressed Oops 的失效。建议将 <code>-Xms</code> 和 <code>-Xmx</code> 设置为相同值，以避免动态调整带来的性能开销。可以在 <code>jvm.options</code> 文件中配置：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms16g<span class="params"></span></span><br><span class="line"><span class="params">-Xmx16g</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>垃圾回收器</strong>：</p><ul><li>选择合适的垃圾回收器：Elasticsearch 7.x 版本及以上默认使用 G1 GC，适用于大多数场景。可以根据具体需求和环境考虑其他垃圾回收器（如 CMS），但 G1 GC 通常是较好的选择。确保在 <code>jvm.options</code> 中设置：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>JVM 参数优化</strong>：</p><ul><li>堆外内存：限制堆外内存，以避免 OOM（Out Of Memory）错误：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxDirectMemorySize=16g</span><br></pre></td></tr></tbody></table></figure></li><li>垃圾回收日志：启用 GC 日志以监控和分析垃圾回收性能：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog:gc*:file=/var/<span class="built_in">log</span>/elasticsearch/gc.<span class="built_in">log</span>:time,level,tags</span><br></pre></td></tr></tbody></table></figure></li><li>线程栈大小：调整线程栈大小，可以在某些场景下提高性能：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>堆栈优化</strong>：</p><ul><li>内存锁定：在 <code>elasticsearch.yml</code> 中启用内存锁定：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>JVM 版本</strong>：</p><ul><li>使用最新的稳定版本：确保使用最新的 Java 版本，并且是经过 Elasticsearch 测试和推荐的版本。Elasticsearch 通常推荐使用 Oracle JDK 或 OpenJDK。</li></ul></li><li><p><strong>线程池</strong>：</p><ul><li>线程池配置：根据使用场景优化线程池配置（例如，搜索线程池、写线程池等），可以在 <code>elasticsearch.yml</code> 中配置：<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">thread_pool.search.size:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">thread_pool.write.size:</span> <span class="number">30</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="Linux-系统优化"><a href="#Linux-系统优化" class="headerlink" title="Linux 系统优化"></a>Linux 系统优化</h2><ul><li><p><strong>系统资源限制</strong>：</p><ul><li>文件描述符：增加最大文件描述符数量（Elasticsearch 建议至少配置 65536）。<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"elasticsearch soft nofile 65536"</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"elasticsearch hard nofile 65536"</span> &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></tbody></table></figure></li><li>虚拟内存：增加虚拟内存映射数量（Elasticsearch 建议至少配置 262144）。<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"vm.max_map_count=262144"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl<span class="params"> -w</span> vm.max_map_count=262144</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>内存和交换</strong>：</p><ul><li>禁用交换分区：Elasticsearch 对性能敏感，尽量避免使用交换分区。<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapoff<span class="params"> -a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"vm.swappiness = 1"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl<span class="params"> -w</span> vm.swappiness=1</span><br></pre></td></tr></tbody></table></figure></li><li>锁定内存：允许 Elasticsearch 锁定内存以防止内存交换（需要在 Elasticsearch 配置文件 <code>elasticsearch.yml</code> 中设置 <code>bootstrap.memory_lock: true</code>）。<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"elasticsearch soft memlock unlimited"</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"elasticsearch hard memlock unlimited"</span> &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>磁盘和文件系统</strong>：</p><ul><li>文件系统类型：使用适合大规模读写操作的文件系统（如 ext4 或 XFS）。</li><li>磁盘 I/O 调度器：将磁盘 I/O 调度器设置为 <code>noop</code> 或 <code>deadline</code>，适合 SSD 磁盘。<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"noop"</span> &gt; /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></tbody></table></figure></li><li>磁盘分区对齐：确保磁盘分区对齐以提高 I/O 性能，特别是在使用 SSD 磁盘时。</li></ul></li><li><p><strong>网络设置</strong>：</p><ul><li>TCP 设置：优化 TCP 参数以提高网络性能。<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_retries2 = 5"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_keepalive_time = 300"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_keepalive_intvl = 60"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_keepalive_probes = 9"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl<span class="params"> -p</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 ElasticSearch 的性能优化，包括 ES 优化、 JVM 优化、Linux 系统优化。</summary>
    
    
    
    
    <category term="搜索引擎" scheme="https://www.techgrow.cn/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器 CPU 负载过高的定位分析</title>
    <link href="https://www.techgrow.cn/posts/b365ed8e.html"/>
    <id>https://www.techgrow.cn/posts/b365ed8e.html</id>
    <published>2024-01-03T14:13:45.000Z</published>
    <updated>2024-01-03T14:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将以 Java 应用程序为例子，介绍如何在 Linux 服务器上，快速定位分析 CPU 负载（占用率）过高的问题，即通过多个命令精确定位到存在问题的 Java 代码。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><blockquote><p>使用 <code>top</code> 命令找出 CPU 占用率最高的进程，记录下进程 ID</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><ul><li><code>top</code> 命令的输出结果：</li></ul><p><img data-src="../../../asset/2024/04/linux-java-thread-check-1.png"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><blockquote><p>使用 <code>ps</code> 命令进一步找出 CPU 占用率最高的线程，记录下线程 ID</p></blockquote><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出进程 6113 的所有线程，并显示线程 ID 和线程已使用的 CPU 时间</span></span><br><span class="line">ps -T -p 6113 -o THREAD,tid,time</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ps</code> 命令的参数解释：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-T：显示所有的线程</span><br><span class="line">-p：进程 ID</span><br><span class="line">-o：用户自定义的输出格式</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ps</code> 命令的输出结果：</li></ul><p><img data-src="../../../asset/2024/04/linux-java-thread-check-2.png"></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><blockquote><p>将找到的线程 ID 转换为十六进制格式（英文小写），比如 <code>17e2</code></p></blockquote><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">"%x\n"</span> 6114</span><br></pre></td></tr></tbody></table></figure><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><blockquote><p>使用 <code>jstack</code> 命令进一步精确定位到错误代码</p></blockquote><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 6113 | grep 17e2 -A 60</span><br></pre></td></tr></tbody></table></figure><ul><li><code>jstack</code> 命令的参数解释：</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 进程ID | grep 线程ID(十六进制格式) -A 输出行数</span><br></pre></td></tr></tbody></table></figure><ul><li><code>jstack</code> 命令的输出结果：</li></ul><p><img data-src="../../../asset/2024/04/linux-java-thread-check-3.png"></p>]]></content>
    
    
    <summary type="html">本文主要介绍 Linux 服务器 CPU 负载过高的定位分析。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="并发编程" scheme="https://www.techgrow.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>近期学习计划</title>
    <link href="https://www.techgrow.cn/posts/860c6c02.html"/>
    <id>https://www.techgrow.cn/posts/860c6c02.html</id>
    <published>2024-01-02T14:38:21.000Z</published>
    <updated>2024-02-05T14:38:21.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误, 请重新输入." data-whm="文章校验失败, 但不影响阅读解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b2030e8d0c19e253a9151525e83bcb5644ad9e7ef9c51b8a61ead17ab881b9ab">4cfab7e4fdfd9afdbf1592f9652b8a199f3cb3b67d053a3a2b7db0e886465ca164af0df16bf14e0fab728c9ff50fc391cebc6b0cccdb129e6ba846f64fd1707908115181dd12f8623e78de3879033c9f76dccdb2aca93fa5b64ea70af83fda03ff378127688246fd68b19d16f2edb96c0c5e42cc28860181f561cd5311a41d1a7d4a84a65a6216916a002ddb385ffb0c2663792bec981c87fe04d8f258708cd72bb89577ca1e2c51ba4d795877b0c14f3b2ae25df3babbb633f1792d5c0477d2fa4edf15c0a2fb827b95bd9a7066e242a274dea01f92d0858df04ad5c8cc077e147b67a169368c10e980846cd92d3fe1d5ce2712d2a5c5573a0fe5eded499e725acc4013fa791a66f552814d7859a5153ae45895f6259b0a165c200e3c753f2863b20f624eebb792c27548fdaac67c70584d4621cee294823f674039694aeb76a0d6cd9af764723f5250268ef3f6a0249c236e9876faf8ffe1b402c9a8887a989f9570bbcd3e99488396d8d529d2da716ff13a5546a074c62281ea698ddc6f7c3b346985643db1ab7ce7ba84f72981ac775b6673642e7b3edf9d6423c6ed77cfa2650729eee7eef8acde5bb59b6d47b64d799ba32f7439b38f56cb19720b2b4d787eeba7c7dd39b78c5e1b79c068902d759e16cf44733eb979ed6c10753a46daa77f19ba0ba83aa9ce6ae1195dbd0e1146649fb3da9b4af693c8653ecb02f440353dbd6cefdb283bd8ae14e73f2b84c4d5a035446a0f4d78b78de074e43b48bdaf598490975e0c00c3841e8d7ec390708b3a0b955ae1a2b353038c515b81f9b5c22160b0036b1bfdd482a365edc5b770b9409f69f3a291d1dee92ee8bb6f0fff5436e479db838e015d281c5dbf43f12c86324637a6acd30b8fb69e1477244dbfd35dd1f8797d954a7db666c734b6db51ad1f71e902081eeca58bbfc338c1f34d19ba63fc470477bf3a4fab27312fffcd8a5e089558278930c1d66e3189fec93848428107048c6f2c85f277f743c247ee1f2f79f18e21e4c94dbc5e2e4c9ed0fdfbd0b3cc8dd29382bf1d880a3f077735c5127a0eadb673951c9b6127c9b537142aaa70ebda5d5407f48bb9ae4ff33fb150a3d5a5ad9d8bb719729abcc8ce9379b666c14b6470b60751c77fbef62eaf5ea3e57f6b5d840d445cb207c34acd0488cbdd427f833d5325d4b904e60ba34e459c76cc52a431d71180e0404843dcef31ead39312aa84d54c6c2031c2da2299c640d61149a81871e0f520ccc44d914c116bb2c6d1ffdfe7a68ef3846015ba36fa2437fe2f4e7390befe4589fb1195eaa4638784c145329fb340850dd195aec1075ddcc3fc171e34c8ea9d60a89da367fad1b201f4dca28965c5e6cb68d7592ceb36ff711a835e0b5d6876cde762379c0b51f6f5479cc6ed8d899e5c11880eb2532104e062d27b2f8096482e103fb30d6bbdbc18e6a1d678547cf21697153ef5d42540a841c9ab54bca8a76004e811602d6e55436ee182a7a14ed46c8ca2166bc9242e0149e7532940ed708603adc2bf78fdfa0482a714eff347d475ef75391c0618edfabda95b236c1dea8f76ca4aafcb8f378d1cd56911d41c514dee9c52b669e0439f69bafc4d54191fb6e36e412edcc88a9d8decf9b24698532bee15eda4cf2199c1f2f4623878db28cadd770799915f9f9e17d7f80a051ef899b2efac01267bff73c85b5c1b342ecef76f71343e037040442e4dbe15bd6b0706c34cca06328923ddc2436d953b3afdc7bc86e7ac4b2ac6f46323c868a32f7e38c2e297505a5405aaaad4aacbdaddbcc65965d8487ae1ba7670cea5ba705084c5b8b45c1d1123a149e1b5817761b0f23c3e5e80e2fa1783a08d90370530113f3d84737ed1d111a5225c5347e3f7a0a6077947b35ec93c2b8387b5582df218cc325db2898388e9ddd078edb80aeb1794e298ae3d4cdb00ec2fadd79947bdd16bda0a445d46c444e8d2316f134d8d0e130c2b032d14cdbd23fb44cf5c726a65052c5ed9dbe6fb6a0dcc2272ccbabf11027a62a2d4c5250a08ffe5817d80372075cdc41f9d92db00cffc5a3330860d4b264a5f750becc1df9567d34daace514cc2585c724bfcee8f2aed137494dbf650c647d9e4e9359cb1a01ca4fb1dd873478c0d15eae4fec24b173b80ec6519804b56b295640c76a4f7998683a7828b48ff7657307c86f7d0e2883d8bf64a9c9cce6642bd73d0d5ca33706828019ba93dc88dcd9719be38bc79eabcea156f44974057ba616f8ea1dbb2208d9d10b32687ab86d4e3c49c3899df49e84a1abf46585364c5aa80b8b93b1411af3ed0ee9f5d162094c457c5f8aa103ec03dbd176efb9e30768ffbd419cb9ad15c56e3316fd558581fed62f91ff12c01aeebbc8a21cdef83930bc88ac0cfbcfe35fd5891bfe80136dea6280e909949d0a18e40f34d418da33dd525e2d7ecf59f2be0a5003656e4664661237553fa9f316ec8c6961a3c5007975508b1954e35463036dcb3ae12984b4c0aeb41faa5518eb09b28d8d46d62c1b50870006238f4a8a9dab4eb5b70df8a79e465985ee5e7caaae303521858fe69ec9e784670b01c7d2e6abb3193e90dc3ca3e89624ba6db2a818df3db7bc874fc103daa778f1db0eabac541e90327d4811255b0ed52a20ce74bf9dcd6c3a6a9287ac22f9852c890ed35f17c500d4c0eb2676a65167ffdfc17cc57fa700ab20c67877da172421707b3e399f4941fff662a97a96d70fb7bb4ea0585ef31efaffb4847952b13b526334cf1697cc087c5a14733365f70ba87319528668e378a569664bf65c91701f79792b99f85743a060483f2e347331dd0c4d58eff400f5de31f3bc83f3f5a054664ec39a5eea65a3fc6510091bd9eac230fd93db289d41a0253441da5aa25bafef8ef1c91446dfec784a7f05d94a021428b9069a260a13252882322d222a20b7c5e2a7c73a513c3ad184d43f2dd950e09ed71a348e06b36a67e5aa2b7233b3636110a1b2cce3e9bdf3223c0139ab3462bf28115853a138a5a59ff5d3bc8c0fad0e3d07285ff9a32cd985a04e269613e2ea388bcd9a2534204e7843eeb98ee596094003332a2fced56a0b61aa4b9db03fd9f609f4f2bd18e62435f90c8c17eba67a1a86dc9c31505d5be09cb67fd938cd5ae6e493ab3714e0c213ba52a2f146c6dc8c043484affa3bf7fd10467e3836052afa11cbc57c1cdd2180086d1bc096bb039443e6dd949b3f3300a1e3dc71e6a8642c1a419044d69fc7971de4b25150846f6f272bf9fc90c6182e65ab3d6b0d9470ce717ad0dbca8b64ed83298b2283d8ffc515cd80e2c1abdc08cc9fc7e15d73269074018fc4c260dc022237156378bf299ab0f96612640fdc9350fa4899ee7765eafb3a83709a24a5c070e92025577ded6ed56fe2dee37ea16b66b9a560aa42a5ab11fb8dd9c25def94cf6ee2674535e20ed1b0ca374965ba1cc23a4d1fac0c812e32223de0b0e254369553ae3a00be69cb0fb860abf4df8f764faeabad4def490db9cdd479a3701a8a5ac3215c1733916b9f16752f16d8b6bb16c6a9f123ebabe357d8b6b4bc715052793157cfcb20d574d25b236b82d283edf6b22f3d8c4c36b907479d69776d4567bb89d272eefad2f490eb9898b7656b26975b0c6420b74faf45a4d3197b6772463ef6f93ef5eb0671b315bff5124a8e923eae5e4450af8622c33e55298e5b792bb491101d4447dcd223bae5958f188ef683bc4488cd9de851330033ce9051db9666fd8e8c23ccc8e42effbe25999df78c79e0febbccf7e3a6694eea9803eefb7084f6531aecf7e56c7e578f00f249dddb461d7b615bcaff6722291dd8c8fb9e6735fad292de8763501a4085c6dc1c101401c504608e4a34bce86b41f6a6e74cde3615bbdd3b66793491225d7365f9bca2ab1d88c04ed65af4ada2a819690e7de5a462171cbc08f797ef90029ddce717af4eee315d9cb7f2fea113053f93878906aa12809c83c86bdf7ebe355a06049e71510b580166025485e97d6864401a489e74f1e4da62d350f6d81e6844e598a04ce2c84cf8142d8b975227b8381c8ca676fac901116f92731d99888113d5baf4547955bbc85d5e7555d3749a4718bcf4ba5fa823263dc55905e2f43e1da42806a2aa96951a4ec66bfa2bcb55fa30446508a781c5b45fc1ab03c850d8d440e250d485dffa1931031a123adb78ae128251f5981ace31748d2bddb1bf48c94abbae0839e2e472e122dd54806a893e83f236f3542a601e81a22bff7d2e623f4894a970e103d2be4a60fadd3e24647060a32bac1d5bdefbfb8cceea3281a63020d9a6bd0e41aba7661c1e44289131516887747f74b56de5b998206437c3755b3e1b1dc5f0541510c0e2c1ef2fc3bc17e44f69a4f21c437c5aaaa712bc8eb8d3f49967eada483f929c3790c94b9d1b19f8842043ca97adb608dc38ad86a0b2bd705da579f14ce1c8619019c89c67f6af733162f1c99088b3c937e4b2935ca422c7478888feef3c78b7c376f317bd103b189c32b803533c5e850b41ad9546f506653b84482896f2530047c14a93d0f5d9ad8de23af32b0b625c2872b1e1106caeb5376635f6ed75b501a209b4911fd630644fc737abf0e04f50ca2df00e756a5ff9ee0eb2d89a2268f4b4b68c06c866fb730e22951973625ed5c6f51bdf7b760f41edcd2838828589bef7e6fb779092e36c6f83f3618366b118c87661566cf0a1dc2c537a71cb4781f76a2e3d6bb3f2a5e45be4af37c61bf07d3da72e6eaf8a702abc8a2c23aa4ab3d5cd37b748d4c95ca97bf6d6bf30674b9614f7b1bf2da9baed6889158b1fdb8e021969098fbdb0f8beb571a8b73fe0b126a9534991acad9cfe725ece1c69aa99369f3c33e12c7c21fdbff8bb8ceb8070232026b4fcdda88e1a4928d359d82f84f9a4126c5238664ec689658104886b90d9d705b1a835f21ba51440a10ea00db58e3cce4b737b7c7c258bf746994540c37b9218db6ccf6ab883d0b32db01baea97e43bf4dd6cfd3bdf552dc242c62f636a52f788598ce8efa0b36ba1f14683fde308f99f23ee0e57c4d71c6cfa7f342bcca44817476d85b14c86443439e4a8293c14a9f618162fea14ff6606830f7b19a021ae13d928514916ec862f8058230ea49be8282081a09563443c17344dd5abc42a98e9013e435f680f524a1112b039a624352e6321e4392d6f0d182c2164ac0e65341faeeab636c1981d6f1b93928afa611ba3c0c09862145e33d1ab2b83bc37c41856182e680dba8ecc7064964c982b8ad6025da6e32bde07d4e5855ad6625a3768436581a5836b71caf59e2d2fe03a078ec3ae474e3c74549433e8cfb577d3bb7b5fef6e585d318915904dcd266df6844f62a4ba42e6904d626cc316433e5512e5d9fad72a17f2204538007b76d50c6b35e293f2e492fff78c3714bac696edac74a595642f054f0f3499063457f8a1250c8d160e71b3f377e45209bab2e99c24bc9daf020010d9f33b7d13b6d1eebcf9bd152a8d20121c17d72a7ab8fad6bcb3325ba77c4bde9f975e0c9fb961030c1fdde4f787a916cbde1276e307db7162788271d961d62b23f1b90bde59a7699dc810c3075e52017f03343bb873537662d853919f99be63326b8c793a56c4d50c68347c873a721213f6c9b3d3177866eb032603848a901b8840535457c378a7d2a3415eb401668d4177e6311ccd86718b09c873d91c4f6e1b7c2c7f00bbf6949ec8719227daa981796a4092a7b7d4d6d774526743c1eb950d398a9b95d5d47d298a25cf1bea1c3208191e3fb65444b618154f9744abd709a3def5d6708c77adcbdb2e3679640a0e11f29622787eeb59ef2b038e0c516bcc69829dd0203640feeb7e0b15ea6524b54c2ec3872f1489ce5eb811f9718c1f08cd90e3cb923d4cdbd991933136cbacb9b3826f271a0a4f71e27364cbaa428608d3ffad770361115aa342c19ea4e5ada4abf79bca8be7317c217d0fde7fe2e3821385a87892cc661bbef0318254b805ea662a75c0d34683e9f88909edbf9f703223f8fc221fa27b025966601f5d37273b50ac7fc1197e9efc1df9c8027d444a5ac4941987c901938371a549e21065430f39ad49dbf74a955fff43865c0cd063461a4551cf426cf8089396734563d14e22f973fb0024d55afea71cad47d97e4aaa7da64d9bc28d00f9f44c7fc8a7ee5273f81f3ec71ae9c6cda006f6edcfad2f929d89feae9620655db9dbaa90e5381c19ff2baa7198fe52c871229e231294422f9444f3ce88cb0a203fcf7155a2e5500b0b6ce55069025ad732c902093542a68b56364817fb9f8d1825f83904e2d7cfffac16de3292bd5652484fe634835ffaeeb26350c42ed084ab80852a6ba626e1da2e0377993194d0e994c4906c632294077841bb3281f54e232262783d6efdc1fdc4e59dd8c2cb408dca53a38788221e853468f665ee41a9364f305a44f210f0dc0713044591f32c6d97809beaeec0a3c4a63584e28e8022c995221d3223de94885c9258f33b0f0f62623a6e1a1ba1e2b5cb8d3e85486f063590d6f1ec5e946334e52673af60ce6cd0a98506a59afad8721542f81869b11378b87e4c8dad522764272e4b4c1a7a2693496b6ee3d6600c38439a60a9bc2869ad57e1645a551cc2207ac2a559df57cd69990ce7b628c7f49959dd9d0bcd545d900e641811f0c04f95971281e101b84e7202909e6a88836a42c267890708097d4fb78f72e1e54d86c7b7b05e07b9360fa0a57dc63cfac7863c982d59c89d12103b41ac24fe8e8eb905b488ce58b684ff3f95cf4d0d36740b8a8d454029744b9417e326acef50c4fb13e21b0e548fb5146400250122bdadeb1ddb00b11e8bf9bdff64ae1ad5637d3691512dcd126cfe68e8a9cb994001637dde99d57127a65fd5e465fcc8cc7a458a7eb17be302421aa8ef90a6fdbef7df21fb1badc3d01e5ebd736c14ac865810c0ffa2662e849a9151527731b06420c1772a78d89e1f8dded4cd601509fdb39ca9cd0a497d0390cfdedd45c6f812c6beca004aa0096d14194359f06d24980f3ede665d25292bbd40b04a576b34901e2792fbef6357659a31d421d29dfbf57ec4b38086ea3cc5b1b3f9ab483e92fd789b7f1a495e5aa3b9036898056c19f6147922819888e93fe4246e502c4434648a4008e92ccabdcafc4287b14233eb74bc7a2b311896e302a0f82e99a984b0846378125b4b3c79038c02d7226acaaca4c250c2c3c7a59872491292fb6acb68cff782d60a2cc1c2a7b9a1ee4f1320cde88290996f1db0b2f1f7bee8a5d1a3c93eae61a2d1ab00f1d0efa46a39e90a602ec9f5cf40b61b197ea8ce2d6dbd26eed10203ffd25a90faa0e9e63524ecabbd89ccbf7c09248dd9d817117c6f2d0568936b1ff43cd491cdfc0af56cbc63bd6c390f2d11a852408242c29b92add64b4d440f480bc264fa3ba46f7d47aa2932d0404671f4d9f75b209f2731aa6c45887bec9cd085a716c2705e9243b80190aa988c142f752f2108530ddd610e754af3b7a11db8481467b0c96dd2497af896a9c8abcaab5d7ab897ed1e27c18e043ee733a74bbc7ee2becc8ca8c2e47c46cdf0c47d39dc921ea86da7986fc2203e8240583c7ad615e87658f493c6a8816f22f5eda7e7376b4fd3ec7a0b35f143997a14223644ccfa0cafe6fff1570c105befde3f539321f32011adfa9706c34f1338671409f25a799f4541a672b2e7d2a4a1478fa4cec808a385eeb93a4ac82f76c8186e8685fcfa368462daefac4b51678dc526e5f95d9a5c6a5dba8d356f031b5a1d8f7fc8706485c07f98a4be75613041c54a020657e8062cd264407cf72d27ade5afe7efbfda0a71235387657f3d3a9e03e00eff0b9cab643b89609b172d1de3a693cbb3956bb4dbf3033b519c520b09d5c4d36082b26ff9c0a5afcf1879a0ca0d8448a487bd997480cbb6b952caa8aebaf94db13dc943ed15bf835d80785a45a7b0745308cace7e6e013278fe6175b0d15394d1fc85861f078b2dbf0e367df8a8efba5630cfe88912bf46fe94c2f24cbe420017e3812c6a2dec3cc5f9b777ec967452924cd298b26ca5b061abdb8cbe48b3a32d84dd59556bc02408bc23bd4c81f66269a3d3c2ebff71977d1d971c3eba9f85e2388e0e42c1355fcbf3afcb94e9cd1dcb1d984d0c36b61446b19a3caaf2962108d24ef888056515f3837fae07165c6924b7551e7a4a7602a308cde9223178bd1083988e6c605425148babc144d201f66672fe66e8755773f72b8fb8f7c278694329481e4c479ed10883396c97734c4d790fdb73dc77270962493bdd02ac77fdf4e30e06faf1a1fc27988f50f2d2c5c135656772f98f31c15a8ec276dcdc91d09bdf458e973c623073a75f346cf984a897a6af92668d13def647ba9e8c6ef8eae9c3900fb02d4e5f5497d3666c97bb8cf00a113696930bc36e376fedab295af337b88f64f606d21bf5c3aae27e7a4f4bc47bb9a88e61750f77df7a3b5156d71b5391f3f89c416930b42b059e16adf880e1385dcb1ac58311a13814c7e23de911834acbbff8a69d079aa5c378c8ac154e00ba29f52ee073ec2ee4dcc9ab5f02e2a72f850b081aa80cc1a4b2508123d44ab1b8a1d9f7cbc89dad0d7709f0fd195bce6fa44a11508b59effde5f4db4f40aef663219c4dcc62571728785a9bb769a2d32c001debf3f40a87b973344d7140ad8f15e84efb5e8016fe6e6c91b1c4e4cdde2aba7599df8cd8b875238115fa147188083e433cbc1a6eed8ae2b08fc73f56fb0a041dc8be46a388d037a59c059aabc6ef3b00fe32bbede166017e4e032c5fd9aaee00070b84ae46a8c6068ff356fc21d303e279e2dc3e6af88a50f2d14d16520610eaada529d8216d681fcdd623de40a40f0c00fecaed676209d8cc628df12428e98619d50d54b9f2c944d72122c61eccc5614b94aca78075090378aed120f005bdf2bc12ddf3a6e89d72ffa6e04b720221ea137c8e79969de1a9997422cafc155febf7e5350723317a43dbfa83e575fbafc0c0072c8c3d10245e5e876254a0fee8a8c3620fdb46af4753f705359146c6b28c4026aa42075f42d660b7f396fceb4916eab9f15fb7701d2547561b7b654a97914baac49fa1c9b85644ec474ae337dec9d5f4f273c053e885a0a4befd9f270568fb8790d35480c606a86e73e706efb11c6c6883b63339664cf5a209185d7990fed0909611c64fcbaed94f84ece25becb636fb297cdbe1a1e7337b787188a7b4ba891c969c8a525fc06f29022eceebe3f8f2f5a1a0992cbc4cbebb160c4ea205c81fe7be59ce119a4f174a37dad21f85d1bffc47f31d048cbbc85cbf2c23539fe828d62045d0968a405a041ab5607ad270e02625bde3afbbf3f25674533e4b35be5260a6a3d5959444113eea72936e30c437979996d6893088260d899d7d0bd5e111c6ab2e60d182af7b3170e42b8d0a32e7898a2b62396d698dcaebf24a9eb276f20ff62cf74a81bada095add9c4ca7cc6aca83f7e496503a533586cbfd89af21d6ab90e7e1766851027b2109e129e8376725ce643b5bdd2a5c6f5dcee14df5a3ca598563b609a733a05b79728972928e8fb74f653156041a15731351c0ec42e416a868d80c81290962db60178b434f336cc10e9c3dbfb51aab6ebeb97ea3bac4497fa5f88500017ff7255454165ec5ef75bc31133e8283413f0e69574a0135636701a7e1495e2e3d30f9d153984be33aff6b622b415d371d915d9cf99c47928e4412b5c18294443d033a586defcdcc4bd8ba4dbf284adf928a7b1b77855beedcd0034c2992691df6f5bcbbec7af238f56706456849ace01ab653e5ba15fc17516b20f391b3b5cfd1670cd0ef97be8d11f2de8d27fefbcc8e4845e3dae83f2ef8ce39e9a3f7814fa68a2b316508f81a6937ccc66f4efb5bb0d753ae9a24d8084bc4d176d8100c434bb08a66d3a924a542dc2c308a735cef29a708ab6f97d7be65c6756e07f7ac82ca26d000547c233c6d351a011050920482af3042013822c2760cd88078257826ef059ec75efd8117ca56c7716254b1cbbb8359d86c8cdf9c376cfb82dac3736328b20c1ff00598b5423205e8fb8dc0d042e3dec9add1e73d610c559d2c855c5fe531fb95763e57f4748b04c949734c773c5cbda1578d7ceb17e877a566ed8f22fd95b7a964e4bcd3a8dabc280b8e27159e0ac4f85877fae2ff805b2cb37282b2a9a25932902a4e725f91da959c3f25f047cc5c6a333d80b281ed2f2cf400d79974feaa553e6181689900cbd6ba730883d8898444973556d0ae4e58e950e0e42aa5ac21f9c4c3f0c29f00f3ab147e1120fce80fb7e09ca1fc1148cafa0893aeea6beddd1ed8b80f9d16de3d246ac263e3343f4ac3b46d3302e90ffecbcb3760f2379e220b123923e1a7c8a614566ac2e1d04fd1eb296df98c081f2d77548522be19785c3b2e19f447024cdabaf04674e7497db57a838f1eb11d32257d36e53fea896aced59cb90c8d3e1dae702f660b6a4f3fb6b3d48b04f44da147c3453beb5e12fd26121e94ada0ab487c57bba64096c850427d3fa0b58b13b656f388f5948df59c34385f6e2eec8f15d8aaf5fbd8a890cabe93b69f9469ca1e7fa92c7dacae6827e3c6f030c5c17cd3ec60d96cf5c254db6a741599278c8d4947ed6a9a7bb7f4cf7d688f867c510d9421e0cca1de714f4d8262afd9abbf1d9175692d6f9f92a399d2512c8fc4580cc5e2d98c32bb88d3673198b2519caabe2a9a6e2c6248346dc1b006293c2e6fa9aa48b915b137aae83a686b3c4a83163320f9164a2b57f95edf5cdab1130e604338783d46731dad62df81f59ad287d3b00957339b62f1eb42a22c5c29f29291dd0cca5a902c9b09d18b734f5daef5685fcef79cad883d607744a837241ee1f0b0109ea0c469f30c1652b33f95a15849e6ed1a9c5b550e8fe02e42457659e3f1659cf90adb59387e783f63baf339602b95cadcab7f0d8e353528ac5d1600892ea3066cc7d094f73380ba305de5d72209035c67045c66dda153cc1ae7d1e4c25c6bda008fda092d42b4eff9904a871bcf6d6202e726de94260eb642e2a170094ca42d4578a6ca05809876d975d6cb06f920bd86f29ce0b2b80a8c2adf0e4fcd2ab6c83fd1f2dd7dcc6d5689127e7c3c9390dde8f82548b5b3bcd62e15b1defc38001448b0c59f430b4082cde21994d4408ffee7dd2d6b6577f4486646c86ee128f6d4c27b62a397cebec8bfbcabbe6b9a8de829d7c6f48e84b6ba9e578876b17a4691110ba7b5a17d6ae409cc4d57357c2843d0c81057f996eb738993b7ecace4d05c47e3f1f81d6e61a0fc1c20d6bd8e38443b08784e33ab256fe7ff2d32fbabd1b12ad2630afd4567653f587f1018c757d0bc7beff70a0de0a09e694ff0b06148ed54e40e88c68b949e9d023eb68ebfde2c13cb5bd07615c309cc03026caf320605a91570f5e2cdd52e7d25055b463b92194ec606097e57cbc9d1963e44203355c906b6bf9c8f41620baa1e0aefbc1e12a90f6e57090203c1d3a0e96f099856d5cd46a702b542076a46f549a91ec63b41a6a4f550ea5b2541341cc09619c2a84ba9752d1fe13caa8b05be75566f829415a8db6e8dbd977b575c3f8b119acf5ffc93655161e586518017a96e1cf3e31ffc568345169a7ee7816ef3c2cec5deb2e9c84f4f15b790ea2f4e07b05b067ecc2f938a5c3e9a0e7d220f231007673038177eb7e137848e2ab1f7f29daf5bd96bc7f10e71e7fda161e3f3535164dc2625663e1ec0306ca39ff88e4f98318300f36a5f46778b77cbbb6143b72732937096aa86049711ba52d90221f0f2fa79a7abefd70af5f9077c8bc680b3aba92df5a124f6f3e008793ae62513551d59fe8292eca03d76dc42db36ccf64a9e65ed2d9bf0b4f7e00a09979b80533dfd697eacc56a84614be953901d60e2e3be9382221dc66ea9ccd63edb67a8a6873bf58de6f9e0cb3815dc510a5ed4bfd689ec73013cf2e189874687905d2ec563cbaaa68ff680ca1939532453c0baf610120e4f98b075b3957b432da13b7d0088c4ca735012bd22dd2adf14367f79ddf6c061f5f7caadbdb8889c82b6d9f7c8b15acdee6cb5b89eafee355b1d51db1efd5520dfcad72cc6b6d4a7c94509b161b33fdbd04aad8968013d673837891567848629cdbf5f1a9760eb730c3b38767b6ca0798cdb8e6fce09e426f1bb87e9dd30bf893abba8fa2873d18f7b1c487a7ad9eb83ab83b68a65ad9a03598e5e4a46de1d92eca0b227fcd8af5f2afc8c01097881052b1c14bd853a07870bcfb3ef4cf3389f6dc1b6958c194672d9e3d99e0f5c55a8d0bc22382d797cb731b9f4c16665d1dff324d5f2c735ebddbe4c6223ddb28594f21597ccc5ba06e6ecb3cd1886cffbca2a16f60bf7fea8c195d11202c057e65437bb84532f475805bb2a193da89e67fbeab6f5a7401a6b4f650691ec16ca062c14b9dd63ce27df2e7456e9c9463aee868159b030eff4ce3306d661704b82ae7c73253ff3a3b9e0b598e317fa2d35e618ce552f61d46f0d53055a462ab3c1a58ccf5c486c9bd67aeb0f0bec5e28b9a1839d73f7930f05c376c14bf0d8c1e96fa4a3e397e02c0a033ab71b0e3d02e9d2a9d58fd3f663ae46ef339874944dc1226b9d52bd63674f5bd1c68d6d2feb7e3790cc8186894586cf0e6950390ba053c724004bec081f23bd85b7f045c58d1299c21b4c0558370daa762d0d2e0a7c1dd32dc03420d276a2279658444d461c8462a3a97206f4b90cb3db6c918348cf6c59569bf2956bcf3d927c003a2c4107a20975549a5b80e60e5b3817298fff0e6a9ff3ac3a61b3efd094c734dcfb286b6592eefe892f29c070470a5eae3d4ea111768b4f025d78e1826b0562d1f53852848025d45ab0e5da6eafb60f23d7c705b7bef3a1a02bc772823bc1d5151830eb9e5fcc0db514a9376c05c840ce5b23df1efcad6ce9056f462904572d174476cae76049b05d39c39a16f05de2d5a61bc875dfa183235e79944962c218b0994dafbd49940e0eb23645a52e319a231fb8ae528dbd6fbc67272d5c5f67bfa1a34ba49526914fa6c945daf457e935a526eba095860b5a1190fab9dda9d343e499eea3f362c085b82b66d30bb37838efb3a9a27b5474dc1ab7d751afba31f582c727c5c7a28ad4231567bb1e7859a5c6d11fcc86811c7b2018a33fee6b44d7ab867296517cd2bc18df67bee4f0bab718563c21439d1714eca4b978d2a2b9ea12457761ee29c92e183fa9b219d0248bf90553aebaf71b2bd8799997a593a2114bf6f1d8ef5e031267e4be81c1e4d1a0b5a3616c5dd81e5ef0ffe8f554dc9c3b26324218f91f57edad3920707d55866e945cd342e0b01446397b63b2aa5fd1e04a95ba7db4bb2aa30046def252c7dcb71fe5dd2aa81c2a3ca96013953c1da07ed317b005cde745183c9d9fdaede91b69fc543c3eebdb1dbf5df993f22309d5fd6ee736602313d7fb7c345d48961b626b5d1ff7100be011a5387c5c51bb90304b715f61ab894f83935502f3c5817bea20befc545908d3d20fe845b1485e770ae06cd9b86eef0b2d36cb4463ac33a668cecd09b3fac3e562fc019e9105720b7c561e84dbf028ae41344155c8f8b8e41eaae45a44375cb01405a92d8188aa64ac6bbcba64d1809e039d7630acd783cf26bf0dca2a66297ffe8223cc68cb153908424672436c61932900c47691fe91fcaa47343cfbe6afc5c638863f88c8f4833c86c2a973ec7a686f2183f4b954682de072aa39cdea76ec66ee365ab463f6483e4e6ba171af28e0725a92013a43623207d9cf0eff379adbec8b0d90233b7278227f8761a15955b72d0e2b3ffac857cac64f949271f87b7c30f2fc91a51cada4cb2f94ab8a8a62c34b097b62368a87d808444ecd638ffc162bcf46c52edeb02c76c9730dba2971aa0578f724177aa5e7705e61b1c56c6db121ad00cd3a5dd68585d7b8d3b671bb60045c46cc78c50342de6515d769d579850ebfb889cbd9d4bbfeeace6efaeffe02831d2c764ba593077f1874da00f97d9389cfb7311fe9a36b1b2cf7374764892e7bb0a04869ba51e75b2a95670bf9cbc02acd0ef08be4b9878f8e9e37967bd5f53b313ae2a57a8b4e3ac5de74c95c4732921a4f1fee360400616a81363cfa00dcf4e70900a0dfd3ac445855735ea76e581777ba1bb29e87cef13126dc839dbee82626b4fd05d91c66279f627f9d608c7ea857408cb33da29967d8d25b4e1c22df53f0424ecbc29a654c565b1e60b9701bb14bfe68b290b2e789ee5603555c594067bbc2112087347fd1eca2007e9d92e9d98e442759941ed096d74487687f206b80dc68db2a723ddc0634d7410a27221ab6d1694c6a6b3af496254e225fc93f7ba9e757c2b6bcd21cc268b4e3e9969795a2a212f69d61cdef90f0fc8d95b0b21002da456f3c1897979f1a7a3b415508b14d60d044ea271423d1fe1aebefdb243ec0a28e3b03d047411d587d4c806152a55d8bf5f6b7613a96663f0363e59039fc36711bf03355af98293d7f3551c52d08c4a847f61bb2374853d32008d765fa33db72fbb0d7a7e1c216e30bf385be43f21fa82d761c3b4a95fec8dc89d478c8d8472511da379507367d3c21bd3e59498a47f5829a095f304e491eefb992bd0fcbe3424716b89b8c0dda5cd3a58f0b29db411b41afe952c4c3fbf20d288832d5387e1d7072f8d4267d646e13f7f7a83b6d904b9e64a5f454da9e3a400a5f14d931ea624c6c722564baa89527a9766d267415a97da4db449ec2da3c7a9433ef27df872e5d0079741daa19ee0da40895fd670c63a45940d33bd84bbca8db417d50027d7f722b0db32966e5181f222cfcab8f70958defb6134b2d07a53b4cf3068683241dc0bb6be7f75b3fcc2ffda7e69049dcea259459326f754b749edfe8f3b47ab88662d536a042ef0b2a851035d93aa934e7bc96057ac179f8623ad74127d5db6030c3c5423ca58300ff6ac1baa4f2fff530700b55886026b9a2ca2adb4e0940a404c4a7c3cdd80895381f2d906ff8d469b4babe285dfb7fd35c426e4d752363b50178ba5e31783c62fac458c76ff41a3c2fea80a62dcb989d705eda80d92892a4d7ad4d226e9a8c37decbbf6d0bc36ca3b7f468c9dc346c14e9ceacabaac9e208d8f3c834d415f2eb5deced8299403c31c5a00eb457aba363a83e679a93f664d4dfa814170bbe3f5f9685e7ec5601f2f2dcfcec7afa71f26f26fd4e4d50df9292941e42c9e1536385392a6ca968617f2d44001bf556b0cbecd9e7c716f9f5a34c682b4e36608c85f4584634d13eae752d190a98279b1dce90e9bb8d66ca8a46f8147f20190732de96ae68cdf4c60668b7e84b4d1a691c9df438472d564d286befb801ec3bee1ecf2cdb6fbc23bac6a0a94f5d7383c083dd6751ae022b2c95835ace9177be3980fb6ffc808dbdd38a6fcab66e2057aed18ede592303fde8c6e20d508cca2987fa8cdeb9d73bf4d15cd8bac4fbe63b23d47b228eab480c6fdfaee0c9beb7005db41fc0fadf69e789bbc356145abcba6c14f309890d1a4e80d57cea97daaa994855daa8eba4245f76e5a614042d13d09279cab32c7552f0e30ec1b958ee29f1b4d18ec3c793c56c33b0915c540a93806338c4339a3e1f032874205e6f05efe98002fdec7d4a080c833444dd5ff3087c9464d1a6d6f4c4a124354ae9a17954b2e6cfc63ea7fb2d0b6676e496de4f692749fd9ee047353fc6b3d92befd0b99f60c0daf0bf66651bcf7b689d68bc8dbe50af7e45e233bb7e60627a99100bb9d71ca7388fc124f03e90c00db42c7d852a376bcd9693644c1594a5d589886c65a3869a8fdd6b5003443c3f425a9075abbfeea562bf7ff7bad3b88a0c87995d98244d26715a74e3e06328f01f6c673ae8dd150c51e6629f765d4f8aa77bde6e7285363c7d126bcd2a3eb03bcfb47157e4dbf0ab4ed258fd597b90bc98ec1f6868d8eda405d28d8412622e98053c7f8bf3b66dcdf2a1c9385db23291b075985e2edbb35e4ac16bd672cba3ee697e15040562bc0bac4f909002d04ee8ed13764ca58f074ec49c2349dc53d76acdc34325d76226cb13801cc2335ea996ccaf41e9739c239b1ed0e4fa785a8ae85027aa9324fed7d7cf7fb1750ad11e7a7720d12d0db9c09f310cd887266dc62f103c15a6e2e16f1f3085c2d49bd570520393fb9a2ec4e54100268edce9f2bf011d3b8a7b3bd49031a1672399a5dbc9aa72027f6247941fd9ff6f83ae2ba9687c704dbbf0d834db1b213488fce0cab10f621272b4f2c3dfb69b57f953b7193df3b41b2df00c197bf3824263653110c32dad20cac3c23c3c67b52fd01006ce6b788301405bcb10c1a203cb048e87b7c831fd9d28381c37a9616b6d0cbd952a057d0252c3953382f0a6971500c9348dba45a2e8c2027721259bb434d81b6002f992bac1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="请 输 入 阅 读 密 码.">请 输 入 阅 读 密 码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">本文主要记录近期开发相关的学习计划。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="加密博客" scheme="https://www.techgrow.cn/tags/%E5%8A%A0%E5%AF%86%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>近期开发计划</title>
    <link href="https://www.techgrow.cn/posts/29d74d90.html"/>
    <id>https://www.techgrow.cn/posts/29d74d90.html</id>
    <published>2024-01-02T14:38:21.000Z</published>
    <updated>2024-02-05T14:38:21.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误, 请重新输入." data-whm="文章校验失败, 但不影响阅读解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7aa038b85c2e84e72ab1db689533070f5573ed05f84a9c955d7977b52ef5538e">4cfab7e4fdfd9afdbf1592f9652b8a199f3cb3b67d053a3a2b7db0e886465ca1ea14179f28e40c4d184809b24d2f909058d2606747febc969140bf1db3dbbb1a7542b98eb3d7de26ec2c86ec81828b35913853b3ca6e01e7cdd106a9462dcbff705b54ac505b28447538b61c3ec4400b8cb84079a99816fe59006d71ef364f10dfb4d6a52fa3c40030b50b35a957f58eeaf772e9c44236a3270411d3be05e2b07d30b9bac2b2c9e4a597c4d551dde647547269d613d69e329a68cd1dcba6a2bae36bd33e5e11d2a5d518899e43e6fbe0524ed9b9c309564739dcbd3851cc07f0cf45fdf977054a7183a76498682d3bcbe26762ba095458de76d41fd18e8353e46f9e6a744945ca97a1e13148bb3f9423d01ee13a6b4834facb1fd3008b9bc0b23815838f409203118497fae9e3c50332fdcc1f781ba863ad73325b42ab0feec4ff52515efcaae7b170dbd491c656284a85ddf836e73fcccf8e7ca5401292a93019511a0678c1a62a4f9d524748fa16eb444d4ba9b9709af6db0fd8358faffb7d0c03a8d01f503646851d8ec0c9f69f5e075714dcc796357f1870f6f0dca899a9bf358860381dd91e102a52d8499852d404fc84364601414cf25f113952a4e8453feca610d559c44f8a12d16bfedd77987b81e1710f415778084a5bb8f4a5c6c2aab5f7ed9a2212789eea24995e31f21d19c0f60d3d46829a35a209ad5a64ba59a81bdcf152f450d14cd1a48d46a1387566700476d2ecdb9d8353d4cbf63e855586f66ae706f65dc4955184b9a65a836128c63f24689bd56daa7a178ce5757d9d01dc84779600b82e6a988dab8b740a61c2ff52336f31143d91d739de64ac0009731caf857040616087028acc4ed0f44ce7db4b06867cc89fbeb38e768587f29842144388051bf5a9d0e6d50c34f302fd7baa802f9f9c168ffda3ebac1d2050694c4497144e66768873510e3bd1c5331c36ce81277ca2b8b28a332997ea2d4a0c033d8734e7f53a93fd0f7d93befa1e2ca440424342540b5fb5dafb58bae19439fc52008da933c4ab1c09c9397180751c729410b4e33e4b42e2ca464123092a013681dc189d3c6c9b568c9ef209dd27aa322816b62fdb4d438cbb725b076f448c90ab1226f482c58e4a439618e5544ad0b035ece5da84f39b6e91cc187ad85bba9ad3d1df678e401029e9de1b70b3eb57536d7dd879dfcf8c3e624a38256e95a99af821624daa673e38bd8747b26b94d5348d0d27779b447f343f87368acb8e537276216e2e5e6561d9ccaa46b82bd680bce7c4f4cc56d82439b2024cb26c26c284a9d8f5ce24f35b52d335f8b62fc257b04b8ebac321d9785d90e835961fd2c723e3eaf1e9e9f98ee5db63e0521cac3e574a777bb5f1b4b5dbb8ba3d93a4168cc2dfcc0b9a0ae2442d97a01fa711ef780b41f63d893f1f9f6e88ed61953c66ef74636546b60e5f3b74dedf7826adb9aafc045a4d081cc0c6c46f7d99ecc3ac20e73e1b55a401ba5aa22f530c892de0f7961c766fc616288952010e6da9b886d01b932b09af54700ca58efd3d810c1b6e44c3d4f523cd5bf484023309b809e90de2882acb79c237a7a53594e54cd663039a5c74d97b93a5552c24ef2db394e2bca465056620ea92087125ac05f012fe376adaad2684a73e829406a0537e0c721990efafb49abc2d2573fef95878899b9b3bc40aebb4dacfc78dedfe5f8c510f95fc8cb0c645e44a85a438a33e3abfae5b91404b5baaa760e533120ae51b8a1b45d03db0bb7de2afeb3c68cd14915e3aa2cf82d4006b4925c5c061e4e67f779c38b0398feb23efe1b4af81aa7c13957cee35779cb2baf9aaef4eb0074ba9856601131144f3f32b06b8576ebaeaea8467d965e248dec371e7458f974280e534d7df0ed9d0bd01e8d8c8699fab51b573418372ce4c097c62b155d034eab1fb62d37e66d1931e99c8c49eff493573b2f81085af4de971a5b6c8798d3aae32abc0058307e4eacb6d4c20a714d8025ef4a7aabca790b41248b65894b64b5844136de8c10b9a51a96137dfdae9fbe2f8aa1bec41ec1b99bd9e00772946d236131f0e967f002172ee52b95cd5294ee434c95d941684c440616e2d692c46ce12482b1b975fea4822b6c403a9044b94723fb0f8c340d69c4280cdc99c7ad5bfd27a961d195ab077396fb346fbf60a83f70fd162efc7dea1b6b0aab01b08a18fd862d646ecee92cc5b4aac63b70a87e5374a6b2ad3732c63be3b7fec49225659ec8661145100469d3368056e1c5059b25129d28f297492af8aa0d955560b368ccaf6da9b4b74726223aa8713bc5d07c0683dec0ecdd18c1eb5758f6c9fb7f2b378bb0f0e9158c5b1f4e9965ea2dd715b871e0a4b17b315e9212509bb190ba53daefac614109d530a6c6a72a403193252f64cde247028c19e65b05e2aa5a628efed935c6ac9c288ea9b946bebbcfea053b7abf03b3fa9a8bbf594f4a364281fdddbb6404a71011f4bf85ad4eb9042d591b74b9b827ef705ea7fb47c6503cba8dd79b7d1a33e8e3a15bb2d8e2ca8a36eb685c94b2d78215b71c98b2c0b3ee37e035bafbbafef30c0983a823efe8e7117435dd296db8e79ee3f3a744a2538dfde388f61d0a6d130734c4e44be686c870afdb7a1caa863bdabc994fce857ebf7972073d4426ebf9405f5926b4a25db7461119b55bd9ec4bd07931eb8c7d447e022e17a2df094a1dc00dcacd1fc064f1054276eed105893619605c48d576be245c5b87c97301e98a03f4e7214bb91ccb684917f6d96f2fd3488a7eca5ee845751e15fa94e41092d5e55efeab282dcdd9e11323b8a3946b92b5a59100d1e1491e329296363557a9af9262b745f52b40442e617efb7736c99a740dca8af13ebddcd673eb4a534f72e933973592758b63bbd367081a651b5caa7693a2a0ebda3c9f381a2ba519351c4c1d716001a1848bdd3202c31f564397ceb9eb3e4e70041673ccfaa66bd757cea040a014a4391e18d126faec37a2ee964edd824d8c5d2de2c3ead3f410961b608cad747e2bc14687da33756d6de87cc5f8dff3547d7e63964d64eafa0cb410cf2690800747f38b1a7921cfb554ea6bfff93e4207b42461762ef62c1bdc669e1899d1bb55eacf78d9996258735b9a96d7632068e0736297bda947ac28572609247d9f0e1c88c57b891ae7e97a36b4332161e91c23a37f07780aeb2ec85d85e9dea91110a395c7b162dcc3995b684d10eb28d8c55aa78a45b50171f6b23658357003d77d76c00f69027d812e5a3278649dd7f510af0d5eb652abdc305daab3743709e2dad44b171ddc5be2200541a923d4fb3b83785916e92604a89b9f17fc4b838abb234a80e9e037601fc00ef31188b3464ae33435dfb10ab5c973090ac8f01badd332ec2e904e605cc4a3385be2648132d8718fa5f8fb37c035144517ab367a704133c9644c5d1dbcccd2cb46bf88d63527a0116c8282a3f90f9c7a142d29ee89e95e272aa7063df9143ab4ddba067e8d9fb8e84e1ed83e648e0d238ee55f89ac10c0d62477d0f7c123e9c3d88d6e94e2fdc0b162ac345a16e8a23a0c02f82b4e358a37eca0f550842074acdf047d912df3390745af62d280f49d6292bf2f2c09c0a824f6b8636cdb1638a362e2652aea98475ad25b689189ed0940d539736cadb54cb971531dd44ccb04dc1ae651569af62e117d836931dca4e0895fd6eeb4bca0d59f7c421dbe4e44b4cb69b59b67356219451c11b8d7dd5bf20e013a1ffe68d983d1f722c28bc1d7919d49391c48bf1f7ad94a8950d4cc574db236fdd0bae29273aff2931b6b0b981d3e8b6031c1e6f29a5bc4bbd788723eb8b77b8d311fbf17f848d7709988df6130a9050950aa3dea53fee05c55ce0129f5d50dc4bb80243fd3dcfd8ea416b51808c78d2b2a48f9295cb0c48d850f4d9ea9754f770976bcf621dd13892580768a72d15472a8cdc8025628dfbd380c5be7a4f9d36dc72cc0a5a5281119618c23394885a86b6e0fcf909f2fe8964b41f729a21ea6fe351b1057ae08b3e1afc0d3ef3e0a8e6ea83f57ffcf9269dcd4e5a25369630477074a1243e17561171b83664124025196b8581d3daacf8bf6630fe9bc0026fd074b6661e53781f90a757827dff0df9294f141d088c3209794d875c4fac17e0d476f8a760608d272c6e44cb59ba224e27b2df0bf92d167b9c88d7654110876536879bd3fff1db399662dbbe65bb8451b63dfefba2c0cc6511f4d0bd7135cd679d571b0f8278fb6d16883a843ac8feef8a31fe0484d3a70ae7e9e264437e831c618323b273e75b07cc94a4942b7abee0e629f1d1afefdff8bb8d1e92b9d256a9b8270f7ed297bae1cecd45422e80e518f7911d1a0fd78b969d016e08d330fa115d88ce949c137b9cd4f094428fdb499bf6d554a1bf5a89e15cff3a2ca75b42c4e45593dec554558a68993f38206a93ed9f0108dda3554077915127d450d5517f8b63e2274614f61f8df13b408a990f9946d710005fe09a1ee277c47cf38c4358e2d3263791a611a975c8d10ab60b427b5cb5a8551f564bbf59daab665729f836398fdf8dead68c8a2f6c540a3b70fbac21f8730386c18d0e24212731760555c6f60b23e4bc8054b59868ff124046064aedb65b38d9c17f7cffe6efe3c9dbc79f95771675913101fecb789a17a362750f9d1d3f23d0293554e9a5364a3f57a57f33924e50a836a1e448f0074c7c1d99a42bfb695109fdd3462da7fe1c0f953a6028ba576dc5f0bd3b8b69782888a326b4c23d48d9ef531ff8a74cc96f7ae17b926bb76e45598d4f4d186485d107985561cbc8f7eb5361ea6ea16dabfa2506c0bf67b316d547735432ae0c1d549c359d932b3866f0d366c9be1ded3c3073af4943144b8f8f5a81a51e9ed6a812b6bfe57c9288a01360741989c98f4a5f814da3bf74171fa964c630020d35fe88e46467f9dd37c0bcdd9c54ad21b5630df463bcffdc9b5086439fbd90cd5feebd21fbf19858a0bff3f959cf4c8aa546625becce865924cbca2047d82cb3451a2054d8896936256978eab4d6708896210809c05f87d4a1f6412ea838e6a22ae451e61c7a0cc0d15dca8897b8c04e8a8f9555ab8c26f8bea71412c44ee056cb8b1be5878d616b5127f581ea01974ac9e8765f48a3d2291685f878cfe2c710c1224aea84f4544b60fe75e20747ea69d919e5438ee2c46f09a3a829a33f8d344cdba5a0d4f8a6be912ee9dc2073e64ca73bb6cf8a18df311c05c8e1cadff10de8bf4284b4195c05729b5daa7d27077042fc43e20b4aa2271d673cfab972be594036dd6add32bfdd752066ba423c74fc701ef431b52eef8908df6526566f8f3e9662dc00f198ee669d37676b2a538b5ca4299f8e982cae65320161f6e43f38a25115091bed6696b1f2d7b2cc5e0199ffb5dbee9b63f219e1ba13da38735677e30cf4336cd8656efac6dc6afade3773ba1104d218d8f3b2020835336c8d7ac1e15e5ce10dc5811c6f52efb493fc5e4dc69304e44b4f753d9e3beebe013acea970a32144a91e53f2049b786e68389162b6337a4bb41e367c15389458e1af8ac7da2d943bd7ca97c8a3b17ce7538b095f15a86b6159e68709b65e196b5d4b44cf844bc6176a4b8ef844464f3987a211a93e24dfa199f8f34b19166e626cce8c8e9dbc116b0fcb62c4cd88b4aeeb0119b76eb38f624cd9b8a1cbfd5f43214f8f45034aeed30c89435f44bdfcd2adf832089f9716f02808677410dad61df3da105822adec82a11bf601a2b14289cbf8fce26b01ae6802dfcd8d0592027b83135734e4147bb453814b708231a72d6d12a58022dc7c8e546fc90f95b6102c5d650925e9613efa2b7a520ffb62bc526cd6602b6d30178ca55c18efc7b058c64d9c3f199390f507c18429710b5d52cf5a3fc655e2eb7688c11df912756dd978dd262293f702824caf505fcd6e551ceef8282d230e2768a63457ecadd3a7f8597dbf914ac64e1235003b652037d5045dddec13e1e31192cbd3072744e593e4f2bb49b136ada88e09ba5576ce8d38e8335f8f4f3290dd837de1c8a51e3acb0877936f072366c1151dc70033c28816f6e9a6efc83ad3425f88f78d62ce100cb5a7723f24374567f5653c46cb8323c69571aa468834974110f5dc82a30875bab673be32e95062212ff48ee5e856672f35710fcefcf29362ea983f223d5ca3d01789ff6450a19f93a521acdb652884c351c56f222a03e9c49e45319c9942d717c30101654f3c51031bb677fbcd5a7a4355c62ccb933b7ce3c3611dfb12234b152bcc270d5d3a57f6ce3bfa9a910f4ff1e2799dcfea466e5ac7f9365acc05ac0c2e9edfa3d0b8f084b5f402dbc4f9941cdbcb8ccf46e1776333e5a2bb6df995be4e3b87f10ec5bb4f04c538d087fc9f5dbc9eb683f1971e53016afc07fa5ecaf402068e19b7b2029215d7b8b2defef4a172968a7ab3dee2cb19cef50825e0e915ebd73dbec0cce52d1944e6aad535af0957f425d5ffe17d51638f241ff13bebb8f1358333bd5f1c9e9d9a560611cfd917e14b53e2a5d653980f581504b29f6ead070e64230ab9dae5410176b8744855e1c165235bffa9b3460dc763afca48d7c41aa892fcf38cf6b3d20ba7a20dad3f604894d404d83e74dcae2f9144843c1a81d6767f55ad82c55b3556d81301baf67529a1de8b33b18822c2a7338059682b196ec7eba1a3baf268ec6869f127437ee6d6ef4a5c518b40523e0674e0ffbf1917dc5ca27deeef6d41a6600b1193e0f0ebe6bd93d6b1bea9943617596c4726e9d9f3aa7cbab91c5a9fc9049c84b4bb9ea41d0c6f1cdfe3f72b1a03ce13344e61e9f8b1f19311d9a7d907243ed69be76f6331fa81f69b09b7533748d7b2a05c9f1474e014c06436d960c68263dd2b6901762151d628e06526bf38fda01d348277169cca7394c10737bce7df1a1336c517683f6a905f0e2bf5e0f9bdea98c4ac933345fc74560d88c4ecd2f4776ffec9b599d5b4366a2dcbf9e8ba78fd2f258141e900ad8f3de5c491595fedb26fd1a4fd4bc88de3735c0390ab8bfd211cde9f6575fdfe227bd67e9cff80241f75cd27bf2d549bb4c03d5887becd8345bee94b40770f09678175698a3d67bf8afaeecdcd2ac2a7e1a9db5fdc81b837cf76b964fdca7c35e527a41f3c32be359c4ad173df3085b78986b28100865a760d7ff0fb80d93eb470a57e9a1667d64c576da0898479cc8f54b74b2c895289fc321081df00400a686d75a116754ea4cb29ce5b6e5917cd7db174df72c4f7cc5ceca1e0b53cdce9779ad6bd511c31e7d5bb73b8f0cb2452b0f4f7d1bf73740aa1806ab113df1c82901d59db26690a388a3d17be3bc88c880cb92501e2dfdd76d1681c7e30a34e4469f06b67670cf626da64b3bdc160c82d4f4427217e1bb3baac2f6004ffe4f8da116e1336eb2c217957defd6c15af86195715fc5ac9132d339e754d00b308fd090316c37439e743277ab213484e5a68f4fcb2c65be736e26fda553648ba748f1a17b21001bfd5f02d54d395b50dc4ed81302c5cedd11bd5d9b75ba57cfe4a358a0ad3ca5e1952d402c72a7647322c931a2d913bb537d331ac1858694a7611d07e5154783d6d1c18efe984d82294203c3278d59f5d6a524e295ecc6120714350b9989be5c49fce14982491cd3ad781bedbd82e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="请 输 入 阅 读 密 码.">请 输 入 阅 读 密 码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">本文主要记录近期的近期开发计划。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="加密博客" scheme="https://www.techgrow.cn/tags/%E5%8A%A0%E5%AF%86%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Docker 搭建 Kafka 集群</title>
    <link href="https://www.techgrow.cn/posts/d2c9b56d.html"/>
    <id>https://www.techgrow.cn/posts/d2c9b56d.html</id>
    <published>2023-12-19T14:13:45.000Z</published>
    <updated>2023-12-19T14:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->]]></content>
    
    
    <summary type="html">本文主要介绍如何使用 Docker 搭建 Kafka 集群。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="容器化" scheme="https://www.techgrow.cn/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Qt 各版本官方下载地址</title>
    <link href="https://www.techgrow.cn/posts/5bd27ea.html"/>
    <id>https://www.techgrow.cn/posts/5bd27ea.html</id>
    <published>2023-12-04T13:55:33.000Z</published>
    <updated>2023-12-04T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 Qt <code>5.15</code> 开始，Qt 的开源版本只支持在线安装，不再提供离线安装包。使用在线安装器可以安装 Qt <code>5.9</code> 之后 Qt <code>5</code> 和 Qt <code>6</code> 的各个子版本。</p><div class="admonition note"><p class="admonition-title">Qt 的长期技术支持版本</p><ul><li>Qt 6 发布后，Qt 5 仍然在更新，Qt 5 系列的最后一个长期技术支持版本是 <code>5.15</code>。</li><li>Qt 6 系列的第一个长期技术支持版本是 <code>6.2</code>，包含了 Qt 框架中的所有模块。</li></ul></div><h2 id="官方下载地址"><a href="#官方下载地址" class="headerlink" title="官方下载地址"></a>官方下载地址</h2><ul><li><a href="http://download.qt.io/">Qt 相关下载大全</a></li><li><a href="https://download.qt.io/archive/online_installers/">在线安装器的下载地址</a></li><li><a href="http://download.qt.io/archive/qtcreator/">Qt Creator 各个版本的下载地址</a></li><li><a href="http://download.qt.io/archive/vsaddin/">Qt VS 开发插件各个版本的下载地址</a></li></ul><span id="more"></span><h2 id="Qt-官方资源下载（较慢）"><a href="#Qt-官方资源下载（较慢）" class="headerlink" title="Qt 官方资源下载（较慢）"></a>Qt 官方资源下载（较慢）</h2><blockquote><p>Qt 官方有一个专门的资源下载网站，所有的开发环境和相关工具都可以从这里下载，具体地址是：<code>http://download.qt.io/</code></p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-1.png"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td> archive</td><td> 各种 Qt 开发工具安装包，新旧都有（可以下载 Qt 开发环境和源代码）。</td></tr><tr><td>community_releases</td><td> 社区定制的 Qt 库，Tizen 版 Qt 以及 Qt 附加源码包。</td></tr><tr><td>development_releases</td><td> 开发版，有新的和旧的不稳定版本，在 Qt 开发过程中的非正式版本。</td></tr><tr><td>learning</td><td> 有学习 Qt 的文档教程和示范视频。</td></tr><tr><td>ministro</td><td> 迷你版，目前是针对 Android 的版本。</td></tr><tr><td>official_releases</td><td> 正式发布版，即最新稳定版的 Qt 库和开发工具（可以下载 Qt 开发环境和源代码）。</td></tr><tr><td>online</td><td>Qt 在线资源。</td></tr><tr><td>snapshots</td><td> 预览版，最新的开发测试中的 Qt 库和开发工具。</td></tr></tbody></table><blockquote><p><code>archive</code> 和 <code>official_releases</code> 两个目录都有最新的 Qt 开发环境安装包，这里以 <code>archive</code> 目录里的内容为例来说明。点击进入 <code>archive</code> 目录，会看到多个子目录：</p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-2.png"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td> vsaddin</td><td>Qt 针对 Visual Studio 集成的插件。</td></tr><tr><td>qtcreator</td><td>Qt 官方的集成开发工具。</td></tr><tr><td>qt</td><td>Qt 开发环境的下载目录。</td></tr><tr><td>online_installers</td><td> 在线安装器，国内用户的下载速度较慢。</td></tr><tr><td>additional_libraries</td><td>QT 框架的一些附加模块。</td></tr></tbody></table><blockquote><p>再进入 <code>qt</code> 子目录 ，会看到所有的 Qt 版本，从 <code>1.0</code> 到目前的 <code>6.6</code></p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-3.png"></p><blockquote><p>进入 <code>6.6</code> 目录，会看到各种子版本</p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-4.png"></p><blockquote><p>进入 <code>6.6.1</code> 子版本，会看到多个目录</p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-5.png"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td> submodules</td><td>Qt 各个子模块的源码包</td></tr><tr><td> single</td><td>Qt 完整的源码包</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">Qt 版本号的命名规则</p><p>这里解释一下 Qt 的版本号，比如 <code>6.5.3</code> 是完整的 Qt 版本号，第一个数字 6 是大版本号（major），第二个数字 5 是小版本号（minor），第三个数字 3 是补丁号（patch）。只要前面两个数字相同，Qt 的特性就是一致的，最后的数字是对该版本的补丁更新。</p></div><h2 id="Qt-国内镜像资源下载（较快）"><a href="#Qt-国内镜像资源下载（较快）" class="headerlink" title="Qt 国内镜像资源下载（较快）"></a>Qt 国内镜像资源下载（较快）</h2><p>在国内，Qt 的官方下载速度较慢，建议使用国内镜像网站下载。这里推荐几个国内著名的 Qt 镜像网站，主要是各个高校的：</p><table><thead><tr><th>镜像网站名称</th><th>下载地址</th></tr></thead><tbody><tr><td>中国科学技术大学 </td><td><a href="http://mirrors.ustc.edu.cn/qtproject/">http://mirrors.ustc.edu.cn/qtproject/</a></td></tr><tr><td> 清华大学 </td><td><a href="https://mirrors.tuna.tsinghua.edu.cn/qt/">https://mirrors.tuna.tsinghua.edu.cn/qt/</a></td></tr><tr><td> 北京理工大学 </td><td><a href="http://mirror.bit.edu.cn/qtproject/">http://mirror.bit.edu.cn/qtproject/</a></td></tr><tr><td> 中国互联网络信息中心 </td><td><a href="https://mirrors.cnnic.cn/qt/">https://mirrors.cnnic.cn/qt/</a></td></tr></tbody></table><blockquote><p>值得一提的是，国内镜像网站的资源目录结构和 Qt 官网是类似的，这里不再赘述。</p></blockquote><h2 id="Qt-在线安装案例"><a href="#Qt-在线安装案例" class="headerlink" title="Qt 在线安装案例"></a>Qt 在线安装案例</h2><blockquote><p>在 <a href="https://download.qt.io/archive/online_installers/">Qt 官网</a> 下载在线安装器，如 <code>qt-unified-windows-x86-4.2.0-online.exe</code></p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-6.png"></p><blockquote><p>双击在线安装器的 <code>EXE</code> 文件，开始安装 Qt，然后根据自己实际需求安装所需的组件</p></blockquote><p><img data-src="../../../asset/2023/12/qt-download-7.png"></p><div class="admonition note"><p class="admonition-title">提示</p><ul><li>Qt 的安装一般需要 20G 以上的磁盘空间，请确保磁盘有足够的空间。</li><li>由于笔者在本地安装了 Visual Studio 2019，因此在上述图中选择了 <code>MSVC 2019 64-bit</code> 开发套件，若不需要，可以选择不安装该组件。</li><li>笔者选择安装 Qt 的长期技术支持版本，分别是 Qt <code>5.15</code> 与 Qt <code>6.2</code>，若不需要使用 Qt 5，可以选择不安装上述图中 Qt <code>5.15.2</code> 相关的组件，只安装 Qt 6 相关的组件。</li></ul></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://c.biancheng.net/view/3851.html">Qt 下载（多种下载通道 + 所有版本）</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Qt 各版本的官方下载地址，包括 Qt 的安装教程、镜像网站下载加速等内容。</summary>
    
    
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>分库分表可能真的要退出历史舞台</title>
    <link href="https://www.techgrow.cn/posts/8c661fac.html"/>
    <id>https://www.techgrow.cn/posts/8c661fac.html</id>
    <published>2023-11-26T14:45:21.000Z</published>
    <updated>2023-11-26T14:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一开始，开箱即用的 MySQL，一定是企业的首选。不仅仅因为用的人多，更重要的是生态成熟。随着业务的飞速发展（虽然现在这种机会比较少了），对于 MySQL 来说，很快就会遇到各种性能问题。这个时候，就需要由单机 MySQL 向分布式发展了。</p><h2 id="传统数据库的瓶颈"><a href="#传统数据库的瓶颈" class="headerlink" title="传统数据库的瓶颈"></a>传统数据库的瓶颈</h2><p>单机 MySQL 面临很多问题：</p><ul><li>单表太大，比如超过 500w，查询就非常吃力</li><li>单库太大，各种资源告急</li><li>读请求太高，严重影响写请求</li></ul><span id="more"></span><h2 id="传统数据库解决方案"><a href="#传统数据库解决方案" class="headerlink" title="传统数据库解决方案"></a>传统数据库解决方案</h2><p>很长时间以来，国内互联网的做法普遍是采用加入一个中间件的方式来解决，但随着分布式数据库的技术越来越成熟，这些魔法逐渐下沉到它本应该解决的层面 – 数据库实现层。留给分库分表技术的时间已经不多，它的存量市场越来越少了。分库分表技术，退出历史舞台，也是迟早的事情了。解决上面三个单机 MySQL 问题，有很多种切入层面，常见的有框架层、驱动层、代理层。</p><h3 id="第一种（框架层）"><a href="#第一种（框架层）" class="headerlink" title="第一种（框架层）"></a>第一种（框架层）</h3><p>简单地在 MyBatis 或者 JPA 之上使用 AOP 或者拦截器封装一层，也可以实现，这也是最傻的方式。</p><h3 id="第二种（驱动层）"><a href="#第二种（驱动层）" class="headerlink" title="第二种（驱动层）"></a>第二种（驱动层）</h3><p>再进一步，就可以在 JDBC 之上的驱动层来实现，把分库分表的路由维护在内存里，通过重写的 DataSource、Connection、Statment、ResultSet 等，对业务进行无侵入的改进。但可惜的是，这类方案还必须要维护与逻辑表相对应的物理表，而且功能也是阉割的，不确定性依然不小。更要命的是，JDBC 只支持 Java，对于某些公司来说，就非常的不适用。</p><h3 id="第三种（代理层）"><a href="#第三种（代理层）" class="headerlink" title="第三种（代理层）"></a>第三种（代理层）</h3><p>再就是采用中间件的传统模式，引入 Proxy 中间件，即把自己伪装成一个 MySQL Server，接受 Client 的请求。至于它后面怎么去操作真实的数据库，开发者都不需要知道。但 Proxy 本身也是一套服务，需要保证高可用，且有运维成本在里面，同时功能依然是阉割的。</p><h2 id="新型数据库解决方案"><a href="#新型数据库解决方案" class="headerlink" title="新型数据库解决方案"></a>新型数据库解决方案</h2><p>框架层、驱动层、代理层，在过去很长一段时间里，有无数的互联网公司前赴后继的试水，从 TDDL、Cobar，到 MyCat、ShardingSphere，各种层面的中间件也是层出不穷。但最近几年，这种争相斗艳的场面逐渐不再，到最后剩下来的，也就 ShardingSphere 这一枝独秀了。是问题不存在了么？不，正好相反，问题越来越严重。并不是问题消失了，而是它被转化成其他解决方式了。</p><h3 id="分布式数据库的前景"><a href="#分布式数据库的前景" class="headerlink" title="分布式数据库的前景"></a>分布式数据库的前景</h3><p>抛开关系型数据库不说，很久之前，类似于 ElasticSearch、Cassandra 这样的 NoSQL 存储，分片和副本的概念，就已经非常成熟了，而且它们是内置的，并不需要 DBA 去人工维护它们的物理位置。对于关系型数据库来说，走向分布式也终将成为必然。随着 Raft 等协议应用越来越广泛，分布式数据库的可靠性也逐渐得到了保证。如果以前因为事务问题而拒绝采用某些 NoSQL 产品，那么如今完全兼容 MySQL 的分布式数据库，没有理由再拒绝。</p><h3 id="分布式数据库的选择"><a href="#分布式数据库的选择" class="headerlink" title="分布式数据库的选择"></a>分布式数据库的选择</h3><p>云厂商，直接提供了像 Aurora、PolarDB 之类的 MySQL 增强，更有类似 TiDB、OceanBase 这样纯粹的分布式数据库，越来越多的业务走向了这个终途。当团队加班加点验证着分库分表中间件的时候，却发现其实换个兼容的存储就能玩得转，你会怎么选，简直不用再多说。当然，一旦选用了分布式数据库，以前的 DBA 经验可能就不管用了，比如说索引及其二级索引。开发团队不得不学习新的知识，来应对分布式环境。但这些都是阵痛，<strong>长远看来，分布式数据库是趋势，而分库分表中间件只能吃存量业务。</strong></p><h2 id="如何选择解决方案"><a href="#如何选择解决方案" class="headerlink" title="如何选择解决方案"></a>如何选择解决方案</h2><ul><li>如果业务拥有常年累积的大量复杂数据，建议采用复杂的分库分表组件。</li><li>如果业务比较新，在可预见的未来会有大量数据，那选择分布式数据库是最合适的。</li></ul><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p><strong>分库分表中间件并不是消失了。它摇身一变，变成了分布式数据库的一部分。</strong>你可能会听到很多切到分布式数据库，又从分布式数据库切回到 MySQL 的案例，这属于想吃螃蟹但并没有吃到。目前来看，分布式数据库越来越稳定，生态建设也越来越好。而分库分表，则适用于存量业务，终将会退出历史的舞台。</p>]]></content>
    
    
    <summary type="html">分库分表可能真的要退出历史舞台。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="数据库" scheme="https://www.techgrow.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Cisdem PDF Converter OCR 转换器破解安装</title>
    <link href="https://www.techgrow.cn/posts/3ac58081.html"/>
    <id>https://www.techgrow.cn/posts/3ac58081.html</id>
    <published>2023-11-22T13:18:36.000Z</published>
    <updated>2023-11-22T13:18:36.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PDF 可以在任何屏幕上完美地显示内容，并且可以轻松阅读、存档或分发文件，而 Office 格式是文档创建和编辑的必备格式，因此 PDF 转换对于进一步编辑或重复使用变得很常见。<strong>Cisdem PDF Converter OCR 支持快速无缝地将 PDF 转换为多种文档格式，同时支持将扫描版的 PDF 文档转换成可编辑的 PDF 文档。</strong></p><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>支持 Windows 7、Windows 8、Windows 10、Windows 11 的 64 位操作系统。</p><h2 id="软件简介"><a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h2><p>Cisdem PDF Converter OCR 是一款 PDF 格式转换软件，可以轻松地将正常和可扫描的 PDF 文档转换为可编辑文本格式的文件，比如转换为可编辑和可搜索的 PDF、Word、Excel、PPT、ePub、HTML、TXT、Rtfd、图片 (JPEG，BMP，PNG，GIF，TIFF) 等格式，支持 OCR 技术，同时保持原始布局和文件质量。</p><h2 id="软件特点"><a href="#软件特点" class="headerlink" title="软件特点"></a>软件特点</h2><p>Cisdem PDF Converter OCR 将尽力保留文本、图像、表格元素，并尽可能准确地保持原始格式、布局。例如，它可以在 Word 文档中保留复杂 PDF 文件的原始外观和感觉，将表格数据放入 Excel 电子表格中的正确单元格中，并在 PowerPoint 中保留布局，您无需花费数小时调整输出文件。OCR (光学字符识别) 用于根据形状和外观识别文本字符，它可以帮助从扫描的 PDF 或图像文件中提取文本内容，是归档和重新扫描 PDF 的必备功能。Cisdem PDF Converter OCR 不仅可以通过启用 OCR 功能快速批量处理扫描的 PDF 和图像文件，还可以通过手动标记文本、图像和表格来微调 OCR 应用区域，以实现更准确的识别。Cisdem PDF Converter OCR 可以识别 200 多种语言，包括英语、中文、西班牙语、阿拉伯语、法语、俄语、葡萄牙语、德语、日语、韩语等。</p><span id="more"></span><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul><li>百度网盘链接: <code>https://pan.baidu.com/s/1jls5BTI_kinz5e70wbbQHg</code></li><li>百度网盘提取码: <code>7exm</code></li></ul><h3 id="破解安装"><a href="#破解安装" class="headerlink" title="破解安装"></a>破解安装</h3><ol><li>在软件下载并解压后，将获得 <code>Setup.exe</code> 和 <code>Crack</code> 等文件，双击 <code>Setup.exe</code> 文件开始安装</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-1.png"></p><ol start="2"><li>默认选择创建桌面快捷方式，然后点击 <code>next</code> 按钮</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-2.png"></p><ol start="3"><li>点击 <code>install</code> 按钮开始安装软件</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-3.png"></p><ol start="4"><li>去掉勾选，先不要运行软件，等待安装破解补丁</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-4.png"></p><ol start="5"><li>在安装破解补丁前，首先打开软件的安装目录。如果忘记软件的安装目录，请返回到系统桌面，找到软件的桌面快捷图标，并右键点击图标，出现弹窗后选择 <code>打开文件位置</code> 即可获得软件的安装目录</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-5.png"></p><ol start="6"><li>打开解压后的 <code>Crack</code> 文件夹，将里面的破解补丁文件复制到软件安装目录中替换</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-6.png"></p><ol start="7"><li>选择替换目标中的文件</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-7.png"></p><ol start="8"><li>双击桌面的快捷方式运行软件，点击顶部菜单栏里的 <code>About</code> 选项，查看是否激活成功</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-8.png"></p><h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><ol><li>将需要转换的 PDF 文件拖拽到软件的主界面中，此时会提示在线下载并安装 OCR 模块，点击 <code>OK</code> 按钮开始下载。如果下载失败，可以关闭并重启软件，拖拽 PDF 文件到主界面，然后重新安装 OCR 模块</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-9.png"></p><ol start="2"><li>等待 OCR 模块下载完成</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-10.png"></p><ol start="3"><li> OCR 模块下载完成后，根据提示进行安装</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-11.png"></p><ol start="4"><li>若需要将扫描版的 PDF 文件转换为可编辑的 PDF 文件，可以选择 <code>OCR PDF</code>，并点击 <code>齿轮</code> 图标，选择语言为 <code>Chinese（Simplified）</code> 和 <code>English</code>，然后点击 <code>OK</code> 按钮</li></ol><p><img data-src="../../../asset/2023/10/pdf-converter-12.png"></p><ol start="5"><li>最后选择 PDF 文件转换后的输出目录，然后点击 <code>Convert</code> 按钮开始转换 PDF 文件</li></ol><p><img data-src="../../../asset/2023/10/pdf-convert-13.png"></p>]]></content>
    
    
    <summary type="html">本文主要记录 Cisdem PDF Converter OCR 转换器的破解安装教程，包括如何将 PDF 转换为其他格式的文件。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 云原生解决方案介绍</title>
    <link href="https://www.techgrow.cn/posts/16a97c36.html"/>
    <id>https://www.techgrow.cn/posts/16a97c36.html</id>
    <published>2023-11-15T14:13:45.000Z</published>
    <updated>2023-11-15T14:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍 Kafka 在生产实践中存在的问题，如运维操作、负载均衡、故障恢复等各方面，并简单介绍字节跳动、小红书是如何使用消息队列的云原生化来解决这些问题的。</p><h2 id="Kafka-实践遇到的问题"><a href="#Kafka-实践遇到的问题" class="headerlink" title="Kafka 实践遇到的问题"></a>Kafka 实践遇到的问题</h2><p>随着业务快速增长，经典消息队列 Kafka 的劣势开始逐渐暴露，在弹性、规模、成本及运维方面都无法满足业务需求。在本中，将介绍 Kafka 在生产实践中存在的问题，如运维操作、负载均衡、故障恢复等各方面。</p><span id="more"></span><h3 id="运维操作"><a href="#运维操作" class="headerlink" title="运维操作"></a>运维操作</h3><p>Kafka 的重启、扩缩容、分区迁移，这些运维操作都比较复杂。</p><p><img data-src="../../../asset/2023/10/kafka-note-1.png"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><img data-src="../../../asset/2023/10/kafka-note-2.png"></p><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>Kafka 自身支持处理单机故障，但对多机故障却无能为力。</p><p><img data-src="../../../asset/2023/10/kafka-note-3.png"></p><h3 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h3><p><img data-src="../../../asset/2023/10/kafka-note-4.png"></p><h3 id="存算一体架构"><a href="#存算一体架构" class="headerlink" title="存算一体架构"></a>存算一体架构</h3><p><img data-src="../../../asset/2023/10/kafka-note-5.png"></p><h2 id="字节跳动云原生消息队列方案"><a href="#字节跳动云原生消息队列方案" class="headerlink" title="字节跳动云原生消息队列方案"></a>字节跳动云原生消息队列方案</h2><p>BMQ 是字节跳动自研的一款消息队列，基于 C++ 开发，兼容 Kafka 协议，采用 HDFS 分布式存储来存放消息数据。</p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img data-src="../../../asset/2023/10/kafka-note-6.png"></p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p><img data-src="../../../asset/2023/10/kafka-note-7.png"></p><h3 id="Broker-运行机制"><a href="#Broker-运行机制" class="headerlink" title="Broker 运行机制"></a>Broker 运行机制</h3><p><img data-src="../../../asset/2023/10/kafka-note-8.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-9.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-10.png"></p><h3 id="Proxy-运行机制"><a href="#Proxy-运行机制" class="headerlink" title="Proxy 运行机制"></a>Proxy 运行机制</h3><p><img data-src="../../../asset/2023/10/kafka-note-11.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-12.png"></p><h3 id="容灾容错-HDFS"><a href="#容灾容错-HDFS" class="headerlink" title="容灾容错 HDFS"></a>容灾容错 HDFS</h3><p><img data-src="../../../asset/2023/10/kafka-note-13.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-14.png"></p><h3 id="线上业务使用场景"><a href="#线上业务使用场景" class="headerlink" title="线上业务使用场景"></a>线上业务使用场景</h3><p><img data-src="../../../asset/2023/10/kafka-note-15.png"></p><h2 id="小红书-Kafka-云原生最佳实践"><a href="#小红书-Kafka-云原生最佳实践" class="headerlink" title="小红书 Kafka 云原生最佳实践"></a>小红书 Kafka 云原生最佳实践</h2><p>小红书在 Kafka 原有的基础上，引入了分层存储、弹性扩容、消费隔离等特性。</p><h3 id="核心手段"><a href="#核心手段" class="headerlink" title="核心手段"></a>核心手段</h3><p><img data-src="../../../asset/2023/10/kafka-note-16.png"></p><h3 id="系统架构-1"><a href="#系统架构-1" class="headerlink" title="系统架构"></a>系统架构</h3><p><img data-src="../../../asset/2023/10/kafka-note-17.png"></p><h3 id="架构优势"><a href="#架构优势" class="headerlink" title="架构优势"></a>架构优势</h3><p><img data-src="../../../asset/2023/10/kafka-note-18.png"></p><h3 id="成本优化"><a href="#成本优化" class="headerlink" title="成本优化"></a>成本优化</h3><p><img data-src="../../../asset/2023/10/kafka-note-19.png"></p><h3 id="消费隔离"><a href="#消费隔离" class="headerlink" title="消费隔离"></a>消费隔离</h3><p><img data-src="../../../asset/2023/10/kafka-note-20.png"></p><h3 id="智能缓存"><a href="#智能缓存" class="headerlink" title="智能缓存"></a>智能缓存</h3><p><img data-src="../../../asset/2023/10/kafka-note-21.png"></p><h3 id="弹性扩容"><a href="#弹性扩容" class="headerlink" title="弹性扩容"></a>弹性扩容</h3><p><img data-src="../../../asset/2023/10/kafka-note-22.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-23.png"></p><h3 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h3><p><img data-src="../../../asset/2023/10/kafka-note-24.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-25.png"></p><p><img data-src="../../../asset/2023/10/kafka-note-26.png"></p><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><h4 id="升级现有架构"><a href="#升级现有架构" class="headerlink" title="升级现有架构"></a>升级现有架构</h4><p><img data-src="../../../asset/2023/10/kafka-note-27.png"></p><h4 id="引入存算分离架构"><a href="#引入存算分离架构" class="headerlink" title="引入存算分离架构"></a>引入存算分离架构</h4><p><img data-src="../../../asset/2023/10/kafka-note-28.png"></p><h2 id="AutoMQ-云原生消息队列方案"><a href="#AutoMQ-云原生消息队列方案" class="headerlink" title="AutoMQ 云原生消息队列方案"></a>AutoMQ 云原生消息队列方案</h2><h3 id="AutoMQ-for-Kafka"><a href="#AutoMQ-for-Kafka" class="headerlink" title="AutoMQ for Kafka"></a>AutoMQ for Kafka</h3><p>由 <a href="https://www.automq.com/">AutoMQ</a> 开源的新一代消息流存储平台，面向开发者提供低成本、无状态、 100% 兼容 Apache Kafka 的消息服务。目前有两种版本，分别是商业版与开源版本。</p><ul><li><a href="https://docs.automq.com/zh/docs/automq-s3kafka/YUzOwI7AgiNIgDk1GJAcu6Uanog">官方中文文档</a></li><li><a href="https://github.com/AutoMQ/automq-for-kafka">GitHub 开源项目</a></li></ul><h3 id="AutoMQ-for-RocketMQ"><a href="#AutoMQ-for-RocketMQ" class="headerlink" title="AutoMQ for RocketMQ"></a>AutoMQ for RocketMQ</h3><p>由 <a href="https://www.automq.com/">AutoMQ</a> 基于 Apache RocketMQ 5.0 的云原生开源实现。目前有两种版本，分别是商业版与开源版本。</p><ul><li><a href="https://github.com/AutoMQ/automq-for-rocketmq">GitHub 开源项目</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/post/7199550396213542973">消息队列 | 青训营笔记</a></li><li><a href="https://www.bilibili.com/video/BV1Cc411R7kt">字节跳动云原生消息队列实践 - 视频</a></li><li><a href="https://www.bilibili.com/video/BV1dw411s7g8">小红书 Kafka 云原生化最佳实践 - 视频</a></li><li><a href="https://www.bilibili.com/video/BV1hM411S7PP">如何实现 Apache Kafka 十倍的降本增效 - 视频</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Kafka 云原生解决方案。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="微服务" scheme="https://www.techgrow.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.techgrow.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="消息队列" scheme="https://www.techgrow.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的 Xinetd 服务介绍</title>
    <link href="https://www.techgrow.cn/posts/7f134f1e.html"/>
    <id>https://www.techgrow.cn/posts/7f134f1e.html</id>
    <published>2023-11-14T13:48:23.000Z</published>
    <updated>2023-11-14T13:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Xinetd-简介"><a href="#Xinetd-简介" class="headerlink" title="Xinetd 简介"></a>Xinetd 简介</h2><p>Xinetd 是新一代的网络守护进程服务程序，又叫超级 Internet 服务器，经常用来管理保护多种轻量级 Internet 服务。它在 Linux 的安全中有着举足轻重的地位，它管理的服务都是一些不是很常用，但是系统中偶尔也会用到的小服务或者该服务没什么好的安全机制，比如：Ftp、Rsync、Telnet、SSH 等。它并不是一真正意义上的服务，Xinetd 相当于 Rync、SSH 等服务的代理人，比如代理了 <code>sshd</code>，那就可以关闭 SSH 服务，22 端口就由 Xinetd 服务代理了。它的作用大致可以分为以下几个：访问控制、防止 DOS 攻击、服务转发、用户交互式体验等。</p><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul><li><code>超级守护进程</code>：多个服务统一由一个进程管理，该进程可以管理多个服务。</li><li><code>独立启动的守护进程</code>：每个特定服务都有单独的守护进程（stand-alone），这个保证单一服务始终存活的进程就是独立启动的守护进程。</li></ul><span id="more"></span><h3 id="优点介绍"><a href="#优点介绍" class="headerlink" title="优点介绍"></a>优点介绍</h3><ul><li><p>强大的存取控制功能</p><ul><li>设置特定的连接时间；</li><li>内置对恶意用户和善意用户的差别待遇设定；</li><li>使用 <code>libwrap</code> 支持，其效能更甚于 <code>tcpd</code>；</li><li>可以限制连接的等级，基于主机的连接数和基于服务的连接数；</li><li>将某个服务设置到特定的主机以提供服务。</li></ul></li><li><p>有效防止 DoS 攻击</p><ul><li>可以限制连接的等级；</li><li>可以限制一个主机的最大连接数，从而防止某个主机独占某个服务；</li><li>可以限制日志文件的大小，防止磁盘空间被填满。</li></ul></li><li><p>强大的日志功能</p><ul><li>可以为每一个服务 <code>syslog</code> 设定日志等级；</li><li>如果不使用 <code>syslog</code>，也可以为每个服务建立日志文件；</li><li>可以记录请求的起止时间以决定对方的访问时间；</li><li>可以记录试图非法访问的请求。</li></ul></li><li><p>转向功能</p><ul><li>可以将客户端的请求转发到另一台主机去处理。</li></ul></li><li><p>支持 IPv6</p><ul><li>Xinetd 从 <code>2.1.8.8 pre*</code> 版本开始就支持 IPv6，另外 IPv4 仍然被支持。</li></ul></li><li><p>与客户端的交互功能</p><ul><li>无论客户端请求是否成功，Xinetd 都会有提示告知连接状态。</li></ul></li></ul><h3 id="缺点介绍"><a href="#缺点介绍" class="headerlink" title="缺点介绍"></a>缺点介绍</h3><p>Xinetd 当前最大的缺点是对 RPC 支持的不稳定，但是可以启用 <code>protmap</code>，使它与 Xinetd 共存来解决这个问题。</p><h2 id="Xinetd-使用"><a href="#Xinetd-使用" class="headerlink" title="Xinetd 使用"></a>Xinetd 使用</h2><p>原则上任何系统服务都可以使用 Xinetd，然而最适合的应该是那些常见的网络服务，并且这些服务的请求数目和频繁程度不会太高。像 DNS 和 Apache 就不适合采用 Xinetd 进行管理，而像 FTP、Telnet、SSH 等就适合使用 Xinetd 进行管理。</p><ul><li>系统默认使用 Xinetd 的服务可以分为如下几类<ul><li>① 标准 Internet 服务：telnet、ftp。</li><li>② 信息服务：finger、netstat、systat。</li><li>③ 邮件服务：imap、imaps、pop2、pop3、pops。</li><li>④ RPC 服务：rquotad、rstatd、rusersd、sprayd、walld。</li><li>⑤ BSD 服务：comsat、exec、login、ntalk、shell、talk。</li><li>⑥ 内部服务：chargen、daytime、echo、servers、services、time。</li><li>⑦ 安全服务：irc。</li><li>⑧ 其他服务：name、tftp、uucp。</li></ul></li></ul><p>具体可以使用 Xinetd 进行管理的服务都在 <code>/etc/services</code> 配置文件中定义，该配置文件记录了网络服务名和它们对应使用的端口号及协议。文件中的每一行对应一种服务，它由 4 个字段组成，中间用 Tab 键或空格键分隔，分别表示 <code>服务名称</code>、<code>使用端口</code>、<code>协议名称</code> 及 <code>别名</code>。在一般情况下，不要修改该配置文件的内容，因为这些设置都是 Internet 标准的设置。一旦修改，可能会造成系统冲突，使用户无法正常访问资源。Linux 系统的端口号范围为 0 ~ 65535，不同范围的端口号有不同的意义：</p><ul><li><code>0</code>：不使用。</li><li><code>1 ~ 1023</code>：系统保留，只能由 <code>root</code> 用户使用。</li><li><code>1024 ~ 4999</code>：由客户端程序自由分配。</li><li><code>5000 ~ 65535</code>：由服务器程序自由分配。</li></ul><h2 id="Xinetd-配置"><a href="#Xinetd-配置" class="headerlink" title="Xinetd 配置"></a>Xinetd 配置</h2><p> Xinetd 的配置文件是 <code>/etc/xinetd.conf</code>，但是它只包括默认值，并包含 <code>/etc/xinetd.d</code> 目录中的配置文件。如果要启用或禁用某项 Xinetd 服务，可以编辑位于 <code>/etc/xinetd.d</code> 目录中的配置文件。例如，<code>disable</code> 属性被设为 <code>yes</code>，表示该项服务已禁用；<code>disable</code> 属性被设为 <code>no</code>，表示该项服务已启用。参数和值之间的操作符可以是 <code>=</code>、<code>+=</code> 或 <code>-=</code>。所有属性可以使用 <code>=</code>，其作用是分配一个或多个值。某些属性可以使用 <code>+=</code> 或 <code>-=</code>，其作用分别是将其值增加到某个现存的值表中，或将其值从现存值表中删除。详细的配置参数说明如下：</p><table><thead><tr><th>配置参数</th><th>说明</th></tr></thead><tbody><tr><td> enabled</td><td> 是否启用该服务或服务列表</td></tr><tr><td> disabled</td><td> 是否停用该服务或服务列表</td></tr><tr><td> server</td><td> 启动脚本的位置</td></tr><tr><td> server_args</td><td></td></tr><tr><td>socket_type</td><td> 服务的数据包类型</td></tr><tr><td> log_type</td><td> 包括：日志类型、路径、报警最大容量、停止服务的最大容量</td></tr><tr><td> log_on_success</td><td> 成功后要将哪些值记录到日志中</td></tr><tr><td> log_on_failure</td><td> 失败后要将哪些值记录到日志中</td></tr><tr><td> only_from</td><td> 只有指定 IP 可以访问</td></tr><tr><td> no_access</td><td> 指定 IP 不可以访问</td></tr><tr><td> access_times</td><td> 允许连接的时间</td></tr><tr><td> user</td><td> 运行此服务进程的用户</td></tr><tr><td> wait</td><td> 服务将以多线程的方式运行</td></tr><tr><td> max_load</td><td> 系统最大负载系数</td></tr><tr><td> cps m n</td><td> 限制每秒 m 个入站连接，如果超过 m，则等待 n 秒，主要用于对付服务攻击</td></tr><tr><td> port</td><td> 连接的端口</td></tr><tr><td> nice</td><td></td></tr><tr><td>protocol</td><td> 连接使用的协议</td></tr><tr><td> instances</td><td> 最大连接进程数</td></tr><tr><td> per_source</td><td> 限制每个主机的最大连接数</td></tr><tr><td> bind</td><td></td></tr><tr><td>mdns</td><td></td></tr><tr><td>v6only</td><td></td></tr><tr><td>passenv</td><td></td></tr><tr><td>groups</td><td></td></tr><tr><td>umask</td><td></td></tr><tr><td>banner</td><td></td></tr><tr><td>banner_fail</td><td></td></tr><tr><td>banner_success</td><td></td></tr><tr><td>rlimit_as</td><td> 最多可用内存</td></tr><tr><td> rlimit_cpu</td><td>CPU 每秒最多处理的进程数</td></tr></tbody></table><h2 id="Xinetd-安装"><a href="#Xinetd-安装" class="headerlink" title="Xinetd 安装"></a>Xinetd 安装</h2><ul><li>CentOS 安装 Xinetd</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo yum -y install xinetd</span><br></pre></td></tr></tbody></table></figure><ul><li>Xinetd 服务管理 </li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">sudo service xinetd start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">sudo service xinetd stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">sudo service xinetd restart</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/weixin_43869703/article/details/133879164">Xinetd 服务介绍</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Xinetd 服务的使用。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第 146 道题 - LRU 缓存</title>
    <link href="https://www.techgrow.cn/posts/d43b3761.html"/>
    <id>https://www.techgrow.cn/posts/d43b3761.html</id>
    <published>2023-11-13T13:55:33.000Z</published>
    <updated>2023-11-13T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode 的 第 146 道算法题 - <a href="https://leetcode.cn/problems/lru-cache/">LRU 缓存</a>。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计并实现一个满足 LRU（最近最少使用）缓存约束的数据结构。实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code>：以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code>：如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code></li><li><code>void put(int key, int value)</code>：如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字 - 值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><span id="more"></span><p>函数 <code>get</code> 和 <code>put</code> 必须以 O (1) 的平均时间复杂度运行。输入 / 输出示例如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 {1=1}</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">大厂面试题</p><p>在大厂的笔试中，有像腾讯、百度直接考原题的，也有像字节跳动那样考变种的题目，比如在 LRU 的基础上要求增加过期时间，过期的 key 要删除掉。实现思路可以参考 Redis 中 Key 的惰性删除。给每个节点增加一个 <code>expire</code> 属性（时间戳），表示节点的过期时间。当创建或更新节点时，基于当前时间加上设定的生存时间（TTL）计算得到时间戳。当尝试获取一个节点时，首先检查该节点是否存在，然后判断它的 <code>expire</code> 属性是否小于当前时间（即节点是否已经过期）。这样，每次访问节点时只会检查该节点，而不需要轮询所有节点。</p></div><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><ul><li>LRU 算法可以使用双向链表实现，也就是在各个 Node 节点之间增加 <code>prev</code> 指针和 <code>next</code> 指针，以此构成双向链表。将新增或者访问到的节点移动到链表的头部，超出容量时则从链表的尾部删除节点。</li><li>要满足 O (1) 时间复杂度，可以使用 HaspMap，里面储存的是 key 与链表节点，这样可以快速查找节点，然后将它删除或者移动到链表的头部。</li><li>LRU 的算法核心是哈希链表，本质就是哈希表 + 双向链表的结合体 (HashMap + DoubleLinkedList)，时间复杂度是 O (1)，底层的数据结构如下图所示：</li></ul><p><img data-src="../../../asset/2024/04/algorithm-lru-cache-1.png"></p><ul><li>下面这幅动图完美诠释了 HashMap + DoubleLinkedList 的工作原理，其中 <code>key2</code> 是最近访问的数据（可以将其移动到双向链表的尾部或者头部）。</li></ul><p><img data-src="../../../asset/2024/04/algorithm-lru-cache-2.gif"></p><h2 id="题目答案"><a href="#题目答案" class="headerlink" title="题目答案"></a>题目答案</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于哈希表（HashMap） + 双向链表（DoubleLinkedList）实现 LRU 缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&lt;Integer, Integer&gt;&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleLinkedList&lt;Integer, Integer&gt; doubleLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache2</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PUT操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最近使用到的节点移动到链表的头部</span></span><br><span class="line">        Node&lt;Integer, Integer&gt; node = map.get(key);</span><br><span class="line">        doubleLinkedList.remove(node);</span><br><span class="line">        doubleLinkedList.addHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) {</span><br><span class="line">            <span class="comment">// 更新节点的值，并将最近使用到的节点移动到链表的头部</span></span><br><span class="line">            Node&lt;Integer, Integer&gt; node = map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            doubleLinkedList.remove(node);</span><br><span class="line">            doubleLinkedList.addHead(node);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 位置满了，删除数据</span></span><br><span class="line">            <span class="keyword">if</span> (map.size() == <span class="keyword">this</span>.cacheSize) {</span><br><span class="line">                Node&lt;Integer, Integer&gt; lastNode = doubleLinkedList.getLast();</span><br><span class="line">                doubleLinkedList.remove(lastNode);</span><br><span class="line">                map.remove(lastNode.key);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 插入新的节点</span></span><br><span class="line">            Node&lt;Integer, Integer&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">            doubleLinkedList.addHead(newNode);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K, V&gt; prev;    <span class="comment">// 前驱节点</span></span><br><span class="line">        Node&lt;K, V&gt; next;    <span class="comment">// 后驱节点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚拟的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">        Node&lt;K, V&gt; head;    <span class="comment">// 头节点</span></span><br><span class="line">        Node&lt;K, V&gt; tail;    <span class="comment">// 尾节点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">            <span class="comment">// 初始状态是头尾相连</span></span><br><span class="line">            <span class="keyword">this</span>.head.next = tail;</span><br><span class="line">            <span class="keyword">this</span>.tail.prev = head;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加到头部</span></span><br><span class="line"><span class="comment">         * &lt;p&gt; 将最近使用到的节点移动到链表的头部</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>{</span><br><span class="line">            node.prev = <span class="keyword">this</span>.head;</span><br><span class="line">            node.next = <span class="keyword">this</span>.head.next;</span><br><span class="line">            <span class="keyword">this</span>.head.next.prev = node;</span><br><span class="line">            <span class="keyword">this</span>.head.next = node;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>{</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">            <span class="comment">// GC</span></span><br><span class="line">            node.prev = <span class="keyword">null</span>;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取最后一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node&lt;K, V&gt; <span class="title">getLast</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.tail.prev;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>单元测试代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        LRUCache2 lruCache = <span class="keyword">new</span> LRUCache2(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        lruCache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lruCache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lruCache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(lruCache.map.keySet());</span><br><span class="line"></span><br><span class="line">        lruCache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(lruCache.map.keySet());</span><br><span class="line"></span><br><span class="line">        lruCache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(lruCache.map.keySet());</span><br><span class="line">        lruCache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(lruCache.map.keySet());</span><br><span class="line">        lruCache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(lruCache.map.keySet());</span><br><span class="line">        lruCache.put(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(lruCache.map.keySet());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3]</span><br><span class="line">[2, 3, 4]</span><br><span class="line">[2, 3, 4]</span><br><span class="line">[2, 3, 4]</span><br><span class="line">[2, 3, 4]</span><br><span class="line">[3, 4, 5]</span><br></pre></td></tr></tbody></table></figure><p>在上述单元测试的输出结果中，Key 的打印顺序是有误的（但 LRU 算法的实现是正确的），因为这是 HashMap 中 Key 的顺序（HashMap 是无序的），并不是 DoubleLinkedList 中 Key 的顺序，但至少可以说明最近最少使用的数据已经被删除了。</p>]]></content>
    
    
    <summary type="html">本文主要记录刷过的 LeetCode 算法题。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="缓存" scheme="https://www.techgrow.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="算法" scheme="https://www.techgrow.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
