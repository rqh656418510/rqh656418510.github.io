<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay 的技术博客</title>
  
  <subtitle>用进废退 | 艺不压身</subtitle>
  <link href="https://www.techgrow.cn/atom.xml" rel="self"/>
  
  <link href="https://www.techgrow.cn/"/>
  <updated>2021-12-15T13:13:21.000Z</updated>
  <id>https://www.techgrow.cn/</id>
  
  <author>
    <name>Clay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 屏幕截图和图片粘贴</title>
    <link href="https://www.techgrow.cn/posts/9eb6789a.html"/>
    <id>https://www.techgrow.cn/posts/9eb6789a.html</id>
    <published>2021-12-15T13:13:21.000Z</published>
    <updated>2021-12-15T13:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><ul><li><code>xclip</code>：0.13</li><li><code>gnome-screenshot</code>：3.26.0</li></ul><h3 id="xclip-简介"><a href="#xclip-简介" class="headerlink" title="xclip 简介"></a>xclip 简介</h3><p><a href="https://github.com/astrand/xclip">xclip</a> 是一个剪贴板的命令行实用工具，它可以从标准文件或文件中读取数据（文本、图片）并将其放置在剪贴板里，也可以将剪贴板里的数据（文本、图片）输出到标准文件或文件中，适用于 Debian/Ubuntu/CentOS/Arch 等主流的 Linux 发行版。</p><h3 id="xclip-功能说明"><a href="#xclip-功能说明" class="headerlink" title="xclip 功能说明"></a>xclip 功能说明</h3><ul><li>Accesses the <code>cut-buffers</code></li><li>Prints contents of selection to standard out</li><li>Waits for selection requests in the background</li><li>Supports the INCR mechanism for large transfers</li><li>Reads data piped to standard in or files given as arguments</li><li>Accesses the <code>XA_PRIMARY</code>, <code>XA_SECONDARY</code> or <code>XA_CLIPBOARD</code> selection</li><li>Connects to the X display in <code>$DISPLAY</code>, or specified with <code>-display host:0</code></li></ul><span id="more"></span><h2 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h2><p><code>gnome-screenshot</code> 是一款 GNOME 命令行工具，它是一款用来对整个屏幕、一个特定的窗口或者用户所定义一些其他区域进行捕获的工具。该工具提供了几个其他的功能，包括对所捕获的截图的边界进行美化的功能，不适用于 <code>KDE</code>、<code>Xfce</code> 等 Linux 桌面环境。</p><h3 id="截图工具的使用"><a href="#截图工具的使用" class="headerlink" title="截图工具的使用"></a>截图工具的使用</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 捕捉整个屏幕</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕捉当前Shell窗口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -w</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕捉指定区域</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 延迟捕捉屏幕</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -d 5</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕捉当前Shell窗口，并去除窗口的边框</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -w -b</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 区域截图，并将截图复制到剪贴板</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -acbp</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 区域截图，并将截图输出到指定的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -abpf screenshot.png</span></span><br></pre></td></tr></tbody></table></figure><h3 id="截图工具的参数说明"><a href="#截图工具的参数说明" class="headerlink" title="截图工具的参数说明"></a>截图工具的参数说明</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-c, --clipboard              将截图直接发送到剪贴板</span><br><span class="line">-w, --window                 截取窗口，而不是整个屏幕</span><br><span class="line">-a, --area                   截取屏幕的一个区域，而不是整个屏幕</span><br><span class="line">-b, --include-border         在截图中包含窗口边框</span><br><span class="line">-B, --remove-border          去除屏幕截图的窗口边框</span><br><span class="line">-p, --include-pointer        在截图中包含鼠标指针</span><br><span class="line">-d, --delay=秒               在指定延迟后截图[以秒计]</span><br><span class="line">-e, --border-effect=特效     添加到边框的特效（阴影、边框、老照片或无特效）</span><br><span class="line">-i, --interactive            交互设置选项</span><br><span class="line">-f, --file=文件名            将截图直接保存为该文件</span><br><span class="line">--version                    打印版本信息并退出</span><br><span class="line">--display=显示               要使用的 X 显示</span><br></pre></td></tr></tbody></table></figure><h2 id="xclip-的安装"><a href="#xclip-的安装" class="headerlink" title="xclip 的安装"></a>xclip 的安装</h2><h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><p><strong>CentOS</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y libXmu libXmu-devel</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Debian/Ubuntu</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> apt-get install -y libx11-dev libxmu-headers libxt-dev libxmu-dev</span></span><br></pre></td></tr></tbody></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/astrand/xclip.git</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入源码目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> xclip</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 预配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> autoreconf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install.man</span></span><br></pre></td></tr></tbody></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -version</span></span><br><span class="line">xclip version 0.13</span><br><span class="line">Copyright (C) 2001-2008 Kim Saunders et al.</span><br><span class="line">Distributed under the terms of the GNU GPL</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看命令手册</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man xclip</span></span><br></pre></td></tr></tbody></table></figure><h2 id="xclip-的使用示例"><a href="#xclip-的使用示例" class="headerlink" title="xclip 的使用示例"></a>xclip 的使用示例</h2><h3 id="图片的使用示例"><a href="#图片的使用示例" class="headerlink" title="图片的使用示例"></a>图片的使用示例</h3><ul><li>将图片复制到剪贴板 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一步：区域截图，将截图输出到指定的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -abpf screenshot.png</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步：将指定的图片复制到剪贴板</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection clipboard -t image/png -i screenshot.png</span></span><br></pre></td></tr></tbody></table></figure><ul><li>将剪贴板的图片输出到指定的文件 </li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一步：区域截图，并将截图复制到剪贴板</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gnome-screenshot -acbp</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步：将剪贴板的图片输出到指定的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection clipboard -t image/png -o &gt; clipboard.png</span></span><br></pre></td></tr></tbody></table></figure><h3 id="完整的使用示例"><a href="#完整的使用示例" class="headerlink" title="完整的使用示例"></a>完整的使用示例</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Copy your uptime into the selection for pasting:</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> uptime | xclip</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Copy your password file for pasting:</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip /etc/passwd</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Save some text you have Edit | Copied in a web browser:</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -o -sel clip &gt; webpage.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Open a URL selected in an email client</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mozilla `xclip -o`</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Copy XA_PRIMARY to XA_CLIPBOARD</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -o | xclip -sel clip</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># In command mode in vim, select some lines of text, then press shift-:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># for an ex prompt, and use this command to copy the selected lines of</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># text to the primary X selection:</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> !xclip -f</span></span><br></pre></td></tr></tbody></table></figure><p>值得一提的是，<code>xclip</code> 自身还提供了 <code>xclip-copyfile</code>、<code>xclip-pastefile</code>、<code>xclip-cutfile</code> 命令行工具，支持在不同的目录和机器之间拷贝和移动文件，详见：<a href="https://github.com/astrand/xclip/blob/master/README">官方文档</a></p><h2 id="VS-Code-使用说明"><a href="#VS-Code-使用说明" class="headerlink" title="VS Code 使用说明"></a>VS Code 使用说明</h2><p>在 Linux 系统下，VS Code 的 MarkDown 插件 <a href="https://github.com/telesoho/vscode-markdown-paste-image">Markdown Paste</a> 底层使用了 <code>xclip</code>，且版本必须大于等于 <code>0.13.0</code>，否则这类插件无法正常粘贴剪贴板里的图片到 MarkDown 文件里。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://unix.stackexchange.com/questions/145131/copy-image-from-clipboard-to-file">Copy image from clipboard to file</a></li><li><a href="https://askubuntu.com/questions/1196914/gnome-screenshot-cant-copy-to-clipboard-in-ubuntu-18-04">GNOME Screenshot can’t copy to clipboard in Ubuntu 18.04</a></li><li><a href="https://superuser.com/questions/199285/how-to-copy-image-to-clipboard-to-paste-to-another-application/1098582#1098582">How to copy image to clipboard, to paste to another application</a></li><li><a href="https://askubuntu.com/questions/759651/how-to-copy-an-image-to-the-clipboard-from-a-file-using-command-line">How to copy an image to the clipboard from a file using command line</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Linux 如何安装 xclip, 并结合 gnome-screenshot 实现屏幕截图、图片粘贴、剪贴板粘贴等功能。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++ 设计模式初探</title>
    <link href="https://www.techgrow.cn/posts/790d6d80.html"/>
    <id>https://www.techgrow.cn/posts/790d6d80.html</id>
    <published>2021-12-13T13:55:33.000Z</published>
    <updated>2021-12-13T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 常用的设计模式，包括单例模式等。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 开发常用代码块之一</title>
    <link href="https://www.techgrow.cn/posts/b84a96ac.html"/>
    <id>https://www.techgrow.cn/posts/b84a96ac.html</id>
    <published>2021-12-12T13:43:49.000Z</published>
    <updated>2021-12-12T13:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h2><h3 id="格式化当前时间"><a href="#格式化当前时间" class="headerlink" title="格式化当前时间"></a>格式化当前时间</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化当前时间</span></span><br><span class="line"><span class="comment">// 默认格式是: 2020-06-07 23:46:53</span></span><br><span class="line"><span class="function">string <span class="title">formatCurrentTime</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">time_t</span> rawtime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">time</span>(&amp;rawtime);</span><br><span class="line">info = <span class="built_in">localtime</span>(&amp;rawtime);</span><br><span class="line"><span class="built_in">strftime</span>(buffer, <span class="number">80</span>, <span class="string">"%Y-%m-%d %H:%M:%S"</span>, info);</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化当前时间</span></span><br><span class="line"><span class="comment">// format: 格式字符串，例如 %Y-%m-%d %H:%M:%S</span></span><br><span class="line"><span class="function">string <span class="title">formatCurrentTime</span><span class="params">(string format)</span> </span>{</span><br><span class="line"><span class="keyword">time_t</span> rawtime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">time</span>(&amp;rawtime);</span><br><span class="line">info = <span class="built_in">localtime</span>(&amp;rawtime);</span><br><span class="line"><span class="built_in">strftime</span>(buffer, <span class="number">80</span>, format.<span class="built_in">c_str</span>(), info);</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; formatCurrentTime() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; formatCurrentTime(<span class="string">"%Y-%m-%d"</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-11-22 22:52:43</span><br><span class="line">2021-11-22</span><br></pre></td></tr></tbody></table></figure><h3 id="计算两个日期之间的天数"><a href="#计算两个日期之间的天数" class="headerlink" title="计算两个日期之间的天数"></a>计算两个日期之间的天数</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个年份是否为闰年</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算特定年份的天数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysOfYear</span><span class="params">(<span class="keyword">int</span> year)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">isLeap</span>(year) ? <span class="number">366</span> : <span class="number">365</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定的日期，计算它在该年的第几天</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dayInYear</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> DAY[<span class="number">12</span>] = { <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> };</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLeap</span>(year)) {</span><br><span class="line">DAY[<span class="number">1</span>] = <span class="number">29</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; month - <span class="number">1</span>; ++i) {</span><br><span class="line">day += DAY[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> day;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断日期字符串是否合法，并分别取出日期中的年月日</span></span><br><span class="line"><span class="comment">// date: 日期字符串，格式是: 20211201</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stringToDate</span><span class="params">(string date, <span class="keyword">int</span>&amp; year, <span class="keyword">int</span>&amp; month, <span class="keyword">int</span>&amp; day)</span> </span>{</span><br><span class="line">year = <span class="built_in">atoi</span>(date.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">4</span>).<span class="built_in">c_str</span>());</span><br><span class="line">month = <span class="built_in">atoi</span>(date.<span class="built_in">substr</span>(<span class="number">4</span>, <span class="number">2</span>).<span class="built_in">c_str</span>());</span><br><span class="line">day = <span class="built_in">atoi</span>(date.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">2</span>).<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">int</span> DAY[<span class="number">12</span>] = { <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> };</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLeap</span>(year)) {</span><br><span class="line">DAY[<span class="number">1</span>] = <span class="number">29</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> year &gt;= <span class="number">0</span> &amp;&amp; month &lt;= <span class="number">12</span> &amp;&amp; month &gt; <span class="number">0</span> &amp;&amp; day &lt;= DAY[month - <span class="number">1</span>] &amp;&amp; day &gt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个日期之间的天数</span></span><br><span class="line"><span class="comment">// date1: 日期字符串，格式是: 20211201</span></span><br><span class="line"><span class="comment">// date2: 日期字符串，格式是: 20211201</span></span><br><span class="line"><span class="comment">// 当返回值为 -1 时，说明日期的格式不正确</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysBetween2Date</span><span class="params">(string date1, string date2)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> year1, month1, day1;</span><br><span class="line"><span class="keyword">int</span> year2, month2, day2;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">stringToDate</span>(date1, year1, month1, day1) || !<span class="built_in">stringToDate</span>(date2, year2, month2, day2)) {</span><br><span class="line">cout &lt;&lt; <span class="string">"输入的日期格式不正确"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (year1 == year2 &amp;&amp; month1 == month2) {</span><br><span class="line"><span class="keyword">return</span> day1 &gt; day2 ? day1 - day2 : day2 - day1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (year1 == year2) {</span><br><span class="line"><span class="keyword">int</span> d1, d2;</span><br><span class="line">d1 = <span class="built_in">dayInYear</span>(year1, month1, day1);</span><br><span class="line">d2 = <span class="built_in">dayInYear</span>(year2, month2, day2);</span><br><span class="line"><span class="keyword">return</span> d1 &gt; d2 ? d1 - d2 : d2 - d1;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="comment">// 确保year1年份比year2早</span></span><br><span class="line"><span class="keyword">if</span> (year1 &gt; year2) {</span><br><span class="line"><span class="built_in">swap</span>(year1, year2);</span><br><span class="line"><span class="built_in">swap</span>(month1, month2);</span><br><span class="line"><span class="built_in">swap</span>(day1, day2);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 计算第一个日期在该年还剩多少天</span></span><br><span class="line"><span class="keyword">int</span> d1, d2, d3;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLeap</span>(year1)) {</span><br><span class="line">d1 = <span class="number">366</span> - <span class="built_in">dayInYear</span>(year1, month1, day1);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">d1 = <span class="number">365</span> - <span class="built_in">dayInYear</span>(year1, month1, day1);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 计算第二日期在当年中的第几天</span></span><br><span class="line">d2 = <span class="built_in">dayInYear</span>(year2, month2, day2);</span><br><span class="line"><span class="comment">// 计算两个年份相隔的天数</span></span><br><span class="line">d3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> year = year1 + <span class="number">1</span>; year &lt; year2; year++) {</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLeap</span>(year))</span><br><span class="line">d3 += <span class="number">366</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">d3 += <span class="number">365</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> d1 + d2 + d3;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days = <span class="built_in">daysBetween2Date</span>(<span class="string">"20101111"</span>, <span class="string">"20111111"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"相差 "</span> &lt;&lt; days &lt;&lt; <span class="string">" 天"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days2 = <span class="built_in">daysBetween2Date</span>(<span class="string">"20200202"</span>, <span class="string">"20200131"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"相差 "</span> &lt;&lt; days2 &lt;&lt; <span class="string">" 天"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days3 = <span class="built_in">daysBetween2Date</span>(<span class="string">"20230712"</span>, <span class="string">"20050619"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"相差 "</span> &lt;&lt; days3 &lt;&lt; <span class="string">" 天"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相差 365 天</span><br><span class="line">相差 2 天</span><br><span class="line">相差 6597 天</span><br></pre></td></tr></tbody></table></figure><h2 id="加载动态库"><a href="#加载动态库" class="headerlink" title="加载动态库"></a>加载动态库</h2><h3 id="加载动态库（-so）"><a href="#加载动态库（-so）" class="headerlink" title="加载动态库（.so）"></a>加载动态库（.so）</h3><p>下述示例代码，适用于 Linux 系统的 C++ 开发。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载动态库</span></span><br><span class="line">    <span class="keyword">void</span> *handle = <span class="built_in">dlopen</span>(<span class="string">"./libadd_c.so"</span>, RTLD_LAZY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!handle)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open lib error\n"</span>);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">dlerror</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">add_t</span>)</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用动态库</span></span><br><span class="line">    <span class="keyword">add_t</span> add = (<span class="keyword">add_t</span>) <span class="built_in">dlsym</span>(handle, <span class="string">"add"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!add)</span><br><span class="line">    {</span><br><span class="line">        cout&lt;&lt;<span class="built_in">dlerror</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">dlclose</span>(handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    a = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态库</span></span><br><span class="line">    <span class="built_in">dlclose</span>(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="加载动态链接库（-dll）"><a href="#加载动态链接库（-dll）" class="headerlink" title="加载动态链接库（.dll）"></a>加载动态链接库（.dll）</h3><p>下述示例代码，适用于 Windows 系统的 C++ 开发。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">HINSTANCE hInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载动态链接库</span></span><br><span class="line">hInstance = <span class="built_in">LoadLibrary</span>(<span class="string">"./socketclient.dll"</span>);</span><br><span class="line"><span class="keyword">if</span> (hInstance == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"LoadLibrary() 调用失败, ErrorCode: %d"</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数类型指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*CltSocketInit)</span><span class="params">(<span class="keyword">void</span>** handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用动态链接库</span></span><br><span class="line">CltSocketInit cltSocketInit = (CltSocketInit)<span class="built_in">GetProcAddress</span>(hInstance, <span class="string">"cltSocketInit"</span>);</span><br><span class="line"><span class="keyword">if</span> (cltSocketInit != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">void</span>* handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in">cltSocketInit</span>(&amp;handle);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"result = %d"</span>, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放动态链接库</span></span><br><span class="line"><span class="keyword">if</span> (hInstance != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hInstance);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>基于 C++ 11 实现等价于 Javascript 的 <code>setTimeout()</code> 和 <code>setInterval()</code> 函数。</p><ul><li>timer.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(TimerFunction)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(TimerFunction, <span class="keyword">long</span> delay)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInterval</span><span class="params">(TimerFunction, <span class="keyword">long</span> interval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">atomic&lt;<span class="keyword">bool</span>&gt; active{ <span class="literal">true</span> };</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer::setTimeout</span><span class="params">(TimerFunction function, <span class="keyword">long</span> delay)</span> </span>{</span><br><span class="line">active = <span class="literal">true</span>;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([=]() {</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (!active.load()) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">this_thread::sleep_for(chrono::milliseconds(delay));</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (!active.load()) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">function();</span></span></span><br><span class="line"><span class="params"><span class="function">})</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer::setInterval</span><span class="params">(TimerFunction function, <span class="keyword">long</span> interval)</span> </span>{</span><br><span class="line">active = <span class="literal">true</span>;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([=]() {</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (active.load()) {</span></span></span><br><span class="line"><span class="params"><span class="function">this_thread::sleep_for(chrono::milliseconds(interval));</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (!active.load()) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">function();</span></span></span><br><span class="line"><span class="params"><span class="function">}</span></span></span><br><span class="line"><span class="params"><span class="function">})</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer::stop</span><span class="params">()</span> </span>{</span><br><span class="line">active = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"timer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refreshConfig</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"execute refresh config ..."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 使用智能指针</span></span><br><span class="line"><span class="function">unique_ptr&lt;Timer&gt; <span class="title">timer</span><span class="params">(<span class="keyword">new</span> Timer())</span></span>;</span><br><span class="line">Timer::TimerFunction* refreshFunc = refreshConfig;</span><br><span class="line">timer-&gt;<span class="built_in">setInterval</span>(refreshConfig, <span class="number">3000</span>);</span><br><span class="line">timer-&gt;<span class="built_in">setTimeout</span>(refreshConfig, <span class="number">5000</span>);</span><br><span class="line">_getch();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execute refresh config ...</span><br><span class="line">execute refresh config ...</span><br><span class="line">execute refresh config ...</span><br><span class="line">execute refresh config ...</span><br><span class="line">execute refresh config ...</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要记录 C++ 开发常用的代码块。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
    <category term="代码块" scheme="https://www.techgrow.cn/tags/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之四</title>
    <link href="https://www.techgrow.cn/posts/791ffdcd.html"/>
    <id>https://www.techgrow.cn/posts/791ffdcd.html</id>
    <published>2021-12-08T13:55:33.000Z</published>
    <updated>2021-12-08T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="标准-I-O-流的介绍"><a href="#标准-I-O-流的介绍" class="headerlink" title="标准 I/O 流的介绍"></a>标准 I/O 流的介绍</h2><h3 id="I-O-流的概念"><a href="#I-O-流的概念" class="headerlink" title="I/O 流的概念"></a>I/O 流的概念</h3><p>程序的输入指的是从输入文件将数据传送给程序，程序的输出指的是从程序将数据传送给输出文件。C++ 的输入输出包含以下三个方面的内容：</p><ul><li><code>对系统指定的标准设备的输入和输出</code>：即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称 <code>标准 I/O</code>。</li><li><code>以外存磁盘文件为对象进行输入和输出</code>：即从磁盘文件输入数据，数据输出到磁盘文件。以外存文件为对象的输入输出称为文件的输入输出，简称 <code>文件 I/O</code>。</li><li><code>对内存中指定的空间进行输入和输出</code>：通常指定一个字符数组作为存储空间（实际上可以利用该内存空间存储任何信息）。这种输入和输出称为字符串输入输出，简称 <code>串 I/O</code>。</li></ul><h3 id="I-O-流类库的结构"><a href="#I-O-流类库的结构" class="headerlink" title="I/O 流类库的结构"></a>I/O 流类库的结构</h3><p>在 C 语言中，用 <code>printf</code> 和 <code>scanf</code> 进行输入输出，往往不能保证所输入输出的数据是可靠的安全的。在 C++ 的输入输出中，编译系统对数据类型进行严格的检查，凡是类型不正确的数据都不可能通过编译。因此 C++ 的 I/O 操作是类型安全（Type Safe）的。C++ 的 I/O 操作是可扩展的，不仅可以用来输入输出标准类型的数据，也可以用于用户自定义类型的数据。C++ 通过 I/O 类库来实现丰富的 I/O 功能。这样使 C++ 的输人输出明显地优于 C 语言中的 <code>printf</code> 和 <code>scanf</code>，但是也为之付出了代价，C++ 的 I/O 系统因此变得比较复杂，要掌握许多使用细节。C++ 编译系统提供了用于输入输出的 <code>iostream</code> 类库。<code>iostream</code> 这个单词是由 3 个部分组成的，即 <code>i-o-stream</code>，意为输入输出流。在 <code>iostream</code> 类库中包含许多用于输入输出的类，如下图所示：</p><span id="more"></span><p><img data-src="../../../asset/2021/12/cplus-plus-io-1.png" alt="cplus-plus-io-1"></p><p><code>ios</code> 是抽象基类，由它派生出 <code>istream</code> 类和 <code>ostream</code> 类，两个类名中第 1 个字母 i 和 o 分别代表输入（input）和输出（output）。<code>istream</code> 类支持输入操作，<code>ostream</code> 类支持输出操作，<code>iostream</code> 类支持输入输出操作。<code>iostream</code> 类是从 <code>istream</code> 类和 <code>ostream</code> 类通过多重继承而派生的类，其继承层次如下图所示：</p><p><img data-src="../../../asset/2021/12/cplus-plus-io-2.png" alt="cplus-plus-io-2"></p><p><code>iostream</code> 类库中不同的类的声明被放在不同的头文件中，用户在自己的程序中用 <code>#include</code> 命令包含了有关的头文件，这就相当于在本程序中声明了所需要用到的类。可以换 — 种说法：头文件是程序与类库的接口。<code>iostream</code> 类库的接口分别由不同的头文件来实现，常用的头文件如下：</p><ul><li><code>strstream</code>：用于字符串流 I/O</li><li><code>fstream</code>：用于实现文件的 I/O 操作</li><li><code>iomanip</code>：在使用格式化 I/O 时，应包含此头文件</li><li><code>iostream</code>：包含了对输入输出流进行操作所需的基本信息</li><li><code>stdiostream</code>：用于混合使用 C 语言和 C++ 的 I/O 机制，例如希望将 C 语言程序转变为 C++ 程序</li></ul><p>在 <code>iostream</code> 头文件中定义的类有 <code>ios，istream，ostream，iostream，istream_withassign，ostream_withassign，iostream_withassign</code> 等。在 <code>iostream</code> 头文件中不仅定义了相关的类，还定义了 4 种标准 I/O 对象，如下所示：</p><p><img data-src="../../../asset/2021/12/cplus-plus-io-3.png" alt="cplus-plus-io-3"></p><p><code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 本来在 C++ 中是被定义为左位移运算符和右位移运算符的，由于在 <code>iostream</code> 头文件中对它们进行了重载，使它们能用作标准类型数据的输入和输出运算符。所以，在使用到它们的程序中必须用 <code>#include &lt;iostream&gt;</code> 命令将其包含到程序中。在 <code>iostream</code> 中只对 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出进行重载。如果用户声明了新的类型，并希望用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符对其进行输入输出，则需要按照 C++ 的运算符重载规则来做。</p><h2 id="标准-I-O-流的使用"><a href="#标准-I-O-流的使用" class="headerlink" title="标准 I/O 流的使用"></a>标准 I/O 流的使用</h2><h3 id="标准输入流的简单使用"><a href="#标准输入流的简单使用" class="headerlink" title="标准输入流的简单使用"></a>标准输入流的简单使用</h3><p>标准输入流对象 <code>cin</code> 的常用函数如下：</p><ul><li><code>cin.get()</code>，一次只能读取一个字符</li><li><code>cin.get(一个参数)</code>，读一个字符</li><li><code>cin.get(多个参数)</code>，可以读字符串</li><li><code>cin.getline()</code>，读取整行字符串，包括读取空格字符</li><li><code>cin.ignore()</code>，用于忽略或清除输入缓冲区中的一个或多个字符</li><li><code>cin.putback()</code>，将数据放回缓冲区</li><li><code>cin.peek()</code>，返回值是一个 <code>char</code> 型的字符，即指针指向的当前字符，但它只是观测指针停留在当前的位置并不后移；如果要访问的字符是文件结束符，则函数的返回值是 <code>EOF</code> 或者 <code>-1</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input1</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入一个数字: "</span>;</span><br><span class="line">cin &gt;&gt; number;</span><br><span class="line">cout &lt;&lt; <span class="string">"输入的数字是: "</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input2</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串: "</span>;</span><br><span class="line">cin &gt;&gt; buf;<span class="comment">// 当遇到空格符时，会停止接收数据输入</span></span><br><span class="line">cout &lt;&lt; <span class="string">"输入的字符串: "</span>;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input3</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串: "</span>;</span><br><span class="line"><span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)<span class="comment">// 如果缓冲区没有数据，则程序会阻塞</span></span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input4</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> a, b, c;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串: "</span>;</span><br><span class="line">cin.<span class="built_in">get</span>(a);<span class="comment">// 如果缓冲区没有数据，则程序会阻塞</span></span><br><span class="line">cin.<span class="built_in">get</span>(b);</span><br><span class="line">cin.<span class="built_in">get</span>(c);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input5</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串: "</span>;</span><br><span class="line">cin.<span class="built_in">getline</span>(buf, <span class="number">256</span>);<span class="comment">// 当遇到空格符时，不会停止接收数据输入</span></span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input6</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> buf1[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">256</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串:"</span>;  <span class="comment">// 例如输入：abc  efghi</span></span><br><span class="line">cin &gt;&gt; buf1;</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">2</span>);<span class="comment">// 忽略缓冲区的数据</span></span><br><span class="line">cin.<span class="built_in">getline</span>(buf2, <span class="number">256</span>);</span><br><span class="line">cout &lt;&lt; buf1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input7</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> buf1[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">256</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入字符串:"</span>;  <span class="comment">// 例如输入：abc  efghi</span></span><br><span class="line">cin &gt;&gt; buf1;</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> num = cin.<span class="built_in">peek</span>();<span class="comment">// 查看缓冲区是否有数据</span></span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">cin.<span class="built_in">getline</span>(buf2, <span class="number">256</span>);</span><br><span class="line">cout &lt;&lt; buf1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input8</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 分开处理输入的整数和字符</span></span><br><span class="line">cout &lt;&lt; <span class="string">"Please, enter a number or a word: "</span>;</span><br><span class="line"><span class="keyword">char</span> c = std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((c &gt;= <span class="string">'0'</span>) &amp;&amp; (c &lt;= <span class="string">'9'</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin.<span class="built_in">putback</span>(c);<span class="comment">// 将数据放回缓冲区</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="string">"You entered a number: "</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">cin.<span class="built_in">putback</span>(c);<span class="comment">// 将数据放回缓冲区</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch);</span><br><span class="line">cout &lt;&lt; <span class="string">"You entered a character: "</span> &lt;&lt; ch &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="标准输出流的简单使用"><a href="#标准输出流的简单使用" class="headerlink" title="标准输出流的简单使用"></a>标准输出流的简单使用</h3><p>标准输出流对象 <code>cout</code> 的常用函数如下：</p><ul><li><code>cout.flush()</code></li><li><code>cout.put()</code></li><li><code>cout.write()</code></li><li><code>cout.width()</code></li><li><code>cout.fill()</code></li><li><code>cout.setf()</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output1</span><span class="params">()</span> </span>{</span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">'h'</span>).<span class="built_in">put</span>(<span class="string">'e'</span>).<span class="built_in">put</span>(<span class="string">'l'</span>).<span class="built_in">put</span>(<span class="string">'l'</span>).<span class="built_in">put</span>(<span class="string">'o'</span>).<span class="built_in">put</span>(<span class="string">'\n'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output2</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"hello world\n"</span>;</span><br><span class="line">cout.<span class="built_in">write</span>(str, <span class="built_in">strlen</span>(str));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output3</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 使用流对象的成员函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"&lt;Start&gt;"</span>;</span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">30</span>);</span><br><span class="line">cout.<span class="built_in">fill</span>(<span class="string">'*'</span>);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::showbase);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::internal);</span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">"&lt;End&gt;\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output4</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 使用控制符</span></span><br><span class="line">cout &lt;&lt; <span class="string">"&lt;Start&gt;"</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">30</span>)</span><br><span class="line">&lt;&lt; <span class="built_in">setfill</span>(<span class="string">'*'</span>)</span><br><span class="line">&lt;&lt; <span class="built_in">setiosflags</span>(ios::showbase)</span><br><span class="line">&lt;&lt; <span class="built_in">setiosflags</span>(ios::internal)</span><br><span class="line">&lt;&lt; hex</span><br><span class="line">&lt;&lt; <span class="number">123</span></span><br><span class="line">&lt;&lt; <span class="string">"&lt;End&gt;\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="built_in">output1</span>();</span><br><span class="line"><span class="built_in">output2</span>();</span><br><span class="line"><span class="built_in">output3</span>();</span><br><span class="line"><span class="built_in">output4</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello world</span><br><span class="line">&lt;Start&gt;0x**************************7b&lt;End&gt;</span><br><span class="line">&lt;Start&gt;0x**************************7b&lt;End&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="文件-I-O-流的简单使用"><a href="#文件-I-O-流的简单使用" class="headerlink" title="文件 I/O 流的简单使用"></a>文件 I/O 流的简单使用</h3><h4 id="以普通的方式读写文件"><a href="#以普通的方式读写文件" class="headerlink" title="以普通的方式读写文件"></a>以普通的方式读写文件</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="keyword">char</span>* fname = <span class="string">"D:/file.txt"</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(fname)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (fout) {</span><br><span class="line">fout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl;</span><br><span class="line">fout.<span class="built_in">flush</span>();</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">char</span>* fname = <span class="string">"D:/file.txt"</span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(fname)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (fin) {</span><br><span class="line"><span class="keyword">while</span> (fin.<span class="built_in">get</span>(ch)) {</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">}</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFileApp</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 以追加的方式打开文件</span></span><br><span class="line"><span class="keyword">char</span>* fname = <span class="string">"D:/file.txt"</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(fname, ios::app)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (fout) {</span><br><span class="line">fout &lt;&lt; <span class="string">"What"</span> &lt;&lt; endl;</span><br><span class="line">fout.<span class="built_in">flush</span>();</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="built_in">writeFile</span>();</span><br><span class="line"><span class="built_in">readFile</span>();</span><br><span class="line"><span class="built_in">writeFileApp</span>();</span><br><span class="line"><span class="built_in">readFile</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">What</span><br></pre></td></tr></tbody></table></figure><h4 id="以二进制的方式读写文件"><a href="#以二进制的方式读写文件" class="headerlink" title="以二进制的方式读写文件"></a>以二进制的方式读写文件</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Teacher</span>()</span><br><span class="line">{</span><br><span class="line">age = <span class="number">33</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Teacher</span>(<span class="keyword">int</span> _age, <span class="keyword">char</span>* _name)</span><br><span class="line">{</span><br><span class="line">age = _age;</span><br><span class="line"><span class="built_in">strcpy</span>(name, _name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"age:"</span> &lt;&lt; age &lt;&lt; <span class="string">", name:"</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span>age;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span>* fname = <span class="string">"D:/file.dat"</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(fname, ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!fout) {</span><br><span class="line">cout &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将类对象写入二进制文件（序列化）</span></span><br><span class="line"><span class="function">Teacher <span class="title">t1</span><span class="params">(<span class="number">23</span>, <span class="string">"Jim"</span>)</span></span>;</span><br><span class="line"><span class="function">Teacher <span class="title">t2</span><span class="params">(<span class="number">26</span>, <span class="string">"Tom"</span>)</span></span>;</span><br><span class="line">fout.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;t1, <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">fout.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;t2, <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">fout.<span class="built_in">flush</span>();</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(fname)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!fin) {</span><br><span class="line">cout &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从二进制文件读取类对象（反序列化）</span></span><br><span class="line">Teacher tmp;</span><br><span class="line">fin.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">tmp.<span class="built_in">print</span>();</span><br><span class="line">fin.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">tmp.<span class="built_in">print</span>();</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age:23, name:Jim</span><br><span class="line">age:23, name:Jim</span><br></pre></td></tr></tbody></table></figure><h2 id="C-集合类的使用"><a href="#C-集合类的使用" class="headerlink" title="C++ 集合类的使用"></a>C++ 集合类的使用</h2><h3 id="Map-的常用操作"><a href="#Map-的常用操作" class="headerlink" title="Map 的常用操作"></a>Map 的常用操作</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 定义Map集合变量</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种数据插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 第二种数据插入方式（推荐）</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// 第三种数据插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// 第四种数据插入方式</span></span><br><span class="line">m[<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方式遍历Map集合</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" , "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式遍历Map集合</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" , value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定的Key</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator item = m.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; item-&gt;first &lt;&lt; <span class="string">" , value = "</span> &lt;&lt; item-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方式判断Key是否存在</span></span><br><span class="line"><span class="comment">// 如果Key存在，find()函数会返回Key对应的迭代器，如果Key不存在，find()函数会返回尾后迭代器end()</span></span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">find</span>(<span class="number">100</span>) == m.<span class="built_in">end</span>()) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key "</span> &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">" not exist"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式判断Key是否存在</span></span><br><span class="line"><span class="comment">// count()函数用于统计Key值在Map中出现的次数，Map的Key是不允许重复的，因此如果Key存在会返回1，不存在会返回0</span></span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">count</span>(<span class="number">5</span>) == <span class="number">1</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key "</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">" existed"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的Key</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" , value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">key = 1 , 2</span><br><span class="line">key = 3 , 4</span><br><span class="line">key = 5 , 6</span><br><span class="line">key = 7 , 8</span><br><span class="line"></span><br><span class="line">key = 1 , value = 2</span><br><span class="line">key = 3 , value = 4</span><br><span class="line">key = 5 , value = 6</span><br><span class="line">key = 7 , value = 8</span><br><span class="line"></span><br><span class="line">key = 5 , value = 6</span><br><span class="line"></span><br><span class="line">key 100 not exist</span><br><span class="line"></span><br><span class="line">key 5 existed</span><br><span class="line"></span><br><span class="line">key = 1 , value = 2</span><br><span class="line">key = 3 , value = 4</span><br><span class="line">key = 5 , value = 6</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括 C++ 集合类、标准输入输出流的使用等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之三</title>
    <link href="https://www.techgrow.cn/posts/35cd91d3.html"/>
    <id>https://www.techgrow.cn/posts/35cd91d3.html</id>
    <published>2021-12-06T13:55:33.000Z</published>
    <updated>2021-12-06T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="类型转换的语法"><a href="#类型转换的语法" class="headerlink" title="类型转换的语法"></a>类型转换的语法</h3><ul><li><p>C 语言风格的强制类型转换（Type Cast）很简单，不管什么类型的转换，语法都是：<code>TYPE b = (TYPE) a</code></p></li><li><p>C++ 风格的类型转换，提供了 4 种类型转换操作符来应对不同场合的应用</p><ul><li><code>const_cast</code>：去除变量的 <code>const</code> 只读属性</li><li><code>reinterpreter_cast</code>：重新解释类型（强制类型转换）</li><li><code>static_cast</code>：静态类型转换，如 <code>int</code> 转换成 <code>char</code></li><li><code>dynamic_cast</code>：动态类型转换，如父类和子类之间的多态类型转换</li></ul></li><li><p> C++ 4 种类型转换的语法：<code>TYPE B = static_cast&lt;TYPE&gt; (a)</code></p></li></ul><span id="more"></span><h3 id="类型转换的一般性介绍"><a href="#类型转换的一般性介绍" class="headerlink" title="类型转换的一般性介绍"></a>类型转换的一般性介绍</h3><p>一般性介绍：</p><ul><li>a) <code>const_cast&lt;&gt;()</code>：去除变量的 <code>const</code> 只读属性</li><li> b) <code>reinterpret_cast&lt;&gt;()</code>：重新解释类型，不同类型之间会进行强制类型转换</li><li> c) <code>dynamic_cast&lt;&gt;()</code>：动态类型转换，安全的基类和派生类之间转换，运行时会做类型检查</li><li> d) <code>static_cast&lt;&gt;()</code>：静态类型转换，编译的时候 C++ 编译器会做类型检查，基本类型都能转换，但是不能转换指针类型（多态除外）</li></ul><p>一般性结论：</p><ul><li>a) 在 C 语言中，不能隐式类型转换的，在 C++ 中可以用 <code>reinterpret_cast&lt;&gt;()</code> 进行强行类型解释</li><li> b) 在 C 语言中，能隐式类型转换的，在 C++ 中可用 <code>static_cast&lt;&gt;()</code> 进行类型转换，因为 C++ 编译器在编译的时候，一般都可以顺利通过类型检查</li><li> c) <code>static_cast&lt;&gt;()</code> 和 <code>reinterpret_cast&lt;&gt;()</code> 基本上把 C 语言中的强制类型转换功能给覆盖了，但 <code>reinterpret_cast&lt;&gt;()</code> 很难保证代码的移植性</li></ul><h3 id="类型转换的简单使用案例"><a href="#类型转换的简单使用案例" class="headerlink" title="类型转换的简单使用案例"></a>类型转换的简单使用案例</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> {</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"dog cry ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">watchHome</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"dog watch home"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"cat cry ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playBall</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"cat play ball ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playAnimal</span><span class="params">(Animal *animal)</span> </span>{</span><br><span class="line">    animal-&gt;<span class="built_in">cry</span>();</span><br><span class="line">    <span class="comment">// 动态类型转换，将父类转换为子类，运行时会做类型检查</span></span><br><span class="line">    Dog *dog = <span class="keyword">dynamic_cast</span>&lt;Dog *&gt;(animal);</span><br><span class="line">    <span class="keyword">if</span> (dog != <span class="literal">NULL</span>) {</span><br><span class="line">        dog-&gt;<span class="built_in">watchHome</span>();</span><br><span class="line">    }</span><br><span class="line">    Cat *cat = <span class="keyword">dynamic_cast</span>&lt;Cat *&gt;(animal);</span><br><span class="line">    <span class="keyword">if</span> (cat != <span class="literal">NULL</span>) {</span><br><span class="line">        cat-&gt;<span class="built_in">playBall</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span> </span>{</span><br><span class="line">    <span class="comment">// const_cast 去除变量的 const 只读属性</span></span><br><span class="line">    <span class="keyword">char</span> *m_buf = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(buf);</span><br><span class="line">    m_buf[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m_buf &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBuf2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义指针指向一个常量，这里的常量的内存空间不可以更改</span></span><br><span class="line">    <span class="keyword">char</span>* buf = <span class="string">"aaaaa"</span>;</span><br><span class="line">    <span class="comment">// const_cast 去除变量的 const 只读属性</span></span><br><span class="line">    <span class="keyword">char</span>* m_buf = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(buf);</span><br><span class="line">    <span class="comment">// 此时若更改指针所指向的内存空间，会带来灾难性的后果</span></span><br><span class="line">    m_buf[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m_buf &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态类型转换，编译的时候 C++ 编译器会做类型检查</span></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pi);</span><br><span class="line">    cout &lt;&lt; <span class="string">"num1 = "</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态类型转换，基本类型都能转换，但是不能转换指针类型（多态除外）</span></span><br><span class="line">    <span class="comment">// int* p2 = static_cast&lt;int*&gt;(p1);  // 错误写法，C++ 编译器编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新解释类型，不同类型之间会进行强制类型转换，包括转换指针类型</span></span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">"p2 = "</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除变量的 const 只读属性</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"aaaaa"</span>;</span><br><span class="line">    <span class="built_in">printBuf</span>(buf);</span><br><span class="line">    <span class="comment">// printBuf2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态类型转换，基类和派生类之间转换，运行时会做类型检查</span></span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">playAnimal</span>(&amp;dog);</span><br><span class="line">    <span class="built_in">playAnimal</span>(&amp;cat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多态的其他使用场景</span></span><br><span class="line">    Animal *pAnimal = <span class="literal">NULL</span>;</span><br><span class="line">    pAnimal = &amp;dog;</span><br><span class="line">    pAnimal = <span class="keyword">static_cast</span>&lt;Animal *&gt;(&amp;dog); <span class="comment">// 编译通过</span></span><br><span class="line">    pAnimal-&gt;<span class="built_in">cry</span>();</span><br><span class="line">    pAnimal = <span class="keyword">reinterpret_cast</span>&lt;Animal *&gt;(&amp;dog); <span class="comment">// 编译通过</span></span><br><span class="line">    pAnimal-&gt;<span class="built_in">cry</span>();</span><br><span class="line"></span><br><span class="line">    Tree tree;</span><br><span class="line">    <span class="comment">// pAnimal = static_cast&lt;Animal*&gt;(&amp;tree); // 错误写法，C++ 编译器编译失败</span></span><br><span class="line">    pAnimal = <span class="keyword">reinterpret_cast</span>&lt;Animal *&gt;(&amp;tree); <span class="comment">// 编译通过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num1 = 3</span><br><span class="line">p2 = 005661B8</span><br><span class="line">baaaa</span><br><span class="line">baaaa</span><br><span class="line">dog cry ...</span><br><span class="line">dog watch home</span><br><span class="line">cat cry ...</span><br><span class="line">cat play ball ...</span><br><span class="line">dog cry ...</span><br><span class="line">dog cry ...</span><br></pre></td></tr></tbody></table></figure><p>使用总结：</p><ul><li>一般情况下，不建议进行类型转换，应该避免进行类型转换</li><li>要清楚地知道：要转换的变量，类型转换前是什么类型，类型转换后是什么类型，转换后有什么后果</li></ul><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><ul><li>异常的介绍：<ul><li>异常是一种程序控制机制，与函数机制独立和互补</li><li>函数是一种以栈结构展开的上下函数衔接的程序控制系统，而异常是另一种控制结构，它依附于栈结构，却可以同时设置多个异常类型作为捕获条件，从而实现以类型匹配在栈机制中跳跃回馈</li></ul></li><li>异常设计目的：<ul><li>栈机制是一种高度节律性的控制机制，面向对象编程却要求对象之间有方向、有目的的控制传动，从一开始，异常就是冲着改变程序控制结构，以适应面向对象程序更有效地工作这个主题，而不是仅为了进行错误处理</li><li>异常设计出来之后，却发现在错误处理方面获得了最大的好处</li></ul></li></ul><h3 id="异常处理的基本思想"><a href="#异常处理的基本思想" class="headerlink" title="异常处理的基本思想"></a>异常处理的基本思想</h3><h4 id="传统错误处理机制"><a href="#传统错误处理机制" class="headerlink" title="传统错误处理机制"></a>传统错误处理机制</h4><p>传统的程序错误处理机制，是通过函数返回值来处理错误。</p><h4 id="异常处理的基本思想-1"><a href="#异常处理的基本思想-1" class="headerlink" title="异常处理的基本思想"></a>异常处理的基本思想</h4><p><img data-src="../../../asset/2021/12/cplus-plus-exception-1.png" alt="cplus-plus-exception-1"></p><ul><li>异常跨越了函数，并超脱于函数机制，决定了其对函数的跨越式回跳</li><li> C++ 的异常处理机制使得异常的引发和异常的处理不必在同一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理，上层调用者可以在适当的位置设计对不同类型异常的处理</li><li>异常是专门针对抽象编程中的一系列错误进行处理的，C++ 中不能借助函数机制，因为栈结构的本质是先进后出，依次访问，无法进行跳跃，但错误处理的特征却是遇到错误信息就想要转到若干级之上进行重新尝试，如图所示：</li></ul><p><img data-src="../../../asset/2021/12/cplus-plus-exception-2.png" alt="cplus-plus-exception-2"></p><h3 id="C-异常的基础使用"><a href="#C-异常的基础使用" class="headerlink" title="C++ 异常的基础使用"></a>C++ 异常的基础使用</h3><h4 id="异常的基本语法"><a href="#异常的基本语法" class="headerlink" title="异常的基本语法"></a>异常的基本语法</h4><p><img data-src="../../../asset/2021/12/cplus-plus-exception-3.png" alt="cplus-plus-exception-3"></p><ul><li>a) 若有异常则通过 <code>throw</code> 操作创建一个异常对象并抛掷</li><li> b) 将可能抛出异常的程序段嵌在 <code>try</code> 块之中，控制通过正常的顺序执行到达 <code>try</code> 语句，然后执行 <code>try</code> 代码块内的保护段</li><li> c) 如果在保护段执行期间没有引起异常，那么跟在 <code>try</code> 代码块后的 <code>catch</code> 子句就不会执行，程序从 <code>try</code> 代码块后跟随的最后一个 <code>catch</code> 子句后面的语句将继续执行下去</li><li> d) <code>catch</code> 子句按其在 <code>try</code> 代码块后出现的顺序被检查，匹配到的 <code>catch</code> 子句将捕获并处理异常（或继续抛掷异常）</li><li>e) 如果匹配的异常处理器未被找到，则函数 <code>terminate()</code> 将被自动调用，其缺省功能是调用函数 <code>abort()</code> 终止程序的运行</li><li> f) 处理不了的异常，可以在 <code>catch</code> 子句的最后一个分支，使用 <code>throw</code> 语法，向上抛掷异常</li></ul><h4 id="异常的简单使用案例一"><a href="#异常的简单使用案例一" class="headerlink" title="异常的简单使用案例一"></a>异常的简单使用案例一</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == y) {</span><br><span class="line"><span class="keyword">throw</span> y;<span class="comment">// 抛出 int 类型的异常</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> x / y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in">divide</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span> e) {</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">", 被除数不能为零"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 会捕获所有未被捕获的异常，必须最后出现</span></span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"发生未知的异常 ..."</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"程序正常结束运行"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0, 被除数不能为零</span><br><span class="line">程序正常结束运行</span><br></pre></td></tr></tbody></table></figure><h4 id="异常的简单使用案例二"><a href="#异常的简单使用案例二" class="headerlink" title="异常的简单使用案例二"></a>异常的简单使用案例二</h4><p>异常机制与函数机制互不干涉，但捕捉的方式是基于类型匹配。异常捕捉相当于函数返回类型的匹配，而不是函数参数的匹配，所以异常捕捉不用考虑一个抛掷中的多种数据类型匹配问题。异常捕捉是严格按照类型匹配的，它的类型匹配之苛刻程度可以和模板的类型匹配相媲美。它不允许相容类型的隐式转换，比如，抛掷 <code>char</code> 类型的异常，用 <code>int</code> 类型就捕捉不到对应的异常。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.3</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"Please input a exception number: "</span>;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (a) {</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">throw</span> i;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">throw</span> d;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">throw</span> str;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">B</span>();</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">"No exception throws here.\n"</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"int exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">double</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"double exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">char</span>*) {</span><br><span class="line">cout &lt;&lt; <span class="string">"char* exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (A) {</span><br><span class="line">cout &lt;&lt; <span class="string">"class A exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (B) {</span><br><span class="line">cout &lt;&lt; <span class="string">"class B exception.\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"That's ok.\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please input a exception number: 3</span><br><span class="line">char* exception.</span><br><span class="line">That's ok.</span><br></pre></td></tr></tbody></table></figure><h4 id="异常在继承中的使用案例"><a href="#异常在继承中的使用案例" class="headerlink" title="异常在继承中的使用案例"></a>异常在继承中的使用案例</h4><ul><li>MyException.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeException</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printErr</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NegativeException</span> :</span> <span class="keyword">public</span> SizeException {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NegativeException</span>(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printErr</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"数组大小不能小于零, 当前大小为 "</span> &lt;&lt; <span class="keyword">this</span>-&gt;size &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TooBigException</span> :</span> <span class="keyword">public</span> SizeException {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TooBigException</span>(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printErr</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"数组大小太大, 当前大小为 "</span> &lt;&lt; <span class="keyword">this</span>-&gt;size &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroException</span> :</span> <span class="keyword">public</span> SizeException {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroException</span>(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printErr</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"数组大小不允许为零"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>MyArray.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyException.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="keyword">int</span> size) {</span><br><span class="line">        <span class="comment">// 数组初始化大小检查，大小不合法则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">NegativeException</span>(size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">ZeroException</span>(size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; <span class="keyword">this</span>-&gt;m_max_size) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">TooBigException</span>(size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_size = size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="keyword">const</span> MyArray&amp; obj) {</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyArray</span>() {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用类成员函数，重载运算符 "[]"</span></span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用类成员函数，重载运算符 "="</span></span><br><span class="line">    MyArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp; obj) {</span><br><span class="line">        <span class="comment">// 释放原本的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[obj.m_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyArray&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m_size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_space;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">    <span class="keyword">int</span> m_max_size = <span class="number">1000</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> MyArray&amp; obj) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">        out &lt;&lt; obj.m_space[i] &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyArray.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用构造函数</span></span><br><span class="line">        <span class="function">MyArray <span class="title">array1</span><span class="params">(<span class="number">-6</span>)</span></span>;</span><br><span class="line">        <span class="comment">// MyArray array1(5);</span></span><br><span class="line">        <span class="comment">// MyArray array1(0);</span></span><br><span class="line">        <span class="comment">// MyArray array1(2000);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载运算符 "[]"</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">getsize</span>(); i++) {</span><br><span class="line">            array1[i] = <span class="number">20</span> + i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载运算符 "&lt;&lt;"</span></span><br><span class="line">        cout &lt;&lt; array1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">        MyArray array2 = array1;</span><br><span class="line">        cout &lt;&lt; array2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="function">MyArray <span class="title">array3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        array3[<span class="number">0</span>] = <span class="number">43</span>;</span><br><span class="line">        array3[<span class="number">1</span>] = <span class="number">56</span>;</span><br><span class="line">        array3[<span class="number">2</span>] = <span class="number">79</span>;</span><br><span class="line">        cout &lt;&lt; array3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载运算符 "="</span></span><br><span class="line">        array3 = array2;</span><br><span class="line">        cout &lt;&lt; array3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用引用捕获异常（多态）</span></span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (SizeException&amp; e) {</span><br><span class="line">        e.<span class="built_in">printErr</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"发生未知异常"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组大小不能小于零, 当前大小为 -6</span><br></pre></td></tr></tbody></table></figure><h3 id="C-异常的进阶使用"><a href="#C-异常的进阶使用" class="headerlink" title="C++ 异常的进阶使用"></a>C++ 异常的进阶使用</h3><h4 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h4><p>异常被抛出后，从进入 <code>try</code> 代码块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构，析构的顺序与构造的顺序相反。这一过程称为 <code>栈解旋（unwinding）</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">        cout &lt;&lt; <span class="string">"构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>, <span class="title">t2</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == y) {</span><br><span class="line">        <span class="keyword">throw</span> y;    <span class="comment">// 抛出 int 类型的异常</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// divide(5, 0);  如果 divide() 函数的调用写在 try 代码块之外，那么 Test 类的析构函数不会自动被调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">divide</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span> e) {</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; <span class="string">", 被除数不能为零"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"发生未知的异常"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数被调用</span><br><span class="line">构造函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">0, 被除数不能为零</span><br></pre></td></tr></tbody></table></figure><h4 id="异常接口的声明"><a href="#异常接口的声明" class="headerlink" title="异常接口的声明"></a>异常接口的声明</h4><ul><li>a) 为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，例如：<code>void func() throw (A, B, C , D) {}</code>，这个函数 <code>func（）</code> 能够且只能抛出类型 A、B、C、D 及其子类型的异常</li><li> b) 如果一个函数抛出了它的异常接口声明所不允许抛出的异常，<code>unexpected()</code> 函数会被调用，该函数的默认行为是调用 <code>terminate()</code> 函数中止程序</li><li> c) 如果在函数声明中没有包含异常接口声明，则此函数可以抛掷任何类型的异常，例如：<code>void func() {}</code></li><li>d) 一个不抛掷任何类型异常的函数，可以声明为：<code>void func() throw() {}</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> {</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能够且只能抛出类型 A、B、C、D 及其子类型的异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(A, B, C, D)</span> </span>{</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">A</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能抛出任何类型的异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以抛出任何类型的异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcC</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">B</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="built_in">funcA</span>();</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">cout &lt;&lt; <span class="string">"发生异常 ..."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发生异常 ...</span><br></pre></td></tr></tbody></table></figure><h4 id="默认的异常处理器"><a href="#默认的异常处理器" class="headerlink" title="默认的异常处理器"></a>默认的异常处理器</h4><h5 id="terminate-函数"><a href="#terminate-函数" class="headerlink" title="terminate() 函数"></a>terminate () 函数</h5><p>在 C++ 中，异常是不可以忽略的，当异常找不到匹配的 <code>catch</code> 子句时，会调用系统的库函数 <code>terminate()</code>（在头文件中）；默认情况下，<code>terminate（）</code> 函数会调用标准 C 库函数 <code>abort（）</code> 使程序终止而退出。当调用 <code>abort()</code> 函数时，程序不会调用正常的终止函数，也就是说，全局对象和静态对象的析构函数不会执行，这就可能会导致内存泄漏。<strong>值得一提的是，在多线程程序中，各个 <code>terminate()</code> 函数是互相独立的，每个线程都有自己的 <code>terminate()</code> 函数。</strong></p><h5 id="set-terminate-函数"><a href="#set-terminate-函数" class="headerlink" title="set_terminate() 函数"></a>set_terminate () 函数</h5><p>在 C++ 中，通过使用标准的 <code>set_terminate()</code> 函数，可以设置自己的 <code>terminate（)</code> 函数。自定义的 <code>terminate()</code> 函数不能有参数，而且返回值类型必须为 <code>void</code>。另外，<code>terminate()</code> 函数不能抛出异常，它必须终止程序。如果 <code>terminate()</code> 函数被调用，这就意味着问题已经无法解决了。</p><h5 id="设置默认的异常处理器"><a href="#设置默认的异常处理器" class="headerlink" title="设置默认的异常处理器"></a>设置默认的异常处理器</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 terminate() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTerminate</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"函数 myTerminate() 被 terminate() 调用!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 设置默认的异常处理器</span></span><br><span class="line">    <span class="built_in">set_terminate</span>(myTerminate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">0</span>, result;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"被除数为零!"</span>;   <span class="comment">//抛出异常，由 terminate() 函数捕获</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            result = x / y;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 不会被整型异常捕获</span></span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span> e) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"捕获到整型异常!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"程序正常结束运行!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数 myTerminate() 被 terminate() 调用!</span><br></pre></td></tr></tbody></table></figure><h4 id="C-提供的标准异常库"><a href="#C-提供的标准异常库" class="headerlink" title="C++ 提供的标准异常库"></a>C++ 提供的标准异常库</h4><h5 id="标准异常库的介绍"><a href="#标准异常库的介绍" class="headerlink" title="标准异常库的介绍"></a>标准异常库的介绍</h5><p><img data-src="../../../asset/2021/12/cplus-plus-exception-4.png" alt="cplus-plus-exception-4"><br><img data-src="../../../asset/2021/12/cplus-plus-exception-5.png" alt="cplus-plus-exception-5"></p><h5 id="标准异常库的使用案例"><a href="#标准异常库的使用案例" class="headerlink" title="标准异常库的使用案例"></a>标准异常库的使用案例</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>(<span class="keyword">int</span> age) {</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">100</span>) {</span><br><span class="line">            <span class="comment">// 抛出标准库内的异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">"年龄太大"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承标准库内的异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> exception {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_p = p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">what</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"MyException 类型的异常 : "</span> &lt;&lt; m_p &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *m_p;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// Teacher teacher(105);</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">"发生自定义异常!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (out_of_range e) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"out_of_range 类型的异常 : "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (MyException &amp;e) {</span><br><span class="line">        e.<span class="built_in">what</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"发生未知类型的异常!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyException 类型的异常 : 发生自定义异常!</span><br></pre></td></tr></tbody></table></figure><h4 id="异常类型和异常变量的生命周期"><a href="#异常类型和异常变量的生命周期" class="headerlink" title="异常类型和异常变量的生命周期"></a>异常类型和异常变量的生命周期</h4><ul><li><code>throw</code> 异常是有类型的，可以使用数字、字符串、类对象，<code>catch</code> 严格按照类型进行匹配</li><li><code>throw</code> 类对象类型的异常时：<ul><li>如果捕获异常的时候，使用一个异常变量，则拷贝构造该异常变量</li><li>如果捕获异常的时候，使用了引用，则会使用 <code>throw</code> 时候的那个对象</li><li>捕获异常的时候，指针可以和引用 / 元素同时出现，但是引用与元素不能同时出现</li><li><strong>结论：如果抛出的是类对象类型的异常，则使用引用进行异常捕获比较合适 </strong></li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadSrcType</span> {</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadDestType</span> {</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadProcessType</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BadProcessType</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"BadProcessType的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">BadProcessType</span>(<span class="keyword">const</span> BadProcessType&amp; obj) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"BadProcessType的拷贝构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BadProcessType</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"BadProcessType的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStrcpy</span><span class="params">(<span class="keyword">char</span>* to, <span class="keyword">char</span>* from)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (to == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">BadDestType</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (from == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">BadSrcType</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*from == <span class="string">'a'</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">BadProcessType</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (*from == <span class="string">'b'</span>) {</span><br><span class="line">        <span class="comment">// 不建议使用这种写法</span></span><br><span class="line">        <span class="keyword">throw</span>&amp; (<span class="built_in">BadProcessType</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (*from == <span class="string">'c'</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadProcessType;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*from != <span class="string">'\0'</span>) {</span><br><span class="line">        *to = *from;</span><br><span class="line">        to++;</span><br><span class="line">        from++;</span><br><span class="line">    }</span><br><span class="line">    *to = <span class="string">'\0'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf1[] = <span class="string">"cbbcdefg"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">1024</span>] = { <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="built_in">myStrcpy</span>(buf2, buf1);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (BadSrcType e) {</span><br><span class="line">        cout &lt;&lt; <span class="string">" BadSrcType 类型异常"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (BadDestType e) {</span><br><span class="line">        cout &lt;&lt; <span class="string">" BadDestType 类型异常"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 结论1: 如果接收异常的时候，使用一个异常变量，则拷贝构造该异常变量</span></span><br><span class="line"><span class="comment">    catch (BadProcessType e)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; " BadProcessType 类型异常" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 结论2: 如果接收异常的时候，使用了引用，则会使用throw时候的那个对象</span></span><br><span class="line"><span class="comment">    catch (BadProcessType&amp; e)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; " BadProcessType 类型异常" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 结论3: 接收异常的时候，指针可以和引用/元素同时出现，但是引用与元素不能同时出现</span></span><br><span class="line"><span class="comment">    catch (BadProcessType* e)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; " BadProcessType 类型异常" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        delete e;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 结论4: 如果抛出的是类对象类型的异常，则使用引用进行异常捕获比较合适</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未知 类型异常"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括类型转换、异常机制、标准异常库的使用等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之二</title>
    <link href="https://www.techgrow.cn/posts/779107de.html"/>
    <id>https://www.techgrow.cn/posts/779107de.html</id>
    <published>2021-11-29T13:55:33.000Z</published>
    <updated>2021-11-29T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="函数模板和类模板"><a href="#函数模板和类模板" class="headerlink" title="函数模板和类模板"></a>函数模板和类模板</h2><p>C++ 提供了函数模板（function template）。<strong>所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表，这个通用函数就称为函数模板</strong>。凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时，系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。</p><p><img data-src="../../../asset/2021/12/cplus-plus-template-1.png" alt="cplus-plus-template-1"></p><span id="more"></span><p>C++ 提供两种模板机制：函数模板、类模板</p><ul><li>模板又称之为 <code>泛型编程</code></li><li>模板把函数或类要处理的数据类型参数化，表现为参数的多态性，称为类属</li><li>模板用于表达逻辑结构相同，但具有数据元素类型不同的数据对象的通用行为</li><li>类属 —— 类型参数化，又称参数模板，使得程序（算法）可以从逻辑功能上抽象，把被处理的对象（数据）类型作为参数传递</li></ul><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="函数模板的定义"><a href="#函数模板的定义" class="headerlink" title="函数模板的定义"></a>函数模板的定义</h4><p><img data-src="../../../asset/2021/12/cplus-plus-template-2.png" alt="cplus-plus-template-2"></p><ul><li>模板声明的语法为：<code>template &lt; 类型形式参数表 &gt;</code>，例如 <code>template &lt;typename T&gt;</code></li><li>类型形式参数表的语法为：<code>typename T1 ,  typename T2 , …… , typename Tn</code> 或者 <code>class T1 ,  class T2 , …… , class Tn</code></li></ul><h4 id="函数模板的调用"><a href="#函数模板的调用" class="headerlink" title="函数模板的调用"></a>函数模板的调用</h4><ul><li><code>myswap(a, b);</code>：自动数据类型推导</li><li><code>myswap&lt;float&gt;(a, b);</code>：显示类型调用（推荐）</li></ul><h4 id="函数模板的简单使用"><a href="#函数模板的简单使用" class="headerlink" title="函数模板的简单使用"></a>函数模板的简单使用</h4><p><img data-src="../../../asset/2021/12/cplus-plus-template-3.png" alt="cplus-plus-template-3"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>{</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动数据类型推导</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d, y = %d\n"</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动数据类型推导</span></span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">0.5</span>, m = <span class="number">0.8</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(n, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %f, m = %f\n"</span>, n, m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示类型调用（推荐）</span></span><br><span class="line">    <span class="keyword">char</span> i = <span class="string">'h'</span>, j = <span class="string">'e'</span>;</span><br><span class="line">    myswap&lt;<span class="keyword">char</span>&gt;(i, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %c, m = %c\n"</span>, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 2, y = 1</span><br><span class="line">n = 0.800000, m = 0.500000</span><br><span class="line">n = e, m = h</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板做函数参数"><a href="#函数模板做函数参数" class="headerlink" title="函数模板做函数参数"></a>函数模板做函数参数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数模板，实现数组排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arraySort</span><span class="params">(T1* array, <span class="keyword">int</span> size, <span class="keyword">bool</span> asc = <span class="literal">true</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">NULL</span> || size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T1 tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) {</span><br><span class="line">            <span class="comment">// 升序排序（从小到大）</span></span><br><span class="line">            <span class="keyword">if</span> (asc) {</span><br><span class="line">                <span class="keyword">if</span> (array[i] &gt; array[j]) {</span><br><span class="line">                    tmp = array[i];</span><br><span class="line">                    array[i] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 降序排序（从大到小）</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; array[j]) {</span><br><span class="line">                    tmp = array[i];</span><br><span class="line">                    array[i] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数模板，打印数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T2* array, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        cout &lt;&lt; array[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> array[] = { <span class="number">32</span>, <span class="number">16</span>, <span class="number">29</span>, <span class="number">9</span>, <span class="number">43</span>, <span class="number">53</span>, <span class="number">23</span> };</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(array) / <span class="built_in"><span class="keyword">sizeof</span></span>(*array);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之前: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">int</span>&gt;(array, size);</span><br><span class="line"></span><br><span class="line">    arraySort&lt;<span class="keyword">int</span>&gt;(array, size, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之后: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">int</span>&gt;(array, size);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> array2[] = { <span class="string">'c'</span>, <span class="string">'z'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'q'</span>, <span class="string">'m'</span> };</span><br><span class="line">    <span class="keyword">int</span> size2 = <span class="built_in"><span class="keyword">sizeof</span></span>(array2) / <span class="built_in"><span class="keyword">sizeof</span></span>(*array2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之前: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">char</span>&gt;(array2, size2);</span><br><span class="line"></span><br><span class="line">    arraySort&lt;<span class="keyword">char</span>&gt;(array2, size2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"排序之后: "</span>;</span><br><span class="line">    printArray&lt;<span class="keyword">char</span>&gt;(array2, size2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">排序之前: 32 16 29 9 43 53 23</span><br><span class="line">排序之后: 53 43 32 29 23 16 9</span><br><span class="line">------------------------------</span><br><span class="line">排序之前: c z h i q m</span><br><span class="line">排序之后: c h i m q z</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板与普通函数"><a href="#函数模板与普通函数" class="headerlink" title="函数模板与普通函数"></a>函数模板与普通函数</h4><p>函数模板和普通函数的区别：</p><ul><li>a) 函数模板不允许自动类型转化</li><li> b) 普通函数能够进行自动类型转换</li></ul><p>函数模板和普通函数的调用规则：</p><ul><li>a) C++ 编译器优先考虑使用普通函数</li><li> b) 如果函数模板可以产生一个更好的匹配，那么编译器会选择函数模板 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>{</span><br><span class="line">T tmp;</span><br><span class="line">tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">cout &lt;&lt; <span class="string">"模板函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> b)</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"普通函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'z'</span>;</span><br><span class="line"><span class="built_in">myswap</span>(a, c); <span class="comment">// 调用普通函数</span></span><br><span class="line"><span class="built_in">myswap</span>(c, a); <span class="comment">// 调用普通函数，会进行隐式的类型转换</span></span><br><span class="line"><span class="built_in">myswap</span>(a, a); <span class="comment">// 调用函数模板（本质是类型参数化），将严格地按照类型进行匹配，不会进行隐式的类型转换</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 10, b = z</span><br><span class="line">普通函数被调用</span><br><span class="line">a = 122, b =</span><br><span class="line"></span><br><span class="line">普通函数被调用</span><br><span class="line">模板函数被调用</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板与函数重载"><a href="#函数模板与函数重载" class="headerlink" title="函数模板与函数重载"></a>函数模板与函数重载</h4><ul><li>a) 函数模板可以像普通函数一样被重载</li><li> b) 通过空模板实参列表的语法，可以限制编译器只使用函数模板匹配</li><li> c) 如果函数模板可以产生一个更好的匹配，那么编译器会选择函数模板 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"int Max(int a, int b)"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"T Max(T a, T b)"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板重载</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"T Max(T a, T b, T c)"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">Max</span>(a, b), c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Max</span>(a, b) &lt;&lt; endl; <span class="comment">// 当函数模板和普通函数都符合调用时,优先选择普通函数</span></span><br><span class="line">cout &lt;&lt; Max&lt;&gt;(a, b) &lt;&lt; endl; <span class="comment">//  通过空模板实参列表的语法，可以限制编译器只使用函数模板匹配</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Max</span>(<span class="number">3.0</span>, <span class="number">4.0</span>) &lt;&lt; endl; <span class="comment">// 如果函数模板产生更好的匹配 使用函数模板</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Max</span>(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>) &lt;&lt; endl; <span class="comment">// 函数模板的重载</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Max</span>(<span class="string">'a'</span>, <span class="number">100</span>) &lt;&lt; endl;  <span class="comment">// 调用普通函数，可以进行隐式类型转换 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Max(int a, int b)</span><br><span class="line">2</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">2</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">4</span><br><span class="line">T Max(T a, T b, T c)</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">T Max(T a, T b)</span><br><span class="line">7</span><br><span class="line">int Max(int a, int b)</span><br><span class="line">100</span><br></pre></td></tr></tbody></table></figure><h4 id="函数模板底层原理剖析"><a href="#函数模板底层原理剖析" class="headerlink" title="函数模板底层原理剖析"></a>函数模板底层原理剖析</h4><ul><li>编译器并不是根据函数模板，产生能够处理任意参数的函数</li><li>编译器本质上是根据具体的调用类型，从函数模板产生不同的函数</li><li><strong>编译器会对函数模板进行两次编译，在声明的地方对函数模板代码本身进行第一次编译，在调用的地方对参数替换后的函数模板代码进行第二次编译</strong></li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板与函数模板的定义和使用类似，在实际项目开发中，经常有两个或多个类，其功能是相同的，仅仅是数据类型不同，为了不重复定义功能相同的类，可以使用类模板来解决这类问题。</p><h4 id="类模板的定义"><a href="#类模板的定义" class="headerlink" title="类模板的定义"></a>类模板的定义</h4><p><img data-src="../../../asset/2021/12/cplus-plus-template-4.png"></p><ul><li>类模板用于实现类所需数据的类型参数化</li><li>类模板在表示如数组、表、图等数据结构显得特别重要，这些数据结构的表示和算法不受所包含的元素类型的影响</li><li>在下述的所有代码中，<code>template &lt;typename T&gt;</code> 等价于 <code>template &lt;class T&gt;</code></li></ul><h4 id="类模板的简单使用"><a href="#类模板的简单使用" class="headerlink" title="类模板的简单使用"></a>类模板的简单使用</h4><p>值得一提的是，在类模板中如果使用了构造函数，则必须遵守 C++ 类的构造函数的调用规则</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(T t) {</span><br><span class="line"><span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">getT</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T t;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板做函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">(A&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>{</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getT</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;<span class="comment">// 模板类是抽象的，需要声明具体的类型（模板参数列表），这里的 &lt;int&gt; 不能省略</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getT</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">printA</span>(a2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">50</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板与派生类的使用"><a href="#类模板与派生类的使用" class="headerlink" title="类模板与派生类的使用"></a>类模板与派生类的使用</h4><h5 id="普通类继承类模板"><a href="#普通类继承类模板" class="headerlink" title="普通类继承类模板"></a>普通类继承类模板</h5><p>在 C++ 中，类模板可以被普通类继承，普通类继承类模板时，需要声明父类具体的数据类型。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(T a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T a;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类继承类模板，需要声明具体的类型（模板参数列表），这里的 &lt;int&gt; 不能省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&lt;<span class="keyword">int</span>&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : A&lt;<span class="keyword">int</span>&gt;(a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">b.<span class="built_in">printB</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">a = 1, b = 3</span><br></pre></td></tr></tbody></table></figure><h5 id="类模板继承类模板"><a href="#类模板继承类模板" class="headerlink" title="类模板继承类模板"></a>类模板继承类模板</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(T a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T a;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板继承类模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&lt;T&gt; {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(T a, T b) : <span class="built_in">A</span>(a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">B&lt;<span class="keyword">double</span>&gt; <span class="title">b</span><span class="params">(<span class="number">3.2</span>, <span class="number">4.5</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; b.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b.<span class="built_in">getB</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3.2</span><br><span class="line">4.5</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板函数的三种写法"><a href="#类模板函数的三种写法" class="headerlink" title="类模板函数的三种写法"></a>类模板函数的三种写法</h4><p>值得一提的是，企业项目开发中，建议使用第一种或者第三种方式，STL 库一般都采用第一种方式。</p><h5 id="所有的类模板函数写在类的内部（第一种）"><a href="#所有的类模板函数写在类的内部（第一种）" class="headerlink" title="所有的类模板函数写在类的内部（第一种）"></a>所有的类模板函数写在类的内部（第一种）</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">Complex</span>(T a, T b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; c2) {</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c2.a, <span class="keyword">this</span>-&gt;b + c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&amp; c1) {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; c1.b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Complex <span class="title">sub</span><span class="params">(Complex&amp; c1, Complex&amp; c2)</span> </span>{</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(c1.a - c2.a, c1.b - c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T a;</span><br><span class="line">T b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">c1.<span class="built_in">print</span>();</span><br><span class="line">c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c4 = <span class="built_in">sub</span>(c1, c2);</span><br><span class="line">cout &lt;&lt; c4 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 1, b = 4</span><br><span class="line">a = 3, b = 6</span><br><span class="line">a = 4, b = 10</span><br><span class="line">a = -2, b = -2</span><br></pre></td></tr></tbody></table></figure><h5 id="所有的类模板函数写在类的外部（第二种）"><a href="#所有的类模板函数写在类的外部（第二种）" class="headerlink" title="所有的类模板函数写在类的外部（第二种）"></a>所有的类模板函数写在类的外部（第二种）</h5><p>所有的类模板函数写在类的外部（写在同一个 <code>.cpp</code> 文件），当使用友元函数重载了 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 运算符时，需要特别注意声明友元函数的写法 <code>friend ostream&amp; operator&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c1);</code>。<strong>特别注意，除了重载运算符 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 必须使用友元函数之外，其他运算符的重载尽量都使用类成员函数。千万不要滥用友元函数，尤其类模板与友元函数一起使用的时候，这是因为需要使用怪异的语法来解决 C++ 编译器出现的错误，且不同的 C++ 编译器表现行为不一定一致。</strong>假设在类模板中滥用了友元函数，解决 C++ 编译问题的语法详见 <a href="../../../asset/2021/12/cplus-plus-template-5.png">图解分析</a>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** START 解决类模板与友元函数滥用（非重载左移与右移运算符）时出现的编译问题 *********/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Complex</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">Complex&lt;T&gt; <span class="title">sub</span><span class="params">(Complex&lt;T&gt;&amp; c1, Complex&lt;T&gt;&amp; c2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** END 解决类模板与友元函数滥用（非重载左移与右移运算符）时出现的编译问题 *********/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">Complex</span>(T a, T b);</span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; c2);</span><br><span class="line"><span class="comment">// 友元函数（滥用友元函数）</span></span><br><span class="line"><span class="keyword">friend</span> Complex sub&lt;T&gt;(Complex&amp; c1, Complex&amp; c2);</span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T a;</span><br><span class="line">T b;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt;::<span class="built_in">Complex</span>(T a, T b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Complex&lt;T&gt;::<span class="built_in">print</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt; Complex&lt;T&gt;::<span class="keyword">operator</span>+(Complex&lt;T&gt;&amp; c2) {</span><br><span class="line"><span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c2.a, <span class="keyword">this</span>-&gt;b + c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&lt;T&gt;&amp; c1) {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; c1.b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数（滥用友元函数）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Complex&lt;T&gt; <span class="title">sub</span><span class="params">(Complex&lt;T&gt;&amp; c1, Complex&lt;T&gt;&amp; c2)</span> </span>{</span><br><span class="line"><span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(c1.a - c2.a, c1.b - c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">3</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">9</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">c1.<span class="built_in">print</span>();</span><br><span class="line">c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c4 = <span class="built_in">sub</span>(c1, c2);</span><br><span class="line">cout &lt;&lt; c4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 3, b = 8</span><br><span class="line">a = 9, b = 5</span><br><span class="line">a = 12, b = 13</span><br><span class="line">a = -6, b = 3</span><br></pre></td></tr></tbody></table></figure><h5 id="所有的类模板函数写在类的外部（第三种）"><a href="#所有的类模板函数写在类的外部（第三种）" class="headerlink" title="所有的类模板函数写在类的外部（第三种）"></a>所有的类模板函数写在类的外部（第三种）</h5><p>所有的类模板函数写在类的外部（分开写在 <code>.h</code> 和 <code>.cpp</code> 中），这里除了重载运算符 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 必须使用友元函数之外，千万不要滥用友元函数；因为 C++ 编译器会出现编译错误，且没有很好的解决方法。</p><ul><li>complex.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(T a, T b);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; c2);</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T a;</span><br><span class="line">T b;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>complex.hpp，这里的 <code>.hpp</code> 文件与 <code>.cpp</code> 文件本质上没有区别，为了方便区分意图，只是文件的后缀不一样而已 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complex.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt;::<span class="built_in">Complex</span>(T a, T b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Complex&lt;T&gt;::<span class="built_in">print</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类成员函数，重载运算符 "+"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt; Complex&lt;T&gt;::<span class="keyword">operator</span>+(Complex&lt;T&gt;&amp; c2) {</span><br><span class="line"><span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c2.a, <span class="keyword">this</span>-&gt;b + c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&lt;T&gt;&amp; c1) {</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; c1.b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp，特别注意，这里引入的是 <code>.hpp</code> 或者 <code>.cpp</code> 文件，而不是 <code>.h</code> 头文件，否则 C++ 编译器会编译失败 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complex.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">6</span>, <span class="number">13</span>)</span></span>;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">23</span>, <span class="number">34</span>)</span></span>;</span><br><span class="line">c1.<span class="built_in">print</span>();</span><br><span class="line">c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 6, b = 13</span><br><span class="line">a = 23, b = 34</span><br><span class="line">a = 29, b = 47</span><br></pre></td></tr></tbody></table></figure><h4 id="类模板中的-static-关键字"><a href="#类模板中的-static-关键字" class="headerlink" title="类模板中的 static 关键字"></a>类模板中的 static 关键字</h4><ul><li>从类模板实例化的每种数据类型模板类都有自己的类模板数据成员，该数据类型的模板类的所有对象共享同一个 <code>static</code> 数据成员</li><li>和非模板类的 <code>static</code> 数据成员一样，模板类的 <code>static</code> 数据成员也应该在源文件范围内定义和初始化</li><li>每种数据类型的模板类都有自己单独一份的类模板的 <code>static</code> 数据成员副本，详见 <a href="../../../asset/2021/12/cplus-plus-template-6.png">图解分析</a></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Circle</span>(T radius = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_radius = radius;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_total++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(T radius)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;m_radius = radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">getRadius</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getGirth</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * pi * <span class="keyword">this</span>-&gt;m_radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> pi * <span class="keyword">this</span>-&gt;m_radius * <span class="keyword">this</span>-&gt;m_radius;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> m_total;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_radius;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的静态数据成员</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_total;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类模板的静态数据成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Circle&lt;T&gt;::m_total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 每种数据类型的模板类都有自己单独一份的类模板的 static 数据成员副本</span></span><br><span class="line"></span><br><span class="line"><span class="function">Circle&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">4</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"m_total = "</span> &lt;&lt; Circle&lt;<span class="keyword">int</span>&gt;::<span class="built_in">getTotal</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c1.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c1.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c1.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c2.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c2.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c2.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle&lt;<span class="keyword">float</span>&gt; <span class="title">c3</span><span class="params">(<span class="number">3.2</span>)</span>, <span class="title">c4</span><span class="params">(<span class="number">4.3</span>)</span>, <span class="title">c5</span><span class="params">(<span class="number">6.2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"m_total = "</span> &lt;&lt; Circle&lt;<span class="keyword">float</span>&gt;::<span class="built_in">getTotal</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c3.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c3.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c3.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c4.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c4.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c4.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"radius = "</span> &lt;&lt; c5.<span class="built_in">getRadius</span>() &lt;&lt; <span class="string">", girth = "</span> &lt;&lt; c5.<span class="built_in">getGirth</span>() &lt;&lt; <span class="string">", area = "</span> &lt;&lt; c5.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m_total = 2</span><br><span class="line">radius = 4, girth = 25.12, area = 50.24</span><br><span class="line">radius = 6, girth = 37.68, area = 113.04</span><br><span class="line">m_total = 3</span><br><span class="line">radius = 3.2, girth = 20.096, area = 32.1536</span><br><span class="line">radius = 4.3, girth = 27.004, area = 58.0586</span><br><span class="line">radius = 6.2, girth = 38.936, area = 120.702</span><br></pre></td></tr></tbody></table></figure><h3 id="数组模板类的实战案例"><a href="#数组模板类的实战案例" class="headerlink" title="数组模板类的实战案例"></a>数组模板类的实战案例</h3><p>下面将编写数组模板类，模拟 STL 容器的实现，同时贯穿上面所讲的 C++ 模板知识点。</p><details><summary>★点击显示完整的案例代码★</summary><code><ul><li>MyVector.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="keyword">int</span> size = <span class="number">0</span>);</span><br><span class="line">~<span class="built_in">MyVector</span>();</span><br><span class="line"><span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">MyVector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&amp; obj);</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt;(ostream&amp; out, MyVector&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_space; <span class="comment">// 指向数组的指针</span></span><br><span class="line"><span class="keyword">int</span> m_size;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>MyVector.hpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyVector.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;::<span class="built_in">MyVector</span>(<span class="keyword">int</span> size) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = size;</span><br><span class="line"><span class="comment">// 分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> T[size];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;::~<span class="built_in">MyVector</span>() {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;::<span class="built_in">MyVector</span>(<span class="keyword">const</span> MyVector&lt;T&gt;&amp; obj) {</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> T[obj.m_size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> MyVector&lt;T&gt;::<span class="built_in">getSize</span>() {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数，重载运算符 "[]"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; MyVector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数，重载运算符 "="</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyVector&lt;T&gt;&amp; MyVector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> MyVector&lt;T&gt;&amp; obj) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space) {</span><br><span class="line"><span class="comment">// 释放原本的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_size = obj.m_size;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> T[obj.m_size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[i] = obj.m_space[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyVector&lt;T&gt;&amp; obj) {</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.m_size; i++) {</span><br><span class="line">cout &lt;&lt; obj.m_space[i] &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Teacher.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Teacher</span>();</span><br><span class="line"><span class="built_in">Teacher</span>(<span class="keyword">int</span> age, <span class="keyword">const</span> <span class="keyword">char</span>* name);</span><br><span class="line"><span class="built_in">Teacher</span>(<span class="keyword">const</span> Teacher&amp; obj);</span><br><span class="line">~<span class="built_in">Teacher</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Teacher&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Teacher&amp; obj);</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Teacher&amp; obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_age;</span><br><span class="line"><span class="keyword">char</span>* m_name;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>Teacher.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Teacher.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>() {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="keyword">int</span> age, <span class="keyword">const</span> <span class="keyword">char</span>* name) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="keyword">const</span> Teacher&amp; obj) {</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = obj.m_age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(obj.m_name) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, obj.m_name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Teacher::~<span class="built_in">Teacher</span>() {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数，重载运算符 "="</span></span><br><span class="line">Teacher&amp; Teacher::<span class="keyword">operator</span>=(<span class="keyword">const</span> Teacher&amp; obj) {</span><br><span class="line"><span class="comment">// 释放原本的内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_name);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = obj.m_age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(obj.m_name) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, obj.m_name);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数，重载运算符 "&lt;&lt;"</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Teacher&amp; obj) {</span><br><span class="line">cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; obj.m_age &lt;&lt; <span class="string">" name = "</span> &lt;&lt; obj.m_name;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Teacher::getAge</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Teacher::getName</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>{</span><br><span class="line"><span class="comment">// 释放原本的内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_name);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name) {</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_name, name);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp，值得一提的是，这里需要引入 <code>Teacher.cpp</code> 和 <code>MyVector.hpp</code>，而不是 <code>Teacher.h</code> 和 <code>MyVector.h</code> 头文件，否则 C++ 编译器会编译失败，本质原因是由于 C++ 编译器会对模板进行两次编译导致的，详见  <a href="https://blog.csdn.net/big_bit/article/details/52289162">C++ 模板的编译错误分析</a>。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Teacher.cpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyVector.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用构造函数</span></span><br><span class="line"><span class="function">MyVector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符 "[]"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">v[i] = i + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符 "&lt;&lt;"</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用拷贝构造函数</span></span><br><span class="line">MyVector&lt;<span class="keyword">int</span>&gt; v2 = v;</span><br><span class="line">cout &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符 "="</span></span><br><span class="line"><span class="function">MyVector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">v3 = v2;</span><br><span class="line">cout &lt;&lt; v3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器存放类对象</span></span><br><span class="line"><span class="function">MyVector&lt;Teacher&gt; <span class="title">teachers</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teachers.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line"><span class="function">Teacher <span class="title">t</span><span class="params">(i + <span class="number">20</span>, <span class="string">"Jim"</span>)</span></span>;</span><br><span class="line">teachers[i] = t;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; teachers &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器存放指针</span></span><br><span class="line"><span class="function">MyVector&lt;Teacher*&gt; <span class="title">points</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">points[i] = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">25</span> + i, <span class="string">"Tom"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">Teacher* obj = points[i];</span><br><span class="line">cout &lt;&lt; <span class="string">"age = "</span> &lt;&lt; obj-&gt;<span class="built_in">getAge</span>() &lt;&lt; <span class="string">" name = "</span> &lt;&lt; obj-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5,</span><br><span class="line">1, 2, 3, 4, 5,</span><br><span class="line">1, 2, 3, 4, 5,</span><br><span class="line">age = 20 name = Jim, age = 21 name = Jim, age = 22 name = Jim,</span><br><span class="line">age = 25 name = Tom, age = 26 name = Tom, age = 27 name = Tom, age = 28 name = Tom,</span><br></pre></td></tr></tbody></table></figure></code></details><h3 id="函数模板与类模板的使用总结"><a href="#函数模板与类模板的使用总结" class="headerlink" title="函数模板与类模板的使用总结"></a>函数模板与类模板的使用总结</h3><ul><li>模板是 C++ 类型参数化的多态工具，C++ 为此提供了函数模板和类模板</li><li>模板定义以模板声明开始，类属参数必须在模板定义中至少出现一次</li><li>同一个类属参数可以用于多个模板</li><li>类属参数可用于函数的参数类型、返回值类型和声明函数中的变量</li><li>模板由编译器根据实际的数据类型进行实例化，生成可执行代码</li><li>模板中的函数称为模板函数，实例化的类模板称为模板类</li><li>类模板可以在类层次中使用（即可以被继承）</li><li>函数模板可以使用多种方式重载</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括函数模板、类模板等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 进阶基础之一</title>
    <link href="https://www.techgrow.cn/posts/dbff2af9.html"/>
    <id>https://www.techgrow.cn/posts/dbff2af9.html</id>
    <published>2021-11-25T13:55:33.000Z</published>
    <updated>2021-11-29T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="智能指针的入门案例"><a href="#智能指针的入门案例" class="headerlink" title="智能指针的入门案例"></a>智能指针的入门案例</h3><h4 id="unique-ptr-对象的介绍"><a href="#unique-ptr-对象的介绍" class="headerlink" title="unique_ptr 对象的介绍"></a>unique_ptr 对象的介绍</h4><p><code>unique_ptr</code> 是 C++ 11 提供的用于防止内存泄漏的智能指针中的一种实现，独享被管理对象指针所有权的智能指针。<code>unique_ptr</code> 对象包装了一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。<code>unique_ptr</code> 实现了 <code>-&gt;</code> 和 <code>*</code> 运算符的重载，因此它可以像普通指针一样使用。</p><h4 id="unique-ptr-对象的简单使用"><a href="#unique-ptr-对象的简单使用" class="headerlink" title="unique_ptr 对象的简单使用"></a>unique_ptr 对象的简单使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Task</span>(<span class="keyword">int</span> id) {</span><br><span class="line"><span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">cout &lt;&lt; <span class="string">"构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Task</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">23</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"id = "</span> &lt;&lt; taskPtr-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数被调用</span><br><span class="line">id = 23</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></tbody></table></figure><p><code>unique_ptr&lt;Task&gt;</code> 对象 <code>taskPtr</code> 接受原始指针作为参数。当 <code>main</code> 函数退出时，该对象超出作用范围就会自动调用自身的析构函数。在 <code>unique_ptr&lt;Task&gt;</code> 对象 <code>taskPtr</code> 的析构函数中，会删除关联的原始指针，这样就不用专门执行 Task 对象的 <code>delete</code> 操作了。以后不管函数正常退出还是异常退出（由于某些异常），也会始终调用 <code>taskPtr</code> 对象的析构函数。因此，原始指针将始终被删除并防止内存泄漏。</p><h4 id="unique-ptr-对象独享所有权"><a href="#unique-ptr-对象独享所有权" class="headerlink" title="unique_ptr 对象独享所有权"></a>unique_ptr 对象独享所有权</h4><p><code>unique_ptr</code> 对象始终是关联的原始指针的唯一所有者，因此开发者无法通过拷贝构造函数或赋值运算符复制 <code>unique_ptr</code> 对象的副本，只能移动它。由于每个 <code>unique_ptr</code> 对象都是原始指针的唯一所有者，因此在其析构函数中，它可以直接删除关联的指针，不需要任何参考计数。</p><h3 id="智能指针的基础操作"><a href="#智能指针的基础操作" class="headerlink" title="智能指针的基础操作"></a>智能指针的基础操作</h3><h4 id="获取被管理对象的原始指针"><a href="#获取被管理对象的原始指针" class="headerlink" title="获取被管理对象的原始指针"></a>获取被管理对象的原始指针</h4><p>在 <code>unique_ptr</code> 对象上调用 <code>get()</code> 函数，可以获取管理对象的原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task *p1 = taskPtr.<span class="built_in">get</span>();</span><br></pre></td></tr></tbody></table></figure><h4 id="检查-unique-ptr-对象是否为空"><a href="#检查-unique-ptr-对象是否为空" class="headerlink" title="检查 unique_ptr 对象是否为空"></a>检查 unique_ptr 对象是否为空</h4><p>有两种方法创建一个空的 <code>unique_ptr</code> 对象，因为没有与之关联的原始指针，所以它是空的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; ptr;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></tbody></table></figure><p>有两种方法可以检查 <code>unique_ptr</code> 对象是否为空或者是否有与之关联的原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ptr) {</span><br><span class="line">cout&lt;&lt;<span class="string">"ptr is empty"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>){</span><br><span class="line">cout&lt;&lt;<span class="string">"ptr is empty"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用原始指针创建-unique-ptr-对象"><a href="#使用原始指针创建-unique-ptr-对象" class="headerlink" title="使用原始指针创建 unique_ptr 对象"></a>使用原始指针创建 unique_ptr 对象</h4><p>要创建非空的 <code>unique_ptr</code> 对象，需要在创建对象时在其构造函数中传递原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">22</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr</span><span class="params">(<span class="keyword">new</span> unique_ptr&lt;Task&gt;::element_type(<span class="number">23</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>不能通过赋值的方法创建 <code>unique_ptr</code> 对象</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Task&gt; taskPtr = <span class="keyword">new</span> <span class="built_in">Task</span>();     <span class="comment">// 错误写法，编译失败</span></span><br></pre></td></tr></tbody></table></figure><h3 id="智能指针的进阶操作"><a href="#智能指针的进阶操作" class="headerlink" title="智能指针的进阶操作"></a>智能指针的进阶操作</h3><h4 id="重置-unique-ptr-对象"><a href="#重置-unique-ptr-对象" class="headerlink" title="重置 unique_ptr 对象"></a>重置 unique_ptr 对象</h4><p>在 <code>unique_ptr</code> 对象上调用 <code>reset()</code> 函数可以重置它，即它会 <code>delete</code> 已关联的原始指针，并将 <code>unique_ptr</code> 对象设置为空</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskPtr.<span class="built_in">reset</span>();</span><br></pre></td></tr></tbody></table></figure><h4 id="unique-ptr-对象不允许复制"><a href="#unique-ptr-对象不允许复制" class="headerlink" title="unique_ptr 对象不允许复制"></a>unique_ptr 对象不允许复制</h4><p>由于 <code>unique_ptr</code> 不可复制，只能移动。因此，无法通过拷贝构造函数或赋值运算符创建 <code>unique_ptr</code> 对象的副本</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr1</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">22</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr2</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">35</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;Task&gt; taskPtr4 = taskPtr1;  <span class="comment">// 错误写法，编译失败</span></span><br><span class="line"></span><br><span class="line">taskPtr2 = taskPtr1;    <span class="comment">// 错误写法，编译失败</span></span><br></pre></td></tr></tbody></table></figure><h4 id="转移-unique-ptr-对象的所有权"><a href="#转移-unique-ptr-对象的所有权" class="headerlink" title="转移 unique_ptr 对象的所有权"></a>转移 unique_ptr 对象的所有权</h4><p>不允许复制 <code>unique_ptr</code> 对象，但可以转移它们。这意味着 <code>unique_ptr</code> 对象可以将自身关联的原始指针的所有权转移给另一个 <code>unique_ptr</code> 对象</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过原始指针创建taskPtr1</span></span><br><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr1</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">55</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把taskPtr1中关联指针的所有权转移给taskPtr2</span></span><br><span class="line">unique_ptr&lt;Task&gt; taskPtr2 = <span class="built_in">move</span>(taskPtr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// taskPtr1关联指针的所有权现在转移到了taskPtr2中，此时taskPtr1关联的指针为空</span></span><br><span class="line"><span class="keyword">if</span> (taskPtr1 == <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr1 is empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// taskPtr1关联指针的所有权现在转移到了taskPtr2中，此时taskPtr2关联的指针不为空</span></span><br><span class="line"><span class="keyword">if</span> (taskPtr2 != <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr2 is not empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; taskPtr2-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskPtr1 is  empty</span><br><span class="line">taskPtr2 is not empty</span><br><span class="line">55</span><br></pre></td></tr></tbody></table></figure><h4 id="释放-unique-ptr-对象关联的原始指针"><a href="#释放-unique-ptr-对象关联的原始指针" class="headerlink" title="释放 unique_ptr 对象关联的原始指针"></a>释放 unique_ptr 对象关联的原始指针</h4><p>在 <code>unique_ptr</code> 对象上调用 <code>release()</code> 函数，将释放其关联的原始指针的所有权，并返回原始指针，同时设置 <code>unique_ptr</code> 对象为空。特别注意，这里是释放其关联的原始指针的所有权，并没有 <code>delete</code> 原始指针，而调用 <code>reset()</code> 函数则会 <code>delete</code> 原始指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Task&gt; <span class="title">taskPtr1</span><span class="params">(<span class="keyword">new</span> Task(<span class="number">55</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (taskPtr1 != <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr1 is not empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放关联指针的所有权</span></span><br><span class="line">Task* ptr = taskPtr1.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (taskPtr1 == <span class="literal">nullptr</span>) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"taskPtr1 is empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"id = "</span> &lt;&lt; ptr-&gt;<span class="built_in">getId</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskPtr1 is <span class="keyword">not</span> empty</span><br><span class="line">taskPtr1 is empty</span><br><span class="line">id = <span class="number">55</span></span><br></pre></td></tr></tbody></table></figure><h4 id="C-14-使用原始指针创建-unique-ptr-对象"><a href="#C-14-使用原始指针创建-unique-ptr-对象" class="headerlink" title="C++ 14 使用原始指针创建 unique_ptr 对象"></a>C++ 14 使用原始指针创建 unique_ptr 对象</h4><p>C++ 引入了新的语法，可以使用 <code>make_unique</code> 来创建 <code>unique_ptr</code> 对象，省去了 <code>new</code> 关键字的使用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Task&gt; taskPtr = make_unique&lt;Task&gt;(<span class="number">34</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="原子操作的使用"><a href="#原子操作的使用" class="headerlink" title="原子操作的使用"></a>原子操作的使用</h2><h3 id="原子操作简介"><a href="#原子操作简介" class="headerlink" title="原子操作简介"></a>原子操作简介</h3><p>所谓的原子操作，取的就是 “原子是最小的、不可分割的最小个体” 的意义，它表示在多个线程访问同一个全局资源的时候，能够确保在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。在以往的 C++ 标准中并没有对原子操作进行规定，开发人员往往是使用汇编语言，或者是借助第三方的线程库，例如 Intel 的 <code>pthread</code> 来实现。在新标准 C++ 11 中，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如 <code>atomic_bool</code>、<code>atomic_int</code> 等等。如果在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问；这样就可以保证多个线程访问这个共享资源的正确性，从而避免了锁的使用，提高了效率。在新标准 C++ 11 中，<code>atomic</code> 对 <code>int</code>、<code>char</code>、<code>bool</code> 等基础数据结构进行了原子性封装，在多线程环境中，对 <code>atomic</code> 对象的访问不会造成资源竞争，利用 <code>atomic</code> 可实现数据结构的无锁设计。</p><h3 id="atomic-的简介"><a href="#atomic-的简介" class="headerlink" title="atomic 的简介"></a>atomic 的简介</h3><p>在新标准 C++ 11 中，新增了 <code>atomic</code> 关键字，可以使用它定义一个原子类型，详见 <a href="https://zh.cppreference.com/w/cpp/atomic/atomic">C++ 参考手册一</a>、<a href="http://www.cplusplus.com/reference/atomic/">C++ 参考手册二</a>。</p><ul><li>成员函数</li></ul><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td> store</td><td> 原子地以非原子对象替换原子对象的值</td></tr><tr><td> load</td><td> 原子地获得原子对象的值</td></tr><tr><td> operator=</td><td> 存储值于原子对象</td></tr><tr><td> is_lock_free</td><td> 检查原子对象是否免锁</td></tr><tr><td> operator T</td><td> 从原子对象加载值</td></tr><tr><td> exchange</td><td> 原子地替换原子对象的值，并获得它先前持有的值</td></tr><tr><td> compare_exchange_weak、compare_exchange_strong</td><td> 原子地比较原子对象与非原子参数的值，若相等则进行交换，若不相等则进行加载</td></tr></tbody></table><ul><li>特化成员函数</li></ul><table><thead><tr><th>特化成员函数</th><th>说明</th></tr></thead><tbody><tr><td> fetch_add</td><td> 原子地将参数加到存储于原子对象的值，并返回先前保有的值</td></tr><tr><td> fetch_sub</td><td> 原子地从存储于原子对象的值减去参数，并获得先前保有的值</td></tr><tr><td> fetch_and</td><td> 原子地进行参数和原子对象的值的逐位与，并获得先前保有的值</td></tr><tr><td> fetch_or</td><td> 原子地进行参数和原子对象的值的逐位或，并获得先前保有的值</td></tr><tr><td> fetch_xor</td><td> 原子地进行参数和原子对象的值的逐位异或，并获得先前保有的值</td></tr><tr><td><code>operator++</code>、<code>operator++(int)</code>、<code>operator--</code>、<code>operator--(int)</code></td><td>令原子值增加或者减少一</td></tr><tr><td><code>operator+=</code>、<code>operator-=</code>、<code>operator&amp;=</code>、<code>operator^=</code></td><td>加、减，或者与原子值进行逐位与、异或</td></tr></tbody></table><p>值得一提的是，所谓特化函数，也就是 <code>atomic</code> 自身提供的，可以进行原子操作的函数。使用这些函数进行的操作，都是原子的。</p><h3 id="atomic-的使用案例"><a href="#atomic-的使用案例" class="headerlink" title="atomic 的使用案例"></a>atomic 的使用案例</h3><h4 id="加锁不使用-atomic"><a href="#加锁不使用-atomic" class="headerlink" title="加锁不使用 atomic"></a>加锁不使用 atomic</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="comment">// 加锁防止多个线程同时访问同一资源</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">total++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">clock_t</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个线程</span></span><br><span class="line">vector&lt;thread&gt; threads;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(threadFun));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thad : threads) {</span><br><span class="line">thad.<span class="built_in">join</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测total是否正确 10000*10 = 100000</span></span><br><span class="line">cout &lt;&lt; <span class="string">"total number:"</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"耗时："</span> &lt;&lt; end_time - start_time &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total number:10000000</span><br><span class="line">耗时：615ms</span><br></pre></td></tr></tbody></table></figure><h4 id="不加锁使用-atomic"><a href="#不加锁使用-atomic" class="headerlink" title="不加锁使用 atomic"></a>不加锁使用 atomic</h4><p>与加锁相比，使用原子操作（atomic）能大大地提高程序的运行效率。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">atomic&lt;<span class="keyword">size_t</span>&gt; <span class="title">total</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">total++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">clock_t</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动多个线程</span></span><br><span class="line">vector&lt;thread&gt; threads;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(threadFun));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thad : threads) {</span><br><span class="line">thad.<span class="built_in">join</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测total是否正确 10000*10 = 100000</span></span><br><span class="line">cout &lt;&lt; <span class="string">"total number:"</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"耗时："</span> &lt;&lt; end_time - start_time &lt;&lt; <span class="string">"ms"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total number:10000000</span><br><span class="line">耗时：321ms</span><br></pre></td></tr></tbody></table></figure><h3 id="为什么要定义一个原子类型"><a href="#为什么要定义一个原子类型" class="headerlink" title="为什么要定义一个原子类型"></a>为什么要定义一个原子类型</h3><p>举个例子，<code>int64_t</code> 类型，在 32 位机器上为非原子操作。更新时该类型的值时，需要进行两步操作（高 32 位、低 32 位）。如果多线程操作该类型的变量，且在操作时未加锁，可能会出现读脏数据的情况。解决该问题的话，可以使用加锁，或者提供一种定义原子类型的方法。</p><ul><li>定义原子类型 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个"int64_t"的原子类型</span></span><br><span class="line">std::atomic&lt;<span class="keyword">int64_t</span>&gt; value;</span><br></pre></td></tr></tbody></table></figure><ul><li>自加操作（原子）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic提供的特化成员函数，已经重载了++运算符</span></span><br><span class="line">value++</span><br></pre></td></tr></tbody></table></figure><ul><li>读取变量值（原子）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处的原子操作，指的是读取value的值这一步，而不是将value的值赋给x</span></span><br><span class="line"><span class="keyword">int64_t</span> x = value.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br></pre></td></tr></tbody></table></figure><ul><li>更新变量（原子）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> x = <span class="number">10</span>;</span><br><span class="line">value.<span class="built_in">store</span>(x, std::memory_order_relaxed)</span><br></pre></td></tr></tbody></table></figure><h3 id="atomic-不能与-string-一起使用"><a href="#atomic-不能与-string-一起使用" class="headerlink" title="atomic 不能与 string 一起使用"></a>atomic 不能与 string 一起使用</h3><p>特别注意，<code>atomic</code> 关键字不能与 <code>string</code> 类型一起使用，因为 <code>string</code> 不是可简单复制的类型（TriviallyCopyable），详见 <a href="https://en.cppreference.com/w/cpp/atomic/atomic">C++ 参考文档</a>：</p><blockquote><p>The primary std::atomic template may be instantiated with any TriviallyCopyable type T satisfying both CopyConstructible and CopyAssignable.</p></blockquote><hr><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">std::atomic&lt;std::string&gt; str{ <span class="string">"Hello"</span> };</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码编译后，C++ 编译器会出现编译错误，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C2338: atomic&lt;T&gt; requires T to be trivially copyable, copy constructible, move constructible, copy assignable, and move assignable.</span><br></pre></td></tr></tbody></table></figure><p>关于 C++ 编译器为什么会对 <code>std::atomic&lt;std::string&gt;</code> 给出简单的可复制错误，在 <a href="https://stackoverflow.com/questions/58852618/">Stack Overflow</a> 上找到了一个类似的问题可供参考。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://www.cnblogs.com/taiyang-li/p/5914331.html">C++11 新特性之 atomic</a></li><li><a href="https://blog.csdn.net/shaosunrise/article/details/85158249">C++ 智能指针 unique_ptr 详解与示例</a></li><li><a href="https://zhuanlan.zhihu.com/p/91328039">为何优先选用 unique_ptr 而不是裸指针？</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 的进阶基础教程，包括智能指针、atomic 原子操作的介绍等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 使用 API 连接 MySQL 数据库</title>
    <link href="https://www.techgrow.cn/posts/c942e1de.html"/>
    <id>https://www.techgrow.cn/posts/c942e1de.html</id>
    <published>2021-11-24T13:55:33.000Z</published>
    <updated>2021-11-24T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍 C++ 如何使用 MySQL Connector/C++ 的 API 连接 MySQL 数据库，适用于 Windows 系统，MySQL Connector/C++ 的详细介绍可以看<a href="/posts/c942e1de.html#MySQL-Connector-C-%E4%BB%8B%E7%BB%8D">这里</a>。</p><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><table><thead><tr><th>软件</th><th>版本</th><th>默认安装路径</th></tr></thead><tbody><tr><td> MySQL Connector/C++</td><td>1.1.13</td><td>C:\Program Files\MySQL\MySQL Connector C++ 1.1.13</td></tr><tr><td>OpenSSL</td><td>v1.1.1L</td><td>C:\Program Files\OpenSSL-Win64</td></tr><tr><td>boost</td><td>1_77_0</td><td>C:\Program Files\boost_1_77_0</td></tr><tr><td>MySQL Server</td><td>5.7.33</td><td></td></tr><tr><td>C++</td><td>11</td><td></td></tr><tr><td>Visual Studio</td><td>2019</td><td></td></tr><tr><td>Windows System</td><td>Win 10</td><td></td></tr></tbody></table><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="OpenSSL-安装"><a href="#OpenSSL-安装" class="headerlink" title="OpenSSL 安装"></a>OpenSSL 安装</h3><h4 id="安装-OpenSSL"><a href="#安装-OpenSSL" class="headerlink" title="安装 OpenSSL"></a>安装 OpenSSL</h4><p>在 <a href="https://slproweb.com/products/Win32OpenSSL.html">OpenSSL 官网</a> 下载 <code>Win64 OpenSSL v1.1.1L</code> 版本的安装包，下载完成后直接安装，每一步安装步骤选择默认选项即可。OpenSSL 默认的安装路径是 <code>C:\Program Files\OpenSSL-Win64</code>。</p><h4 id="VS-项目添加-OpenSSL-的-库文件"><a href="#VS-项目添加-OpenSSL-的-库文件" class="headerlink" title="VS 项目添加 OpenSSL 的 库文件"></a>VS 项目添加 OpenSSL 的 库文件</h4><p>OpenSSL 安装完成之后，将其安装目录下的 <code>bin</code> 文件夹中的 <code>libssl-1_1-x64.dll</code> 和 <code>libcrypto-1_1-x64.dll</code> 库文件拷贝到 VS 项目的目录中，如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-mysql-5.png"></p><h4 id="VS-项目引入-OpenSSL-的-头文件"><a href="#VS-项目引入-OpenSSL-的-头文件" class="headerlink" title="VS 项目引入 OpenSSL 的 头文件"></a>VS 项目引入 OpenSSL 的 头文件</h4><p>右键项目，选择 <code>属性</code>，导航到 <code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code>，添加 OpenSSL 头文件所在的目录路径（如 <code>C:\Program Files\OpenSSL-Win64\include</code>），如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-mysql2.png"></p><h3 id="MySQL-Connector-C-安装"><a href="#MySQL-Connector-C-安装" class="headerlink" title="MySQL Connector/C++ 安装"></a>MySQL Connector/C++ 安装</h3><h4 id="安装-MySQL-Connector-C"><a href="#安装-MySQL-Connector-C" class="headerlink" title="安装 MySQL Connector/C++"></a>安装 MySQL Connector/C++</h4><p>在 <a href="https://dev.mysql.com/downloads/connector/cpp/">MySQL 官网</a> 上下载 <code>1.1.13</code> 版本的 MySQL Connector/C++，下载完成后直接安装即可。若已经本地已经安装过 MySQL Server，则不再需要手动安装 MySQL Connector/C++，因为默认已经安装过了，但需要留意 MySQL Connector/C++ 与 MySQL 的版本是否匹配 。值得一提的是，MySQL Connector/C++ 支持多个版本共存（同时安装不同的版本），其默认的安装路径为 <code>C:\Program Files\MySQL\Connector.C++ 1.x</code>。</p><h4 id="VS-项目添加-MySQL-Connector-C-的-库文件"><a href="#VS-项目添加-MySQL-Connector-C-的-库文件" class="headerlink" title="VS 项目添加 MySQL Connector/C++ 的 库文件"></a>VS 项目添加 MySQL Connector/C++ 的 库文件</h4><p>MySQL Connector/C++ 安装完成后，将其安装目录下 <code>lib/opt</code> 文件夹中的 <code>mysqlcppconn.dll</code> 与 <code>mysqlcppconn.lib</code> 库文件拷贝到 VS 项目的目录中，如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-mysql-1.png"></p><h4 id="VS-项目引入-MySQL-Connector-C-的头文件"><a href="#VS-项目引入-MySQL-Connector-C-的头文件" class="headerlink" title="VS 项目引入 MySQL Connector/C++ 的头文件"></a>VS 项目引入 MySQL Connector/C++ 的头文件</h4><p>右键项目，选择 <code>属性</code>，导航到 <code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code>，添加 MySQL Connector/C++ 头文件所在的目录路径（如 <code>C:\Program Files\MySQL\MySQL Connector C++ 1.1.13\include</code>），如下图所示：</p><p><img data-src="../../../asset/2021/11/cplusplus-mysql-2.png"></p><h2 id="C-连接-MySQL-的实战案例"><a href="#C-连接-MySQL-的实战案例" class="headerlink" title="C++ 连接 MySQL 的实战案例"></a>C++ 连接 MySQL 的实战案例</h2><h3 id="MySQL-数据库初始化"><a href="#MySQL-数据库初始化" class="headerlink" title="MySQL 数据库初始化"></a>MySQL 数据库初始化</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `t_shop`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `t_shop` <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line">USE `t_shop`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 创建数据库表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `properties`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `properties` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `KEY` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="keyword">VALUE</span>` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `REMARK` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `key_unique_index` (`KEY`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">27</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 往数据库表插入数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_price'</span>, <span class="string">'30.5'</span>, <span class="string">'限制价格'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_number'</span>, <span class="string">'430'</span>, <span class="string">'限制数量'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `properties` (`KEY`, `<span class="keyword">VALUE</span>`, `REMARK`) <span class="keyword">VALUES</span> (<span class="string">'test_limit_balance'</span>, <span class="string">'929.32'</span>, <span class="string">'限制余额'</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="C-连接-MySQL-的代码"><a href="#C-连接-MySQL-的代码" class="headerlink" title="C++ 连接 MySQL 的代码"></a>C++ 连接 MySQL 的代码</h3><ul><li>mysqldb.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql_connection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/driver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/exception.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/resultset.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/statement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppconn/prepared_statement.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sql;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL数据库操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlDB</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MysqlDB</span>(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string database);</span><br><span class="line">~<span class="built_in">MysqlDB</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ExecuteUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">Query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* query, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string host;</span><br><span class="line">string username;</span><br><span class="line">string password;</span><br><span class="line">string database;</span><br><span class="line">Driver* driver;</span><br><span class="line">unique_ptr&lt;Connection&gt; connection;  <span class="comment">// 智能指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>mysqldb.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysqldb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MysqlDB::<span class="built_in">MysqlDB</span>(<span class="keyword">const</span> string host, <span class="keyword">const</span> string username, <span class="keyword">const</span> string password, <span class="keyword">const</span> string database) {</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化MySQL的连接信息</span></span><br><span class="line"><span class="keyword">this</span>-&gt;host = host;</span><br><span class="line"><span class="keyword">this</span>-&gt;username = username;</span><br><span class="line"><span class="keyword">this</span>-&gt;password = password;</span><br><span class="line"><span class="keyword">this</span>-&gt;database = database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">// 加载MySQL驱动</span></span><br><span class="line"><span class="keyword">this</span>-&gt;driver = <span class="built_in">get_driver_instance</span>();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;driver) {</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"failed to load mysql driver"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接MySQL实例</span></span><br><span class="line"><span class="keyword">this</span>-&gt;connection.<span class="built_in">reset</span>(driver-&gt;<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;host.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;username.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;password.<span class="built_in">c_str</span>()));</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;connection) {</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"failed to connect mysql server"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="comment">// 设置默认数据库</span></span><br><span class="line"><span class="keyword">this</span>-&gt;connection-&gt;<span class="built_in">setSchema</span>(<span class="keyword">this</span>-&gt;database.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SQLException&amp; e) {</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: SQLException in "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">"("</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">") on line "</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MysqlDB::~<span class="built_in">MysqlDB</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行任何 SQL 语句，返回一个 bool 值，表明执行该 SQL 语句是否返回了 ResultSet</span></span><br><span class="line"><span class="comment">// 如果执行后第一个结果是 ResultSet，则返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MysqlDB::Execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;connection) {</span><br><span class="line">unique_ptr&lt;Statement&gt; statement = <span class="literal">nullptr</span>;</span><br><span class="line">statement.<span class="built_in">reset</span>(<span class="keyword">this</span>-&gt;connection-&gt;<span class="built_in">createStatement</span>());</span><br><span class="line"><span class="keyword">if</span> (statement)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> statement-&gt;<span class="built_in">execute</span>(sql);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SQLException&amp; e) {</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: SQLException in "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">"("</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">") on line "</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE</span></span><br><span class="line"><span class="comment">// 函数的返回值是一个整数，指示受影响的行数，对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，返回值总为零</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MysqlDB::ExecuteUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;connection) {</span><br><span class="line">unique_ptr&lt;Statement&gt; statement = <span class="literal">nullptr</span>;</span><br><span class="line">statement.<span class="built_in">reset</span>(<span class="keyword">this</span>-&gt;connection-&gt;<span class="built_in">createStatement</span>());</span><br><span class="line"><span class="keyword">if</span> (statement)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> statement-&gt;<span class="built_in">executeUpdate</span>(sql);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SQLException&amp; e) {</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: SQLException in "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">"("</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">") on line "</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 SQL 的预编译机制，执行查询单个结果集（ResultSet）的 SQL 语句，例如 SELECT 语句</span></span><br><span class="line"><span class="function">unique_ptr&lt;ResultSet&gt; <span class="title">MysqlDB::Query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql, <span class="keyword">const</span> vector&lt;string&gt; parameters)</span> </span>{</span><br><span class="line">unique_ptr&lt;ResultSet&gt; resultSet = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;connection) {</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">unique_ptr&lt;PreparedStatement&gt; statement = <span class="literal">nullptr</span>;</span><br><span class="line">statement.<span class="built_in">reset</span>(<span class="keyword">this</span>-&gt;connection-&gt;<span class="built_in">prepareStatement</span>(sql));</span><br><span class="line"><span class="keyword">if</span> (statement) {</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iterator = parameters.<span class="built_in">cbegin</span>(); iterator != parameters.<span class="built_in">cend</span>(); iterator++) {</span><br><span class="line">index++;</span><br><span class="line">statement-&gt;<span class="built_in">setString</span>(index, (*iterator).<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line">resultSet.<span class="built_in">reset</span>(statement-&gt;<span class="built_in">executeQuery</span>());</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SQLException&amp; e) {</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: SQLException in "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">"("</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">") on line "</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"# ERR: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> resultSet;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysqldb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">unique_ptr&lt;MysqlDB&gt; <span class="title">db</span><span class="params">(<span class="keyword">new</span> MysqlDB(<span class="string">"tcp://127.0.0.1:3306"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>, <span class="string">"t_shop"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">string querySql = <span class="string">"select * from properties where `KEY` = ?"</span>;</span><br><span class="line">unique_ptr&lt;ResultSet&gt; result = db-&gt;<span class="built_in">Query</span>(querySql.<span class="built_in">c_str</span>(), { <span class="string">"test_limit_price"</span> });</span><br><span class="line"><span class="keyword">if</span> (result) {</span><br><span class="line">cout &lt;&lt; <span class="string">"Query: "</span> &lt;&lt; querySql &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (result-&gt;<span class="built_in">next</span>()) {</span><br><span class="line">cout &lt;&lt; result-&gt;<span class="built_in">getInt</span>(<span class="string">"ID"</span>) &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"KEY"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"VALUE"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">cout &lt;&lt; result-&gt;<span class="built_in">getString</span>(<span class="string">"REMARK"</span>).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query: select * from properties where `KEY` = ?</span><br><span class="line">27 | test_limit_price | 30.5 | 限制价格 |</span><br></pre></td></tr></tbody></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="缺失-Boost-库"><a href="#缺失-Boost-库" class="headerlink" title="缺失 Boost 库"></a>缺失 Boost 库</h3><p>错误信息：</p><ul><li>项目执行编译操作后，VS 出现下述错误信息，这是本地缺失 <code>boost</code> 库导致的。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error C1083: 无法打开包括文件: “boost/shared_ptr.hpp”: No such file or directory</span><br></pre></td></tr></tbody></table></figure></li></ul><p>解决方法：</p><ul><li>a) 在 <a href="https://www.boost.org/users/download/">Boost 官网</a> 下载最新版本的 <code>Boost</code>，并解压到本地磁盘，例如解压路径为：<code>C:\Program Files\boost_1_77_0</code></li><li>b) 右键项目，选择 <code>属性</code>，导航到 <code>配置属性</code> -&gt; <code>C/C++</code> -&gt; <code>常规</code> -&gt; <code>附加包含目录</code>，添加 <code>Boost</code> 的安装路径（如 <code>C:\Program Files\boost_1_77_0</code>），如下图所示</li><li> c) 重新执行项目的编译操作</li></ul><p><img data-src="../../../asset/2021/11/cplusplus-mysql-3.png"></p><h3 id="缺失-libssl-1-1-64-dll-文件"><a href="#缺失-libssl-1-1-64-dll-文件" class="headerlink" title="缺失 libssl-1_1-64.dll 文件"></a>缺失 libssl-1_1-64.dll 文件</h3><p>错误信息：</p><ul><li>项目运行后，系统弹窗提示以下错误信息。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于找不到 libssl-1_1-64.dll，无法继续执行代码。重新安装程序可能会解决此问题。</span><br></pre></td></tr></tbody></table></figure></li></ul><p>解决方法：</p><ul><li>安装 OpenSSL，并拷贝 <code>libssl-1_1-64.dll</code> 库文件到 VS 项目的目录中，具体步骤可参考上面的 <a href="/posts/c942e1de.html#OpenSSL-%E5%AE%89%E8%A3%85">OpenSSL - 安装</a> 教程。</li></ul><h3 id="缺失-libcrypto-1-1-x64-dll-文件"><a href="#缺失-libcrypto-1-1-x64-dll-文件" class="headerlink" title="缺失 libcrypto-1_1-x64.dll 文件"></a>缺失 libcrypto-1_1-x64.dll 文件</h3><p>错误信息：</p><ul><li>项目运行后，系统弹窗提示以下错误信息。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于找不到 libcrypto-1_1-x64.dll，无法继续执行代码。重新安装程序可能会解决此问题。</span><br></pre></td></tr></tbody></table></figure></li></ul><p>解决方法：</p><ul><li>安装 OpenSSL，并拷贝 <code>libcrypto-1_1-x64.dll</code> 库文件到 VS 项目的目录中，具体步骤可参考上面的 <a href="/posts/c942e1de.html#OpenSSL-%E5%AE%89%E8%A3%85">OpenSSL - 安装</a> 教程。</li></ul><h2 id="MySQL-Connector-C-介绍"><a href="#MySQL-Connector-C-介绍" class="headerlink" title="MySQL Connector/C++ 介绍"></a>MySQL Connector/C++ 介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://dev.mysql.com/doc/connector-cpp/1.1/en/connector-cpp-introduction.html">MySQL Connector/C++</a> 是一个 MySQL 数据库连接器，包含了 C++ 连接 MySQL 服务器所需的头文件和库文件，支持开发使用基于 JDBC 的 API 的 C++ 应用程序。</p><h3 id="开发优势"><a href="#开发优势" class="headerlink" title="开发优势"></a>开发优势</h3><p>与 MySQL 客户端库提供的 MySQL C 语言 API 相比，MySQL Connector/C++ 为 C++ 用户提供以下好处：</p><ul><li>纯 C++ 开发的便利</li><li>支持基于 JDBC 4.0 的 API</li><li> 支持面向对象的编程范式</li><li>减少项目的开发时间</li><li>可根据要求获得商业许可证</li><li>根据 GPL 获得许可，但 FLOSS 许可除外</li></ul><h3 id="分发方式"><a href="#分发方式" class="headerlink" title="分发方式"></a>分发方式</h3><p>MySQL Connector/C++ 有二进制文件和源代码分发版以特定于平台的打包格式提供：</p><ul><li>二进制分发版可用于 Windows、Linux、Unix 和类 Unix 平台</li><li>源代码分发版可作为压缩的 <code>tar</code> 文件或 <code>zip</code> 文件提供，并可在任何受支持的平台上使用</li><li>源代码存储库使用 Git 存储，可在 <a href="https://github.com/mysql/mysql-connector-cpp">GitHub</a> 上获得。</li></ul><h3 id="与-JDBC-的兼容性"><a href="#与-JDBC-的兼容性" class="headerlink" title="与 JDBC 的兼容性"></a>与 JDBC 的兼容性</h3><p>MySQL Connector/C++ 与 JDBC 4.0 API 兼容，没有实现整个 JDBC 4.0 API，但具有以下类：Connection、DatabaseMetaData、Driver、PreparedStatement、ResultSet、ResultSetMetaData、Savepoint、Statement。JDBC 4.0 API 为刚才提到的类定义了大约 450 个方法，MySQL Connector/C++ 实现了其中的大约 80%。</p><h3 id="支持的平台和先决条件"><a href="#支持的平台和先决条件" class="headerlink" title="支持的平台和先决条件"></a>支持的平台和先决条件</h3><p>对于 MySQL Connector/C++ 1.1.11 及更高版本，商业和社区发行版需要 Visual C++ Redistributable for Visual Studio 2015 才能在 Windows 平台上运行。从 MySQL Connector/C++ 1.1.10 开始，社区（非商业）发行版需要适用于 Visual Studio 2013 的 Visual C++ Redistributable。可在 <a href="http://www.microsoft.com/en-us/download/default.aspx">Microsoft 下载中心</a>获取 Redistributable 的安装包，在安装 MySQL Connector/C++ 之前安装它。</p><ul><li><p>要运行带 MySQL Connector/C++ 的应用程序，需要 MySQL 5.6 或更高版本的数据库服务器</p></li><li><p>要构建带 MySQL Connector/C++ 的应用程序</p><ul><li>在 Windows 系统上，需要 Microsoft Visual Studio 2015</li></ul></li><li><p> 要从源代码构建 MySQL Connector/C++</p><ul><li>在 Windows 系统上，需要 Microsoft Visual Studio 2015</li><li>Building Connector/C++ 需要 MySQL 5.7（5.7.9 或更高版本）或 MySQL 8.0（8.0.11 或更高版本）的客户端库</li></ul></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/daelsepara/mysql-connector-demo">mysql-connector-demo</a></li><li><a href="https://dev.mysql.com/doc/connector-cpp/1.1/en/">MySQL Connector/C++ 官方文档</a></li><li><a href="https://github.com/mysql/mysql-connector-cpp">MySQL Connector/C++ Github 仓库</a></li><li><a href="https://dev.mysql.com/doc/connector-cpp/1.1/en/connector-cpp-getting-started-examples.html">MySQL Connector/C++ 官方 API 使用教程</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 如何使用 MySQL Connector/C++ 的 API 连接 MySQL 数据库。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之九</title>
    <link href="https://www.techgrow.cn/posts/f1a16291.html"/>
    <id>https://www.techgrow.cn/posts/f1a16291.html</id>
    <published>2021-11-19T13:55:33.000Z</published>
    <updated>2021-11-21T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h2><h3 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h3><ul><li>当类中声明了虚函数时，编译器会在类中生成一个虚函数表</li><li>虚函数表是一个存储类成员函数指针的数据结构</li><li>虚函数表是由编译器自动生成和维护的</li><li>虚函数（<code>virtual</code>）会被编译器放入虚函数表中</li><li>当存在虚函数时，每个对象中都有一个指向虚函数表的指针（C++ 编译器给父类对象、子类对象提前设置了 <code>VPTR</code> 虚函数表指针，因此 C++ 编译器不需要区分子类对象或者父类对象，只需要在 <code>base</code> 指针中，找 <code>VPTR</code> 指针即可）</li><li><code>VPTR</code> 虚函数表指针一般作为类对象的第一个成员</li></ul><span id="more"></span><h3 id="多态的实现原理图解"><a href="#多态的实现原理图解" class="headerlink" title="多态的实现原理图解"></a>多态的实现原理图解</h3><ul><li>a) 多态实现原理的图解 <a href="../../../asset/2021/11/cplusplus-virtual-1.png">如图</a> 所示</li><li> b) 通过 <code>VPTR</code> 虚函数表指针调用重写函数的过程是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数，而普通成员函数是在编译时就确定了调用的函数</li><li> c) 在效率上，虚函数的效率要低很多，因此出于效率考虑，没有必要将所有成员函数都声明为虚函数，即使 C++ 编译器允许这么做</li><li> d) 由于有了虚函数表，C++ 编译器不再需要知道是子类对象还是父类对象，这往往会给我们造成一种假象：C++ 编译器能识别子类对象或者父类对象</li></ul><h3 id="证明-VPTR-指针的存在"><a href="#证明-VPTR-指针的存在" class="headerlink" title="证明 VPTR 指针的存在"></a>证明 <code>VPTR</code> 指针的存在</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent1</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不声明虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent1"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent2</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent2"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 由于指针也是一种数据类型，由于在Parent2类中声明了虚函数，若Parent2类里存在VPTR指针，那么下面两个类的大小应该是不一样的</span></span><br><span class="line">cout &lt;&lt; <span class="string">"sizeof(Parent1): "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Parent1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"sizeof(Parent2): "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Parent2) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Parent1): 4</span><br><span class="line">sizeof(Parent2): 8</span><br></pre></td></tr></tbody></table></figure><h3 id="父类指针和子类指针的步长可能是不一样的"><a href="#父类指针和子类指针的步长可能是不一样的" class="headerlink" title="父类指针和子类指针的步长可能是不一样的"></a>父类指针和子类指针的步长可能是不一样的</h3><ul><li>a) 指针也只一种数据类型，对 C++ 类对象的指针执行 <code>++</code>、<code>--</code> 运算符仍然是合法的</li><li> b) <code>"多态是用父类的指针指向子类的对象"</code> 和 <code>"父类指针步长的自加（++）"</code> 是两个完全不同的概念</li><li> c) 当子类继承父类后，没有添加任何自己的成员变量和成员函数，那么此时父类指针和子类指针的步长才是一样的</li><li> d) 指针运算是按照指针所指的类型进行的，父类指针和子类指针的步长可能是不一样的，不要用父类指针自加（<code>++</code>）、自减（<code>--</code>）的方式来操作子类的对象数组 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a = <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> b, <span class="keyword">int</span> c) :<span class="built_in">Parent</span>(<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Parent* parent = <span class="literal">NULL</span>;</span><br><span class="line">Child* child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Child  array[] = { <span class="built_in">Child</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">Child</span>(<span class="number">3</span>,<span class="number">4</span>), <span class="built_in">Child</span>(<span class="number">5</span>, <span class="number">6</span>) };</span><br><span class="line">parent = array;</span><br><span class="line">child = array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针自加运算后运行可能会出错，这里父类指针和子类指针的步长是不一样的，不要用父类指针自加（`++`）、自减（`--`）的方式来操作子类的对象数组</span></span><br><span class="line">parent++;</span><br><span class="line">child++;</span><br><span class="line"></span><br><span class="line">parent++;</span><br><span class="line">child++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="在父类的构造函数中调用虚函数，不能实现多态"><a href="#在父类的构造函数中调用虚函数，不能实现多态" class="headerlink" title="在父类的构造函数中调用虚函数，不能实现多态"></a>在父类的构造函数中调用虚函数，不能实现多态</h3><p>子类的 <code>VPTR</code> 指针是分步完成初始化的，当执行父类的构造函数时，子类 的 <code>VPTR</code> 指针指向父类的虚函数表，当父类的构造函数执行完毕后，才会把子类的 <code>VPTR</code> 指针指向子类的虚函数表。因此，<strong>在父类的构造函数中调用虚函数，不能实现多态</strong>。</p><ul><li>a) 分析图解 <a href="../../../asset/2021/11/cplusplus-virtual-2.png">如图</a> 所示</li><li> b) 对象在创建的时，由编译器对 <code>VPTR</code> 指针进行初始化</li><li> c) 只有当对象的构造全部完成后，<code>VPTR</code> 指针的指向才能最终确定 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="comment">// 在父类的构造函数中调用虚函数</span></span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> c) : <span class="built_in">Parent</span>(a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">5</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I'm parent, a = 5</span><br></pre></td></tr></tbody></table></figure><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><h3 id="纯虚函数和抽象类的基本概念"><a href="#纯虚函数和抽象类的基本概念" class="headerlink" title="纯虚函数和抽象类的基本概念"></a>纯虚函数和抽象类的基本概念</h3><p>基本概念：</p><ul><li>a) 纯虚函数是一个在基类中说明的虚函数，且在基类中没有被定义，要求任何派生类都定义自己的版本</li><li> b) 纯虚函数为各派生类提供一个公共界面，可以实现接口的封装和设计、软件的模块功能划分</li><li> c) 纯虚函数的声明形式： <code>virtual  类型  函数名 ( 参数表 ) = 0;</code></li><li>d) 一个具有纯虚函数的基类称为抽象类</li></ul><p>使用限制：</p><ul><li>a) 可以声明抽象类的指针和引用</li><li> b) 抽象类不能创建对象（实例化）</li><li>c) 抽象类不能作为函数的参数类型和返回值类型</li></ul><p><img data-src="../../../asset/2021/11/cplusplus-virtual-3.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-virtual-4.png"></p><h3 id="纯虚函数和抽象类的应用案例"><a href="#纯虚函数和抽象类的应用案例" class="headerlink" title="纯虚函数和抽象类的应用案例"></a>纯虚函数和抽象类的应用案例</h3><p>定义一个图形抽象类 Figure，并声明了负责计算图形面积的纯虚函数 <code>getArea()</code>，然后再定义 Circle、Triangle、Squre 派生类，并各自实现了纯虚函数 <code>getArea()</code> 来计算不同图形的面积。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 声明纯虚函数，计算面积</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Circle</span>(<span class="keyword">double</span> r) {</span><br><span class="line"><span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算圆的面积</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">double</span> area = <span class="number">3.14</span> * r * r;</span><br><span class="line">cout &lt;&lt; <span class="string">"圆的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Triangle</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算三角形的面积</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">double</span> area = a * b / <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"三角形的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> :</span> <span class="keyword">public</span> Figure {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Square</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算四边形的面积</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">double</span> area = a * b;</span><br><span class="line">cout &lt;&lt; <span class="string">"四边形的面积: "</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArea</span><span class="params">(Figure* base)</span> </span>{</span><br><span class="line">base-&gt;<span class="built_in">getArea</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// Figure f;// 错误写法，抽象类不能实例化</span></span><br><span class="line"></span><br><span class="line"><span class="function">Triangle <span class="title">Triangle</span><span class="params">(<span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">6.8</span>)</span></span>;</span><br><span class="line"><span class="function">Square <span class="title">square</span><span class="params">(<span class="number">50</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以声明抽象类的指针</span></span><br><span class="line">Figure* pBase = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">5.3</span>);</span><br><span class="line">pBase-&gt;<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以声明抽象类的引用</span></span><br><span class="line">Figure&amp; base = square;</span><br><span class="line">base.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printArea</span>(&amp;Triangle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">圆的面积: 88.2026</span><br><span class="line">四边形的面积: 3000</span><br><span class="line">三角形的面积: 300</span><br></pre></td></tr></tbody></table></figure><h3 id="纯虚函数和抽象类在多继承中的应用案例"><a href="#纯虚函数和抽象类在多继承中的应用案例" class="headerlink" title="纯虚函数和抽象类在多继承中的应用案例"></a>纯虚函数和抽象类在多继承中的应用案例</h3><p>C++ 中没有 Java 中的接口概念，但可以使用抽象类和纯虚函数模拟 Java 中的接口（代码如下）。值得一提的是，C++ 中的接口类只有函数原型定义，没有任何数据的定义，同时继承多个接口类不会带来二义性和复杂性等问题。C++ 面向抽象类编程（Java 面向接口编程）是项目开发中重要技能之一。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口类一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口类二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>() {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = <span class="number">8</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Parent</span>() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类，首先继承父类，然后继承多个接口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent, <span class="keyword">public</span> Interface1, <span class="keyword">public</span> Interface2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"Child::print() 函数被执行"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Child child;</span><br><span class="line">child.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Parent* parent = &amp;child;</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; parent-&gt;<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Interface1* interface1 = &amp;child;</span><br><span class="line"><span class="keyword">int</span> result1 = interface1-&gt;<span class="built_in">add</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"2 + 5 = "</span> &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Interface2* interface2 = &amp;child;</span><br><span class="line"><span class="keyword">int</span> result2 = interface2-&gt;<span class="built_in">mult</span>(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"3 * 6 = "</span> &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 8</span><br><span class="line">2 + 5 = 7</span><br><span class="line">3 * 6 = 18</span><br></pre></td></tr></tbody></table></figure><h3 id="纯虚函数和抽象类在多继承中的使用总结"><a href="#纯虚函数和抽象类在多继承中的使用总结" class="headerlink" title="纯虚函数和抽象类在多继承中的使用总结"></a>纯虚函数和抽象类在多继承中的使用总结</h3><p>C++ 中没有 Java 中的接口概念：</p><ul><li>绝大多数面向对象语言都不支持多继承</li><li>绝大多数面向对象语言都支持接口的概念 </li><li>C++ 中没有 Java 中的接口概念，但可以使用抽象类和纯虚函数模拟 Java 中的接口</li><li> C++ 中的接口类只有函数原型定义，没有任何数据的定义（代码如下）<details><summary>★点击显示示例代码★</summary><code><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface</span>  </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>; </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></code></details></li></ul><p>工程上多继承的使用说明：</p><ul><li>a) 多继承已经被实际开发经验所抛弃</li><li> b) 工程开发中真正意义上的多继承是几乎不被使用的</li><li> c) 多继承带来的代码复杂性远多于其带来的便利</li><li> d) 多继承对代码维护性上的影响是灾难性的</li><li> e) 在设计方法上，任何多继承都可以使用单继承代替</li><li> f) 在多继承中，使用虚继承不能完全解决二义性的问题<ul><li><a href="/posts/4c2ae4c0.html#%E8%99%9A%E7%BB%A7%E6%89%BF">虚继承的使用与适用场景介绍</a></li><li>虚继承只适用于有共同基类（公共基类）的多继承场景（钻石菱形 ◇），如<a href="../../../asset/2021/11/cplusplus-extends-17.png">右图</a>所示</li><li>对于 <code>V</code> 字形的多继承场景，虚继承是没办法解决二义性问题的，如<a href="../../../asset/2021/11/cplusplus-extends-21.png">右图</a>所示</li></ul></li></ul><p>工程上继承多个接口类的使用说明：</p><ul><li>a) 继承多个接口类不会带来二义性和复杂性等问题</li><li> b) 多继承可以通过精心设计的单继承和接口类来代替</li><li> c) 接口类只是一个功能说明，而不是功能实现，子类需要根据功能说明定义功能实现</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括多态原理、纯虚函数与抽象类、VPTR 虚函数表指针的介绍等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之八</title>
    <link href="https://www.techgrow.cn/posts/4c2ae4c0.html"/>
    <id>https://www.techgrow.cn/posts/4c2ae4c0.html</id>
    <published>2021-11-17T13:55:33.000Z</published>
    <updated>2021-11-18T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><h3 id="多继承概念"><a href="#多继承概念" class="headerlink" title="多继承概念"></a>多继承概念</h3><ul><li><p>a) 一个类有多个直接基类（父类）的继承关系称为多继承</p></li><li><p>b) 类 C 可以根据访问控制同时继承类 A 和类 B 的成员，并添加自己的成员</p></li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-12.png"></p><span id="more"></span><ul><li>c) 多继承声明语法 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class  派生类名 : 访问控制  基类名1 ,  访问控制  基类名2 ,  … , 访问控制  基类名n</span><br><span class="line">{</span><br><span class="line">数据成员和成员函数声明</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="多继承的简单应用"><a href="#多继承的简单应用" class="headerlink" title="多继承的简单应用"></a>多继承的简单应用</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-13.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>(<span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : <span class="built_in">Base1</span>(a), <span class="built_in">Base2</span>(b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Base3 <span class="title">base</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">base.<span class="built_in">printA</span>();</span><br><span class="line">base.<span class="built_in">printB</span>();</span><br><span class="line">base.<span class="built_in">printC</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">c = 3</span><br></pre></td></tr></tbody></table></figure><h3 id="派生类的构造函数和成员访问"><a href="#派生类的构造函数和成员访问" class="headerlink" title="派生类的构造函数和成员访问"></a>派生类的构造函数和成员访问</h3><p>在多继承的派生类中，其构造函数和成员访问的特性如下：</p><ul><li>拥有多个基类的派生类的构造函数，可以用初始化列表调用基类构造函数来初始化数据成员。</li><li>执行顺序与单继承构造函数情况类似，多个直接基类构造函数执行顺序取决于定义派生类时指定的各个继承基类的顺序。</li><li>一个派生类对象拥有多个直接或间接基类的成员。不同名成员访问不会出现二义性，如果不同的基类有同名成员，那么派生类对象访问时应该加以识别。</li></ul><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><h3 id="虚继承的概念"><a href="#虚继承的概念" class="headerlink" title="虚继承的概念"></a>虚继承的概念</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-14.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-15.png"></p><p>总结：</p><ul><li>如果一个派生类从多个基类继承，而这些基类又有一个共同的基类（公共基类），则在对该基类中声明的成员进行访问时，可能会产生二义性。</li><li>如果在多条继承路径上有一个公共的基类，那么在继承路径的某处汇合点，这个公共基类就会在派生类的对象中产生多个基类子对象</li><li>要使这个公共基类在派生类中只产生一个子对象，必须对这个基类声明为虚继承，使这个基类成为 <code>虚基类</code>。</li><li>虚继承声明需要使用关键字：<code>virtual</code></li></ul><h3 id="虚继承的简单应用"><a href="#虚继承的简单应用" class="headerlink" title="虚继承的简单应用"></a>虚继承的简单应用</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-16.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>(<span class="keyword">int</span> x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">cout &lt;&lt; <span class="string">"Base 类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"x = "</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">virtual</span>  <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>(<span class="keyword">int</span> b, <span class="keyword">int</span> x) : <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 由于父类和虚基类没有默认的无参构造函数，所以这里的派生类需要在初始化列表中，显式调用父类、虚基类的有参构造函数</span></span><br><span class="line"><span class="built_in">Base3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> x) : <span class="built_in">Base1</span>(a, x), <span class="built_in">Base2</span>(b, x), <span class="built_in">Base</span>(x) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Base3 <span class="title">base</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;  <span class="comment">// 虚基类Base的构造函数只会被调用一次</span></span><br><span class="line">base.<span class="built_in">printA</span>();</span><br><span class="line">base.<span class="built_in">printB</span>();</span><br><span class="line">base.<span class="built_in">printC</span>();</span><br><span class="line">base.<span class="built_in">printX</span>();<span class="comment">// 当不声明虚继承的时候，此写法会产生二义性，C++编译器会出现编译错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base 类的构造函数被调用</span><br><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">c = 3</span><br><span class="line">x = 4</span><br></pre></td></tr></tbody></table></figure><p>值得一提的是，如果虚基类声明了非默认形式的（即带参数的）构造函数，并且没有声明默认形式的（无参）构造函数，此时在整个继承关系中，直接或者间接继承虚基类的所有派生类，都必须在构造函数的成员初始化列表中列出对虚基类的初始化。因为涉及到多重继承和虚继承，为避免派生类因调用多个父类的构造函数后多次构造更上层虚基类，所以需要派生类自己显示调用继承而来的虚基类的构造函数，而继承链上其它所有对虚基类的构造函数调用将被忽略。简单一句话概况：<strong>父类不会帮子类调用虚基类的构造函数，子类在构造时必须自己初始化所有虚基类。</strong></p><h3 id="虚继承的适用场景"><a href="#虚继承的适用场景" class="headerlink" title="虚继承的适用场景"></a>虚继承的适用场景</h3><ul><li>虚继承只适用于有共同基类（公共基类）的多继承场景（钻石菱形 ◇），如<a href="../../../asset/2021/11/cplusplus-extends-17.png">右图</a>所示</li><li>对于 <code>V</code> 字形的多继承场景（代码如下），虚继承是没办法解决二义性问题的，如<a href="../../../asset/2021/11/cplusplus-extends-21.png">右图</a>所示 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>(<span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base1, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2 {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base3</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : <span class="built_in">Base1</span>(a), <span class="built_in">Base2</span>(b) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Base3 <span class="title">base</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承只适用于有共同基类（公共基类）的多继承场景（钻石菱形 ◇）</span></span><br><span class="line"><span class="comment">// 即使上面声明了虚继承，但此写法仍然会产生二义性，C++编译器会出现编译错误</span></span><br><span class="line"><span class="comment">// base.print();</span></span><br><span class="line"></span><br><span class="line">base.Base1::<span class="built_in">print</span>();</span><br><span class="line">base.Base2::<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = 2</span><br></pre></td></tr></tbody></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是面向对象的三大概念（如下）之一，按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会使用到多态。C++ 的多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。值得一提的是，多态是设计模式的基础，同时也是框架的基石。</p><ul><li><code>封装</code>：突破了 C 语言函数的概念。</li><li><code>继承</code>：提高了代码的可重用性。</li><li><code>多态</code>：多态是指在不同继承关系的类对象中，去调同一函数，产生了不同的行为。多态的一般使用方式，是使用一个父类的指针或引用去调用子类中被重写的方法。</li></ul><h3 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h3><h4 id="函数重写的概念"><a href="#函数重写的概念" class="headerlink" title="函数重写的概念"></a>函数重写的概念</h4><ul><li>函数重写是指在子类中定义与父类中原型相同的函数</li><li>父类中被重写的函数依然会继承给子类</li><li>默认情况下，在子类中重写的函数将隐藏父类中的函数</li><li>通过作用域分辨符 <code>::</code> 可以访问到父类中被隐藏的函数</li><li>函数重写只发生在父类与子类之间，而函数重载只发生在同一个类中</li></ul><h4 id="函数重写的应用"><a href="#函数重写的应用" class="headerlink" title="函数重写的应用"></a>函数重写的应用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> c) : <span class="built_in">Parent</span>(a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类重写父类中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">3</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行子类的函数，默认情况下子类中重写的函数将隐藏父类中的函数</span></span><br><span class="line">child.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行父类的函数，通过作用域分辨符"::"可以访问到父类中被隐藏的函数</span></span><br><span class="line">child.Parent::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I'm child, c = 7</span><br><span class="line">I'm parent, a = 3</span><br></pre></td></tr></tbody></table></figure><h4 id="函数重写与函数重载的区别"><a href="#函数重写与函数重载的区别" class="headerlink" title="函数重写与函数重载的区别"></a>函数重写与函数重载的区别</h4><ul><li><p>函数重载</p><ul><li>必须在同一个类中进行</li><li>子类无法重载父类的函数，父类同名函数将被子类的覆盖</li><li>重载是在编译期间根据参数类型、个数和顺序决定函数的调用</li></ul></li><li><p>函数重写</p><ul><li>必须发生于父类与子类之间</li><li>父类与子类中的函数必须有完全相同的原型</li><li>使用 <code>virtual</code> 关键字声明之后，能够产生多态（如果不使用 <code>virtual</code> 关键字声明，那叫重定义）</li></ul></li></ul><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h4 id="类型兼容原则遇上函数重写"><a href="#类型兼容原则遇上函数重写" class="headerlink" title="类型兼容原则遇上函数重写"></a>类型兼容原则遇上函数重写</h4><p>当 <a href="/posts/e4826e2c.html#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E5%8E%9F%E5%88%99">类型兼容原则</a> 遇上函数重写时，执行以下代码后会出现意外的现象，即被调用的永远是父类的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> c) : <span class="built_in">Parent</span>(c) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类重写父类中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Parent* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Parent <span class="title">parent</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行父类的函数</span></span><br><span class="line">p = &amp;parent;</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行父类的函数</span></span><br><span class="line">p = &amp;child;</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I'm parent, a = 6</span><br><span class="line">I'm parent, a = 5</span><br></pre></td></tr></tbody></table></figure><p>C/C++ 是静态编译型语言，在执行编译时，编译器会自动根据指针的类型判断指向的是一个什么样的对象。但在编译 <code>print()</code> 函数的时候，编译器不可能知道指针 <code>p</code> 究竟指向了什么对象，因为程序还没有运行。同时编译译器没有理由报错，于是编译器认为最安全的做法是编译到父类的 <code>print()</code> 函数，因为父类和子类肯定都有相同的 <code>print()</code> 函数。这就是所谓的 <code>静态多态</code> 或 <code>静态联编</code>，函数调用在程序执行之前就已经准备好了；有时候这也被称为 <code>早绑定</code>，因为 <code>print()</code> 函数在程序编译期间就已经设置好了。<strong>这就引出了面向对象新的需求，希望根据实际的对象类型来判断重写函数的调用；如果父类指针指向的是父类对象则调用父类中定义的函数，如果父类指针指向的是子类对象则调用子类中定义的重写函数，<a href="../../../asset/2021/11/cplusplus-extends-18.png">如图</a>所示。</strong></p><h4 id="虚函数的应用"><a href="#虚函数的应用" class="headerlink" title="虚函数的应用"></a>虚函数的应用</h4><p>C++ 中通过 <code>virtual</code> 关键字对多态进行支持，使用 <code>virtual</code> 关键字声明的函数被重写后即可展现多态特性，一般称之为 <code>虚函数</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 "virtual" 关键字声明父类的函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> c) : <span class="built_in">Parent</span>(c) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 "virtual" 关键字声明重写父类中的函数</span></span><br><span class="line"><span class="comment">// 只要父类中的函数有 "virtual" 关键字的声明，那么子类的 "virtual" 声明可写可不写，一般建议都写上</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Parent* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Parent <span class="title">parent</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行父类的函数</span></span><br><span class="line">p = &amp;parent;</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行子类的函数</span></span><br><span class="line">p = &amp;child;</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I'm parent, a = 6</span><br><span class="line">I'm child, c = 5</span><br></pre></td></tr></tbody></table></figure><p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 <code>Parent</code> 和 <code>Child</code> 类的对象的地址存储在 <code>*p</code> 中，所以会调用各自的 <code>print()</code> 函数。正如所看到的，父类 <code>Parent</code> 的每个子类都有一个 <code>print()</code> 函数的独立实现。<strong>这就是多态的一般使用方式，即使用一个父类的指针或引用去调用子类中被重写的方法。有了多态就可以有多个不同的实现类，它们都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</strong></p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>虚析构函数的作用：为了避免内存泄漏，通过父类的指针，可以将所有子类对象的析构函数都执行一遍（释放所有的子类资源）。即虚析构函数使得在删除指向子类对象的父类指针时，可以调用子类的析构函数来实现释放子类中堆内存的目的，从而防止内存泄漏。</p><ul><li>析构函数可以是虚的，虚析构函数用于指引 <code>delete</code> 运算符正确析构动态对象</li><li>构造函数不能是虚函数，因为建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数</li></ul><h4 id="虚析构函数的简单应用"><a href="#虚析构函数的简单应用" class="headerlink" title="虚析构函数的简单应用"></a>虚析构函数的简单应用</h4><p><img data-src="../../../asset/2021/11/cplusplus-extends-19.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-20.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() {</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"Hello A"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"A 类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">A</span>() {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">cout &lt;&lt; <span class="string">"A 类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>() {</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"Hello B"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"B 类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">B</span>() {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">cout &lt;&lt; <span class="string">"B 类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 此写法，如果上面不使用 "virtual" 修饰A类（基类）的析构函数，派生类与所有基类的析构函数依然都会被自动调用一次</span></span><br><span class="line">B* b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此写法，如果上面不使用 "virtual" 修饰A类（基类）的析构函数，那么只有A类（基类）的析构函数会被调用一次，B类（派生类）的析构函数不会被调用，这样就会造成内存泄漏</span></span><br><span class="line"><span class="comment">// 虚析构函数的作用是，通过父类的指针，可以将所有子类对象的析构函数都执行一遍（释放所有的子类资源）。</span></span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A 类的构造函数被调用</span><br><span class="line">B 类的构造函数被调用</span><br><span class="line">B 类的析构函数被调用</span><br><span class="line">A 类的析构函数被调用</span><br><span class="line"></span><br><span class="line">A 类的构造函数被调用</span><br><span class="line">B 类的构造函数被调用</span><br><span class="line">B 类的析构函数被调用</span><br><span class="line">A 类的析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h4 id="虚析构函数的作用总结"><a href="#虚析构函数的作用总结" class="headerlink" title="虚析构函数的作用总结"></a>虚析构函数的作用总结</h4><ul><li>a) 如果基类的析构函数不加 <code>virtual</code> 关键字修饰，那么就是普通析构函数<ul><li>当基类中的析构函数没有声明为虚析构函数时，派生类开始从基类继承，基类的指针指向派生类的对象时，<code>delete</code> 基类的指针时，只会调用基类的析构函数，不会调用派生类的析构函数</li></ul></li><li> b) 如果基类的析构函数加 <code>virtual</code> 关键字修饰，那么就是虚析构函数<ul><li>当基类中的析构函数声明为虚析构函数时，派生类开始从基类继承，基类的指针指向派生类的对象时，<code>delete</code> 基类的指针时，先调用派生类的析构函数，再调用基类中的析构函数</li></ul></li></ul><h3 id="多态的理论基础"><a href="#多态的理论基础" class="headerlink" title="多态的理论基础"></a>多态的理论基础</h3><ul><li><code>联编</code>：是指一个程序模块、代码之间互相关联的过程</li><li><code>静态联编</code>：是程序的匹配、连接在编译阶段实现，也称为早期联编（早绑定）<ul><li>函数重载属于静态联编</li></ul></li><li><code>动态联编</code>：是指程序联编推迟到运行时进行，所以又称为晚期联编（迟绑定）<ul><li>虚函数、<code>switch</code> 语句和 <code>if</code> 语句属于动态联编</li></ul></li></ul><p>多态理论联系实际应用（<a href="/posts/4c2ae4c0.html#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E5%8E%9F%E5%88%99%E9%81%87%E4%B8%8A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">代码示例</a>）：</p><ul><li>C++ 与 C 相同，是静态编译型语言</li><li>在编译时，编译器会自动根据指针的类型判断指向的是一个什么样的对象，所以编译器认为父类指针指向的是父类对象</li><li>由于程序没有运行，所以不可能知道父类指针指向的具体是父类对象还是子类对象</li><li>从程序安全的角度，编译器假设父类指针只指向父类对象，因此编译的结果为调用父类的成员函数，这种特性就是 <code>静态联编</code></li></ul><h3 id="多态成立的三个必要条件"><a href="#多态成立的三个必要条件" class="headerlink" title="多态成立的三个必要条件"></a>多态成立的三个必要条件</h3><ul><li>a) 要有继承</li><li> b) 要有虚函数重写</li><li> c) 父类指针或引用指向子类对象</li></ul><h3 id="C-11-的-override-和-final"><a href="#C-11-的-override-和-final" class="headerlink" title="C++ 11 的 override 和 final"></a>C++ 11 的 override 和 final</h3><p><code>override 关键字</code>：用来检查函数是否重写，在子类中的函数声明里加上该关键字 <code>virtual void fun() override {}</code>，编译器就会自动检查对应的函数是否重写了父类中的函数<br><code>final 关键字</code>：在类的声明中加上该关键字 <code>class A final {};</code>，目的是为了不让这个类被继承。或者，在一个函数后加上该关键字，表示这个函数不能被重写 <code>void fun() final {}</code></p>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括多继承、虚继承、函数重写、虚函数、多态、虚析构函数等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之七</title>
    <link href="https://www.techgrow.cn/posts/e4826e2c.html"/>
    <id>https://www.techgrow.cn/posts/e4826e2c.html</id>
    <published>2021-11-14T13:55:33.000Z</published>
    <updated>2021-11-15T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="继承概念"><a href="#继承概念" class="headerlink" title="继承概念"></a>继承概念</h2><p>面向对象程序设计有 4 个主要特点：抽象、封装、继承和多态性。面向对象程序设计的两个重要特征一数据抽象与封装，两者已经能够设计出基于对象的程序，这是面向对象程序设计的基础。要较好地进行面向对象程序设计，还必须了解面向对象程序设计另外两个重要特征 —— 继承性和多态性。继承性是面向对象程序设计最重要的特征，可以说，如果没有掌握继承性，就等于没有掌握类和对象的精华，就是没有掌握面向对象程序设计的真谛。</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>类之间一般有三种关系：<code>has-A</code>、<code>uses-A</code> 和 <code>is-A</code>：</p><ul><li><code>has-A</code>：包含关系，用以描述一个类由多个 “部件类” 构成。实现 <code>has-A</code> 关系可以用类成员表示，即一个类中的数据成员是另一种已经定义的类。</li><li><code>uses-A</code>：一个类部分地使用另一个类。类之间成员函数的联系，可以通过定义友元或者对象参数传递来实现。</li><li><code>is-A</code>：机制称为 “继承” 。关系具有传递性，不具有对称性。</li></ul><span id="more"></span><h3 id="继承关系举例"><a href="#继承关系举例" class="headerlink" title="继承关系举例"></a>继承关系举例</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-1.png"></p><h3 id="继承相关概念"><a href="#继承相关概念" class="headerlink" title="继承相关概念"></a>继承相关概念</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-2.png"></p><h3 id="派生类的定义"><a href="#派生类的定义" class="headerlink" title="派生类的定义"></a>派生类的定义</h3><p><img data-src="../../../asset/2021/11/cplusplus-extends-3.png"></p><p>值得一提的是，C++ 中的继承方式（public、private、protected）会影响子类的对外访问属性。</p><h3 id="继承重要说明"><a href="#继承重要说明" class="headerlink" title="继承重要说明"></a>继承重要说明</h3><ul><li>a) 子类拥有父类的所有成员变量和成员函数</li><li> b) 子类可以拥有父类没有的方法和属性</li><li> c) 子类就是一种特殊的父类</li><li> d) 子类对象可以当作父类对象使用</li></ul><h3 id="继承使用案例"><a href="#继承使用案例" class="headerlink" title="继承使用案例"></a>继承使用案例</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类（基类）（父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义派生类（子类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) {</span><br><span class="line"><span class="comment">// 直接访问父类（基类）（父类）的成员变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; <span class="string">", c="</span> &lt;&lt; <span class="keyword">this</span>-&gt;c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">child.<span class="built_in">print</span>();<span class="comment">// 直接调用父类（基类）（父类）的成员函数</span></span><br><span class="line">child.<span class="built_in">echo</span>();<span class="comment">// 直接调用派生类（子类）的成员函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1, b=2</span><br><span class="line">a=1, b=2, c=3</span><br></pre></td></tr></tbody></table></figure><h2 id="派生类的访问控制"><a href="#派生类的访问控制" class="headerlink" title="派生类的访问控制"></a>派生类的访问控制</h2><p>派生类（子类）继承了基类（父类）的全部成员变量和成员函数（除了构造函数和析构函数之外的成员函数），但是这些成员的访问属性，在派生过程中是可以调整的。</p><h3 id="单个类的访问控制"><a href="#单个类的访问控制" class="headerlink" title="单个类的访问控制"></a>单个类的访问控制</h3><p>在 C++ 中，类成员变量和类成员函数的访问级别为 <code>public</code>、<code>private</code>、<code>protected</code></p><ul><li><code>private</code>：修饰的成员变量和成员函数，只能在类的内部被访问</li><li><code>public</code>：修饰的成员变量和成员函数，可以在类的内部和类的外部被访问</li><li><code>protected</code>：修饰的成员变量和成员函数，可以在派生类的内部访问，不能在派生类的外部被访问</li><li>特别注意：若在类中没有声明访问控制级别的成员变量和成员函数，默认都是 <code>private</code> 访问级别的</li></ul><h3 id="继承成员的访问控制"><a href="#继承成员的访问控制" class="headerlink" title="继承成员的访问控制"></a>继承成员的访问控制</h3><p>在 C++ 中，不同的继承方式（<code>public</code>、<code>private</code>、<code>protected</code>）会改变继承成员的访问属性：</p><ul><li><code>public 继承</code>：父类成员在子类中保持原有的访问级别</li><li><code>private 继承</code>：父类成员在子类中都变为 <code>private</code> 成员</li><li><code>protected 继承</code>：父类中 <code>public</code> 成员会变成 <code>protected</code>，父类中 <code>private</code> 成员仍然为 <code>private</code>，父类中 <code>protected</code> 成员仍然为 <code>protected</code></li><li>特别注意：<code>private</code> 成员在子类中依然存在，但是无法访问到的，即不论使用哪种方式继承父类，子类都不能直接使用父类的私有成员</li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-4.png"></p><h3 id="继承成员访问控制的-“三看”-原则"><a href="#继承成员访问控制的-“三看”-原则" class="headerlink" title="继承成员访问控制的 “三看” 原则"></a>继承成员访问控制的 “三看” 原则</h3><p>在 C++ 中，不同的继承方式（<code>public</code>、<code>private</code>、<code>protected</code>）会改变继承成员的访问属性，最终可总结为以下三个原则（判断某一句话，是否可以被访问）：</p><ul><li>a) 看调用语句是写在子类的内部还是外部</li><li> b) 看子类如何从父类继承（<code>public</code>、<code>private</code>、<code>protected</code>）</li><li>c) 看父类中的访问级别（<code>public</code>、<code>private</code>、<code>protected</code>）</li></ul><h3 id="派生类成员访问级别控制的原则"><a href="#派生类成员访问级别控制的原则" class="headerlink" title="派生类成员访问级别控制的原则"></a>派生类成员访问级别控制的原则</h3><p>对于派生类自身的成员，访问级别控制的原则如下：</p><ul><li>a) 需要被外界访问的成员直接设置为 <code>public</code></li><li>b) 只能在当前类中访问的成员设置为 <code>private</code></li><li>c) 只能在当前类和子类中访问的成员设置为 <code>protected</code></li></ul><h2 id="继承中的构造和析构"><a href="#继承中的构造和析构" class="headerlink" title="继承中的构造和析构"></a>继承中的构造和析构</h2><h3 id="类型兼容原则"><a href="#类型兼容原则" class="headerlink" title="类型兼容原则"></a>类型兼容原则</h3><p>类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类<strong>（公有继承）</strong>的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。值得一提的是，在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承得到的成员，类型兼容规则是多态性的重要基础之一。类型兼容规则中所指的替代包括以下情况：</p><ul><li>子类对象可以当作父类对象使用</li><li>子类对象可以直接赋值给父类对象</li><li>子类对象可以直接初始化父类对象</li><li>父类指针可以直接指向子类对象</li><li>父类引用可以直接引用子类对象 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printParent</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类（公有继承）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printChild</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">howToPrint</span><span class="params">(Parent* p)</span> </span>{</span><br><span class="line">p-&gt;<span class="built_in">printParent</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">howToPrint</span><span class="params">(Parent&amp; p)</span> </span>{</span><br><span class="line">p.<span class="built_in">printParent</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Parent p1;</span><br><span class="line">p1.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line">Child c1;</span><br><span class="line">c1.<span class="built_in">printChild</span>();</span><br><span class="line">c1.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-1 父类指针可以直接指向子类对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">"1-1"</span> &lt;&lt; endl;</span><br><span class="line">Parent* p2 = <span class="literal">NULL</span>;</span><br><span class="line">p2 = &amp;c1;</span><br><span class="line">p2-&gt;<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-2 父类指针可以直接指向子类对象，指针做函数参数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"1-2"</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">howToPrint</span>(&amp;p1);</span><br><span class="line"><span class="built_in">howToPrint</span>(&amp;c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1 父类引用可以直接引用子类对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">"2-1"</span> &lt;&lt; endl;</span><br><span class="line">Parent&amp; p3 = c1;</span><br><span class="line">p3.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2 父类引用可以直接引用子类对象，引用做函数参数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"2-2"</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">howToPrint</span>(p1);</span><br><span class="line"><span class="built_in">howToPrint</span>(c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1 子类对象可以直接初始化父类对象，会自动调用父类的拷贝构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"3-1"</span> &lt;&lt; endl;</span><br><span class="line">Parent p4 = c1;</span><br><span class="line">p4.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4-1 子类对象可以直接赋值给父类对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">"4-1"</span> &lt;&lt; endl;</span><br><span class="line">Parent p5;</span><br><span class="line">p5 = c1;</span><br><span class="line">p5.<span class="built_in">printParent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">I'm parent</span><br><span class="line">I'm child</span><br><span class="line">I'm parent</span><br><span class="line">1-1</span><br><span class="line">I'm parent</span><br><span class="line">1-2</span><br><span class="line">I'm parent</span><br><span class="line">I'm parent</span><br><span class="line">2-1</span><br><span class="line">I'm parent</span><br><span class="line">2-2</span><br><span class="line">I'm parent</span><br><span class="line">I'm parent</span><br><span class="line">3-1</span><br><span class="line">I'm parent</span><br><span class="line">4-1</span><br><span class="line">I'm parent</span><br></pre></td></tr></tbody></table></figure><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p>类在 C++ 编译器的内部可以理解为结构体，子类是由父类成员叠加子类新成员得到的。</p><p><img data-src="../../../asset/2021/11/cplusplus-extends-5.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-6.png"></p><p>父类与子类的构造函数、析构函数的关系如下：</p><ul><li>在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初始化</li><li>在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清理</li></ul><h3 id="继承中的构造与析构的调用原则"><a href="#继承中的构造与析构的调用原则" class="headerlink" title="继承中的构造与析构的调用原则"></a>继承中的构造与析构的调用原则</h3><ul><li>a) 子类对象在创建时，会首先调用父类的构造函数</li><li> b) 父类构造函数执行结束后，再执行子类的构造函数</li><li> c) 当父类只存在有参构造函数时，必须在子类的初始化列表中显示调用父类的构造函数</li><li> d) 析构函数调用的先后顺序与构造函数相反，即先调用子类的析构函数，再调用父类的析构函数 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">cout &lt;&lt; <span class="string">"父类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Parent</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"父类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printParent</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当父类只存在有参构造函数时，必须在子类的初始化列表中显示调用</span></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : <span class="built_in">Parent</span>(a, b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">cout &lt;&lt; <span class="string">"子类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Child</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"子类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printChild</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, c = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">c1.<span class="built_in">printParent</span>();</span><br><span class="line">c1.<span class="built_in">printChild</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类的构造函数被调用</span><br><span class="line">子类的构造函数被调用</span><br><span class="line">I'm parent, a = 1, b = 2</span><br><span class="line">I'm child, c = 3</span><br><span class="line">子类的析构函数被调用</span><br><span class="line">父类的析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h3 id="继承与组合混搭情况下，构造和析构的调用原则"><a href="#继承与组合混搭情况下，构造和析构的调用原则" class="headerlink" title="继承与组合混搭情况下，构造和析构的调用原则"></a>继承与组合混搭情况下，构造和析构的调用原则</h3><p>继承与组合对象混搭使用的情况下，构造函数与析构函数的调用原则如下：</p><ul><li><code>构造函数的调用</code>：先构造父类，再构造成员变量，最后构造自身</li><li><code>析构函数的调用</code>：先析构自身，再析构成员变量，最后析构父类 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Object</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">cout &lt;&lt; <span class="string">"Object类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Object</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"Object类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printObject</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm object, a = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> :</span> <span class="keyword">public</span> Object {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过初始化列表，调用父类的构造函数</span></span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">char</span>* p) : <span class="built_in">Object</span>(<span class="number">1</span>, <span class="number">2</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">cout &lt;&lt; <span class="string">"Parent类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Parent</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"Parent类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printParent</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, p = "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过初始化列表，调用组合对象与父类的构造函数</span></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">char</span>* c) : <span class="built_in">obj1</span>(<span class="number">3</span>, <span class="number">4</span>), <span class="built_in">obj2</span>(<span class="number">5</span>, <span class="number">6</span>), <span class="built_in">Parent</span>(c) {</span><br><span class="line"><span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">cout &lt;&lt; <span class="string">"Child类的构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Child</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"Child类的析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printChild</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, p = "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"><span class="comment">// 组合对象</span></span><br><span class="line">Object obj1;</span><br><span class="line">Object obj2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span>* str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'J'</span>;</span><br><span class="line">str[<span class="number">1</span>] = <span class="string">'i'</span>;</span><br><span class="line">str[<span class="number">2</span>] = <span class="string">'m'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Child <span class="title">c1</span><span class="params">(str)</span></span>;</span><br><span class="line">c1.<span class="built_in">printChild</span>();</span><br><span class="line">c1.<span class="built_in">printParent</span>();</span><br><span class="line">c1.<span class="built_in">printObject</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object类的构造函数被调用</span><br><span class="line">Parent类的构造函数被调用</span><br><span class="line">Object类的构造函数被调用</span><br><span class="line">Object类的构造函数被调用</span><br><span class="line">Child类的构造函数被调用</span><br><span class="line">I'm child, p = Jim</span><br><span class="line">I'm parent, p = Jim</span><br><span class="line">I'm object, a = 1, b = 2</span><br><span class="line">Child类的析构函数被调用</span><br><span class="line">Object类的析构函数被调用</span><br><span class="line">Object类的析构函数被调用</span><br><span class="line">Parent类的析构函数被调用</span><br><span class="line">Object类的析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h3 id="继承中的同名成员的处理方式"><a href="#继承中的同名成员的处理方式" class="headerlink" title="继承中的同名成员的处理方式"></a>继承中的同名成员的处理方式</h3><ul><li>当子类成员与父类成员同名时，子类依然可以从父类继承同名成员</li><li>在子类中通过作用域分辨符 <code>::</code> 进行同名成员的区分（在子类中使用父类的同名成员，需要显式地使用类名限定符），其作用类似 Java 中的 <code>super</code> 关键字</li><li>同名成员存储在内存中的不同位置 </li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-7.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-8.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm parent, a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Child</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : <span class="built_in">Parent</span>(a, b) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b + <span class="number">5</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"I'm child, a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类访问自身的同名成员函数</span></span><br><span class="line">child.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类访问自身的同名成员变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">"child's a = "</span> &lt;&lt; child.a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"child's b = "</span> &lt;&lt; child.b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类访问父类的同名成员函数</span></span><br><span class="line">child.Parent::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类访问父类的同名成员变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">"parent's a = "</span> &lt;&lt; child.Parent::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"parent's b = "</span> &lt;&lt; child.Parent::b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I'm child, a = 6, b = 7</span><br><span class="line">child's a = 6</span><br><span class="line">child's b = 7</span><br><span class="line">I'm parent, a = 1, b = 2</span><br><span class="line">parent's a = 1</span><br><span class="line">parent's b = 2</span><br></pre></td></tr></tbody></table></figure><h3 id="派生类中的-static-关键字使用"><a href="#派生类中的-static-关键字使用" class="headerlink" title="派生类中的 static 关键字使用"></a>派生类中的 static 关键字使用</h3><p>在 C++ 的普通类中，<code>static</code> 关键字的使用可以看 <a href="/posts/a35089f6.html#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">这里</a>，而派生类中 <code>static</code> 关键字的使用说明如下：</p><ul><li>基类定义的静态成员，将被所有派生类共享</li><li>根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质（遵守派生类成员访问级别控制的原则）</li><li>在派生类中访问基类的静态成员，需要显式说明，对应的语法是：<code>类名 :: 成员</code> 或者通过对象访问：<code>对象名 . 成员</code></li></ul><p><img data-src="../../../asset/2021/11/cplusplus-extends-10.png"></p><p><img data-src="../../../asset/2021/11/cplusplus-extends-11.png"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 声明公有的静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 声明公有的静态成员变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 声明私有的静态成员变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义私有的静态成员变量</span></span><br><span class="line"><span class="keyword">int</span> Parent::b = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义公有的静态成员变量，这里不是简单的变量赋值，更重要的是告诉C++编译器，给静态成员变量分配内存, 否则在派生类中用到该变量就会报错</span></span><br><span class="line"><span class="keyword">int</span> Parent::a = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 访问从基类继承得到的静态成员变量</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getA2</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 访问基类的静态成员变量</span></span><br><span class="line"><span class="keyword">return</span> Parent::a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// return b;  错误写法，基类中静态成员自身的访问特性遵守派生类的访问级别控制原则，因此这里不能访问基类中私有的静态成员变量b</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用从基类继承得到的静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用基类的静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>{</span><br><span class="line">Parent::<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外访问基类的静态成员变量和静态成员函数</span></span><br><span class="line">Parent::a++;</span><br><span class="line">Parent::<span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外访问派生类的静态成员变量和静态成员函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; Child::a &lt;&lt; endl;</span><br><span class="line">Child::<span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Child c1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.<span class="built_in">getA2</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; c1.Parent::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">c1.<span class="built_in">print1</span>();</span><br><span class="line">c1.<span class="built_in">print2</span>();</span><br><span class="line">c1.Parent::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = 31, b = 50</span><br><span class="line"></span><br><span class="line">a = 31</span><br><span class="line">a = 31, b = 50</span><br><span class="line"></span><br><span class="line">a = 31</span><br><span class="line">a = 31</span><br><span class="line">a = 31</span><br><span class="line"></span><br><span class="line">a = 31, b = 50</span><br><span class="line">a = 31, b = 50</span><br><span class="line">a = 31, b = 50</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括继承、派生类的访问控制、继承中的构造函数和析构函数等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CTP 程序化交易基础之一</title>
    <link href="https://www.techgrow.cn/posts/d35e15f1.html"/>
    <id>https://www.techgrow.cn/posts/d35e15f1.html</id>
    <published>2021-11-12T13:55:33.000Z</published>
    <updated>2021-11-12T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="CTP-介绍"><a href="#CTP-介绍" class="headerlink" title="CTP 介绍"></a>CTP 介绍</h2><h3 id="CTP-简介"><a href="#CTP-简介" class="headerlink" title="CTP 简介"></a>CTP 简介</h3><p>综合交易平台（Comprehensive Transaction Platform，CTP）是专门为期货公司开发的一套期货经纪业务管理系统，由交易、风险控制和结算三大系统组成。其中，交易系统主要负责订单处理、行情转发及银期转账业务，结算系统负责交易管理、帐户管理、经纪人管理、资金管理、费率设置、日终结算、信息查询以及报表管理等，风控系统则主要在盘中进行高速的实时试算，以及时揭示并控制风险。系统能够同时连通国内四家期货交易所，支持国内商品期货和股指期货的交易结算业务，并能自动生成、报送保证金监控文件和反洗钱监控文件。</p><h3 id="CTP-架构"><a href="#CTP-架构" class="headerlink" title="CTP 架构"></a>CTP 架构</h3><p>综合交易平台是基于全内存的交易系统，采用创新的完全精确重演的分布式体系架构，支持 7x24 小时连续交易，运维人员不必每日启停系统，可以做到 “一键运维”，该特性使得综合交易平台新增交易中心以扩展业务规模时不用增加运维人力的成本。支持 FENS 机制的 “一键切换” 多活交易中心也是目前市场上只有 CTP 系统实现了的特性。该机制使得交易系统可在某个交易中心宕机的情况下立即切换到另一个备用交易中心，得以实现真真正正的连续交易。综合交易平台公开并对外开放交易系统接口，使用该接口可以接收交易所的行情数据和执行交易指令。该接口采用开放接口（API）的方式接入，早已在期货界已经形成事实上的行业标准。</p><span id="more"></span><h3 id="CTP-API"><a href="#CTP-API" class="headerlink" title="CTP API"></a>CTP API</h3><p>从 <a href="http://www.sfit.com.cn/">CTP 官网</a>（非交易时段禁止访问）可以了解到，CTP API 从 <code>v6.3.15</code> 版开始引入强制看穿式认证规则，CTP 不再兼容之前的 API 版本。目前，CTP API 最新版是 <code>v6.6.1</code>，与 <code>v6.3.15</code> 相比较最大的改动是，<code>InstrumentID</code> 由最长 30 个字节增加到 80 个字节。CTP 生产系统兼容 <code>v6.3.15</code> 及以上版本。但是，大部分期货公司做看穿式认证的仿真系统要求使用新版 API 才能接入。所以，新用户做看穿式认证时首先要确认 API 的版本号。</p><p><img data-src="../../../asset/2021/12/ctp-1.png"></p><h2 id="CTP-仿真系统"><a href="#CTP-仿真系统" class="headerlink" title="CTP 仿真系统"></a>CTP 仿真系统</h2><h3 id="SimNow-仿真系统"><a href="#SimNow-仿真系统" class="headerlink" title="SimNow 仿真系统"></a>SimNow 仿真系统</h3><p><a href="https://www.simnow.com.cn/product.action">SimNow</a> 是上期技术为广大投资者打造的一个最接近真实市场环境的仿真平台，主要面向期货经纪公司和投资者服务，提供整套期货交易的信息化技术平台。<a href="http://www.simnow.com.cn/">SimNow 官网</a>（非交易时段禁止访问），交易者注册 SimNow 仿真账户后，可以使用从 CTP 官网下载 API 接入这套仿真交易系统。开发、测试完成之后，只需要更换用户名、密码、前置地址等信息就可以接入期货公司生产系统进行实盘交易。SimNow 要求 CTP API 的版本是 <code>v6.3.15</code> 及以上才能够接入。</p><h4 id="认证信息"><a href="#认证信息" class="headerlink" title="认证信息"></a>认证信息</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BrokerID = "9999"</span><br><span class="line">AppID = "SimNow_client_test"</span><br><span class="line">AuthCode = "0000000000000000"</span><br></pre></td></tr></tbody></table></figure><p>值得一提的是，默认的 <code>BrokerID</code> 为 <code>9999</code>，<code>AppID</code> 为 <code>SimNow_client_test</code>，<code>AuthCode</code> 为 <code>0000000000000000（16个0）</code>，默认不会开终端认证，程序化用户可以选择不开终端认证接入。</p><h4 id="生产仿真环境"><a href="#生产仿真环境" class="headerlink" title="生产仿真环境"></a>生产仿真环境</h4><p>以下的前置地址，交易时段与真实生产环境（实盘）一致。</p><ul><li>电信 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://180.168.146.187:10201</span><br><span class="line">FrontMdAddr=tcp://180.168.146.187:10211</span><br></pre></td></tr></tbody></table></figure><ul><li>电信 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://180.168.146.187:10202</span><br><span class="line">FrontMdAddr=tcp://180.168.146.187:10212</span><br></pre></td></tr></tbody></table></figure><ul><li>移动 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://218.202.237.33:10203</span><br><span class="line">FrontMdAddr=tcp://218.202.237.33:10213</span><br></pre></td></tr></tbody></table></figure><h4 id="测试仿真环境"><a href="#测试仿真环境" class="headerlink" title="测试仿真环境"></a>测试仿真环境</h4><ul><li>支持全天交易（7x24），不间断轮播某天行情</li><li> SimNow 新注册用户，需要等到第三个交易日才能使用</li><li>交易时段：交易日 16：00 ～ 次日 09：00；非交易日 16：00 ～ 次日 15：00</li><li> 仅服务于 CTP API 开发爱好者，仅为用户提供 CTP API 测试需求，不提供结算等其它服务 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://180.168.146.187:10130</span><br><span class="line">FrontMdAddr=tcp://180.168.146.187:10131</span><br></pre></td></tr></tbody></table></figure><h4 id="仿真成交规则"><a href="#仿真成交规则" class="headerlink" title="仿真成交规则"></a>仿真成交规则</h4><ul><li>期货交易按照交易所公布的买一卖一价对价成交</li><li>买入时：如果委托价大于等于卖一价，则成交，成交价为委托价、卖一价、最新价三价取中，如果委托价小于卖一价，不能成交，等待更优的行情才能成交</li><li>卖出时：如果委托价小于等于买一价，则成交，成交价为委托价、买一价、最新价三价取中，如果委托价大于买一价，不能成交，等待更优的行情才能成交</li></ul><h4 id="仿真交易时间"><a href="#仿真交易时间" class="headerlink" title="仿真交易时间"></a>仿真交易时间</h4><p><img data-src="../../../asset/2021/12/ctp-3.png"></p><h3 id="NSight-仿真系统"><a href="#NSight-仿真系统" class="headerlink" title="NSight 仿真系统"></a>NSight 仿真系统</h3><p>交易者在 <a href="http://www.n-sight.com.cn/">NSight 官网</a> 注册仿真账户后，可以使用从 CTP 官网下载的 API <code>v6.3.15</code> 接入这套仿真交易系统。开发、测试完成之后，只需要更换用户名、密码、前置地址等信息就可以接入期货公司生产系统进行实盘交易。</p><h4 id="认证信息-1"><a href="#认证信息-1" class="headerlink" title="认证信息"></a>认证信息</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BrokerID = "10010"</span><br><span class="line">AppID = ""</span><br><span class="line">AuthCode = ""</span><br></pre></td></tr></tbody></table></figure><p>值得一提的是，默认的 <code>BrokerID</code> 为 <code>10010</code>，<code>AppID</code> 与 <code>AuthCode</code> 均为空字符串。</p><h4 id="生产仿真环境-1"><a href="#生产仿真环境-1" class="headerlink" title="生产仿真环境"></a>生产仿真环境</h4><p>以下的前置地址，交易时段与真实生产环境（实盘）一致。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FrontAddr=tcp://210.14.72.12:4600</span><br><span class="line">FrontMdAddr=tcp://210.14.72.12:4602</span><br></pre></td></tr></tbody></table></figure><h2 id="期货交易终端"><a href="#期货交易终端" class="headerlink" title="期货交易终端"></a>期货交易终端</h2><p>市面上主流的期货交易终端可以在 <a href="https://www.simnow.com.cn/static/softwareDownload.action">SimNow 官网</a>（非交易时段禁止访问）下载。</p><h3 id="快期期货交易终端"><a href="#快期期货交易终端" class="headerlink" title="快期期货交易终端"></a>快期期货交易终端</h3><p>对于量化交易者，在没有自主开发监控客户端之前，快期是一个很不错的选择。这里以 <code>快期 v2</code> 版本举例，若使用快期登录 SimNow 的模拟账户，则只需要在快期的登录界面选择服务器 <code>上期技术-xx</code> 即可，下拉列表里不同的服务器分别使用了不同的前置地址，而 <code>用户代码</code> 直接填写 <code>InvestorID</code>。</p><p><img data-src="../../../asset/2021/12/ctp-2.png"></p><h2 id="CTP-开放平台"><a href="#CTP-开放平台" class="headerlink" title="CTP 开放平台"></a>CTP 开放平台</h2><ul><li><a href="https://github.com/krenx1983/openctp">CTP 开放平台</a></li><li><a href="https://zhuanlan.zhihu.com/p/366725237">CTP 接口兼容模拟交易平台 - 类似 SimNow</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 CTP 程序化交易的基础内容，包括 CTP、SimNow、NSight 的介绍。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="量化交易" scheme="https://www.techgrow.cn/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之六</title>
    <link href="https://www.techgrow.cn/posts/a54941f5.html"/>
    <id>https://www.techgrow.cn/posts/a54941f5.html</id>
    <published>2021-11-06T13:55:33.000Z</published>
    <updated>2021-11-12T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>类的友元函数是定义在类的外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型在类的声明中出现过，但是友元函数并不是类的成员函数，而是普通函数（全局函数）。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <code>friend</code>。</p><h3 id="友元函数的规则"><a href="#友元函数的规则" class="headerlink" title="友元函数的规则"></a>友元函数的规则</h3><p>为什么要引入友元函数：</p><p>C++ 利用 <code>friend</code> 修饰符，可以让一些设定的函数能够对一些保护数据进行访问，避免把类的成员全部设置成 <code>public</code>，最大限度的保护数据成员的安全。同时友元函数可以实现类之间的数据共享，减少系统开销，提高效率。由于友元函数破环了封装机制，因此推荐尽量使用成员函数，除非不得已的情况下才使用友元函数。</p><p>什么时候使用友元函数：</p><ul><li>多个类要共享数据的时候</li><li>运算符重载的某些场合需要使用友元函数</li></ul><span id="more"></span><p>友元函数的参数：</p><p>因为友元函数没有 <code>this</code> 指针，所以参数会有三种情况：</p><ul><li>a) 要访问非 <code>static</code> 成员时，需要对象做参数</li><li> b) 要访问 <code>static</code> 成员或全局变量时，则不需要对象做参数</li><li> c) 如果做参数的对象是全局对象，则不需要对象做参数</li></ul><p>友元函数的位置：</p><ul><li>因为友元函数是类外的函数（普通函数），所以它的声明可以放在类的私有段（private）或公有段（public），两者都是没有区别的</li><li>一个函数可以是多个类的友元函数，只需要在各个类中分别声明即可</li></ul><p>友元函数的调用：</p><ul><li>可以直接调用友元函数，不需要通过对象或指针</li><li>友元函数的调用与普通函数（全局函数）的调用方式和原理一致</li></ul><h3 id="友元函数的使用"><a href="#友元函数的使用" class="headerlink" title="友元函数的使用"></a>友元函数的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">int</span> a) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">update2</span><span class="params">(A* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update1</span><span class="params">(A* p)</span> </span>{</span><br><span class="line"><span class="comment">// p-&gt;a = 30;  // 错误写法，在普通函数（全局函数）内，私有数据成员不能在类外被访问</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(A* p)</span> </span>{</span><br><span class="line">p-&gt;a = <span class="number">30</span>;<span class="comment">// 在友元函数内，可以通过对象参数访问私有数据成员</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">update2</span>(a);<span class="comment">// 调用友元函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a-&gt;<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 30</span><br></pre></td></tr></tbody></table></figure><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的私有（private）成员和保护（protected）成员。当希望一个类可以访问另一个类的保护数据时，可以将该类声明为另一类的友元类。定义友元类的语法格式为 <code>friend class 类名;</code>，其中类名必须是程序中的一个已定义过的类。值得一提的是，友元类通常设计为一种对数据操作或类之间传递消息的辅助类。</p><h3 id="友元类的规则"><a href="#友元类的规则" class="headerlink" title="友元类的规则"></a>友元类的规则</h3><ul><li>友元关系不能被继承</li><li>友元关系是单向的，不具有交换性。若类 B 是类 A 的友元，则类 A 不一定是类 B 的友元，要看在类 B 中是否有相应的声明</li><li>友元关系不具有传递性，若类 B 是类 A 的友元，类 C 是 类 B 的友元，则类 C 不一定是类 A 的友元，要看类 A 中是否有相应的声明</li></ul><h3 id="友元类的使用"><a href="#友元类的使用" class="headerlink" title="友元类的使用"></a>友元类的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明友元类 B</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">aObj.a = a;<span class="comment">// 类 B 是类 A 的友元类，因此 B 类的所有成员函数都可以访问 A 类的私有成员或者保护成员</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">aObj.<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A aObj;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">setValue</span>(<span class="number">100</span>);</span><br><span class="line">b.<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 100</span><br></pre></td></tr></tbody></table></figure><h2 id="运算符重载基础"><a href="#运算符重载基础" class="headerlink" title="运算符重载基础"></a>运算符重载基础</h2><p>所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是 <code>一名多用</code>。运算符也可以重载，实际上，开发者已经在不知不觉之中使用了运算符重载。例如，大家都已习惯于用加法运算符 <code>+</code> 对整数、单精度数和双精度数进行加法运算，如 <code>5 + 8，5.8 + 3.67</code> 等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的，但由于 C++ 已经对运算符 <code>+</code> 进行了重载，所以就能适用于 int、float、doUble 类型的运算。又如 <code>&lt;&lt;</code> 是 C++ 的位运算中的位移运算符（左移），但在输出操作中又是与流对象 <code>cout</code> 配合使用的流插入运算符。<code>&gt;&gt;</code> 也是位移运算符 (右移），但在输入操作中又是与流对象 <code>cin</code> 配合使用的流提取运算符。这就是运算符重载 (Operator Overloading)。C++ 系统对 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 进行了重载，用户在不同的场合下使用它们时，作用是不同的。对 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 的重载处理是放在头文件 <code>stream</code> 中的。因此，如果要在程序中用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 作流插入运算符和流提取运算符，必须在本文件模块中包含头文件 <code>stream</code>，当然还应当包括命名空间的使用声明 <code>using namespace std</code>。</p><h3 id="运算符重载的语法"><a href="#运算符重载的语法" class="headerlink" title="运算符重载的语法"></a>运算符重载的语法</h3><p><img data-src="../../../asset/2021/11/cplusplus-overload-1.png" alt="cplusplus-overload-1"></p><p>例如：</p><ul><li><code>使用类成员函数完成 "-" 运算符重载的语法</code>：Complex operator-(Complex &amp;c2)</li><li><code>使用友元函数完成 "+" 运算符重载的语法</code>：Complex operator+(Complex &amp;c1, Complex &amp;c2)</li></ul><h3 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><p><img data-src="../../../asset/2021/11/cplusplus-overload-6.png" alt="cplusplus-overload-6"><br><img data-src="../../../asset/2021/11/cplusplus-overload-2.png" alt="cplusplus-overload-2"></p><h3 id="运算符重载的两种方式"><a href="#运算符重载的两种方式" class="headerlink" title="运算符重载的两种方式"></a>运算符重载的两种方式</h3><p><img data-src="../../../asset/2021/11/cplusplus-overload-3.png" alt="cplusplus-overload-3"><br><img data-src="../../../asset/2021/11/cplusplus-overload-4.png" alt="cplusplus-overload-4"><br><img data-src="../../../asset/2021/11/cplusplus-overload-5.png" alt="cplusplus-overload-5"></p><h3 id="前置与后置运算符重载规则"><a href="#前置与后置运算符重载规则" class="headerlink" title="前置与后置运算符重载规则"></a>前置与后置运算符重载规则</h3><p>在 C++ 中是通过一个占位参数（<code>int</code>）来区分前置运算符和后置运算符的重载，例如 <code>++a</code>、<code>a++</code>、<code>--b</code>、<code>b--</code>。</p><p><img data-src="../../../asset/2021/11/cplusplus-overload-7.png" alt="cplusplus-overload-7"></p><h3 id="运算符重载的简单使用案例"><a href="#运算符重载的简单使用案例" class="headerlink" title="运算符重载的简单使用案例"></a>运算符重载的简单使用案例</h3><h4 id="二元运算符重载"><a href="#二元运算符重载" class="headerlink" title="二元运算符重载"></a>二元运算符重载</h4><p>在下述的案例中，演示了如何使用类成员函数和友元函数实现二元运算符的重载。值得一提的是，除了使用友元函数外，还可以使用全局函数（普通函数）来实现运算符的重载，不同的是使用友元函数更方便，可以直接访问类的所有私有（private）成员和保护（protected）成员。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数完成 "-" 运算符的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(Complex&amp; c2) {</span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(<span class="keyword">this</span>-&gt;a - c2.a, <span class="keyword">this</span>-&gt;b - c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> c3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明用于 "+" 运算符重载的友元函数</span></span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(Complex&amp; c1, Complex&amp; c2);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数完成 "+" 运算符的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; c1, Complex&amp; c2) {</span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(c1.a + c2.a, c1.b + c2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> c3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用友元函数</span></span><br><span class="line">Complex c3 = <span class="keyword">operator</span>+(c1, c2);</span><br><span class="line">c3.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数完成 "+" 运算符的重载</span></span><br><span class="line">Complex c4 = c1 + c2;</span><br><span class="line">c4.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用类成员函数</span></span><br><span class="line">Complex c5 = c1.<span class="keyword">operator</span>-(c2);</span><br><span class="line">c5.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数完成 "-" 运算符的重载</span></span><br><span class="line">Complex c6 = c1 - c2;</span><br><span class="line">c6.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=4, b=6</span><br><span class="line">a=4, b=6</span><br><span class="line">a=-2, b=-2</span><br><span class="line">a=-2, b=-2</span><br></pre></td></tr></tbody></table></figure><h4 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h4><p>在下述的案例中，演示了如何使用类成员函数和友元函数实现一元运算符的重载。值得一提的是，除了使用友元函数外，还可以使用全局函数（普通函数）来实现运算符的重载，不同的是使用友元函数更方便，可以直接访问类的所有私有（private）成员和保护（protected）成员。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">", b="</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数完成 "前置--" 运算符的重载</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>--() {</span><br><span class="line"><span class="keyword">this</span>-&gt;a--;</span><br><span class="line"><span class="keyword">this</span>-&gt;b--;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数完成 "后置--" 运算符的重载</span></span><br><span class="line"><span class="comment">// 使用占位参数进行函数重载，是为了解决与 "前置--" 类成员函数冲突的问题</span></span><br><span class="line">Complex <span class="keyword">operator</span>--(<span class="keyword">int</span>) {</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a, <span class="keyword">this</span>-&gt;b)</span></span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;a--;</span><br><span class="line"><span class="keyword">this</span>-&gt;b--;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明用于 "前置++" 运算符重载的友元函数</span></span><br><span class="line"><span class="keyword">friend</span> Complex&amp; <span class="keyword">operator</span>++(Complex&amp; c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明用于 "后置++" 运算符重载的友元函数</span></span><br><span class="line"><span class="comment">// 使用占位参数进行函数重载，是为了解决与 "前置++" 友元函数冲突的问题</span></span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>++(Complex&amp; c1, <span class="keyword">int</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数完成 "前置++" 运算符的重载</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>++(Complex&amp; c1)</span><br><span class="line">{</span><br><span class="line">c1.a++;</span><br><span class="line">c1.b++;</span><br><span class="line"><span class="keyword">return</span> c1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数完成 "后置++" 运算符的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>++(Complex&amp; c1, <span class="keyword">int</span>) {</span><br><span class="line"><span class="function">Complex <span class="title">tmp</span><span class="params">(c1.a, c1.b)</span></span>;</span><br><span class="line">c1.a++;</span><br><span class="line">c1.b++;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">8</span>, <span class="number">9</span>)</span>, <span class="title">c3</span><span class="params">(<span class="number">15</span>, <span class="number">16</span>)</span>, <span class="title">c4</span><span class="params">(<span class="number">24</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数完成 "前置++" 运算符的重载</span></span><br><span class="line">++c1;</span><br><span class="line">c1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数完成 "前置--" 运算符的重载</span></span><br><span class="line">--c2;</span><br><span class="line">c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数完成 "后置++" 运算符的重载</span></span><br><span class="line">Complex c5 = c3++;</span><br><span class="line">c3.<span class="built_in">print</span>();</span><br><span class="line">c5.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数完成 "后置--" 运算符的重载</span></span><br><span class="line">Complex c6 = c4--;</span><br><span class="line">c4.<span class="built_in">print</span>();</span><br><span class="line">c6.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=2, b=3</span><br><span class="line">a=7, b=8</span><br><span class="line">a=16, b=17</span><br><span class="line">a=15, b=16</span><br><span class="line">a=23, b=24</span><br><span class="line">a=24, b=25</span><br></pre></td></tr></tbody></table></figure><h4 id="左移运算符的重载"><a href="#左移运算符的重载" class="headerlink" title="左移运算符的重载"></a>左移运算符的重载</h4><p>值得一提的是，<code>&lt;&lt;</code> 左移运算符和 <code>&gt;&gt;</code> 右移运算符的重载，只能使用友元函数或者全局函数，不能使用类成员函数，这也是友元函数的重要作用之一。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 声明友元函数实现 "&lt;&lt;" 左移运算符的重载</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&amp; c1);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数实现 "&lt;&lt;" 左移运算符的重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Complex&amp; c1) {</span><br><span class="line">out &lt;&lt; <span class="string">"a="</span> &lt;&lt; c1.a &lt;&lt; <span class="string">", b="</span> &lt;&lt; c1.b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">6</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; c1 &lt;&lt; c2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1, b=2</span><br><span class="line">a=6, b=9</span><br></pre></td></tr></tbody></table></figure><h4 id="等号运算符的重载"><a href="#等号运算符的重载" class="headerlink" title="等号运算符的重载"></a>等号运算符的重载</h4><ul><li><code>=</code> 运算符的结合性是从右到左</li><li><code>=</code> 运算符的重载用于对象数据的复制</li><li>必须通过类成员函数重载 <code>=</code> 运算符，不能使用友元函数</li><li><code>=</code> 运算符重载的函数原型为：<code>类型  &amp;  类名  :: operator= ( const  类名 &amp; ) ;</code></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Name</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name) {</span><br><span class="line">cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">len = <span class="built_in">strlen</span>(name);</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝的实现</span></span><br><span class="line"><span class="built_in">Name</span>(<span class="keyword">const</span> Name&amp; name) {</span><br><span class="line">cout &lt;&lt; <span class="string">"拷贝构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">len = name.<span class="built_in">getLen</span>();</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, name.<span class="built_in">getP</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Name</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getP</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数实现 "=" 运算符的重载</span></span><br><span class="line">Name&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Name&amp; n) {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 重新分配内存空间</span></span><br><span class="line">len = n.<span class="built_in">getLen</span>();</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, n.<span class="built_in">getP</span>());</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">Name <span class="title">obj1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line"><span class="function">Name <span class="title">obj2</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line"><span class="function">Name <span class="title">obj4</span><span class="params">(<span class="string">"Tim"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会自动调用拷贝构造函数（属于深拷贝）</span></span><br><span class="line">Name obj3 = obj1;</span><br><span class="line">cout &lt;&lt; <span class="string">"obj3.name: "</span> &lt;&lt; obj3.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj3.len:  "</span> &lt;&lt; obj3.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用拷贝构造函数（属于浅拷贝）</span></span><br><span class="line"><span class="comment">// 默认情况下，若这里不对 "=" 运算符进行重载，最终程序会异常终止运行（由于同一块内存空间被释放两次导致）</span></span><br><span class="line">obj4 = obj1;</span><br><span class="line">cout &lt;&lt; <span class="string">"obj4.name: "</span> &lt;&lt; obj4.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj4.len:  "</span> &lt;&lt; obj4.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">拷贝构造函数被调用了</span><br><span class="line">obj3.name: Peter, obj3.len:  5</span><br><span class="line">obj4.name: Peter, obj4.len:  5</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br></pre></td></tr></tbody></table></figure><h4 id="函数运算符的重载"><a href="#函数运算符的重载" class="headerlink" title="函数运算符的重载"></a>函数运算符的重载</h4><p>在下述的案例中，演示了如何使用类成员函数重载函数运算符 <code>()</code>，值得一提的是，不能用友元函数重载函数运算符 <code>()</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">Test test;</span><br><span class="line">cout &lt;&lt; <span class="built_in">test</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></tbody></table></figure><h2 id="运算符重载进阶"><a href="#运算符重载进阶" class="headerlink" title="运算符重载进阶"></a>运算符重载进阶</h2><h3 id="为什么不要重载-amp-amp-和-操作符"><a href="#为什么不要重载-amp-amp-和-操作符" class="headerlink" title="为什么不要重载 &amp;&amp; 和 || 操作符"></a>为什么不要重载 &amp;&amp; 和 || 操作符</h3><ul><li>a) <code>&amp;&amp;</code> 和 <code>||</code> 是 C++ 中非常特殊的操作符</li><li> b) <code>&amp;&amp;</code> 和 <code>||</code> 内置实现了短路规则</li><li> c) 操作符重载是靠函数重载来完成的</li><li> d) 操作数作为函数参数传递</li><li> e) C++ 的函数参数都会被求值，无法实现短路规则</li></ul><h3 id="不同函数实现运算符重载的应用场景"><a href="#不同函数实现运算符重载的应用场景" class="headerlink" title="不同函数实现运算符重载的应用场景"></a>不同函数实现运算符重载的应用场景</h3><p>友元函数和类成员函数的选择方法：</p><ul><li>a) <code>=</code>、<code>[]</code>、<code>()</code> 和 <code>-&gt;</code> 运算符，只能通过类成员函数进行重载</li><li> b) 当无法修改左操作数的类时，只能通过友元函数进行重载，例如 <code>&lt;&lt;</code> 与 <code>&gt;&gt;</code> 运算符</li></ul><p>友元函数重载 <code>&lt;&lt;</code> 与 <code>&gt;&gt;</code> 运算符：</p><ul><li><code>istream</code> 和 <code>ostream</code> 是 C++ 的预定义流类</li><li><code>cin</code> 是 <code>istream</code> 的对象，<code>cout</code> 是 <code>ostream</code> 的对象</li><li>运算符 <code>&lt;&lt;</code> 由 <code>ostream</code> 重载为插入操作，用于输出基本类型数据</li><li>运算符 <code>&gt;&gt;</code> 由 <code>istream</code> 重载为提取操作，用于输入基本类型数据</li><li>只能使用友元函数或者全局函数重载 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符，输出和输入用户自定义的数据类型</li></ul><p>类成员函数与友元函数实现运算符重载的步骤：</p><ul><li>a) 要承认运算符重载是一个函数，写出函数名称，如 <code>operator +()</code></li><li>b) 根据操作数，写出函数参数</li><li> c) 根据业务，完善函数的返回值（看函数是返回引用、指针还是元素），及实现函数业务；例如当函数的返回值充当左值时，需要返回一个引用</li></ul><h3 id="使用友元函数重载运算符的注意事项"><a href="#使用友元函数重载运算符的注意事项" class="headerlink" title="使用友元函数重载运算符的注意事项"></a>使用友元函数重载运算符的注意事项</h3><ul><li>a) 友元函数重载运算符常用于运算符的左右操作数类型不相同的场景</li><li> b) 在函数的第一个参数需要隐式转换的情形下，使用友元函数重载运算符是正确的选择</li><li> c) 友元函数没有 <code>this</code> 指针，所需操作数都必须在函数的参数表中显式声明，很容易实现类型的隐式转换</li><li> d) 在 C++ 中不能用友元函数重载的运算符分别有：<code>=</code>、<code>[]</code>、<code>()</code> 和 <code>-&gt;</code></li><li>e) 在 C++ 中不要重载 <code>&amp;&amp;</code> 和 <code>||</code> 运算符</li><li> f) C++ 的运算符重载遵循函数重载的规则</li><li> g) 除了重载运算符 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 必须使用友元函数之外，其他运算符的重载尽量都使用类成员函数，千万不要滥用友元函数，尤其类模板与友元函数一起使用的时候</li></ul><h3 id="运算符重载的综合使用案例"><a href="#运算符重载的综合使用案例" class="headerlink" title="运算符重载的综合使用案例"></a>运算符重载的综合使用案例</h3><h4 id="重载自定义数组类的各种运算符"><a href="#重载自定义数组类的各种运算符" class="headerlink" title="重载自定义数组类的各种运算符"></a>重载自定义数组类的各种运算符</h4><p>在本案例中，自定义了数组类 <code>Array</code>，并使用类成员函数分别对 <code>Array</code> 类的 <code>[]</code>、<code>=</code>、<code>==</code>、<code>!=</code> 运算符进行重载。</p><details><summary>★点击显示完整的案例代码★</summary><code><ul><li>Array.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Array</span>(<span class="keyword">int</span> length);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 数组下标运算符，用于数组元素的赋值和取值</span></span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符，用于数组之间的赋值</span></span><br><span class="line">Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符，判断两个数组是否相同</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Array &amp; array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符，判断两个数组是否不相同</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_length;</span><br><span class="line"><span class="keyword">int</span>* m_space;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>Array.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">int</span> length) {</span><br><span class="line">cout &lt;&lt; <span class="string">"有参构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">0</span>) {</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line">cout &lt;&lt; <span class="string">"拷贝构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 深拷贝，单独分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = array.m_length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[array.m_length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.m_length; i++) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[i] = array.m_space[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Array::~<span class="built_in">Array</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 数组下标运算符，用于数组元素的赋值和取值</span></span><br><span class="line"><span class="keyword">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符，用于数组之间的赋值</span></span><br><span class="line">Array&amp; Array::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝，单独分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = array.m_length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[array.m_length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.m_length; i++) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[i] = array.m_space[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符，判断两个数组是否相同</span></span><br><span class="line"><span class="keyword">bool</span> Array::<span class="keyword">operator</span>==(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length != array.m_length) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_length; i++) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space[i] != array.m_space[i]) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符，判断两个数组是否不相同</span></span><br><span class="line"><span class="keyword">bool</span> Array::<span class="keyword">operator</span>!=(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == array);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Array::length</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用构造函数</span></span><br><span class="line"><span class="function">Array <span class="title">array1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">length</span>(); i++) {</span><br><span class="line">array1[i] = i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">length</span>(); i++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"array1["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array1[i] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用拷贝构造函数（属于深拷贝）</span></span><br><span class="line">Array array2 = array1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.<span class="built_in">length</span>(); i++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"array2["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array2[i] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用拷贝构造函数（属于深拷贝）</span></span><br><span class="line">Array array3 = array1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用拷贝构造函数（属于浅拷贝）</span></span><br><span class="line"><span class="comment">// 默认情况下，若这里不对 "=" 运算符进行重载，最终程序会异常终止运行（由于同一块内存空间被释放两次导致）</span></span><br><span class="line">array3 = array2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array3.<span class="built_in">length</span>(); i++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"array3["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array3[i] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个数组是否相同</span></span><br><span class="line"><span class="keyword">bool</span> result1 = array1 == array2;</span><br><span class="line">string strResult1 = result1 ? <span class="string">"="</span> : <span class="string">"!="</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"array1 "</span> &lt;&lt; strResult1 &lt;&lt; <span class="string">" array2 "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个数组是否不相同</span></span><br><span class="line"><span class="keyword">bool</span> result2 = array1 != array2;</span><br><span class="line">string strResult2 = result2 ? <span class="string">"!="</span> : <span class="string">"="</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"array1 "</span> &lt;&lt; strResult2 &lt;&lt; <span class="string">" array2 "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用</span><br><span class="line">array1[0] = 0</span><br><span class="line">array1[1] = 1</span><br><span class="line">array1[2] = 2</span><br><span class="line">array1[3] = 3</span><br><span class="line">array1[4] = 4</span><br><span class="line">拷贝构造函数被调用</span><br><span class="line">array2[0] = 0</span><br><span class="line">array2[1] = 1</span><br><span class="line">array2[2] = 2</span><br><span class="line">array2[3] = 3</span><br><span class="line">array2[4] = 4</span><br><span class="line">拷贝构造函数被调用</span><br><span class="line">array3[0] = 0</span><br><span class="line">array3[1] = 1</span><br><span class="line">array3[2] = 2</span><br><span class="line">array3[3] = 3</span><br><span class="line">array3[4] = 4</span><br><span class="line">array1 = array2</span><br><span class="line">array1 = array2</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></tbody></table></figure></code></details><h4 id="重载自定义字符串类的各种运算符"><a href="#重载自定义字符串类的各种运算符" class="headerlink" title="重载自定义字符串类的各种运算符"></a>重载自定义字符串类的各种运算符</h4><p>在本案例中，自定义了字符串类 <code>MyString</code>，并使用类成员函数和友元函数分别对 <code>MyString</code> 类的 <code>[]</code>、<code>=</code>、<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;&gt;</code>、<code>&lt;&lt;</code> 运算符进行重载。</p><details><summary>★点击显示完整的案例代码★</summary><code><ul><li>MyString.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyString</span>();</span><br><span class="line"><span class="built_in">MyString</span>(<span class="keyword">int</span> len);</span><br><span class="line"><span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p);</span><br><span class="line"><span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">MyString</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 运算符</span></span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* p);</span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&gt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&lt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&lt;&lt;" 运算符</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&gt;&gt;" 运算符</span></span><br><span class="line"><span class="keyword">friend</span> iostream&amp; <span class="keyword">operator</span>&gt;&gt;(iostream&amp; in, MyString&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_length;</span><br><span class="line"><span class="keyword">char</span>* m_space;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>MyString.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>() {</span><br><span class="line"><span class="comment">// 初始化为空字符串</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">int</span> len) {</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) {</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 初始化为空字符串</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = len;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p) {</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line"><span class="comment">// 初始化为空字符串</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, p);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">MyString::<span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line"><span class="comment">// 深拷贝，重新分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = str.m_length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MyString::~<span class="built_in">MyString</span>() {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "[]" 运算符</span></span><br><span class="line"><span class="keyword">char</span>&amp; MyString::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符</span></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* p) {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝，重新分配内存空间</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line"><span class="comment">// 初始化为空字符串</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, p);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "=" 运算符</span></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) {</span><br><span class="line"><span class="comment">// 释放内存空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 深拷贝，重新分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = str.m_length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;m_length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "==" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length == <span class="number">0</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length != <span class="built_in">strlen</span>(p)) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>==(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_length != str.m_length) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "!=" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>!=(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == str);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&gt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(p, <span class="keyword">this</span>-&gt;m_space) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(str.m_space, <span class="keyword">this</span>-&gt;m_space) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类成员函数重载 "&lt;" 运算符</span></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="keyword">char</span>* p) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, p) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString str) <span class="keyword">const</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;m_space, str.m_space) &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&lt;&lt;" 运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyString&amp; str) {</span><br><span class="line">out &lt;&lt; str.m_space;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用友元函数重载 "&gt;&gt;" 运算符</span></span><br><span class="line">iostream&amp; <span class="keyword">operator</span>&gt;&gt;(iostream&amp; in, MyString&amp; str)</span><br><span class="line">{</span><br><span class="line">in &gt;&gt; str.m_space;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyString::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">MyString::c_str</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用有参构造函数</span></span><br><span class="line"><span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line"><span class="function">MyString <span class="title">str2</span><span class="params">(<span class="literal">NULL</span>)</span></span>;</span><br><span class="line"><span class="function">MyString <span class="title">str3</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用拷贝构造函数</span></span><br><span class="line">MyString str4 = str1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "&lt;&lt;" 运算符</span></span><br><span class="line">cout &lt;&lt; <span class="string">"str2 = "</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用拷贝构造函数（属于浅拷贝）</span></span><br><span class="line"><span class="comment">// 重载 "=" 运算符，实现深拷贝</span></span><br><span class="line">str4 = str3;</span><br><span class="line">cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">str4 = <span class="string">"Jim"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">str4 = <span class="literal">NULL</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "[]" 运算符</span></span><br><span class="line"><span class="function">MyString <span class="title">str5</span><span class="params">(<span class="string">"David"</span>)</span></span>;</span><br><span class="line">str5[<span class="number">0</span>] = <span class="string">'F'</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"str5[0] = "</span> &lt;&lt; str5[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"str5 = "</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "==" 运算符</span></span><br><span class="line"><span class="function">MyString <span class="title">str6</span><span class="params">(<span class="string">"Aaron"</span>)</span></span>;</span><br><span class="line">MyString str7 = str6;</span><br><span class="line">cout &lt;&lt; str6 &lt;&lt; (str6 == str7 ? <span class="string">" = "</span> : <span class="string">" != "</span>) &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "!=" 运算符</span></span><br><span class="line">cout &lt;&lt; str6 &lt;&lt; (str6 != <span class="literal">NULL</span> ? <span class="string">" != "</span> : <span class="string">" = "</span>) &lt;&lt; <span class="string">" NULL"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "&lt;" 运算符</span></span><br><span class="line"><span class="function">MyString <span class="title">str8</span><span class="params">(<span class="string">"AAAA"</span>)</span></span>;</span><br><span class="line"><span class="function">MyString <span class="title">str9</span><span class="params">(<span class="string">"BBBB"</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str8 &lt;&lt; (str8 &lt; str9 ? <span class="string">" &lt; "</span> : <span class="string">" &gt; "</span>) &lt;&lt; str9 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str8 &lt;&lt; (str8 &lt; <span class="string">"CCCC"</span> ? <span class="string">" &lt; "</span> : <span class="string">" &gt; "</span>) &lt;&lt; <span class="string">"CCCC"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "&gt;" 运算符</span></span><br><span class="line">cout &lt;&lt; str9 &lt;&lt; (str9 &gt; str8 ? <span class="string">" &gt; "</span> : <span class="string">" &lt; "</span>) &lt;&lt; str8 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str9 &lt;&lt; (str9 &gt; <span class="string">"DDDD"</span> ? <span class="string">" &gt; "</span> : <span class="string">" &lt; "</span>) &lt;&lt; <span class="string">"DDDD"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 "&gt;&gt;" 运算符</span></span><br><span class="line"><span class="function">MyString <span class="title">str11</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入长度为 5 的字符串："</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str11.<span class="built_in">c_str</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"str11 = "</span> &lt;&lt; str11 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyString str4 = NULL;   此写法，会自动调用有参构造函数 `MyString(const char* p);`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyString str1("AB");</span></span><br><span class="line"><span class="comment">// MyString str2 = str1;</span></span><br><span class="line"><span class="comment">// str2 = NULL:    此写法，会自动调用 "=" 运算符重载的函数 `bool operator==(const char* p) const;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">str2 =</span><br><span class="line">str4 = Tom</span><br><span class="line"></span><br><span class="line">str4 = Peter</span><br><span class="line">str4 = Jim</span><br><span class="line">str4 =</span><br><span class="line"></span><br><span class="line">str5[0] = F</span><br><span class="line">str5 = Favid</span><br><span class="line"></span><br><span class="line">Aaron = Aaron</span><br><span class="line">Aaron !=  NULL</span><br><span class="line"></span><br><span class="line">AAAA &lt; BBBB</span><br><span class="line">AAAA &lt; CCCC</span><br><span class="line">BBBB &gt; AAAA</span><br><span class="line">BBBB &lt; DDDD</span><br><span class="line"></span><br><span class="line">请输入长度为 5 的字符串：</span><br><span class="line">abcde</span><br><span class="line">str11 = abcde</span><br></pre></td></tr></tbody></table></figure></code></details><h2 id="C-运算符和结合性的附录"><a href="#C-运算符和结合性的附录" class="headerlink" title="C++ 运算符和结合性的附录"></a>C++ 运算符和结合性的附录</h2><p><img data-src="../../../asset/2021/11/cplusplus-overload-9.png" alt="cplusplus-overload-9"><br><img data-src="../../../asset/2021/11/cplusplus-overload-10.png" alt="cplusplus-overload-10"></p>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括友元函数、友元类、运算符重载等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解决 Windows 系统使用 NPM 时遇到的各种问题</title>
    <link href="https://www.techgrow.cn/posts/b53b9a77.html"/>
    <id>https://www.techgrow.cn/posts/b53b9a77.html</id>
    <published>2021-11-03T13:55:33.000Z</published>
    <updated>2021-11-03T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="pngquant-bin-模块安装失败"><a href="#pngquant-bin-模块安装失败" class="headerlink" title="pngquant-bin 模块安装失败"></a>pngquant-bin 模块安装失败</h2><p>错误信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! path E:\Workspaces_NodeJs\hexo\node_modules\pngquant-bin</span><br><span class="line">npm ERR! command failed</span><br><span class="line">npm ERR! command C:\WINDOWS\system32\cmd.exe /d /s /c node lib/install.js</span><br><span class="line">npm ERR! ‼ getaddrinfo ENOENT raw.githubusercontent.com</span><br><span class="line">npm ERR!   ‼ pngquant pre-build test failed</span><br><span class="line">npm ERR!   i compiling from source</span><br><span class="line">npm ERR!   × ErroE: pngquant failed to build, make sure that libpng-dev is installed</span><br><span class="line">npm ERR!     at E:\Workspaces_NodeJs\hexo\node_modules\bin-build\node_modules\execa\index.js:231:11</span><br><span class="line">npm ERR!     at runMicrotasks (&lt;anonymous&gt;)</span><br><span class="line">npm ERR!     at processTicksAndRejections (node:internal/process/task_queues:96:5)</span><br><span class="line">npm ERR!     at async Promise.all (index 0)</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>解决方法一：</p><p>使用 <code>系统管理员身份</code>，在 Windows 系统上执行 <code>npm install -g windows-build-tools</code> 命令，安装系统缺失的编译工具，然后执行 <code>npm install</code> 命令安装需要的 NPM 模块</p><p>解决方法二（推荐）：</p><p>使用 CNPM 替代 NPM，然后执行 <code>cnpm install</code> 命令安装需要的 NPM 模块</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装CNPM</span><br><span class="line">&gt; npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></tbody></table></figure><p>解决方法三（推荐）：</p><p>在 Windows 系统上挂载 VPN，然后执行 <code>npm install</code> 命令安装需要的 NPM 模块，这可以从根本上解决国内访问 <code>raw.githubusercontent.com</code> 域名时被墙的问题</p><p>解决方法四：</p><p>更改 Host 文件 <code>C:\Windows\System32\drivers\etc\hosts</code>，在文件末尾添加以下内容，解决国内访问 <code>raw.githubusercontent.com</code> 域名时被墙的问题，然后执行 <code>npm install</code> 命令安装需要的 NPM 模块</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">199.232.28.133  raw.githubusercontent.com</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍如何解决 Windows 系统使用 NPM 时遇到的各种问题。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Windows系统" scheme="https://www.techgrow.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10 系统备份与还原常见错误解决</title>
    <link href="https://www.techgrow.cn/posts/490dddd2.html"/>
    <id>https://www.techgrow.cn/posts/490dddd2.html</id>
    <published>2021-11-02T13:55:33.000Z</published>
    <updated>2021-11-02T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows 10 中的备份和还原（Windows 7）作为 Microsoft Windows 组件，继承了 Windows 7 的功能，该功能使您可以备份与恢复文件以及创建系统映像。如果在 Windows 的早期版本中使用 <code>备份</code> 和 <code>还原</code> 来备份文件或创建系统映像，则仍可以在 Windows 10 中恢复这些备份。此外，Windows 10 还包括另一个备份与恢复工具 - <code>文件历史记录</code>，它只备份文档，音乐，图片，视频和桌面文件夹中文件的版本，以及 PC 上可用的 OneDrive 文件。如果要使用 <code>文件历史记录</code> 备份位于其他位置的其他文件，可以将其移至这些文件夹之一，然后再进行备份。保存备份的两个目标地址支持外部硬盘驱动器（例如 USB 闪存驱动器）和网络位置。</p><span id="more"></span><h2 id="系统备份常见错误"><a href="#系统备份常见错误" class="headerlink" title="系统备份常见错误"></a>系统备份常见错误</h2><h3 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h3><h4 id="错误提示信息"><a href="#错误提示信息" class="headerlink" title="错误提示信息"></a>错误提示信息</h4><p><code>无法创建卷影副本，请检查 vss 和 spp 应用程序事件日志更多信息（错误代码：0x81000019）</code></p><p>或者</p><p><code>由于内部错误，备份应用程序无法启动：卷影复制服务组件遇到意外错误（错误代码：0x80042302）</code></p><h4 id="错误解决方案一"><a href="#错误解决方案一" class="headerlink" title="错误解决方案一"></a>错误解决方案一</h4><p>这个错误可能是由于三方杀毒软件冲突或者一些 Windows 备份相关的服务被禁用导致的，具体解决步骤如下：</p><ul><li>a) 暂时关闭或卸载第三方杀毒软件</li><li> b) 使用快捷键 <code>windows + r</code>，输入 <code>services.msc</code>，打开服务控制台，并检查下列服务是否正常运行。如果服务被禁用，请将其启用，并将启动类型设置为 <code>自动</code>。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Volume Shadow Copy (VSS)</span><br><span class="line">Remote Procedure Call (RPCSS)</span><br><span class="line">COM+ Event System (eventsystem)</span><br><span class="line">System Event Notification Service (sens)</span><br><span class="line">Microsoft Software Shadow Copy Provider (SWPRV)</span><br></pre></td></tr></tbody></table></figure><ul><li>c) 重启 Windows 10 系统，然后再次尝试执行系统备份</li></ul><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-4014850419768221" data-ad-slot="7606918662"></ins><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><h4 id="错误解决方案二"><a href="#错误解决方案二" class="headerlink" title="错误解决方案二"></a>错误解决方案二</h4><ul><li>a) 使用快捷键 <code>windows + r</code>，输入 <code>msconfig</code></li></ul><p><img data-src="../../../asset/2021/11/windows-backup-3.png" alt="windows-backup-3"></p><ul><li>b) 点击 <code>服务</code> 标签卡，勾选 <code>隐藏所有的 Microsoft 服务</code> ，然后点击全部禁用并应用</li></ul><p><img data-src="../../../asset/2021/11/windows-backup-4.png" alt="windows-backup-4"></p><ul><li> c) 点击 <code>启动</code> 标签卡，点击 <code>打开任务管理器</code></li></ul><p><img data-src="../../../asset/2021/11/windows-backup-5.png" alt="windows-backup-5"></p><ul><li>d) 禁用全部开机启动项</li></ul><p><img data-src="../../../asset/2021/11/windows-backup-6.png" alt="windows-backup-6"></p><ul><li><p> e) 重启 Windows 10 系统，然后再次尝试执行系统备份</p></li><li><p>f) 系统成功备份后，重新启用在上面的步骤中禁用的服务和开机启动项，最后再次重启系统</p></li></ul><h3 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h3><h4 id="错误提示信息-1"><a href="#错误提示信息-1" class="headerlink" title="错误提示信息"></a>错误提示信息</h4><p><code>Windows 备份在源卷上创建共享保护点失败（错误代码：0×8078006B）</code></p><h4 id="错误解决方案"><a href="#错误解决方案" class="headerlink" title="错误解决方案"></a>错误解决方案</h4><p>这个错误一般是由程序冲突引起的，目前排查出是 <code>腾讯电脑管家</code> 的设置问题导致，具体解决步骤如下：</p><ul><li>a) 打开 <code>腾讯电脑管家</code> 的 <code>设置中心</code></li></ul><p><img data-src="../../../asset/2021/11/windows-backup-1.png" alt="windows-backup-1"></p><ul><li>b) 找到 <code>实时防护</code> 菜单下面的 <code>其他安全提示</code>，将 <code>开启卷影备份</code> 的勾选去掉</li></ul><p><img data-src="../../../asset/2021/11/windows-backup-2.png" alt="windows-backup-2"></p><ul><li> c) 如果上述设置仍然没办法解决问题，建议暂时关闭或卸载 <code>腾讯电脑管家</code></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Windows 10 系统备份与还原常见错误的解决方案。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Windows系统" scheme="https://www.techgrow.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio 使用命令行编译 C/C++ 程序</title>
    <link href="https://www.techgrow.cn/posts/ab3ae9a.html"/>
    <id>https://www.techgrow.cn/posts/ab3ae9a.html</id>
    <published>2021-11-01T13:55:33.000Z</published>
    <updated>2021-11-08T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="VS-使用命令行编译单个-C-C-源文件"><a href="#VS-使用命令行编译单个-C-C-源文件" class="headerlink" title="VS 使用命令行编译单个 C/C++ 源文件"></a>VS 使用命令行编译单个 C/C++ 源文件</h2><p>在 Windows 系统的开始菜单栏里，找到 <code>Developer Command Prompt for VS 2019</code> 应用程序，双击运行后，在 <code>Command</code> 窗口内执行以下命令来编单个 C/C++ 源文件。值得一提的是，这里需要将以下命令中的 <code>HelloWorld</code> 字符串替换为本地真正的 C/C++ 源文件的文件名。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 查看文件列表</span><br><span class="line">&gt; dir</span><br><span class="line">2021/10/30  16:05    &lt;DIR&gt;          .</span><br><span class="line">2021/10/30  16:05    &lt;DIR&gt;          ..</span><br><span class="line">2021/10/30  22:15               601 HelloWorld.cpp</span><br><span class="line"></span><br><span class="line"># 编译C/C++源文件（cl后面字符的是小写L不是数字1）</span><br><span class="line">&gt; cl HelloWorld.cpp /EHsc</span><br><span class="line"></span><br><span class="line"># 查看文件列表，发现成功编译后会多了两个文件</span><br><span class="line">&gt; dir</span><br><span class="line">2021/10/30  16:53    &lt;DIR&gt;          .</span><br><span class="line">2021/10/30  16:53    &lt;DIR&gt;          ..</span><br><span class="line">2021/10/30  22:15               601 HelloWorld.cpp</span><br><span class="line">2021/10/30  16:53           101,888 HelloWorld.exe</span><br><span class="line">2021/10/30  16:53             1,976 HelloWorld.obj</span><br><span class="line"></span><br><span class="line"># 运行编译后的C/C++程序</span><br><span class="line">&gt; HelloWorld    或者 HelloWorld.exe</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="VS-使用命令行编译多个-C-C-源文件"><a href="#VS-使用命令行编译多个-C-C-源文件" class="headerlink" title="VS 使用命令行编译多个 C/C++ 源文件"></a>VS 使用命令行编译多个 C/C++ 源文件</h2><p>假设项目里有如下的三个 C/C++ 源文件，分别是 <code>Array.h</code>、<code>Array.cpp</code>、<code>main.cpp</code>，那么编译这几个文件时就可以使用命令：<code>cl main.cpp Array.cpp /EHsc</code>。值得一提的是，编译命令里不需要指定以 <code>.h</code> 作为后缀的文件，只需要指定所有以 <code>.c</code> 或者 <code>.cpp</code> 作为后缀的文件即可。</p><ul><li>Array.h</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Array</span>(<span class="keyword">int</span> length);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; array);</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_length;</span><br><span class="line"><span class="keyword">int</span>* m_space;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>Array.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">int</span> length) {</span><br><span class="line">cout &lt;&lt; <span class="string">"有参构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">0</span>) {</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; array) {</span><br><span class="line">cout &lt;&lt; <span class="string">"拷贝构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 深拷贝，单独分配内存空间</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = array.m_length;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="keyword">new</span> <span class="keyword">int</span>[array.m_length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.m_length; i++) {</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[i] = array.m_space[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Array::~<span class="built_in">Array</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_space != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_space;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_length = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::setData</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;m_space[index] = value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Array::getData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_space[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Array::length</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>main.cpp</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用构造函数初始化数组</span></span><br><span class="line"><span class="function">Array <span class="title">array1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">length</span>(); i++) {</span><br><span class="line">array1.<span class="built_in">setData</span>(i, i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.<span class="built_in">length</span>(); i++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"array1["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array1.<span class="built_in">getData</span>(i) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用拷贝构造函数初始化数组（属于深拷贝）</span></span><br><span class="line">Array array2 = array1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.<span class="built_in">length</span>(); i++) {</span><br><span class="line">cout &lt;&lt; <span class="string">"array2["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; array2.<span class="built_in">getData</span>(i) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行命令编译 C/C++ 程序后，控制台输出的日志信息如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; cl main.cpp Array.cpp /EHsc</span><br><span class="line"></span><br><span class="line">用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.29.30136 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line">Array.cpp</span><br><span class="line">正在生成代码...</span><br><span class="line">Microsoft (R) Incremental Linker Version 14.29.30136.0</span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">/out:main.exe</span><br><span class="line">main.obj</span><br><span class="line">Array.obj</span><br></pre></td></tr></tbody></table></figure><p>运行编译后的 C/C++ 程序：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; main</span><br><span class="line"></span><br><span class="line">有参构造函数被调用</span><br><span class="line">array1[0] = 0</span><br><span class="line">array1[1] = 1</span><br><span class="line">array1[2] = 2</span><br><span class="line">array1[3] = 3</span><br><span class="line">array1[4] = 4</span><br><span class="line">拷贝构造函数被调用</span><br><span class="line">array2[0] = 0</span><br><span class="line">array2[1] = 1</span><br><span class="line">array2[2] = 2</span><br><span class="line">array2[3] = 3</span><br><span class="line">array2[4] = 4</span><br><span class="line">析构函数被调用</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></tbody></table></figure><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://blog.csdn.net/sbkebcmj/article/details/89711209">模仿 Visual Studio - 命令行编译 C/C++ 程序</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Visual Studio 如何使用命令行编译 C 语言和 C++ 程序。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="开发工具" scheme="https://www.techgrow.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之五</title>
    <link href="https://www.techgrow.cn/posts/a35089f6.html"/>
    <id>https://www.techgrow.cn/posts/a35089f6.html</id>
    <published>2021-10-27T13:55:33.000Z</published>
    <updated>2021-11-03T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><ul><li>C++ 提供的默认拷贝构造函数，可以完成对象的数据成员值简单的复制（浅拷贝）</li><li>对象的数据资源是由指针指向的堆，C++ 提供的默认拷贝构造函数仅作指针值复制（浅拷贝）</li></ul><h3 id="浅拷贝问题剖析"><a href="#浅拷贝问题剖析" class="headerlink" title="浅拷贝问题剖析"></a>浅拷贝问题剖析</h3><span id="more"></span><h4 id="问题抛出"><a href="#问题抛出" class="headerlink" title="问题抛出"></a>问题抛出</h4><p>思考以下的代码为什么会异常终止运行。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Name</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(name);</span><br><span class="line">        p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(length + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p, name);</span><br><span class="line">        len = length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Name</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getP</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Name <span class="title">obj1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line">    Name obj2 = obj1;       <span class="comment">// 自动调用C++提供的默认拷贝构造函数，属于浅拷贝</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1.name: "</span> &lt;&lt; obj1.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj1.len:  "</span> &lt;&lt; obj1.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj2.name: "</span> &lt;&lt; obj2.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj2.len:  "</span> &lt;&lt; obj2.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">obj1.name: Peter, obj1.len:  5</span><br><span class="line">obj2.name: Peter, obj2.len:  5</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line"></span><br><span class="line">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></tbody></table></figure><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>由于在上述的代码中，没有自定义拷贝构造函数，使用的是 C++ 编译器提供的默认拷贝构造函数，因此程序异常终止运行。造成程序异常终止运行的根本原因是，C++ 提供的默认拷贝构造函数属于浅拷贝，当程序运行结束之前，在第二次调用上面的析构函数时会出现错误（同一块内存空间被释放了两次），底层的分析图解可以看<a href="../../../asset/2021/10/cplusplus-copy-1.png">这里</a>。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>显式编写自定义的拷贝构造函数，通过实现深拷贝（申请新的内存空间）来解决上述的问题，底层的分析图解可以看<a href="../../../asset/2021/10/cplusplus-copy-2.png">这里</a>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Name</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(name);</span><br><span class="line">        p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(length + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p, name);</span><br><span class="line">        len = length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝的实现</span></span><br><span class="line">    <span class="built_in">Name</span>(<span class="keyword">const</span> Name &amp;name) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> length = name.<span class="built_in">getLen</span>();</span><br><span class="line">        p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(length + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p, name.<span class="built_in">getP</span>());</span><br><span class="line">        len = length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Name</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getP</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Name <span class="title">obj1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line">    Name obj3 = obj1;       <span class="comment">// 自动调用自定义的拷贝构造函数（深拷贝）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1.name: "</span> &lt;&lt; obj1.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj1.len:  "</span> &lt;&lt; obj1.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj3.name: "</span> &lt;&lt; obj3.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj3.len:  "</span> &lt;&lt; obj3.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">拷贝构造函数被调用了</span><br><span class="line">obj1.name: Peter, obj1.len:  5</span><br><span class="line">obj3.name: Peter, obj3.len:  5</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br></pre></td></tr></tbody></table></figure><p><strong>特别注意：</strong></p><p>在以下的代码中，<code>obj3 = obj1;</code> 依旧属于浅拷贝（这里不会自动调用拷贝构造函数），最终程序也会异常终止运行。若希望解决该问题，需要重载 C++ 的 <code>=</code> 操作符，这里暂时不展开讨论。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Name <span class="title">obj1</span><span class="params">(<span class="string">"Peter"</span>)</span></span>;</span><br><span class="line">    <span class="function">Name <span class="title">obj3</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line">    obj3 = obj1;       <span class="comment">// 浅拷贝，不会自动调用拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1.name: "</span> &lt;&lt; obj1.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj1.len:  "</span> &lt;&lt; obj1.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj3.name: "</span> &lt;&lt; obj3.<span class="built_in">getP</span>() &lt;&lt; <span class="string">", obj3.len:  "</span> &lt;&lt; obj3.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">obj1.name: Peter, obj1.len:  5</span><br><span class="line">obj3.name: Peter, obj3.len:  5</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line"></span><br><span class="line">Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</span><br></pre></td></tr></tbody></table></figure><h2 id="对象的动态建立和释放"><a href="#对象的动态建立和释放" class="headerlink" title="对象的动态建立和释放"></a>对象的动态建立和释放</h2><p><strong>使用类名定义的对象都是静态的（如 <code>Teacher t(30);</code>），在程序运行过程中，对象所占的内存空间是不能随时释放的，只有在程序运行结束之后才会被释放。</strong>但有时候用户希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用，这样可提高内存空间的利用率。在 C++ 中，可以用 <code>new</code> 运算符动态建立对象，用 <code>delete</code> 运算符动态撤销对象。</p><h3 id="new-和-delete-介绍"><a href="#new-和-delete-介绍" class="headerlink" title="new 和 delete 介绍"></a>new 和 delete 介绍</h3><p>在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在 C 语言中是利用库函数 <code>malloc()</code> 和 <code>free()</code> 来分配和撤销内存空间的。C++ 提供了较简便而功能较强的运算符 <code>new</code> 和 <code>delete</code> 来取代 <code>malloc()</code> 和 <code>free()</code> 函数。值得注意的是，<code>new</code> 和 <code>delete</code> 是运算符，不是函数，因此执行效率更高。虽然为了与 C 语言兼容，C++ 仍保留 <code>malloc()</code> 和 <code>free()</code> 函数，但建议用户不要使用 <code>malloc()</code> 和 <code>free()</code> 函数，而是使用 <code>new</code> 和 <code>delete</code> 运算符。</p><h3 id="new-和-delete-的基础语法"><a href="#new-和-delete-的基础语法" class="headerlink" title="new 和 delete 的基础语法"></a>new 和 delete 的基础语法</h3><p><img data-src="../../../asset/2021/10/cplusplus-new.png" alt="cplusplus-new"><br><img data-src="../../../asset/2021/10/cplusplus-delete.png" alt="cplusplus-delete"></p><p><code>new</code> 运算符的简单使用例子如下：</p><ul><li><code>new int;</code>：开辟一个存放整数的内存空间，返回一个指向该内存空间的地址（即指针）</li><li><code>new int(100);</code>：开辟一个存放整数的空间，并指定该整数的初值为 100，返回一个指向该内存空间的地址（即指针）</li><li><code>new char[10];</code>：开辟一个存放字符数组（包括 10 个元素）的空间，返回首元素的地址（即指针）</li><li><code>new int[5][4];</code>：开辟一个存放二维整型数组（大小为 5*4）的空间，返回首元素的地址（即指针）</li><li><code>float *p = new float (3.14159);</code>：开辟一个存放单精度数的空间，并指定该实数的初值为 3.14159，将返回的该空间的地址赋给指针变量</li></ul><p>值得注意的是，用 <code>new</code> 分配数组内存空间时不能指定初值，如果由于内存不足等原因而导致无法正常分配内存空间，那么 <code>new</code> 会返回一个空指针 <code>NULL</code>，用户可以根据该指针的值判断内存空间是否分配成功。</p><h3 id="new-和-delete-的使用案例"><a href="#new-和-delete-的使用案例" class="headerlink" title="new 和 delete 的使用案例"></a>new 和 delete 的使用案例</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>(<span class="keyword">int</span> age) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">        cout &lt;&lt; <span class="string">"构造函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Teacher</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAget</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_age;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言分配基础类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionA -&gt; p = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++分配基础类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionB</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *a = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionB -&gt; a = "</span> &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionB -&gt; b = "</span> &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言分配数组类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionC</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">3</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">    p[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionC -&gt; p = "</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; p[<span class="number">1</span>] &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++分配数组类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionD</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">0</span>] = <span class="string">'e'</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="string">'f'</span>;</span><br><span class="line">    p[<span class="number">2</span>] = <span class="string">'g'</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionD -&gt; p = "</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; p[<span class="number">1</span>] &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionE</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 这里不会自动调用类的构造函数和析构函数</span></span><br><span class="line">    Teacher *p = (Teacher *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Teacher));</span><br><span class="line">    p-&gt;<span class="built_in">setAget</span>(<span class="number">33</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionE -&gt; age = "</span> &lt;&lt; p-&gt;<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionF</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// new和delete会分别自动调用类的构造函数和析构函数</span></span><br><span class="line">    Teacher *p = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">35</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"functionF -&gt; age = "</span> &lt;&lt; p-&gt;<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">functionA</span>();</span><br><span class="line">    <span class="built_in">functionB</span>();</span><br><span class="line">    <span class="built_in">functionC</span>();</span><br><span class="line">    <span class="built_in">functionD</span>();</span><br><span class="line">    <span class="built_in">functionE</span>();</span><br><span class="line">    <span class="built_in">functionF</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">functionA -&gt; p = 3</span><br><span class="line">functionB -&gt; a = 3</span><br><span class="line">functionB -&gt; b = 30</span><br><span class="line">functionC -&gt; p = abc</span><br><span class="line">functionD -&gt; p = efg</span><br><span class="line">functionE -&gt; age = 33</span><br><span class="line">构造函数被调用</span><br><span class="line">functionF -&gt; age = 35</span><br><span class="line">析构函数被调用</span><br></pre></td></tr></tbody></table></figure><p>上面的 <code>Teacher *p = new Teacher(35);</code> 这种写法，是将两个语句（定义指针变量和使用 <code>new</code> 建立新对象）合并为一个语句，并指定初值，在调用对象时，既可以通过对象名，也可以通过指针。在执行 <code>new</code> 运算符时，如果内存空间不足，无法开辟所需的内存空间，目前大多数 C++ 编译器都会返回一个 <code>0</code> 指针值。只要检测返回值是否为 <code>0</code>，就可判断内存空间是否分配成功。ANSI C++ 标准提出，在执行 <code>new</code> 出现故障时，就抛出一个异常，用户可根据异常进行相关处理，但 C++ 标准仍然允许在出现 <code>new</code> 故障时返回 <code>0</code> 指针值。值得注意的是，不同的编译器对 <code>new</code> 故障的处理方法是不同的。当不再需要使用由 <code>new</code> 建立的对象时，可以用 <code>delete</code> 运算符予以释放，此后程序不能再使用该对象。如果用一个指针变量先后指向了不同的动态对象，应注意指针变量的当前指向，以避免释放错了对象。在执行 <code>delete</code> 运算符时，在释放内存空间之前，会自动调用类的析构函数，完成有关善后清理工作。</p><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><h3 id="静态成员变量的概念"><a href="#静态成员变量的概念" class="headerlink" title="静态成员变量的概念"></a>静态成员变量的概念</h3><ul><li>静态成员局部于类，它不是对象成员</li><li>在类外访问静态成员变量时，可以使用 <code>类名 :: </code> 作为限定词，或通过对象访问</li><li>关键字 <code>static</code> 可以用于声明一个类的成员，静态成员提供了一个同类对象的共享机制</li><li>将一个类的成员声明为 <code>static</code> 时，这个类无论有多少个对象被创建，这些对象都共享这个 <code>static</code> 成员 </li></ul><p><img data-src="../../../asset/2021/10/cplusplus-static.png" alt="cplusplus-static"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明静态成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数访问静态成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">        num = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态成员变量，这里不是简单的变量赋值，更重要的是告诉C++编译器，给静态成员变量分配内存</span></span><br><span class="line"><span class="keyword">int</span> Counter::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Counter a, b;</span><br><span class="line">    a.<span class="built_in">showNum</span>();</span><br><span class="line">    b.<span class="built_in">showNum</span>();</span><br><span class="line">    a.<span class="built_in">setNum</span>(<span class="number">10</span>);</span><br><span class="line">    a.<span class="built_in">showNum</span>();</span><br><span class="line">    b.<span class="built_in">showNum</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></tbody></table></figure><h3 id="静态成员变量的使用"><a href="#静态成员变量的使用" class="headerlink" title="静态成员变量的使用"></a>静态成员变量的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;             <span class="comment">// 公有成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> smem;     <span class="comment">// 公有静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="keyword">int</span> num) {</span><br><span class="line">        mem = num;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态成员变量，这里不是简单的变量赋值，更重要的是告诉C++编译器，给静态成员变量分配内存</span></span><br><span class="line"><span class="keyword">int</span>  Counter::smem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="comment">// 访问静态成员变量的方法1（通过类名直接访问）</span></span><br><span class="line">        Counter::smem += i;</span><br><span class="line">        cout &lt;&lt; <span class="string">"Counter::smem = "</span>&lt;&lt; Counter::smem &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问静态成员变量的方法2（通过对象访问）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"c.smem = "</span> &lt;&lt; c.smem &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Counter::smem = 0</span><br><span class="line">Counter::smem = 1</span><br><span class="line">Counter::smem = 3</span><br><span class="line">Counter::smem = 6</span><br><span class="line">Counter::smem = 10</span><br><span class="line">c.smem = 10</span><br></pre></td></tr></tbody></table></figure><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><h3 id="静态成员函数的概念"><a href="#静态成员函数的概念" class="headerlink" title="静态成员函数的概念"></a>静态成员函数的概念</h3><ul><li>静态成员函数、静态成员变量都属于类的</li><li>静态成员函数都是以关键字 <code>static</code> 声明</li><li>在类外调用静态成员函数时，可以使用 <code>类名 :: </code> 作为限定词，或通过对象访问</li><li>静态成员函数提供不依赖于类数据结构的共同操作，它没有 <code>this</code> 指针，而普通成员函数包含一个指向具体对象的 <code>this</code> 指针</li></ul><h3 id="静态成员函数的使用"><a href="#静态成员函数的使用" class="headerlink" title="静态成员函数的使用"></a>静态成员函数的使用</h3><p>值得一提的是，在静态成员函数中，不能访问普通成员变量和调用普通成员函数。这是因为静态成员函数属于整个类的，它没办法区分普通成员变量和普通成员函数是属于哪个具体的对象；同时在静态成员函数内，不能使用 <code>this</code> 指针。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明静态成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(Counter *p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> i, Counter *p)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Counter::getNum</span><span class="params">(Counter *p)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> p-&gt;num;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Counter::setNum</span><span class="params">(<span class="keyword">int</span> i, Counter *p)</span> </span>{</span><br><span class="line">    p-&gt;num = i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Counter obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问静态成员函数的方法1（通过类名直接访问）</span></span><br><span class="line">    Counter::<span class="built_in">setNum</span>(<span class="number">1</span>, &amp;obj);</span><br><span class="line">    cout &lt;&lt; <span class="string">"num = "</span> &lt;&lt; Counter::<span class="built_in">getNum</span>(&amp;obj) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问静态成员函数的方法2（通过对象访问）</span></span><br><span class="line">    obj.<span class="built_in">setNum</span>(<span class="number">3</span>, &amp;obj);</span><br><span class="line">    cout &lt;&lt; <span class="string">"num = "</span> &lt;&lt; obj.<span class="built_in">getNum</span>(&amp;obj) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = 1</span><br><span class="line">num = 3</span><br></pre></td></tr></tbody></table></figure><h2 id="C-面向对象模型初探"><a href="#C-面向对象模型初探" class="headerlink" title="C++ 面向对象模型初探"></a>C++ 面向对象模型初探</h2><h3 id="对象模型概述"><a href="#对象模型概述" class="headerlink" title="对象模型概述"></a>对象模型概述</h3><p>C++ 对象模型可以概括为以下两部分：</p><ul><li>对于各种特性支持的底层实现机制</li><li>语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等</li></ul><p>在 C 语言中，“数据” 和 “处理数据的操作（函数）” 是分开来声明的，也就是说，语言本身并没有支持 “数据和函数” 之间的关联性。在 C++ 中，通过抽象数据类型 ADT（Abstract Data Type），在类中定义数据和函数来实现数据和函数直接的绑定。概括来说，在 C++ 类中有两种成员数据：<code>static</code>、<code>nonstatic</code>，三种成员函数：<code>static</code>、<code>nonstatic</code>、<code>virtual</code>。</p><p><img data-src="../../../asset/2021/10/cplusplus-class.png" alt="cplusplus-class"></p><h3 id="属性和函数的处理机制"><a href="#属性和函数的处理机制" class="headerlink" title="属性和函数的处理机制"></a>属性和函数的处理机制</h3><p>C++ 中的 Class 从面向对象理论出发，将变量（属性）和函数（方法）集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> {</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> {</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getK</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setK</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        k = val;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s1:%d \n"</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2:%d \n"</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c1:%d \n"</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(C1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c2:%d \n"</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(C2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1:12</span><br><span class="line">s2:12</span><br><span class="line">c1:12</span><br><span class="line">c2:12</span><br></pre></td></tr></tbody></table></figure><p>通过上面的案例，可以得知 C++ 类对象中的成员变量和成员函数是分开存储的，C 语言中的内存四区模型仍然有效。C++ 中类的普通成员函数都隐式包含一个指向当前对象的 <code>this</code> 指针。</p><ul><li>静态成员变量：存储于全局数据区中</li><li>普通成员变量：存储于对象中，与 <code>struct</code> 变量有相同的内存布局和字节对齐方式</li><li>成员函数：存储于代码段中</li></ul><h3 id="this-指针的使用"><a href="#this-指针的使用" class="headerlink" title="this 指针的使用"></a>this 指针的使用</h3><p><img data-src="../../../asset/2021/11/cplusplus-this.png" alt="cplusplus-this"></p><p>值得一提的是，当使用 <code>const</code> 修饰类成员函数时，成员函数不能修改被调用对象的值，这是因为此时 <code>const</code> 本质上修饰的是 <code>this</code> 指针，间接也说明了 <code>const</code> 与 <code>static</code> 关键字不能同时修饰类成员函数，示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> _m) : _cm(_m) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="comment">// _cm = 10;  是错误写法，对象的_cm属性值不能被改变</span></span><br><span class="line">        <span class="keyword">return</span> _cm;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cmf</span><span class="params">(<span class="keyword">const</span> Test &amp; _tt)</span> </span>{</span><br><span class="line">    cout &lt;&lt; _tt.<span class="built_in">get_cm</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Cmf</span>(t);   <span class="comment">// 打印结果为8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="全局函数与成员函数的使用"><a href="#全局函数与成员函数的使用" class="headerlink" title="全局函数与成员函数的使用"></a>全局函数与成员函数的使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">testAdd</span><span class="params">(Test&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">Test <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + t2.a, <span class="keyword">this</span>-&gt;b + t2.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//t1.testAdd2(t2);</span></span><br><span class="line"><span class="comment">//返回一个引用，相当于返回自身</span></span><br><span class="line"><span class="comment">//返回t1这个元素，this就是&amp;t1</span></span><br><span class="line"><span class="function">Test&amp; <span class="title">testAdd2</span><span class="params">(Test&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;a = <span class="keyword">this</span>-&gt;a + t2.a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = <span class="keyword">this</span>-&gt;b + t2.b;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//把 *(&amp;t1) 又回到了 t1元素</span></span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="function">Test <span class="title">testAdd</span><span class="params">(Test&amp; t1, Test&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Test tmp;</span><br><span class="line">tmp.a = t1.a + t2.a;</span><br><span class="line">tmp.b = t1.b + t2.b;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printT</span><span class="params">(Test* pT)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"a:"</span> &lt;&lt; pT-&gt;a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; pT-&gt;b &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用全局函数</span></span><br><span class="line">Test t3;</span><br><span class="line">t3 = <span class="built_in">testAdd</span>(t1, t2);</span><br><span class="line"><span class="built_in">printT</span>(&amp;t3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成员函数</span></span><br><span class="line">Test t4 = t1.<span class="built_in">testAdd</span>(t2); <span class="comment">// 将匿名对象直接转化成t4</span></span><br><span class="line">t4.<span class="built_in">printT</span>();</span><br><span class="line"></span><br><span class="line">Test t5;</span><br><span class="line">t5 = t1.<span class="built_in">testAdd</span>(t2); <span class="comment">// 将匿名对象复制给t5</span></span><br><span class="line">t5.<span class="built_in">printT</span>();</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">testAdd2</span>(t2); <span class="comment">// 函数内部使用了this指针</span></span><br><span class="line">t1.<span class="built_in">printT</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:4 b: 6</span><br><span class="line">a:4 b: 6</span><br><span class="line">a:4 b: 6</span><br><span class="line">a:4 b: 6</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括浅拷贝与深拷贝、new 和 delete 运算符的使用、静态成员变量和静态成员函数、this 指针的使用等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 解决 libc.so.6 version GLIBC_2.18 not found 的问题</title>
    <link href="https://www.techgrow.cn/posts/15a7083d.html"/>
    <id>https://www.techgrow.cn/posts/15a7083d.html</id>
    <published>2021-10-24T15:12:41.000Z</published>
    <updated>2021-10-24T15:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>错误日志信息</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib64/libc.so.6: version 'GLIBC_2.18' not found</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>系统环境</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br><span class="line">Linux 3.10.0-1160.45.1.el7.x86_64 #1 SMP Wed Oct 13 17:20:51 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>查看当前 GLIBC 的版本</strong></p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> strings /lib64/libc.so.6 | grep GLIBC</span></span><br><span class="line">GLIBC_2.2.5</span><br><span class="line">GLIBC_2.2.6</span><br><span class="line">GLIBC_2.3</span><br><span class="line">GLIBC_2.3.2</span><br><span class="line">GLIBC_2.3.3</span><br><span class="line">GLIBC_2.3.4</span><br><span class="line">GLIBC_2.4</span><br><span class="line">GLIBC_2.5</span><br><span class="line">GLIBC_2.6</span><br><span class="line">GLIBC_2.7</span><br><span class="line">GLIBC_2.8</span><br><span class="line">GLIBC_2.9</span><br><span class="line">GLIBC_2.10</span><br><span class="line">GLIBC_2.11</span><br><span class="line">GLIBC_2.12</span><br><span class="line">GLIBC_2.13</span><br><span class="line">GLIBC_2.14</span><br><span class="line">GLIBC_2.15</span><br><span class="line">GLIBC_2.16</span><br><span class="line">GLIBC_2.17</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><blockquote><p><strong>问题分析</strong></p></blockquote><p>通过查看当前 GLIBC 的版本，可以发现目前系统中最高只支持 <code>GLIBC_2.17</code>，当需要安装依赖 <code>GLIBC_2.18</code> 的软件时，就会出现 <code>libc.so.6: version 'GLIBC_2.18' not found</code> 的错误信息。<code>glibc</code> 是 GNU 发布的 <code>libc</code> 库，即 C 运行库。<code>glibc</code> 是 Linux 系统中最底层的 API，几乎其它任何运行库都会依赖于 <code>glibc</code>。值得一提的是，<code>glibc</code> 除了封装了 Linux 操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。对于 CentOS 这样的系统，为了追求稳定性（这个值得商榷）往往各种库版本都很低，比如 CentOS 6.5 甚至 CentOS 7.0 自带的还是 <code>glibc 2.12</code>, 而 Ubuntu 14.04 自带 <code>glibc2.19</code>。如果升级 <code>glibc</code> 到一个太新的版本，可能会影响 CentOS 的稳定运行，所以不建议随便升级 <code>glibc</code> 的版本。</p><blockquote><p><strong>解决思路</strong></p></blockquote><ul><li>a) 手动编译安装高版本的 <code>gcc</code></li><li>b) 在低版本的系统编译自己的软件，前提是自己的软件确实不需要使用新版 GCC 才支持的特性</li><li> c) 利用容器技术（如 Docker），在低版本的操作系统内，轻量级的隔离出一个虚拟运行环境，适应自己的软件</li></ul><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-4014850419768221" data-ad-slot="7606918662"></ins><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><blockquote><p><strong>编译安装 GCC</strong></p></blockquote><p><code>glibc</code> 的各个版本可以在<a href="https://ftp.gnu.org/gnu/glibc/">这里</a>下载。<strong>特别注意，在条件允许的情况下，强烈建议在执行下述的 <code>make install</code> 命令之前，全量备份整个 Linux 系统，防止因系统文件意外被破坏，导致系统在启动或运行期间出现崩溃的问题。</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载glibc-2.18</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> curl -O http://ftp.gnu.org/gnu/glibc/glibc-2.18.tar.gz</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar zxf glibc-2.18.tar.gz</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入解压目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> glibc-2.18</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立输出目录，用于存放编译时所有产生的中间文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir build</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入输出目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin --enable-checking=release --enable-languages=c,c++</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译GCC，指定编译使用的线程数为8，编译耗时较长</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make -j8</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装GCC（切记谨慎执行）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>验证 GCC 的版本是否升级成功</strong></p></blockquote><p>如果在下面的输出结果中，出现 <code>GLIBC_2.18</code>，则代表 GCC 的版本升级成功。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> strings /lib64/libc.so.6 | grep GLIBC</span></span><br><span class="line">GLIBC_2.2.5</span><br><span class="line">GLIBC_2.2.6</span><br><span class="line">GLIBC_2.3</span><br><span class="line">GLIBC_2.3.2</span><br><span class="line">GLIBC_2.3.3</span><br><span class="line">GLIBC_2.3.4</span><br><span class="line">GLIBC_2.4</span><br><span class="line">GLIBC_2.5</span><br><span class="line">GLIBC_2.6</span><br><span class="line">GLIBC_2.7</span><br><span class="line">GLIBC_2.8</span><br><span class="line">GLIBC_2.9</span><br><span class="line">GLIBC_2.10</span><br><span class="line">GLIBC_2.11</span><br><span class="line">GLIBC_2.12</span><br><span class="line">GLIBC_2.13</span><br><span class="line">GLIBC_2.14</span><br><span class="line">GLIBC_2.15</span><br><span class="line">GLIBC_2.16</span><br><span class="line">GLIBC_2.17</span><br><span class="line">GLIBC_2.18</span><br></pre></td></tr></tbody></table></figure><p>或者查看 <code>ldd</code> 的版本</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ldd --version</span></span><br><span class="line">ldd (GNU libc) 2.18</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></tbody></table></figure><p>或者查看系统的库文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统的libc.so库文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls /usr/lib64/libc-*.so -al</span></span><br><span class="line">-rwxr-xr-x. 1 root root  2156592 10月 14 02:29 /usr/lib64/libc-2.17.so</span><br><span class="line">-rwxr-xr-x. 1 root root 10232696 10月 24 14:52 /usr/lib64/libc-2.18.so</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看系统的libc.so库文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls /usr/lib64/libc.so* -al</span></span><br><span class="line">-rw-r--r--. 1 root root 253 10月 24 14:51 /usr/lib64/libc.so</span><br><span class="line">lrwxrwxrwx. 1 root root  12 10月 24 14:52 /usr/lib64/libc.so.6 -&gt; libc-2.18.so</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>解决误删 libc.so.6 库文件的问题</strong></p></blockquote><p>在上述的操作中，若误删了 <code>libc.so.6</code> 库文件，会导致系统大多数命令不可用（例如：<code>ls</code>、<code>cp</code>、<code>ln</code>）。此时千万不要随便重启系统，缺少 <code>libc.so.6</code> 库文件很容易导致系统无法正常启动，其次也尽量不要关闭正在运行的终端，因为很多东西还可以补救，建议参考以下步骤重新创建 <code>libc.so.6</code> 库文件。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统可用的libc库文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls /usr/lib64/libc-*.so -al</span></span><br><span class="line">-rwxr-xr-x. 1 root root  2156592 10月 14 02:29 /usr/lib64/libc-2.17.so</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过系统环境变量LD_PRELOAD导入可用的libc库文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> LD_PRELOAD=/usr/lib64/libc-2.17.so</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 利用可用的libc库文件，创建新的libc.so.6库文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -s -f /usr/lib64/libc-2.17.so /usr/lib64/libc.so.6</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消设置系统环境变量LD_PRELOAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">unset</span> LD_PRELOAD</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>参考博客</strong></p></blockquote><ul><li><a href="https://www.jianshu.com/p/5ea4e50bf800">Linux（CentOS）GLIBC 出错的补救方式</a></li><li><a href="https://www.jianshu.com/p/513e01fbd3e0">解决 libc.so.6: version ‘GLIBC_2.18’ not found 的问题</a></li><li><a href="https://blog.csdn.net/changcsw/article/details/79761620">Linux/Centos 下 /lib64/libc.so.6: version ‘GLIBC_2.14’ not found</a></li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 Linux 如何解决 libc.so.6 version GLIBC_2.18 not found 的问题。</summary>
    
    
    
    <category term="hide" scheme="https://www.techgrow.cn/categories/hide/"/>
    
    
    <category term="Linux" scheme="https://www.techgrow.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之四</title>
    <link href="https://www.techgrow.cn/posts/beb2ebb3.html"/>
    <id>https://www.techgrow.cn/posts/beb2ebb3.html</id>
    <published>2021-10-23T13:55:33.000Z</published>
    <updated>2021-10-23T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>C++ 面向对象的基础模型</li><li> C++ 编译器管理类和对象的机制</li><li> C++ 编译器对类对象的生命周期管理，包括对象的创建、使用、销毁等</li></ul><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>a) 类、对象、成员变量、成员函数</li><li> b) 面向对象三大概念：封装、继承、多态</li></ul><span id="more"></span><h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><p>封装（Encapsulation）：</p><ul><li>a) 封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，对数据和函数进行访问控制，这在计算机世界中是用类与对象实现的。</li><li>b) 封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li></ul><p>C++ 中类的封装：</p><ul><li><code>成员变量</code>：C++ 中用于表示类属性的变量</li><li><code>成员函数</code>：C++ 中用于表示类行为的函数</li></ul><h3 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h3><p>在 C++ 中可以给成员变量和成员函数定义访问级别：</p><ul><li><code>private</code>：修饰的成员变量和成员函数，只能在类的内部被访问</li><li><code>public</code>：修饰的成员变量和成员函数，可以在类的内部和类的外部被访问</li><li><code>protected</code>：修饰的成员变量和成员函数，可以在派生类（继承的子类）的内部访问，不能在派生类的外部被访问</li><li>特别注意：若在类中没有声明访问控制级别的成员变量和成员函数，默认都是 <code>private</code> 访问级别的</li></ul><p>基于类成员的访问控制，计算圆形面积的示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_r; <span class="comment">// 圆形的半径</span></span><br><span class="line">    <span class="keyword">double</span> m_s; <span class="comment">// 圆形的面积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> r)</span> </span>{</span><br><span class="line">        m_r = r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getR</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m_r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getS</span><span class="params">()</span> </span>{</span><br><span class="line">        m_s = <span class="number">3.14</span> * m_r * m_r;</span><br><span class="line">        <span class="keyword">return</span> m_s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    cout &lt;&lt; <span class="string">"请输入圆形的半径："</span>;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">    Circle circle;</span><br><span class="line">    circle.<span class="built_in">setR</span>(r);</span><br><span class="line">    cout &lt;&lt; <span class="string">"圆形的面积是："</span> &lt;&lt; circle.<span class="built_in">getS</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="struct-和-class-的区别"><a href="#struct-和-class-的区别" class="headerlink" title="struct 和 class 的区别"></a>struct 和 class 的区别</h3><p>struct 和 class 关键字的区别如下：</p><ul><li>在用 <code>class</code> 定义类时，所有成员的默认属性为 <code>private</code></li><li>在用 <code>struct</code> 定义类时，所有成员的默认属性为 <code>public</code></li></ul><h3 id="类的声明与类的实现一起写"><a href="#类的声明与类的实现一起写" class="headerlink" title="类的声明与类的实现一起写"></a>类的声明与类的实现一起写</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_r; <span class="comment">// 圆形的半径</span></span><br><span class="line">    <span class="keyword">double</span> m_s; <span class="comment">// 圆形的面积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> r)</span> </span>{</span><br><span class="line">        m_r = r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getR</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> m_r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getS</span><span class="params">()</span> </span>{</span><br><span class="line">        m_s = <span class="number">3.14</span> * m_r * m_r;</span><br><span class="line">        <span class="keyword">return</span> m_s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    cout &lt;&lt; <span class="string">"请输入圆形的半径："</span>;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">    Circle circle;</span><br><span class="line">    circle.<span class="built_in">setR</span>(r);</span><br><span class="line">    cout &lt;&lt; <span class="string">"圆形的面积是："</span> &lt;&lt; circle.<span class="built_in">getS</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入圆形的半径：30</span><br><span class="line">圆形的面积是：2826</span><br></pre></td></tr></tbody></table></figure><h3 id="类的声明与类的实现分开写"><a href="#类的声明与类的实现分开写" class="headerlink" title="类的声明与类的实现分开写"></a>类的声明与类的实现分开写</h3><p>在企业开发中，由于项目结构比较庞大，一般都会将类的声明和类的实现分开写在不同的源文件中。</p><p><code>Teacher.h</code> 头文件，声明了 <code>Teacher</code> 类的成员变量和成员函数；使用 <code>#ifndef</code>、<code>#define</code>、<code>#endif</code> 指令，是为了防止 <code>Teacher.h</code> 头文件被多次引用时 C++ 编译器编译失败，也可以直接使用 <code>#pragma once</code> 指令来替代。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEACHER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEACHER_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_name;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p><code>Teacher.cpp</code> 源文件，实现了在 <code>Teacher.h</code> 头文件中定义的成员函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Teacher.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">Teacher::getName</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::setName</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;_name = name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Teacher::getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Main.cpp</code> 源文件</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Teacher.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>] = <span class="string">"Peter"</span>;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    teacher.<span class="built_in">setAge</span>(<span class="number">10</span>);</span><br><span class="line">    teacher.<span class="built_in">setName</span>(name);</span><br><span class="line">    cout &lt;&lt; <span class="string">"age: "</span> &lt;&lt; teacher.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; teacher.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age: 10</span><br><span class="line">name: Peter</span><br></pre></td></tr></tbody></table></figure><h2 id="对象的构造和析构"><a href="#对象的构造和析构" class="headerlink" title="对象的构造和析构"></a>对象的构造和析构</h2><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><h4 id="析构函数的定义"><a href="#析构函数的定义" class="headerlink" title="析构函数的定义"></a>析构函数的定义</h4><p>析构函数的定义：</p><ul><li>C++ 中的类可以定义一个特殊的成员函数来清理对象，这个特殊的成员函数叫做析构函数</li><li>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号 <code>~</code> 作为前缀，它没有任何参数，也没有任何返回类型的声明</li><li>析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源</li><li>析构函数在对象销毁时会自动被调用</li></ul><p>析构函数的调用：</p><ul><li>C++ 编译器会自动调用析构函数</li></ul><h4 id="析构函数的声明"><a href="#析构函数的声明" class="headerlink" title="析构函数的声明"></a>析构函数的声明</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Teacher</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"调用析构函数"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用析构函数</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>创建一个对象时，常常需要做某些初始化的工作，例如对数据成员赋初值。必须注意，类的数据成员是不能在声明类时初始化的。为了解决这个问题，C++ 编译器提供了构造函数（Constructor）来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动被调用。</p><h4 id="构造函数的定义"><a href="#构造函数的定义" class="headerlink" title="构造函数的定义"></a>构造函数的定义</h4><p>构造函数的定义：</p><ul><li>C++ 中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数</li><li>构造函数在定义时可以有参数</li><li>构造函数没有任何返回类型的声明</li><li>构造函数可用于为某些成员变量设置初始值</li></ul><p>构造函数的调用：</p><ul><li><code>自动调用</code>：一般情况下 C++ 编译器会自动调用构造函数</li><li><code>手动调用</code>：在一些特定的情况下，需要手工调用构造函数</li></ul><h4 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h4><p>构造函数一般分为三类：无参数的构造函数、带参数的构造函数、拷贝构造函数（赋值构造函数）。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造函数</span></span><br><span class="line">    <span class="built_in">Test</span>() {</span><br><span class="line">        _a = <span class="number">1</span>;</span><br><span class="line">        _b = <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line">        _a = a;</span><br><span class="line">        _b = b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数（赋值构造函数）</span></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;obj) {</span><br><span class="line">        _a = obj._a;</span><br><span class="line">        _b = obj._b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="默认的构造函数"><a href="#默认的构造函数" class="headerlink" title="默认的构造函数"></a>默认的构造函数</h4><p>C++ 中有两个特殊的构造函数：</p><ul><li><code>默认无参构造函数</code>：当类中没有定义构造函数时，编译器默认会提供一个无参构造函数，并且其函数体为空</li><li><code>默认拷贝构造函数</code>：当类中没有定义拷贝构造函数时，编译器默认会提供一个拷贝构造函数，用于简单地进行类成员变量的值复制</li></ul><h4 id="构造函数的调用方式"><a href="#构造函数的调用方式" class="headerlink" title="构造函数的调用方式"></a>构造函数的调用方式</h4><p>构造函数的调用方式分为以下三种：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>() {</span><br><span class="line">        _a = <span class="number">1</span>;</span><br><span class="line">        _b = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a) {</span><br><span class="line">        _a = a;</span><br><span class="line">        _b = <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</span><br><span class="line">        _a = a;</span><br><span class="line">        _b = b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 第一种：C++编译器调用有参构造函数(等号法)</span></span><br><span class="line">    Test t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, t1.<span class="built_in">getA</span>(), t1.<span class="built_in">getB</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种：C++编译器调用有参构造函数(括号法)</span></span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, t2.<span class="built_in">getA</span>(), t2.<span class="built_in">getB</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++编译器调用无参构造函数</span></span><br><span class="line">    Test t0;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, t0.<span class="built_in">getA</span>(), t0.<span class="built_in">getB</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种：手动调用构造函数生成一个对象(直接调用构造函数法)</span></span><br><span class="line">    Test t3 = <span class="built_in">Test</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, t3.<span class="built_in">getA</span>(), t3.<span class="built_in">getB</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 5, b = 3</span><br><span class="line">a = 10, b = 20</span><br><span class="line">a = 1, b = 1</span><br><span class="line">a = 100, b = 200</span><br></pre></td></tr></tbody></table></figure><h4 id="拷贝构造函数的调用场景"><a href="#拷贝构造函数的调用场景" class="headerlink" title="拷贝构造函数的调用场景"></a>拷贝构造函数的调用场景</h4><h5 id="第一种调用场景"><a href="#第一种调用场景" class="headerlink" title="第一种调用场景"></a>第一种调用场景</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"无参构造函数自动被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a) {</span><br><span class="line">        _a = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;obj) {</span><br><span class="line">        _a = obj._a + <span class="number">10</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _a;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t0</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    t0 = t1;            <span class="comment">// 普通的赋值操作，拷贝构造函数不会被调用</span></span><br><span class="line">    Test t2 = t1;       <span class="comment">// 类的初始化操作(等号法)，拷贝构造函数会被调用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; t2.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">functionA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">拷贝构造函数被调用了</span><br><span class="line">a = 11</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br></pre></td></tr></tbody></table></figure><h5 id="第二种调用场景"><a href="#第二种调用场景" class="headerlink" title="第二种调用场景"></a>第二种调用场景</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"无参构造函数自动被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a) {</span><br><span class="line">        _a = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;obj) {</span><br><span class="line">        _a = obj._a + <span class="number">10</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _a;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;         <span class="comment">// 类的初始化操作(括号法)，拷贝构造函数会被调用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; t2.<span class="built_in">getA</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">functionA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">拷贝构造函数被调用了</span><br><span class="line">a = 13</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br></pre></td></tr></tbody></table></figure><h5 id="第三种调用场景"><a href="#第三种调用场景" class="headerlink" title="第三种调用场景"></a>第三种调用场景</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span> {</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Location</span>(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) {</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Location</span>(<span class="keyword">const</span> Location &amp;p) {</span><br><span class="line">        X = p.X;</span><br><span class="line">        Y = p.Y;</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Location</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> X;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Y;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">(Location b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">getX</span>() &lt;&lt; <span class="string">","</span> &lt;&lt; b.<span class="built_in">getY</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Location <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">functionA</span>(a);         <span class="comment">// 拷贝构造函数会被调用，这里会使用实参变量（a）初始化形参变量（b），同时会多创建一个Location对象（匿名对象），所以最后析构函数会被调用两次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">拷贝构造函数被调用了</span><br><span class="line">1,2</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br></pre></td></tr></tbody></table></figure><h5 id="第四种调用场景"><a href="#第四种调用场景" class="headerlink" title="第四种调用场景"></a>第四种调用场景</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Location</span>(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) {</span><br><span class="line">        x = xx;</span><br><span class="line">        y = yy;</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Location</span>(<span class="keyword">const</span> Location &amp;p) {</span><br><span class="line">        x = p.x;</span><br><span class="line">        y = p.y;</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Location</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数被调用了"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Location <span class="title">functionA</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Location <span class="title">l</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 匿名对象的去与留，关键是看返回匿名对象时如何接收，一般有以下两种情况：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若将函数functionA()返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构</span></span><br><span class="line">    <span class="comment">// 此时有参构造函数和析构函数被调用两次</span></span><br><span class="line">    Location A;</span><br><span class="line">    A = <span class="built_in">functionA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若使用函数functionA()的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成B对象</span></span><br><span class="line">    <span class="comment">// 此时有参构造函数与析构函数各被调用一次</span></span><br><span class="line">    <span class="comment">// Location B = functionA();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行输出的结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有参构造函数被调用了</span><br><span class="line">有参构造函数被调用了</span><br><span class="line">析构函数被调用了</span><br><span class="line">析构函数被调用了</span><br></pre></td></tr></tbody></table></figure><blockquote><p>思考：在上述的代码中，在 <code>main()</code> 函数内直接调用 <code>functionA()</code> 函数时，为什么拷贝构造函数没有被调用呢？是否跟 C++ 编译器的版本有关系呢？</p></blockquote><h4 id="构造函数的使用规则"><a href="#构造函数的使用规则" class="headerlink" title="构造函数的使用规则"></a>构造函数的使用规则</h4><ul><li>当类中没有定义任何一个构造函数时，C++ 编译器会提供默认无参构造函数和默认拷贝构造函数</li><li><strong>当类中定义了拷贝构造函数时，C++ 编译器不会提供默认无参构造函数</strong></li><li><strong>当类中定义了任意的非拷贝构造函数（即当类中定义了有参构造函数或无参构造函数），C++ 编译器不会提供默认无参构造函数</strong></li><li> C++ 提供的默认拷贝构造函数，只负责给类成员变量简单赋值</li><li>必要的时候，需要手动编写拷贝构造函数</li><li>构造函数和普通成员函数都遵循函数重载规则</li></ul><h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><h5 id="初始化列表出现的原因"><a href="#初始化列表出现的原因" class="headerlink" title="初始化列表出现的原因"></a>初始化列表出现的原因</h5><p>有的时候必须用带有初始化列表的构造函数：（1）没有默认无参构造函数的成员类对象；（2）<code>const</code> 成员或引用类型的成员，必须要通过初始化列表进行初始化，因为这两种对象要在声明后马上初始化，而在构造函数中，做的就是对它们赋值，这样是不被允许的。值得一提的是，构造函数中有着比我们所看见的还要多的细节，构造函数可以调用其它的构造函数来初始化对象中的基类对象和成员对象的构造函数。类的数据成员中的其它类对象，若该成员对象是没有默认无参构造函数，则必须进行显式初始化；因为编译器会隐式调用成员对象的默认无参构造函数，而它又没有默认无参构造函数，则编译器会编译失败。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Teacher</span>(<span class="keyword">int</span> age) {</span><br><span class="line">        _age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    Teacher teacher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Teacher <span class="title">t</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    Student s;          <span class="comment">// C++编译器编译不通过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述示例代码无法通过编译，Student 的类数据成员中有一个 Teacher 类的对象 <code>teacher</code>，创建 Student 类时，要先创建其成员对象 <code>teacher</code>；由于 Teacher 类有一个自定义的有参构造函数，C++ 编译器不会再提供默认无参构造函数，因此 <code>teacher</code> 对象无法被自动创建。使用构造函数初始化列表改写后，正确的示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Teacher</span>(<span class="keyword">int</span> age) {</span><br><span class="line">        _age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    Teacher teacher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构造函数的初始化列表来初始化Teacher类对象</span></span><br><span class="line">    <span class="comment">// 这里会自动调用Teacher类的有参构造函数，并将age2作为构造函数的参数传递过去</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">int</span> age1, <span class="keyword">int</span> age2) : <span class="built_in">teacher</span>(age2) {</span><br><span class="line">        _age = age1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> _age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">Teacher <span class="title">getTeacher</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> teacher;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Student <span class="title">s</span><span class="params">(<span class="number">20</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"student.age: "</span> &lt;&lt; s.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">", teacher.age: "</span> &lt;&lt; s.<span class="built_in">getTeacher</span>().<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.age: 20, teacher.age: 35</span><br></pre></td></tr></tbody></table></figure><h5 id="初始化列表使用的语法规则"><a href="#初始化列表使用的语法规则" class="headerlink" title="初始化列表使用的语法规则"></a>初始化列表使用的语法规则</h5><p>构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor::<span class="built_in">Contructor</span>() : <span class="built_in">m1</span>(v1), <span class="built_in">m2</span>(v1,v2), <span class="built_in">m3</span>(v3)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在下述的示例代码中，两个构造函数的最终效果是一样的。使用初始化列表的构造函数是显式地初始化类的成员；而没有使用初始化列表的构造函数是对类的成员赋值，并没有显式地初始化。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="built_in">A</span>(): <span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="number">9.9</span>) {} <span class="comment">//构造函数初始化列表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="built_in">A</span>()   <span class="comment">//构造函数内部赋值</span></span><br><span class="line">    {</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        b = <span class="number">9.9</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="初始化-const-成员和引用成员"><a href="#初始化-const-成员和引用成员" class="headerlink" title="初始化 const 成员和引用成员"></a>初始化 const 成员和引用成员</h5><p>构造函数初始化列表是初始化 <code>const</code> 成员和引用成员的唯一方式。因为 <code>const</code> 成员或引用类型的成员只能被初始化，不能对它们赋值。示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> &amp;j;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数初始化列表</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">c</span>(x), <span class="built_in">j</span>(y) {</span><br><span class="line">        i = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">5</span>, m)</span></span>;    <span class="comment">// C++编译可以通过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>若不通过初始化列表来对 <code>const</code> 成员或引用类型的成员进行初始化，那么缺省情况下，在构造函数被执行之前，对象中的所有成员都已经被它们自己的默认无参构造函数初始化了。由于这两种数据成员要在声明后马上初始化，而在构造函数中，做的就是对它们赋值，这样是不被允许的。示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> &amp;j;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x) {</span><br><span class="line">        i = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="number">5</span>;    <span class="comment">// C++编译不通过，必须通过初始化列表来初始化</span></span><br><span class="line">        j = x;    <span class="comment">// C++编译不通过，必须通过初始化列表来初始化</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>当类中某个数据成员本身也是一个类对象时，应该尽量避免使用赋值操作来对该成员进行初始化，示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string &amp; n)</span><br><span class="line">    {</span><br><span class="line">        name = n;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然这样的构造函数也能得到正确的结果，但这样写效率并不高。当一个 Person 对象创建时，<code>string</code> 类成员对象 <code>name</code> 先会被默认无参构造函数进行初始化，然后在 Person 类的自定义有参构造函数中，它的值又会因赋值操作而再改变一次。这里可以通过初始化列表来显示地对 <code>name</code> 对象进行初始化，这样就可以将前面的两步骤（初始化和赋值）合并成一个步骤了。示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string&amp; n): <span class="built_in">name</span>(n){</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="初始化与赋值的区别"><a href="#初始化与赋值的区别" class="headerlink" title="初始化与赋值的区别"></a>初始化与赋值的区别</h5><p><strong>重点知识点：</strong></p><ul><li><code>初始化</code>：被初始化的对象正在创建</li><li><code>赋值</code>：被赋值的对象已经存在</li><li>初始化列表优先于构造函数的执行</li><li>成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关</li></ul><p>在宏观代码上，两者作用相同。对于数组和结构体来说，初始化和赋值的的形式不同。对于数组，可以使用花括号一起初始化，如果赋值的话，就只能单个元素就行；对于结构体，可以使用花括号初始化，否则只能通过 <code>.</code> 来访问变量进行赋值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> aa;</span><br><span class="line">    <span class="keyword">float</span> bb;</span><br><span class="line">    string cc;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">3</span>];</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    b[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    MyStruct stu1 = {<span class="number">1</span>, <span class="number">3.14f</span>, <span class="string">"hello world"</span>};</span><br><span class="line">    MyStruct stu2;</span><br><span class="line">    stu2.aa = <span class="number">1</span>;</span><br><span class="line">    stu2.bb = <span class="number">3.14f</span>;</span><br><span class="line">    stu2.cc = <span class="string">"we are csdn"</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; stu1.aa &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; stu1.bb &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; stu1.cc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="构造函数和析构函数的调用顺序"><a href="#构造函数和析构函数的调用顺序" class="headerlink" title="构造函数和析构函数的调用顺序"></a>构造函数和析构函数的调用顺序</h5><ul><li>当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同，之后再调用类自身的构造函数</li><li>析构函数的调用顺序与对应的构造函数调用顺序相反</li></ul>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括 C++ 的类和对象、构造函数、析构函数、拷贝构造函数、构造函数初始化列表等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门基础之三</title>
    <link href="https://www.techgrow.cn/posts/f26087ad.html"/>
    <id>https://www.techgrow.cn/posts/f26087ad.html</id>
    <published>2021-10-20T13:55:33.000Z</published>
    <updated>2021-10-20T13:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="C-对-C-语言的函数扩展"><a href="#C-对-C-语言的函数扩展" class="headerlink" title="C++ 对 C 语言的函数扩展"></a>C++ 对 C 语言的函数扩展</h2><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><h4 id="什么是内联函数"><a href="#什么是内联函数" class="headerlink" title="什么是内联函数"></a>什么是内联函数</h4><p>在 C 语言中，使用宏定义函数这种借助编译器的优化技术来减少程序的执行时间，那么在 C++ 中有没有相同的技术或者更好的实现方法呢？答案是有的，那就是内联函数。内联函数作为编译器优化手段的一种技术，在降低程序运行时间上非常有用。C++ 的内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 <code>inline</code>，在调用函数之前需要对函数进行定义。所有在类中定义的函数都是内联函数，即使没有使用 <code>inline</code> 关键字声明。当内联函数收到编译器的指示时，即可发生内联：编译器将使用函数的定义体来替代函数调用语句，这种替代行为发生在编译阶段而非程序运行阶段。值得一提的是，内联函数仅仅是对编译器的内联建议，编译器是否觉得采取建议取决于函数是否符合内联的有利条件。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。</p><h4 id="为什么要使用内联函数"><a href="#为什么要使用内联函数" class="headerlink" title="为什么要使用内联函数"></a>为什么要使用内联函数</h4><p>有时候我们会写一些功能专一的函数，这些函数的函数体不大，包含了很少的执行语句。例如在计算 1~1000 以内的素数时，我们经常会使用开方操作使运算范围缩小，这时我们会写如下一个函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">　　<span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((<span class="keyword">float</span>)n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>然后求范围内素数的函数可以这样写：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="built_in">root</span>(n); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (n%i == <span class="number">0</span>)</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当然，把 <code>root</code> 函数放在循环中不是个不明智的选择，但想象一下，在某个程序上下文内必须频繁地调用某个类似 <code>root</code> 的函数，其调用函数的花销会有多大：当遇到普通函数的调用指令时，程序会保存当前函数的执行现场，将函数中的局部变量以及函数地址压入堆栈，然后再将即将调用的新函数加载到内存中，这要经历复制参数值、跳转到所调用函数的内存位置、执行函数代码、存储函数返回值等过程；当函数执行完后，再获取之前正在调用的函数的地址，回去继续执行那个函数，运行时间开销简直太多了。为了解决上述问题，C++ 内联函数提供了替代函数调用的方案，通过 <code>inline</code> 声明，编译器首先在函数调用处使用函数体本身语句替换了函数调用语句，然后编译替换后的代码。因此，通过内联函数，编译器不需要跳转到内存其他地址去执行函数调用，也不需要保留函数调用时的现场数据。</p><h4 id="如何使用内联函数"><a href="#如何使用内联函数" class="headerlink" title="如何使用内联函数"></a>如何使用内联函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义函数的声明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFUNC(x, y) (x &gt; y) ? x : y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 内联函数的调用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Max (20,10): "</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">20</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Max (0,200): "</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">0</span>, <span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Max (100,1010): "</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">100</span>, <span class="number">1010</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宏定义函数的调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Max (10,30): %d\n"</span>, <span class="built_in">MAXFUNC</span>(<span class="number">10</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Max (20,10): 20</span><br><span class="line">Max (0,200): 200</span><br><span class="line">Max (100,1010): 1010</span><br><span class="line">Max (10,30): 30</span><br></pre></td></tr></tbody></table></figure><h4 id="内联函数的优缺点"><a href="#内联函数的优缺点" class="headerlink" title="内联函数的优缺点"></a>内联函数的优缺点</h4><p>优点：</p><ul><li>它通过避免函数调用所带来的开销来提高程序的运行速度</li><li>通过将函数声明为内联，则可以把函数定义放在头文件内</li><li>它避免了普通函数调用时的额外开销（压栈、弹栈、跳转、返回）</li></ul><p>缺点：</p><ul><li>因为代码的扩展，内联函数增大了可执行程序的体积</li><li> C++ 内联函数的展开是编译阶段，这就意味着如果内联函数发生了改动，那么就需要重新编译代码</li><li>当把内联函数放在头文件中时，它将会使头文件信息变多，不过头文件的使用者不用在意这些细节</li><li>有时候内联函数并不受到青睐，比如在嵌入式系统中，嵌入式系统的存储约束可能不允许体积很大的可执行程序运行</li></ul><h4 id="内联函数的编译限制"><a href="#内联函数的编译限制" class="headerlink" title="内联函数的编译限制"></a>内联函数的编译限制</h4><p>C++ 中内联函数编译的限制：</p><ul><li>函数体不能过于庞大</li><li>不能对函数进行取址操作</li><li>不能存在任何形式的循环语句</li><li>不能存在过多的条件判断语句</li><li>函数的内联声明必须在调用语句之前</li></ul><p>编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈、弹栈、跳转和返回的开销。因此，当函数体的执行开销远大于压栈、弹栈、跳转和返回所用的开销时，那么内联将变得毫无意义。</p><h4 id="什么时候该使用内联函数"><a href="#什么时候该使用内联函数" class="headerlink" title="什么时候该使用内联函数"></a>什么时候该使用内联函数</h4><p>当程序设计需要时，每个函数都可以声明为 <code>inline</code>，下面列举一些有用的建议：</p><ul><li>当对程序执行性能有要求时，那么就可以使用内联函数</li><li>当想使用宏定义一个函数时，那就果断使用内联函数来替代</li><li>在类内部定义的函数会默认声明为 <code>inline</code> 函数，这有利于类实现细节的隐藏</li></ul><p>关键点：</p><ul><li>虚函数不允许内联</li><li>所有在类中定义的函数都默认声明为 <code>inline</code> 函数，所有不用再显示地去声明 <code>inline</code></li><li>虽然说模板函数放中头文件中，但它们不一定是内联的（不是说定义在头文件中的函数都是内联函数）</li><li>C++ 编译器会直接将编译后的内联函数体插入到调用的地方，内联函数在最终生成的代码中是没有定义的</li><li>内联函数由编译器处理，直接将编译后的内联函数体插入到调用的地方；而宏定义由预处理器处理，只进行简单的文本替换，没有任何编译过程</li><li>一些现代的 C++ 编译器提供了扩展语法，能够对函数进行强制内联，例如： <code>g++</code> 中的 <code>__attribute__((always_inline))</code> 属性</li><li>编译器的内联看起来就像是代码的复制与粘贴，但这与预处理宏是很不同的；宏定义函数是强制的内联展开，可能将会污染所有的命名空间与代码，会为程序的调试带来困难</li><li>内联声明只是一种对编译器的建议，编译器是否采用内联措施由编译器自己来决定。现代 C++ 编译器能够进行编译优化，甚至在汇编阶段或链接阶段，一些没有 <code>inline</code> 声明的函数，也可能被编译器内联编译</li></ul><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><p>C++ 中可以在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值，编译器会自动用默认值代替。函数默认参数的使用规则如下：</p><ul><li>只有参数列表后面部分的参数才可以提供默认参数值</li><li>一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参数都必须使用默认参数值 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> x = <span class="number">3</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x: %d\n"</span>, x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> y = <span class="number">4</span>, <span class="keyword">int</span> z = <span class="number">5</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a: %d, b: %d, y: %d, z: %d\n"</span>, a, b, y, z);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">funcA</span>();</span><br><span class="line">    <span class="built_in">funcA</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">funcB</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">funcB</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x: 3</span><br><span class="line">x: 6</span><br><span class="line">a: 1, b: 2, y: 4, z: 5</span><br><span class="line">a: 1, b: 2, y: 3, z: 4</span><br></pre></td></tr></tbody></table></figure><h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><p>函数占位参数只有参数类型声明，而没有参数名声明；一般情况下，在函数体内部无法使用占位参数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"func(1, 2, 3) = %d\n"</span>, <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(1, 2, 3) = 3</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>函数默认参数结合函数占位参数</strong></p><p>可以将函数默认参数与函数占位参数结合起来使用，其意义在于为以后程序的扩展留下空间，并兼容 C 语言代码中可能出现的不规范写法。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> = <span class="number">0</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a + b = %d\n"</span>, a + b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a + b = 3</span><br><span class="line">a + b = 3</span><br></pre></td></tr></tbody></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="函数重载的概念"><a href="#函数重载的概念" class="headerlink" title="函数重载的概念"></a>函数重载的概念</h4><p>函数重载概念（Function Overload）：</p><ul><li>用同一个函数名定义不同的函数</li><li>当函数名和不同的参数搭配时函数的含义不同</li></ul><p>函数重载至少满足下面的一个条件（函数重载的判断标准）：</p><ul><li>参数个数不同</li><li>参数类型不同</li><li>参数顺序不同</li></ul><blockquote><p>特别注意： 函数的返回值不是函数重载的判断标准</p></blockquote><h4 id="函数重载的使用"><a href="#函数重载的使用" class="headerlink" title="函数重载的使用"></a>函数重载的使用</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    c = <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %d\n"</span>, c);</span><br><span class="line"></span><br><span class="line">    c = <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %d\n"</span>, c);</span><br><span class="line"></span><br><span class="line">    c = <span class="built_in">func</span>(<span class="string">"12345"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %d\n"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = 1</span><br><span class="line">c = 3</span><br><span class="line">c = 5</span><br></pre></td></tr></tbody></table></figure><h4 id="函数重载的调用准则"><a href="#函数重载的调用准则" class="headerlink" title="函数重载的调用准则"></a>函数重载的调用准则</h4><p>编译器调用重载函数的准则：</p><ul><li>将所有同名函数作为候选者</li><li>尝试寻找可行的候选函数</li><li>精确匹配实参<ul><li>通过默认参数能够匹配实参</li><li>通过默认类型转换匹配实参</li></ul></li><li>匹配失败<ul><li>最终寻找到的可行候选函数不唯一，则出现二义性，编译失败</li><li>无法匹配所有候选者，函数未定义，编译失败</li></ul></li></ul><p>函数重载的注意事项：</p><ul><li>重载函数的函数类型是不同的</li><li>函数重载是发生在一个类中里面的</li><li>函数的返回值不能作为函数重载的依据</li><li>函数重载是由函数名和参数列表决定的</li><li>重载函数在本质上是相互独立的不同函数</li></ul><h4 id="函数重载与函数指针"><a href="#函数重载与函数指针" class="headerlink" title="函数重载与函数指针"></a>函数重载与函数指针</h4><p>当使用重载函数名对函数指针进行赋值时：</p><ul><li>根据重载规则挑选与函数指针参数列表一致的候选者</li><li>严格匹配候选者的函数类型与函数指针的函数类型 </li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法：声明函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(FUNC)</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法：声明函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*PFUNC)</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 根据上面的第一种写法，定义函数指针类型的变量</span></span><br><span class="line">    FUNC *FUNC = func;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">FUNC</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %d\n"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据上面的第二种写法，定义函数指针类型的变量</span></span><br><span class="line">    PFUNC p = func;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">p</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d = %d\n"</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序运行的输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = 1</span><br><span class="line">d = 7</span><br></pre></td></tr></tbody></table></figure><h4 id="函数重载与函数默认参数"><a href="#函数重载与函数默认参数" class="headerlink" title="函数重载与函数默认参数"></a>函数重载与函数默认参数</h4><p>当函数重载遇上函数默认参数时，如果代码存在二义性，那么 C++ 编译器会编译失败，示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c = <span class="number">0</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a * b * c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// c = func(1, 2); // 存在二义性，调用失败，编译不能通过</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %d\n"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">本文主要介绍 C++ 入门基础的内容，包括内联函数、函数默认参数、函数占位参数、函数重载等。</summary>
    
    
    
    
    <category term="C++" scheme="https://www.techgrow.cn/tags/C/"/>
    
  </entry>
  
</feed>
